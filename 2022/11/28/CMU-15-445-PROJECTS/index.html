<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="CMU-15-445 Database Systems Projects">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU-15-445-PROJECTS">
<meta property="og:url" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="CMU-15-445 Database Systems Projects">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/figure0.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/image-20230330094151325.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/image-20230330094620272.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/figure11.png">
<meta property="article:published_time" content="2022-11-28T10:08:48.000Z">
<meta property="article:modified_time" content="2023-03-30T04:41:36.142Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/figure0.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CMU-15-445-PROJECTS | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/11/28/CMU-15-445-PROJECTS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMU-15-445-PROJECTS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-28 18:08:48" itemprop="dateCreated datePublished" datetime="2022-11-28T18:08:48+08:00">2022-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 12:41:36" itemprop="dateModified" datetime="2023-03-30T12:41:36+08:00">2023-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">CMU-15-445 Database Systems Projects</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Project-1-BUFFER-POOL"><a href="#Project-1-BUFFER-POOL" class="headerlink" title="Project 1 : BUFFER POOL"></a>Project 1 : BUFFER POOL</h1><p>在本实验中，需要在存储管理器中实现缓冲池。缓冲池负责将物理页面从磁盘中读入内存、或从内存中写回磁盘，使得DBMS可以支持大于内存大小的存储容量。并且，缓冲池应当是用户透明且线程安全的。</p>
<h2 id="Task1-LRU-REPLACEMENT-POLICY"><a href="#Task1-LRU-REPLACEMENT-POLICY" class="headerlink" title="Task1 : LRU REPLACEMENT POLICY"></a>Task1 : LRU REPLACEMENT POLICY</h2><p>本部分中需要实现缓冲池中的<code>LRUReplacer</code>，该组件的功能是跟踪缓冲池内的页面使用情况，并在缓冲池容量不足时驱除缓冲池中最近最少使用的页面。其应当具备如下接口：</p>
<ul>
<li><code>Victim(frame_id_t*)</code>：驱逐缓冲池中最近最少使用的页面，并将其内容存储在输入参数中。当<code>LRUReplacer</code>为空时返回False，否则返回True；</li>
<li><code>Pin(frame_id_t)</code>：当缓冲池中的页面被用户访问时，该方法被调用使得该页面从<code>LRUReplacer</code>中驱逐，以使得该页面固定在缓存池中；</li>
<li><code>Unpin(frame_id_t)</code>：当缓冲池的页面被所有用户使用完毕时，该方法被调用使得该页面被添加在<code>LRUReplacer</code>，使得该页面可以被缓冲池驱逐；</li>
<li><code>Size()</code>：返回<code>LRUReplacer</code>中页面的数目；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUReplacer</span> : <span class="keyword">public</span> Replacer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new LRUReplacer.</span></span><br><span class="line"><span class="comment">    * @param num_pages the maximum number of pages the LRUReplacer will be required to store</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LRUReplacer</span><span class="params">(<span class="type">size_t</span> num_pages)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LRUReplacer</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteNode</span><span class="params">(LinkListNode *curr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TODO(student): implement me!</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; data_idx_;</span><br><span class="line">    std::list&lt;<span class="type">frame_id_t</span>&gt; data_;</span><br><span class="line">    std::mutex data_latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，LRU策略可以由<strong>哈希表加双向链表</strong>的方式实现，其中链表充当队列的功能以记录页面被访问的先后顺序，哈希表则记录&lt;页面ID - 链表节点&gt;键值对，以在O(1)复杂度下删除链表元素。实际实现中使用STL中的哈希表<code>unordered_map</code>和双向链表<code>list</code>，并在<code>unordered_map</code>中存储指向链表节点的<code>list::iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">    data_latch_.<span class="built_in">lock</span>(); </span><br><span class="line">    <span class="keyword">if</span> (data_idx_.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        data_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *frame_id = data_.<span class="built_in">front</span>(); </span><br><span class="line">    data_.<span class="built_in">pop_front</span>();</span><br><span class="line">    data_idx_.<span class="built_in">erase</span>(*frame_id); </span><br><span class="line">    data_latch_.<span class="built_in">unlock</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>Victim</code>，首先判断链表是否为空，如不为空则返回链表首节点的页面ID，并在哈希表中解除指向首节点的映射。为了保证线程安全，整个函数应当由<code>mutex</code>互斥锁保护，下文中对互斥锁操作不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">    data_latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = data_idx_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">    <span class="keyword">if</span> (it != data_idx_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data_.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">        data_idx_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    data_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>Pin</code>，其检查<code>LRUReplace</code>中是否存在对应页面ID的节点，如不存在则直接返回，如存在对应节点则通过哈希表中存储的迭代器删除链表节点，并解除哈希表对应页面ID的映射</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">    data_latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = data_idx_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">    <span class="keyword">if</span> (it == data_idx_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">        data_idx_[frame_id] = <span class="built_in">prev</span>(data_.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    data_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>Unpin</code>，其检查<code>LRUReplacer</code>中是否存在对应页面ID的节点，如存在则直接返回，如不存在则在链表尾部插入页面ID的节点，并在哈希表中插入&lt;页面ID - 链表尾节点&gt;映射</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">size_t</span> ret = data_idx_.<span class="built_in">size</span>();</span><br><span class="line">    data_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>Size</code>，返回哈希表大小即可</p>
<h2 id="Task2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#Task2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="Task2 : BUFFER POOL MANAGER INSTANCE"></a>Task2 : BUFFER POOL MANAGER INSTANCE</h2><p>缓冲池 槽, 磁盘 页, buffer pool中free_list_装的是槽号</p>
<p>在部分中，需要实现缓冲池管理模块，其从<code>DiskManager</code>中获取数据库页面，并在缓冲池强制要求时或从缓冲池驱逐页面时将数据库脏页面写回<code>DiskManager</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManagerInstance</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line">...</span><br><span class="line">   Page *pages_;</span><br><span class="line">   <span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">   DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">   <span class="comment">/** Pointer to the log manager. */</span></span><br><span class="line">   LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">   <span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">   std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line">   <span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">   Replacer *replacer_;</span><br><span class="line">   <span class="comment">/** List of free pages. */</span></span><br><span class="line">   std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line">   <span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe     what it protects. */</span></span><br><span class="line">   std::mutex latch_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>缓冲池的成员如上所示，其中<code>pages_</code>为缓冲池中的实际容器页面槽位数组，用于存放从磁盘中读入的页面，并供DBMS访问；<code>disk_manager_</code>为磁盘管理器，提供从磁盘读入页面及写入页面的接口；<code>log_manager_</code>为日志管理器，本实验中不用考虑该组件；<code>page_table_</code>用于保存磁盘页面ID<code>page_id</code>和槽位ID<code>frame_id_t</code>的映射；<code>raplacer_</code>用于选取所需驱逐的页面；<code>free_list_</code>保存缓冲池中的空闲槽位ID。在这里，区分<code>page_id</code>和<code>frame_id_t</code>是完成本实验的关键。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="comment">// There is book-keeping information inside the page that should only be relevant to the buffer     pool manager.</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferPoolManagerInstance</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Page</span>() &#123; <span class="built_in">ResetMemory</span>(); &#125; <span class="comment">/** Constructor. Zeros out the page data. */</span></span><br><span class="line">    ~<span class="built_in">Page</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the actual data contained within this page */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">GetData</span><span class="params">()</span> -&gt; <span class="type">char</span> * </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the page id of this page */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">GetPageId</span><span class="params">()</span> -&gt; <span class="type">page_id_t</span> </span>&#123; <span class="keyword">return</span> page_id_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the pin count of this page */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">GetPinCount</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> pin_count_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return true if the page in memory has been modified from the page on disk, false otherwise     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">IsDirty</span><span class="params">()</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> is_dirty_; &#125;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** Zeroes out the data that is held within the page. */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ResetMemory</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(data_, OFFSET_PAGE_START, PAGE_SIZE); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The actual data that is stored within a page. */</span></span><br><span class="line">    <span class="type">char</span> data_[PAGE_SIZE]&#123;&#125;;</span><br><span class="line">    <span class="comment">/** The ID of this page. */</span></span><br><span class="line">    <span class="type">page_id_t</span> page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    <span class="comment">/** The pin count of this page. */</span></span><br><span class="line">    <span class="type">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */</span></span><br><span class="line">    <span class="type">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/** Page latch. */</span></span><br><span class="line">    ReaderWriterLatch rwlatch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Page</code>是缓冲池中的页面容器，<code>data_</code>保存对应磁盘页面的实际数据；<code>page_id_</code>保存该页面在磁盘管理器中的页面ID；<code>pin_count_</code>保存DBMS中正使用该页面的用户数目；<code>is_dirty_</code>保存该页面自磁盘读入或写回后是否被修改。下面，将介绍缓冲池中的接口实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) == <span class="number">0U</span>) &#123;</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frame_id = page_table_[page_id];</span><br><span class="line">    pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlushPgImp</code>用于显式地将缓冲池页面写回磁盘。首先，应当检查缓冲池中是否存在对应页面ID的页面，如不存在则返回False；如存在对应页面，则将缓冲池内的该页面的<code>is_dirty_</code>置为false，并使用<code>WritePage</code>将该页面的实际数据<code>data_</code>写回磁盘</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [page_id, frame_id] : page_table_) &#123;</span><br><span class="line">        pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlushAllPgsImp</code>将缓冲池内的所有页面写回磁盘。在这里，遍历<code>page_table_</code>以获得缓冲池内的&lt;页面ID - 槽位ID&gt;对，通过槽位ID获取实际页面，并通过页面ID作为写回磁盘的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0.   Make sure you call AllocatePage!</span></span><br><span class="line">    <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">    <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">    <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">    <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">    <span class="type">frame_id_t</span> new_frame_id;</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        new_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">        free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;new_frame_id)) &#123;</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">    <span class="keyword">if</span> (pages_[new_frame_id].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">        <span class="type">page_id_t</span> flush_page_id = pages_[new_frame_id].page_id_;</span><br><span class="line">        pages_[new_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(flush_page_id, pages_[new_frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[new_frame_id].page_id_);</span><br><span class="line">    page_table_[*page_id] = new_frame_id;</span><br><span class="line">    pages_[new_frame_id].page_id_ = *page_id;</span><br><span class="line">    pages_[new_frame_id].<span class="built_in">ResetMemory</span>();</span><br><span class="line">    pages_[new_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(new_frame_id);</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[new_frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewPgImp</code>在磁盘中分配新的物理页面，将其添加至缓冲池，并返回指向缓冲池页面<code>Page</code>的指针。在这里，该函数由以下步骤组成：</p>
<ol>
<li>检查当前缓冲池中是否存在空闲槽位或存放页面可被驱逐的槽位（下文称其为目标槽位），在这里总是先通过检查<code>free_list_</code>以查询空闲槽位，如无空闲槽位则尝试从<code>replacer_</code>中驱逐页面并返回被驱逐页面的槽位。如目标槽位，则返回空指针；如存在目标槽位，则调用<code>AllocatePage()</code>为新的物理页面分配<code>page_id</code>页面ID。</li>
<li>值得注意的是，在这里需要检查目标槽位中的页面是否为脏页面，如是则需将其写回磁盘，并将其脏位设为false；</li>
<li>从<code>page_table_</code>中删除目标槽位中的原页面ID的映射，并将新的&lt;页面ID - 槽位ID&gt;映射插入，然后更新槽位中页面的元数据。需要注意的是，在这里由于我们返回了指向该页面的指针，我们需要将该页面的用户数<code>pin_count_</code>置为1，并调用<code>replacer_</code>的<code>Pin</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">    <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">    <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">    <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">    <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">    <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">    <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) != <span class="number">0U</span>) &#123;</span><br><span class="line">        frame_id = page_table_[page_id];</span><br><span class="line">        pages_[frame_id].pin_count_++;</span><br><span class="line">        replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">        free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">        page_table_[page_id] = frame_id;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">        pages_[frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">        pages_[frame_id].page_id_ = page_id;</span><br><span class="line">        replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id)) &#123;</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[frame_id].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">        <span class="type">page_id_t</span> flush_page_id = pages_[frame_id].page_id_;</span><br><span class="line">        pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(flush_page_id, pages_[frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[frame_id].page_id_);</span><br><span class="line">    page_table_[page_id] = frame_id;</span><br><span class="line">    pages_[frame_id].page_id_ = page_id;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">    pages_[frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FetchPgImp</code>的功能是获取对应页面ID的页面，并返回指向该页面的指针，其由以下步骤组成：</p>
<ol>
<li>首先，通过检查<code>page_table_</code>以检查缓冲池中是否已经缓冲该页面，如果已经缓冲该页面，则直接返回该页面，并将该页面的用户数<code>pin_count_</code>递增以及调用<code>replacer_</code>的<code>Pin</code>方法；</li>
<li>如缓冲池中尚未缓冲该页面，则需寻找当前缓冲池中是否存在空闲槽位或存放页面可被驱逐的槽位（下文称其为目标槽位），该流程与<code>NewPgImp</code>中的对应流程相似，唯一不同的则是传入目标槽位的<code>page_id</code>为函数参数而非由<code>AllocatePage()</code>分配得到。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0.   Make sure you call DeallocatePage!</span></span><br><span class="line">    <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">    <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">    <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">    <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">    <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) == <span class="number">0U</span>) &#123;</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">    frame_id = page_table_[page_id];</span><br><span class="line">    <span class="keyword">if</span> (pages_[frame_id].pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">        latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[frame_id].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">        <span class="type">page_id_t</span> flush_page_id = pages_[frame_id].page_id_;</span><br><span class="line">        pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(flush_page_id, pages_[frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page_id);</span><br><span class="line">    pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DeletePgImp</code>的功能为从缓冲池中删除对应页面ID的页面，并将其插入空闲链表<code>free_list_</code>，其由以下步骤组成：</p>
<ol>
<li>首先，检查该页面是否存在于缓冲区，如未存在则返回True。然后，检查该页面的用户数<code>pin_count_</code>是否为0，如非0则返回False。在这里，不难看出<code>DeletePgImp</code>的返回值代表的是该页面是否被用户使用，因此在该页面不在缓冲区时也返回True；</li>
<li>检查该页面是否为脏，如是则将其写回并将脏位设置为False。然后，在<code>page_table_</code>中删除该页面的映射，并将该槽位中页面的<code>page_id</code>置为<code>INVALID_PAGE_ID</code>。最后，将槽位ID插入空闲链表即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">    <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) != <span class="number">0U</span>) &#123;</span><br><span class="line">        frame_id = page_table_[page_id];</span><br><span class="line">        pages_[frame_id].is_dirty_ |= is_dirty;</span><br><span class="line">        <span class="keyword">if</span> (pages_[frame_id].pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            latch_.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::cout&lt;&lt;&quot;Unpin : pin_count = &quot;&lt;&lt;pages_[frame_id].pin_count_&lt;&lt;std::endl;</span></span><br><span class="line">        <span class="keyword">if</span> (--pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">            replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UnpinPgImp</code>的功能为提供用户向缓冲池通知页面使用完毕的接口，用户需声明使用完毕页面的页面ID以及使用过程中是否对该页面进行修改。其由以下步骤组成：</p>
<ol>
<li>首先，需检查该页面是否在缓冲池中，如未在缓冲池中则返回True。然后，检查该页面的用户数是否大于0，如不存在用户则返回false；</li>
<li>递减该页面的用户数<code>pin_count_</code>，如在递减后该值等于0，则调用<code>replacer_-&gt;Unpin</code>以表示该页面可以被驱逐。</li>
</ol>
<h2 id="Task-3-：PARALLEL-BUFFER-POOL-MANAGER"><a href="#Task-3-：PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="Task 3 ：PARALLEL BUFFER POOL MANAGER"></a>Task 3 ：PARALLEL BUFFER POOL MANAGER</h2><p>不难看出，上述缓冲池实现的问题在于锁的粒度过大，其在进行任何一项操作时都将整个缓冲池锁住，因此几乎不存在并行性。在这里，并行缓冲池的思想是分配多个独立的缓冲池，并将不同的页面ID映射至各自的缓冲池中，从而减少整体缓冲池的锁粒度，以增加并行性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelBufferPoolManager</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;BufferPoolManager *&gt; instances_;</span><br><span class="line">    <span class="type">size_t</span> start_idx_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> pool_size_;</span><br><span class="line">    <span class="type">size_t</span> num_instances_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并行缓冲池的成员如上，<code>instances_</code>用于存储多个独立的缓冲池，<code>pool_size_</code>记录各缓冲池的容量，<code>num_instances_</code>为独立缓冲池的个数，<code>start_idx</code>见下文介绍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager, LogManager *log_manager)</span><br><span class="line">    : <span class="built_in">pool_size_</span>(pool_size), <span class="built_in">num_instances_</span>(num_instances) &#123;</span><br><span class="line">        <span class="comment">// Allocate and create individual BufferPoolManagerInstances</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">            BufferPoolManager *tmp = <span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_mana    ger, log_manager);</span><br><span class="line">            instances_.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ParallelBufferPoolManager::~<span class="built_in">ParallelBufferPoolManager</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) <span class="built_in">delete</span> (instances_[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，各独立缓冲池在堆区中进行分配，构造函数和析构函数需要完成相应的分配和释放工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ParallelBufferPoolManager::GetPoolSize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num_instances_ * pool_size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BufferPoolManager *<span class="title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instances_[page_id % num_instances_];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>GetPoolSize</code>应返回全部缓冲池的容量，即独立缓冲池个数乘以缓冲池容量。</p>
<p><code>GetBufferPoolManager</code>返回页面ID所对应的独立缓冲池指针，在这里，通过对页面ID取余的方式将页面ID映射至对应的缓冲池。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">    BufferPoolManager *instance = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;<span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unpin page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">    BufferPoolManager *instance = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;<span class="built_in">UnpinPage</span>(page_id, is_dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Flush page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">    BufferPoolManager *instance = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;<span class="built_in">FlushPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Delete page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">    BufferPoolManager *instance = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;<span class="built_in">DeletePage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// flush all pages from all BufferPoolManagerInstances</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">        instances_[i]-&gt;<span class="built_in">FlushAllPages</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数仅需调用对应独立缓冲池的方法即可。值得注意的是，由于在缓冲池中存放的为缓冲池实现类的基类指针，因此所调用函数的应为缓冲池实现类的基类对应的虚函数。并且，由于<code>ParallelBufferPoolManager</code>和<code>BufferPoolManagerInstance</code>为兄弟关系，因此<code>ParallelBufferPoolManager</code>不能直接调用<code>BufferPoolManagerInstance</code>对应的<code>Imp</code>函数，因此直接在<code>ParallelBufferPoolManager</code>中存放<code>BufferPoolManagerInstance</code>指针也是不可行的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">    Page *ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> idx = (start_idx_ + i) % num_instances_;</span><br><span class="line">        <span class="keyword">if</span> ((ret = instances_[idx]-&gt;<span class="built_in">NewPage</span>(page_id)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            start_idx_ = (*page_id + <span class="number">1</span>) % num_instances_;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start_idx_++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，为了使得各独立缓冲池的负载均衡，采用轮转方法选取分配物理页面时使用的缓冲池，在这里具体的规则如下：</p>
<ol>
<li>从<code>start_idx_</code>开始遍历各独立缓冲池，如存在调用<code>NewPage</code>成功的页面，则返回该页面并将<code>start_idx</code>指向该页面的下一个页面；</li>
<li>如全部缓冲池调用<code>NewPage</code>均失败，则返回空指针，并递增<code>start_idx</code>。</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project1_figure/figure0.png"><img src="/2022/11/28/CMU-15-445-PROJECTS/figure0.png" alt="figure0"></a></p>
<h1 id="Project-2-EXTENDIBLE-HASH-INDEX"><a href="#Project-2-EXTENDIBLE-HASH-INDEX" class="headerlink" title="Project 2 : EXTENDIBLE HASH INDEX"></a>Project 2 : EXTENDIBLE HASH INDEX</h1><p>在本实验中，需要实现一个<strong>磁盘备份</strong>的<strong>可扩展哈希表</strong>，用于DBMS中的索引检索。磁盘备份指该哈希表可写入至磁盘中，在系统重启时可以将其重新读取至内存中使用。可扩展哈希表是动态哈希表的一种类型，其特点为桶在充满或清空时可以桶为单位进行桶分裂或合并，尽在特定情况下进行哈希表全表的扩展和收缩，以减小扩展和收缩操作对全表的影响。</p>
<h2 id="可扩展哈希表"><a href="#可扩展哈希表" class="headerlink" title="可扩展哈希表"></a>可扩展哈希表</h2><p>本文介绍了书中未讲解的<strong>低位可拓展哈希表</strong>的原理及其实现，且原理与实现之间设置了跳转以方便阅读</p>
<p>在进行实验之前，我们应当了解可扩展哈希表的具体实现原理。在这里，其最根本的思想在于通过改变哈希表用于映射至对应桶的哈希键位数来控制哈希表的总大小，该哈希键位数被称为全局深度。下面是全局深度的一个例子：</p>
<p>[![figure 1](CMU-15-445-PROJECTS&#x2F;figure 1.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 1.png)</p>
<p>上图为通过哈希函数对字符串产生哈希键的一个示例。可见，当哈希键的位数为32位时，不同的哈希键有2^32个，这代表哈希表将拥有上述数目的目录项以将哈希键映射至相应的哈希桶，该数目显然过于庞大了。因此，我们可以仅关注哈希键的低几位（高几位亦可，但使用低位更易实现）以缩小哈希表目录项的个数。例如，当我们仅关注哈希键的后三位时，不同的哈希键为<code>...000</code>至<code>...111</code>共8个，因此我们仅需为哈希表保存8个目录项即可将各低位不同的哈希键映射至对应的哈希表。</p>
<p>[![figure 2](CMU-15-445-PROJECTS&#x2F;figure 2.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 2.png)</p>
<p><strong>local depth指的是（假设local depth为n），在当前的bucket之下，每个元素的key的低n位都是相同的。</strong></p>
<p>除了用于控制哈希表大小的<strong>全局深度</strong>外，每个哈希表目录项均具有一个<strong>局部深度</strong>，其记录该目录项所对应的哈希桶所关注的哈希键位数。因此，局部深度<strong>以桶为单位</strong>划分的，某个目录项的局部深度即为该目录项所指的桶的局部深度。当哈希表的全局深度为<code>i</code>，某目录项的局部深度为<code>j</code>时，指向该目录项所对应的哈希桶的目录项个数为<code>2^(i-j)</code>。</p>
<h3 id="桶分裂-x2F-合并表扩展-x2F-收缩"><a href="#桶分裂-x2F-合并表扩展-x2F-收缩" class="headerlink" title="桶分裂&#x2F;合并	表扩展&#x2F;收缩"></a>桶分裂&#x2F;合并	表扩展&#x2F;收缩</h3><p>下面，我将使用一个例子来展示可扩展哈希表的桶分裂&#x2F;合并，表扩展&#x2F;收缩行为。在说明中，将使用<code>i</code>代表表的全局深度，<code>j</code>代表目录项的局部深度：</p>
<p>[![figure 3](CMU-15-445-PROJECTS&#x2F;figure 3.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 3.png)</p>
<p>当哈希表刚被创建时，其全局深度为0，即哈希表仅有一个目录项，任何一个哈希键都将被映射到同一个哈希桶。当该哈希桶被充满时，需要进行桶和目录的分裂</p>
<p>当桶对应目录项的局部深度 &#x3D; 全局深度时，指向该桶的目录项仅有一条，因此需要进行目录拓展。将目录的全局深度 + 1，原桶分裂为两个local depth &#x3D; global depth 的桶，并将原哈希桶的记录重新插入至新哈希桶或原哈希桶。对于其他目录项，表扩展后低<code>i-1</code>位相同的目录项指向同一桶页面，低第<code>i</code>位相反的两个页面互为<strong>分裂映像</strong>（实验中的自命名词汇）。[代码实现见下文](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#splitcode)。</p>
<p>当上图中的哈希桶充满时，哈希表将更新至下图所示形式：</p>
<p>[![figure 4](CMU-15-445-PROJECTS&#x2F;figure 4.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 4.png)</p>
<p>当<code>...0</code>目录项所对应的桶被充满时，由于全局深度和该目录项的局部深度仍然相同，因此仍需进行表扩展：</p>
<p>[![figure 5](CMU-15-445-PROJECTS&#x2F;figure 5.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 5.png)</p>
<p>当<code>...00</code>目录项所对应的桶充满时，由于全局深度和该目录项的局部深度仍然相同，因此仍需进行表扩展：</p>
<p>[![figure 6](CMU-15-445-PROJECTS&#x2F;figure 6.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 6.png)</p>
<p>当.<code>..001</code>目录项的桶充满时，<strong>由于该目录项的局部深度<code>j</code>小于全局深度<code>i</code>不必进行目录的拓展，仅需将桶分裂，j  + 1，并将原哈希桶映射的目录项的一半指向原哈希桶，另一半指向新哈希桶</strong>。因此有<code>2^(i-j)</code>个目录项指向所需分裂的哈希桶。划分的规则为低<code>j+1</code>位相同的目录项在分裂后仍指向同一个桶</p>
<p>另一个可能的问题是，如何找到与该目录项指向同一哈希桶的其他目录项。在这里，对于全局深度为<code>i</code>，局部深度为<code>j</code>的目录项，与其共同指向同一哈希桶的目录项（下面称为兄弟目录项）的低<code>j</code>位相同，且通过以下三个特性可以方便的遍历所有兄弟目录项：</p>
<ul>
<li>兄弟目录项中的最顶端 目录项为低<code>j</code>位不变、其余位为0的目录项；</li>
<li>相邻两个目录项的哈希键相差<code>1&lt;&lt;j</code>； </li>
<li>兄弟目录项的总数为<code>1&lt;&lt;(i - j)</code>。</li>
</ul>
<p>上述操作代码实现[见下文](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#splitcode)，分裂后的哈希表如下所示：</p>
<p>[![figure 7](CMU-15-445-PROJECTS&#x2F;figure 7.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 7.png)</p>
<p>当一个目录项所指的哈希桶为空时，需要判断其是否可以与其<strong>目标目录项</strong>所指的哈希桶合并。一个目录项的目标目录项可由其低第<code>j</code>位反转得到，值得注意的是，由于目录项间的局部深度可能不同，因此目标目录项不一定是可逆的。例如，上图中<code>...010</code>目录项的目标目录项为<code>...000</code>，而<code>...000</code>的目标目录项却为<code>...100</code>。目录项及其目标目录项所指的两个哈希桶的合并的条件如下：</p>
<p>（1）两哈希桶均为空桶；</p>
<p>（2）目录项及其目标目录项的局部深度相同且不为0。</p>
<p>此时，若<code>...001</code>和<code>...011</code>目录项所指的两个哈希桶均为空，则可以进行合并（代码实现见[下文](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#mergecode)）：</p>
<p>[![figure 8](CMU-15-445-PROJECTS&#x2F;figure 8.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 8.png)</p>
<p>合并后，需要将指向合并后哈希桶的所有目录项的局部深度减一。此时，若<code>...000</code>和<code>...100</code>所指的哈希桶均为空，则可以进行合并：</p>
<p>[![figure 9](CMU-15-445-PROJECTS&#x2F;figure 9.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 9.png)</p>
<p>当哈希桶合并后使得所有目录项的局部深度均小于全局深度时，既可以进行哈希表的收缩。在这里可以体现低位可拓展哈希表，即收缩哈希表仅需将全局深度减一即可，而不需改变其余任何哈希表的元数据。下图展示了哈希表收缩后的形态：</p>
<p>[![figure 10](CMU-15-445-PROJECTS&#x2F;figure 10.png)](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure</a> 10.png)</p>
<h3 id="插入流程"><a href="#插入流程" class="headerlink" title="插入流程"></a>插入流程</h3><img src="/2022/11/28/CMU-15-445-PROJECTS/image-20230330094151325.png" alt="image-20230330094151325" style="zoom: 50%;">

<p><img src="/2022/11/28/CMU-15-445-PROJECTS/image-20230330094620272.png" alt="image-20230330094620272"></p>
<h2 id="Task-1-PAGE-LAYOUTS"><a href="#Task-1-PAGE-LAYOUTS" class="headerlink" title="Task 1 : PAGE LAYOUTS"></a>Task 1 : PAGE LAYOUTS</h2><p>为了能在磁盘中写入和读取该哈希表，在这里需要实现两个页面类存储哈希表的数据，其使用上实验中的<code>Page</code>页面作为载体，以在磁盘中被写入和读取，具体的实现原理将在下文中介绍：</p>
<h3 id="HashTableDirectoryPage"><a href="#HashTableDirectoryPage" class="headerlink" title="HashTableDirectoryPage"></a>HashTableDirectoryPage</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Directory Page for extendible hash table.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Directory format (size in byte):</span></span><br><span class="line"><span class="comment">  * --------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  * | LSN (4) | PageId(4) | GlobalDepth(4) | LocalDepths(512) | BucketPageIds(2048) | Free(1524)</span></span><br><span class="line"><span class="comment">  * --------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTableDirectoryPage</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">page_id_t</span> page_id_;</span><br><span class="line">    <span class="type">lsn_t</span> lsn_;</span><br><span class="line">    <span class="type">uint32_t</span> global_depth_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 编号为i的桶的局部深度和页面分别是 local_depths_[i]  bucket_page_ids_[i]</span></span><br><span class="line">    <span class="type">uint8_t</span> local_depths_[DIRECTORY_ARRAY_SIZE]; </span><br><span class="line">    <span class="type">page_id_t</span> bucket_page_ids_[DIRECTORY_ARRAY_SIZE]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该页面类作为哈希表的目录页面，保存哈希表中使用的所有元数据，包括该页面的页面ID。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  &quot;&lt;&lt;&quot; 运算符左边的数 1U，表示将整数 1 转换成一个 32 位的无符号整数  </span></span><br><span class="line"><span class="comment">//  global_depth_ = 5, 则返回 11110</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">HashTableDirectoryPage::GetGlobalDepthMask</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1U</span> &lt;&lt; global_depth_) - <span class="number">1</span>; &#125; </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HashTableDirectoryPage::CanShrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> bucket_num = <span class="number">1</span> &lt;&lt; global_depth_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; bucket_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (local_depths_[i] == global_depth_) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetGlobalDepthMask</code>通过位运算返回用于计算全局深度低位的掩码；<code>CanShrink()</code>检查当前所有有效目录项的局部深度是否均小于全局深度，以判断是否可以进行表合并</p>
<h3 id="HashTableBucketPage"><a href="#HashTableBucketPage" class="headerlink" title="HashTableBucketPage"></a>HashTableBucketPage</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTableBucketPage</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// For more on BUCKET_ARRAY_SIZE see storage/page/hash_table_page_defs.h</span></span><br><span class="line">    <span class="type">char</span> occupied_[(BUCKET_ARRAY_SIZE - <span class="number">1</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 BUCKET_ARRAY_SIZE = 17，则 (BUCKET_ARRAY_SIZE - 1) / 8 + 1 = 3，需要 3 个 char 变量来表示桶中所有键值对的可读性信息</span></span><br><span class="line">    <span class="type">char</span> readable_[(BUCKET_ARRAY_SIZE - <span class="number">1</span>) / <span class="number">8</span> + <span class="number">1</span>];   </span><br><span class="line">    <span class="comment">// Do not add any members below array_, as they will overlap.</span></span><br><span class="line">    MappingType array_[<span class="number">0</span>]; <span class="comment">// 只需知道它用于存储实际的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该页面类用于存放哈希桶的键值与存储值对，以及桶的槽位状态数据。<code>occupied_</code>数组用于统计桶中的槽是否被使用过，当一个槽被插入键值对时，其对应的位被置为1；<code>readable_</code>数组用于标记桶中的槽是否被占用，当被占用时该值被置为1，否则置为0；<code>array_</code>是C++中一种弹性数组的写法，在这里只需知道它用于存储实际的键值对即可</p>
<p>下面是使用位运算的状态数组读取和设置函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::RemoveAt</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> </span>&#123; <span class="comment">// 从哈希表中删除指定索引处的桶</span></span><br><span class="line">    readable_[bucket_idx / <span class="number">8</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - (bucket_idx % <span class="number">8</span>)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsOccupied</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (occupied_[bucket_idx / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - (bucket_idx % <span class="number">8</span>)))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::SetOccupied</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">    occupied_[bucket_idx / <span class="number">8</span>] |= <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - (bucket_idx % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsReadable</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readable_[bucket_idx / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - (bucket_idx % <span class="number">8</span>)))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::SetReadable</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">    readable_[bucket_idx / <span class="number">8</span>] |= <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - (bucket_idx % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于对应索引的键值读取直接访问<code>array_</code>数组即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">KeyType <span class="title">HASH_TABLE_BUCKET_TYPE::KeyAt</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_[bucket_idx].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">ValueType <span class="title">HASH_TABLE_BUCKET_TYPE::ValueAt</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_[bucket_idx].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::GetValue</span><span class="params">(KeyType key, KeyComparator cmp, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx) &amp;&amp; <span class="built_in">cmp</span>(key, <span class="built_in">KeyAt</span>(bucket_idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">            result-&gt;<span class="built_in">push_back</span>(array_[bucket_idx].second);</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数遍历当前桶页中的所有键值对，并在满足以下条件时将对应的值加入到 result 向量中：</p>
<ol>
<li>键值对在桶中已被占用（IsOccupied(bucket_idx) &#x3D;&#x3D; true）；</li>
<li>键值对的可读性为可读（IsReadable(bucket_idx) &#x3D;&#x3D; true）；</li>
<li>给定的 key 与当前键值对的键相等（cmp(key, KeyAt(bucket_idx)) &#x3D;&#x3D; 0）。</li>
</ol>
<p>在满足以上三个条件的情况下，将当前键值对的值加入到 result 向量中，并将 ret 标记为 true，表示找到了至少一个匹配的键值对。</p>
<p>最后，函数返回 ret 标记，指示是否找到了匹配的键值对</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Insert</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> slot_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> slot_found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!slot_found &amp;&amp; (!<span class="built_in">IsReadable</span>(bucket_idx) || !<span class="built_in">IsOccupied</span>(bucket_idx))) &#123;</span><br><span class="line">            slot_found = <span class="literal">true</span>;</span><br><span class="line">            slot_idx = bucket_idx;</span><br><span class="line">            <span class="comment">// LOG_DEBUG(&quot;slot_idx = %ld&quot;, bucket_idx);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx) &amp;&amp; <span class="built_in">cmp</span>(key, <span class="built_in">KeyAt</span>(bucket_idx)) == <span class="number">0</span> &amp;&amp; value == <span class="built_in">ValueAt</span>(bucket_idx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slot_found) &#123;</span><br><span class="line">        <span class="built_in">SetReadable</span>(slot_idx);</span><br><span class="line">        <span class="built_in">SetOccupied</span>(slot_idx);</span><br><span class="line">        array_[slot_idx] = <span class="built_in">MappingType</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Insert</code>向桶插入键值对，其先检测该键值对是否已经被插入到桶中，如是则返回假；如未找到该键值对，则从小到大遍历所有<code>occupied_</code>为1的位，如出现<code>readable_</code>为1的位，则在<code>array_</code>中对应的数组中插入键值对。由于此种插入特性，因此<code>occupied_</code>为1的位是连续的，因此<code>occupied_</code>的功能与一个<code>size</code>参数是等价的。在这里仍然采用<code>occupied_</code>数组的原因可能是提供静态哈希表的实现兼容性（静态哈希表采用线性探测法解决散列冲突，因此必须使用<code>occupied_</code>数组）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Remove</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx) &amp;&amp; <span class="built_in">cmp</span>(key, <span class="built_in">KeyAt</span>(bucket_idx)) == <span class="number">0</span> &amp;&amp; value == <span class="built_in">ValueAt</span>(bucket_idx)) &#123;</span><br><span class="line">            <span class="built_in">RemoveAt</span>(bucket_idx);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Remove</code>从桶中删除对应的键值对，遍历桶所有位即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NumReadable</span>() == BUCKET_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">HASH_TABLE_BUCKET_TYPE::NumReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NumReadable</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NumReadable()</code>返回桶中的键值对个数，遍历即可。<code>IsFull()</code>和<code>IsEmpty()</code>直接复用<code>NumReadable()</code>实现。</p>
<h3 id="Page与上述两个页面类的转换"><a href="#Page与上述两个页面类的转换" class="headerlink" title="Page与上述两个页面类的转换"></a>Page与上述两个页面类的转换</h3><p>在本部分中，有难点且比较巧妙的地方在于理解上述两个页面类是如何与<code>Page</code>类型转换的。在这里，上述两个页面类并非未<code>Page</code>类的子类，在实际应用中通过<code>reinterpret_cast</code>将<code>Page</code>与两个页面类进行转换。在这里我们回顾一下<code>Page</code>的数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** Zeroes out the data that is held within the page. */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ResetMemory</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(data_, OFFSET_PAGE_START, PAGE_SIZE); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The actual data that is stored within a page. */</span></span><br><span class="line">    <span class="type">char</span> data_[PAGE_SIZE]&#123;&#125;;</span><br><span class="line">    <span class="comment">/** The ID of this page. */</span></span><br><span class="line">    <span class="type">page_id_t</span> page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    <span class="comment">/** The pin count of this page. */</span></span><br><span class="line">    <span class="type">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */</span></span><br><span class="line">    <span class="type">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/** Page latch. */</span></span><br><span class="line">    ReaderWriterLatch rwlatch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Page</code>中用于存放实际数据的<code>data_</code>数组位于数据成员的第一位，其在栈区固定分配一个页面的大小。因此，在<code>Page</code>与两个页面类强制转换时，通过两个页面类的指针的操作仅能影响到<code>data_</code>中的实际数据，而影响不到其它元数据。并且在内存管理器中始终是进行所占空间更大的通用页面<code>Page</code>的分配（实验中的<code>NewPage</code>），因此页面的容量总是足够的。</p>
<h2 id="Task-2-3-HASH-TABLE-IMPLEMENTATION-CONCURRENCY-CONTROL"><a href="#Task-2-3-HASH-TABLE-IMPLEMENTATION-CONCURRENCY-CONTROL" class="headerlink" title="Task 2,3 : HASH TABLE IMPLEMENTATION + CONCURRENCY CONTROL"></a>Task 2,3 : HASH TABLE IMPLEMENTATION + CONCURRENCY CONTROL</h2><p>在这两个部分中，我们需要实现一个线程安全的可扩展哈希表。在对可扩展哈希表的原理清楚后，将其实现并不困难，难点在于如何在降低锁粒度、提高并发性的情况下保证线程安全。下面是哈希表的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line">HASH_TABLE_TYPE::<span class="built_in">ExtendibleHashTable</span>(<span class="type">const</span> std::string &amp;name, BufferPoolManager *buffer_pool_manager,</span><br><span class="line">                                     <span class="type">const</span> KeyComparator &amp;comparator, HashFunction&lt;KeyType&gt; hash_fn)</span><br><span class="line">: <span class="built_in">buffer_pool_manager_</span>(buffer_pool_manager), <span class="built_in">comparator_</span>(comparator), <span class="built_in">hash_fn_</span>(std::<span class="built_in">move</span>(hash_fn)) &#123;</span><br><span class="line">    <span class="comment">// LOG_DEBUG(&quot;BUCKET_ARRAY_SIZE = %ld&quot;, BUCKET_ARRAY_SIZE);</span></span><br><span class="line">    HashTableDirectoryPage *dir_page =</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;directory_page_id_));</span><br><span class="line">    dir_page-&gt;<span class="built_in">SetPageId</span>(directory_page_id_);</span><br><span class="line">    <span class="type">page_id_t</span> new_bucket_id;</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;new_bucket_id);</span><br><span class="line">    dir_page-&gt;<span class="built_in">SetBucketPageId</span>(<span class="number">0</span>, new_bucket_id);</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_bucket_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中，为哈希表分配一个目录页面和桶页面，并设置目录页面的<code>page_id</code>成员、将哈希表的首个目录项指向该桶。最后，不要忘记调用<code>UnpinPage</code>向缓冲池告知页面的使用完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">HASH_TABLE_TYPE::KeyToDirectoryIndex</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> hashed_key = <span class="built_in">Hash</span>(key);</span><br><span class="line">    <span class="type">uint32_t</span> mask = dir_page-&gt;<span class="built_in">GetGlobalDepthMask</span>();</span><br><span class="line">    <span class="keyword">return</span> mask &amp; hashed_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">HASH_TABLE_TYPE::KeyToPageId</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx = <span class="built_in">KeyToDirectoryIndex</span>(key, dir_page);</span><br><span class="line">    <span class="keyword">return</span> dir_page-&gt;<span class="built_in">GetBucketPageId</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">HashTableDirectoryPage *<span class="title">HASH_TABLE_TYPE::FetchDirectoryPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(directory_page_id_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">HASH_TABLE_BUCKET_TYPE *<span class="title">HASH_TABLE_TYPE::FetchBucketPage</span><span class="params">(<span class="type">page_id_t</span> bucket_page_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(bucket_page_id));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面是一些用于提取目录页面、桶页面以及目录页面中的目录项的功能函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_TYPE::GetValue</span><span class="params">(Transaction *transaction, <span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">    HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">    table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">    <span class="type">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, dir_page);</span><br><span class="line">    HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page_id);</span><br><span class="line">    Page *p = <span class="built_in">reinterpret_cast</span>&lt;Page *&gt;(bucket);</span><br><span class="line">    p-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">    <span class="type">bool</span> ret = bucket-&gt;<span class="built_in">GetValue</span>(key, comparator_, result);</span><br><span class="line">    p-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">    table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetValue</code>从哈希表中读取与键匹配的所有值结果，其通过哈希表的读锁保护目录页面，并使用桶的读锁保护桶页面。具体的操作步骤为先读取目录页面，再通过目录页面和哈希键或许对应的桶页面，最后调用桶页面的<code>GetValue</code>获取值结果。在函数返回时注意要<code>UnpinPage</code>所获取的页面。加锁时应当保证锁的获取、释放全局顺序以避免死锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_TYPE::Insert</span><span class="params">(Transaction *transaction, <span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value    )</span> </span>&#123;</span><br><span class="line">    HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">    table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">    <span class="type">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, dir_page);</span><br><span class="line">    HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page_id);</span><br><span class="line">    Page *p = <span class="built_in">reinterpret_cast</span>&lt;Page *&gt;(bucket);</span><br><span class="line">    p-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">        p-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">        table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">        <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">        <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SplitInsert</span>(transaction, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> ret = bucket-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">    p-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">    <span class="comment">// std::cout&lt;&lt;&quot;find the unfull bucket&quot;&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Insert</code>向哈希表插入键值对，这可能会导致桶的分裂和表的扩张，因此需要保证目录页面的读线程安全，一种比较简单的保证线程安全的方法为：在操作目录页面前对目录页面加读锁。但这种加锁方式使得<code>Insert</code>函数阻塞了整个哈希表，这严重影响了哈希表的并发性。可以注意到，表的扩张的发生频率并不高，对目录页面的操作属于读多写少的情况，因此可以使用乐观锁的方法优化并发性能，其在<code>Insert</code>被调用时仅保持读锁，只在需要桶分裂时重新获得读锁。</p>
<p><code>Insert</code>函数的具体流程为：</p>
<ol>
<li>获取目录页面和桶页面，在加全局读锁和桶写锁后检查桶是否已满，如已满则释放锁，并调用<code>UnpinPage</code>释放页面，然后调用<code>SplitInsert</code>实现桶分裂和插入；</li>
<li>如当前桶未满，则直接向该桶页面插入键值对，并释放锁和页面即可。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_TYPE::SplitInsert</span><span class="params">(Transaction *transaction, <span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">    HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">    table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, dir_page);</span><br><span class="line">        <span class="type">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, dir_page);</span><br><span class="line">        HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page_id);</span><br><span class="line">        <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> global_depth = dir_page-&gt;<span class="built_in">GetGlobalDepth</span>();</span><br><span class="line">            <span class="type">uint32_t</span> local_depth = dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx);</span><br><span class="line">            <span class="type">page_id_t</span> new_bucket_id = <span class="number">0</span>;</span><br><span class="line">            HASH_TABLE_BUCKET_TYPE *new_bucket =</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;new_bucket_id));</span><br><span class="line">            <span class="built_in">assert</span>(new_bucket != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>SplitInsert</code>比较复杂，这里进行分段讲解：</p>
<p>首先，获取目录页面并加全局写锁，在添加全局写锁后，其他所有线程均被阻塞了，因此可以放心的操作数据成员。不难注意到，在<code>Insert</code>中释放读锁和<code>SplitInsert</code>中释放写锁间存在空隙，其他线程可能在该空隙中被调度，从而改变桶页面或目录页面数据。因此，在这里需要重新在目录页面中获取哈希键所对应的桶页面（可能与<code>Insert</code>中判断已满的页面不是同一页面），并检查对应的桶页面是否已满。如桶页面仍然是满的，则分配新桶和提取原桶页面的元数据。在由于桶分裂后仍所需插入的桶仍可能是满的，因此在这这里进行循环以解决该问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (global_depth == local_depth) &#123;</span><br><span class="line">    <span class="comment">// if i == ij, extand the bucket dir, and split the bucket</span></span><br><span class="line">    <span class="type">uint32_t</span> bucket_num = <span class="number">1</span> &lt;&lt; global_depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; bucket_num; i++) &#123;</span><br><span class="line">        dir_page-&gt;<span class="built_in">SetBucketPageId</span>(i + bucket_num, dir_page-&gt;<span class="built_in">GetBucketPageId</span>(i));</span><br><span class="line">        dir_page-&gt;<span class="built_in">SetLocalDepth</span>(i + bucket_num, dir_page-&gt;<span class="built_in">GetLocalDepth</span>(i));</span><br><span class="line">    &#125; </span><br><span class="line">    dir_page-&gt;<span class="built_in">IncrGlobalDepth</span>();</span><br><span class="line">    dir_page-&gt;<span class="built_in">SetBucketPageId</span>(bucket_idx + bucket_num, new_bucket_id);</span><br><span class="line">    dir_page-&gt;<span class="built_in">IncrLocalDepth</span>(bucket_idx);</span><br><span class="line">    dir_page-&gt;<span class="built_in">IncrLocalDepth</span>(bucket_idx + bucket_num);</span><br><span class="line">    global_depth++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// if i &gt; ij, split the bucket</span></span><br><span class="line">    <span class="comment">// more than one records point to the bucket</span></span><br><span class="line">    <span class="comment">// the records&#x27; low ij bits are same</span></span><br><span class="line">    <span class="comment">// and the high (i - ij) bits are index of the records point to the same bucket</span></span><br><span class="line">    <span class="type">uint32_t</span> mask = (<span class="number">1</span> &lt;&lt; local_depth) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> base_idx = mask &amp; bucket_idx;</span><br><span class="line">    <span class="type">uint32_t</span> records_num = <span class="number">1</span> &lt;&lt; (global_depth - local_depth - <span class="number">1</span>);</span><br><span class="line">    <span class="type">uint32_t</span> step = (<span class="number">1</span> &lt;&lt; local_depth);</span><br><span class="line">    <span class="type">uint32_t</span> idx = base_idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; records_num; i++) &#123;</span><br><span class="line">        dir_page-&gt;<span class="built_in">IncrLocalDepth</span>(idx);</span><br><span class="line">        idx += step * <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    idx = base_idx + step;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; records_num; i++) &#123;</span><br><span class="line">        dir_page-&gt;<span class="built_in">SetBucketPageId</span>(idx, new_bucket_id);</span><br><span class="line">        dir_page-&gt;<span class="built_in">IncrLocalDepth</span>(idx); </span><br><span class="line">        idx += step * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，需要根据全局深度和桶页面的局部深度判断扩展表和分裂桶的策略。当<code>global_depth == local_depth</code>时，需要进行表扩展和桶分裂，<code>global_depth == local_depth</code>仅需进行桶分裂即可。原理介绍见上文所示：[表扩展及分裂桶](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#splitmethod1)、[仅分裂桶](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#splitmethod2)，在这里不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rehash all records in bucket j</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    KeyType j_key = bucket-&gt;<span class="built_in">KeyAt</span>(i);</span><br><span class="line">    ValueType j_value = bucket-&gt;<span class="built_in">ValueAt</span>(i);</span><br><span class="line">    bucket-&gt;<span class="built_in">RemoveAt</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeyToPageId</span>(j_key, dir_page) == bucket_page_id) &#123;</span><br><span class="line">        bucket-&gt;<span class="built_in">Insert</span>(j_key, j_value, comparator_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        new_bucket-&gt;<span class="built_in">Insert</span>(j_key, j_value, comparator_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout&lt;&lt;&quot;original bucket size = &quot;&lt;&lt;bucket-&gt;NumReadable()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// std::cout&lt;&lt;&quot;new bucket size = &quot;&lt;&lt;new_bucket-&gt;NumReadable()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line"><span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_bucket_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>在完成桶分裂后，应当将原桶页面中的记录重新插入哈希表，由于记录的低<code>i-1</code>位仅与原桶页面和新桶页面对应，因此记录插入的桶页面仅可能为原桶页面和新桶页面两个选择。在重新插入完记录后，释放新桶页面和原桶页面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">bool</span> ret = bucket-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="comment">// std::cout&lt;&lt;&quot;find the unfull bucket&quot;&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若当前键值对所插入的桶页面非空（被其他线程修改或桶分裂后结果），则直接插入键值对，并释放锁和页面，并将插入结果返回<code>Insert</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HASH_TABLE_TYPE::Remove</span><span class="params">(Transaction *transaction, <span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">    HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">    table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">    <span class="type">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, dir_page);</span><br><span class="line">    <span class="type">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, dir_page);</span><br><span class="line">    HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page_id);</span><br><span class="line">    Page *p = <span class="built_in">reinterpret_cast</span>&lt;Page *&gt;(bucket);</span><br><span class="line">    p-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">    <span class="type">bool</span> ret = bucket-&gt;<span class="built_in">Remove</span>(key, value, comparator_);</span><br><span class="line">    p-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx) != <span class="number">0</span>) &#123;</span><br><span class="line">        table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Merge</span>(transaction, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Remove</code>从哈希表中删除对应的键值对，其优化思想与<code>Insert</code>相同，由于桶的合并并不频繁，因此在删除键值对时仅获取全局读锁，只在需要合并桶时获取全局写锁。当删除后桶为空且目录项的局部深度不为零时，释放读锁并调用<code>Merge</code>尝试合并页面，随后释放锁和页面并返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HASH_TABLE_TYPE::Merge</span><span class="params">(Transaction *transaction, <span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">    HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">    table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">    <span class="type">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, dir_page);</span><br><span class="line">    <span class="type">page_id_t</span> bucket_page_id = dir_page-&gt;<span class="built_in">GetBucketPageId</span>(bucket_idx);</span><br><span class="line">    HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page_id);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> local_depth = dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx);</span><br><span class="line">        <span class="type">uint32_t</span> global_depth = dir_page-&gt;<span class="built_in">GetGlobalDepth</span>();</span><br><span class="line">        <span class="comment">// How to find the bucket to Merge?</span></span><br><span class="line">        <span class="comment">// Answer: After Merge, the records, which pointed to the Merged Bucket,</span></span><br><span class="line">        <span class="comment">// have low (local_depth - 1) bits same</span></span><br><span class="line">        <span class="comment">// therefore, reverse the low local_depth can get the idx point to the bucket to Merge</span></span><br><span class="line">        <span class="type">uint32_t</span> merged_bucket_idx = bucket_idx ^ (<span class="number">1</span> &lt;&lt; (local_depth - <span class="number">1</span>));</span><br><span class="line">        <span class="type">page_id_t</span> merged_page_id = dir_page-&gt;<span class="built_in">GetBucketPageId</span>(merged_bucket_idx);</span><br><span class="line">        HASH_TABLE_BUCKET_TYPE *merged_bucket = <span class="built_in">FetchBucketPage</span>(merged_page_id);</span><br><span class="line">        <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">GetLocalDepth</span>(merged_bucket_idx) == local_depth &amp;&amp; merged_bucket-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">            local_depth--;</span><br><span class="line">            <span class="type">uint32_t</span> mask = (<span class="number">1</span> &lt;&lt; local_depth) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">uint32_t</span> idx = mask &amp; bucket_idx;</span><br><span class="line">            <span class="type">uint32_t</span> records_num = <span class="number">1</span> &lt;&lt; (global_depth - local_depth);</span><br><span class="line">            <span class="type">uint32_t</span> step = (<span class="number">1</span> &lt;&lt; local_depth);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; records_num; i++) &#123;</span><br><span class="line">                dir_page-&gt;<span class="built_in">SetBucketPageId</span>(idx, bucket_page_id);</span><br><span class="line">                dir_page-&gt;<span class="built_in">DecrLocalDepth</span>(idx);</span><br><span class="line">                idx += step;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer_pool_manager_-&gt;<span class="built_in">DeletePage</span>(merged_page_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">CanShrink</span>()) &#123;</span><br><span class="line">            dir_page-&gt;<span class="built_in">DecrGlobalDepth</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(merged_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Merge</code>函数获取写锁后，需要重新判断是否满足合并条件，以防止在释放锁的空隙时页面被更改，在合并被执行时，需要判断当前目录页面是否可以收缩，如可以搜索在这里仅需递减全局深度即可完成收缩，最后释放页面和写锁。具体的合并细节和策略见[上文](<a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project">https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/Project</a> 2  EXTENDIBLE HASH INDEX.md#mergemethod)。</p>
<h2 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h2><p><a target="_blank" rel="noopener" href="https://github.com/jlu-xiurui/CMU15445-2021-FALL/blob/ghess/p2-refinement/notes/project2_figure/figure11.png"><img src="/2022/11/28/CMU-15-445-PROJECTS/figure11.png" alt="figure11"></a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/27/%E6%9F%A5%E6%89%BE&%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/" rel="prev" title="查找&排序合集">
      <i class="fa fa-chevron-left"></i> 查找&排序合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/02/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" rel="next" title="15.三数之和">
      15.三数之和 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Project-1-BUFFER-POOL"><span class="nav-number">1.</span> <span class="nav-text">Project 1 : BUFFER POOL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task1-LRU-REPLACEMENT-POLICY"><span class="nav-number">1.1.</span> <span class="nav-text">Task1 : LRU REPLACEMENT POLICY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task2-BUFFER-POOL-MANAGER-INSTANCE"><span class="nav-number">1.2.</span> <span class="nav-text">Task2 : BUFFER POOL MANAGER INSTANCE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-3-%EF%BC%9APARALLEL-BUFFER-POOL-MANAGER"><span class="nav-number">1.3.</span> <span class="nav-text">Task 3 ：PARALLEL BUFFER POOL MANAGER</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">1.4.</span> <span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Project-2-EXTENDIBLE-HASH-INDEX"><span class="nav-number">2.</span> <span class="nav-text">Project 2 : EXTENDIBLE HASH INDEX</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">可扩展哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%B6%E5%88%86%E8%A3%82-x2F-%E5%90%88%E5%B9%B6%E8%A1%A8%E6%89%A9%E5%B1%95-x2F-%E6%94%B6%E7%BC%A9"><span class="nav-number">2.1.1.</span> <span class="nav-text">桶分裂&#x2F;合并	表扩展&#x2F;收缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">插入流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-1-PAGE-LAYOUTS"><span class="nav-number">2.2.</span> <span class="nav-text">Task 1 : PAGE LAYOUTS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTableDirectoryPage"><span class="nav-number">2.2.1.</span> <span class="nav-text">HashTableDirectoryPage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTableBucketPage"><span class="nav-number">2.2.2.</span> <span class="nav-text">HashTableBucketPage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page%E4%B8%8E%E4%B8%8A%E8%BF%B0%E4%B8%A4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">Page与上述两个页面类的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-2-3-HASH-TABLE-IMPLEMENTATION-CONCURRENCY-CONTROL"><span class="nav-number">2.3.</span> <span class="nav-text">Task 2,3 : HASH TABLE IMPLEMENTATION + CONCURRENCY CONTROL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-1"><span class="nav-number">2.4.</span> <span class="nav-text">实验结果</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
