<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="C++八股">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股">
<meta property="og:url" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="C++八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215210345480.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150925539.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150826237.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323152150339.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207131212493.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207143613149.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230327182127099.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131442484.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131536296.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131834043.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131924338.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132509995.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132827930.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161432357.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103852887.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230406225101735.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161511598.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AB3FC1B1325FA341A39644BA061FA439.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230208211405978.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183029287.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181113760.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182404371.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/b0b1814b7ed7990ea54c117fbff29599.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152923685.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152937850.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMjQ0Mzg=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183418866.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183448058.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/1011415-20170701192633914-1313517581-20230303141645878.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218115419272.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230219191007830.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230413593.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230607279.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218122345750.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191931072.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230220214904180.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182905354.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182934695.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230330220200112.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221143214363.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227144327617.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120203431492.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221161535855.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221029160442047.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131733787.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131811712.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131913227.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221132718380.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133036044.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133148277.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133313580.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135029847.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135135171.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135313611.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135454172.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120441103.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120745467.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331121001560.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331121710266.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331141852209.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331142913248.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230222155844859.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200347354.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200602769.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230309193955191.png">
<meta property="article:published_time" content="2022-11-06T14:21:59.000Z">
<meta property="article:modified_time" content="2023-04-07T01:44:01.955Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++八股 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++八股
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 22:21:59" itemprop="dateCreated datePublished" datetime="2022-11-06T22:21:59+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-07 09:44:01" itemprop="dateModified" datetime="2023-04-07T09:44:01+08:00">2023-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C++八股</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="0️⃣C-x2F-C-基础"><a href="#0️⃣C-x2F-C-基础" class="headerlink" title="0️⃣C&#x2F;C++基础"></a>0️⃣C&#x2F;C++基础</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><p>向上转型为什么是安全的？</p>
<p>向上转型是安全的，因为它是将子类对象转换为父类对象，不会丢失子类对象的任何信息。这是因为子类继承了父类的属性和方法，所以子类对象包含了父类对象的所有信息</p>
<h5 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++ 中的四种类型转换"></a>C++ 中的四种类型转换</h5><p><code>static_cast&lt;type&gt;(a)</code> </p>
<blockquote>
<p>  和传统的C语言的强制转换一样，不做任何检查，如转型失败会发生未知错误。</p>
<p><code>static_cast&lt;type&gt;(a)</code> 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int 这种转换的安全性也要开发人员来保证</p>
</blockquote>
<p><code>dynamic_cast&lt;type&gt;(a)</code></p>
<blockquote>
<p>   主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全</p>
<p>  转型失败会返回0并抛出bad_cast</p>
</blockquote>
<p><code>const_cast&lt;type&gt;(a)</code> ：用来去除<strong>某指针或者引用的</strong>const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 </p>
<p><code>reinterpret_cast&lt;type&gt;(a) </code>：可进行任意转型，把a中的内存按type的方式来解读，需要程序员保证转换的正确性。</p>
<hr>
<h5 id="说说-C-中-struct-和-class-的区别"><a href="#说说-C-中-struct-和-class-的区别" class="headerlink" title="说说 C++中 struct 和 class 的区别"></a>说说 C++中 struct 和 class 的区别</h5><ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 private </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 默认是公有继承，而 class 是私有继承</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Y&amp; y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="⚠️说说头文件双引号””和尖括号-lt-gt-的区别"><a href="#⚠️说说头文件双引号””和尖括号-lt-gt-的区别" class="headerlink" title="⚠️说说头文件双引号””和尖括号&lt;&gt;的区别"></a>⚠️说说头文件双引号””和尖括号&lt;&gt;的区别</h5><ul>
<li>&lt;&gt;的头文件是<strong>系统文件</strong>，””的头文件是<strong>自定义文件</strong></li>
<li>编译器预处理阶段查找头文件的路径不一样<ul>
<li>使用&lt;&gt;的头文件：编译器设置的头文件路径</li>
<li>使用””的头文件：当前头文件目录 -&gt; 编译器设置的头文件路径</li>
</ul>
</li>
</ul>
<hr>
<h5 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h5><ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充, 它们在声明时的区别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制权限</td>
<td align="center">默认public，不能修改</td>
<td align="center">public&#x2F;private&#x2F;protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可继承类或者其他结构体</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;  </span><br><span class="line">  <span class="type">int</span>  iAgeNum;  </span><br><span class="line">  string strName; </span><br><span class="line">&#125; <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Student2; <span class="comment">//C中取别名  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1; <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line">Student stu3;  <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="导入C函数的关键字？C-编译时和C有何不同？"><a href="#导入C函数的关键字？C-编译时和C有何不同？" class="headerlink" title="导入C函数的关键字？C++编译时和C有何不同？"></a>导入C函数的关键字？C++编译时和C有何不同？</h5><ol>
<li><p><strong>关键字：</strong>在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为<strong>extern “C”</strong>。加上extern “C”后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而非C++的</p>
</li>
<li><p><strong>编译区别：</strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时只包括<strong>函数名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="⚠️简述C-从代码到可执行文件过程"><a href="#⚠️简述C-从代码到可执行文件过程" class="headerlink" title="⚠️简述C++从代码到可执行文件过程"></a>⚠️简述C++从代码到可执行文件过程</h5><p> C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预处理、编译、汇编、链接</strong>。</p>
<ol>
<li><p>预处理</p>
<p>（1） 展开所有的宏定义#define</p>
<p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p>
<p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p>
<p>（4） 过滤所有的注释, 添加行号, 添加文件名标识</p>
</li>
<li><p>编译</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树</p>
<p>（3） 语义分析：判断表达式是否有意义</p>
<p>（4） 代码优化</p>
<p>（5） 生成汇编代码</p>
</li>
<li><p>汇编    将汇编代码 -&gt; 机器码</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。分为静态链接和动态链接。</p>
<p><strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；Windows下.lib	Linux下.a</p>
<blockquote>
<p>  <code>ar rcs Calc.a x.o y.o</code></p>
<p>  <code>gcc main.c -o myprogramme -L ./ -l Calc</code>		[第一个myprogramme是生成的可执行文件名]</p>
</blockquote>
<p><strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，生成的可执行文件中没有函数代码, 只包含函数的重定位信息, 在执行的过程中，再去找要链接的函数. 所以当删除动态库时，可执行程序就不能运行. Windows下.dll，Linux下.so</p>
<blockquote>
<p>   <code>gcc -c -fPIC a.c b.c</code>		gcc 得到.o文件，得到和位置无关的代码<br>  <code>gcc -shared a.o b.o -o libcalc.so</code>		gcc 得到动态库</p>
</blockquote>
</li>
</ol>
<p>	</p>
<hr>
<h5 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h5><ol>
<li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li>
<li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。</li>
<li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li>
<li><strong>静态成员函数和静态成员变量</strong>是类的一部分,可以被多个对象所共享,无法访问一个对象中的非静态成员</li>
</ol>
<hr>
<h5 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h5><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化</p>
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造</p>
<hr>
<h5 id="说说静态局部变量-全局变量-局部变量的特点"><a href="#说说静态局部变量-全局变量-局部变量的特点" class="headerlink" title="说说静态局部变量, 全局变量, 局部变量的特点"></a>说说静态局部变量, 全局变量, 局部变量的特点</h5><ol>
<li><p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件</p>
<p>全局变量：全局作用域，可以通过extern作用于其他的源文件</p>
</li>
<li><p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值</p>
</li>
</ol>
<hr>
<h5 id="⚠️说说什么是函数指针"><a href="#⚠️说说什么是函数指针" class="headerlink" title="⚠️说说什么是函数指针"></a>⚠️说说什么是函数指针</h5><ol>
<li><strong>概念：</strong>函数指针就是<strong>指向函数入口地址</strong>的指针。</li>
<li><strong>定义</strong>形式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in">int</span> (*f)(<span class="type">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *,<span class="type">const</span> <span class="type">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a , <span class="type">const</span> <span class="type">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in">sizeof</span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="nullptr可以调用成员函数吗？为什么？"><a href="#nullptr可以调用成员函数吗？为什么？" class="headerlink" title="nullptr可以调用成员函数吗？为什么？"></a>nullptr可以调用成员函数吗？为什么？</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以，因为在<strong>编译时指针</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this&#x3D;nullptr，运行出错。</p>
<hr>
<h5 id="内联函数和函数的区别-内联函数的作用"><a href="#内联函数和函数的区别-内联函数的作用" class="headerlink" title="内联函数和函数的区别,内联函数的作用"></a>内联函数和函数的区别,内联函数的作用</h5><ol>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p>   <strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<hr>
<h5 id="说说内联函数和宏的区别"><a href="#说说内联函数和宏的区别" class="headerlink" title="说说内联函数和宏的区别"></a>说说内联函数和宏的区别</h5><ol>
<li><strong>宏定义不是函数</strong>，相当于直接替换；<strong>而内联函数本质上是一个函数</strong>，内联函数满足函数的性质，比如有返回值、参数列表</li>
<li><strong>宏函数</strong>是在预编译的时候字符串替换；<strong>而内联函数</strong>则是在编译的时候进行代码插入</li>
<li><strong>宏定义</strong>是没有类型检查的；<strong>而内联函数</strong>在编译的时候会进行类型的检查</li>
</ol>
<hr>
<h5 id="说说new和malloc的区别，底层实现原理"><a href="#说说new和malloc的区别，底层实现原理" class="headerlink" title="说说new和malloc的区别，底层实现原理"></a>说说new和malloc的区别，底层实现原理</h5><ol>
<li>new是操作符可以被重载，而malloc是函数</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转</li>
<li>new分配内存更直接和安全</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk () 函数【当进程需要分配更多内存时，可以使用<code>brk()</code>函数将堆的结束位置向上移动一定的距离。相反，当进程释放内存时，可以使用<code>brk()</code>将堆的结束位置向下移动】；当开辟的空间大于 128K 时，调用mmap()</p>
<p>malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<p> (1) 创建一个新的对象</p>
<p> (2) 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
<p> (3) 执行构造函数（为这个新对象添加属性）</p>
<hr>
<h5 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h5><ol>
<li>delete 是操作符，而 free 是函数；</li>
<li>free 不会调用对象的析构函数，而 delete 会调用对象的析构函数；</li>
<li>调用 free 之前需要检查要释放的指针是否为 NULL，使用 delete 释放内存则不需要检查指针是否为 NULL；</li>
</ol>
<hr>
<h5 id="说说const和define的区别。"><a href="#说说const和define的区别。" class="headerlink" title="说说const和define的区别。"></a>说说const和define的区别。</h5><p>const用于定义常量；而define用于定义宏 ：</p>
<ol>
<li>const生效于编译的阶段；define生效于预处理阶段</li>
<li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的</li>
<li>const定义的常量是带类型的；define定义的常量不带类型，不利于类型检查</li>
</ol>
<hr>
<h5 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">const</span> <span class="type">int</span> a;     <span class="comment">// 指的是a是一个常量，不允许修改</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// 同 const int *a;</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="number">5.</span> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> a;   <span class="comment">// 都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️同名全局变量在多个c文件中公用的方法"><a href="#⚠️同名全局变量在多个c文件中公用的方法" class="headerlink" title="⚠️同名全局变量在多个c文件中公用的方法"></a>⚠️同名全局变量在多个c文件中公用的方法</h5><p>项目文件夹下有a.c、b.c和c.h三个文件, 其中a.c和b.c文件中都#include c.h <strong>我们希望声明一个变量key，在a.c和b.c中公用</strong></p>
<p>有人想，既然是想两个文件都用，那就在c.h中声明一个unsigned char key，然后由于包含关系，在a.c和b.c中都是可见的，所以就能共用了,但实际写出来，我们发现编译的时候编译器提示出错，编译器认为我们重复定义了key这个变量。这是因为**#include命令就是原封不动的把头文件中的内容搬到#include的位置**，所以相当于a.c和b.c中都执行了一次unsigned char key，而C语言中全局变量是项目内可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义</p>
<p><strong>正确办法1：</strong>使用extern关键字来声明变量为外部变量。在其中一个c文件中定义一个全局变量key，然后在另一个要使用key的c文件中用extern声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：<strong>定义</strong>和<strong>声明</strong>。例如在a.c文件中定义变量key，在b.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png" alt="image-20230215202524179" style="zoom:50%;">

<p><strong>正确办法2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a.c文件中：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> changeflag = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*c.h文件中：*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> changeflag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*b.c文件中：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span> <span class="comment">// 这样就已经可以使用全局变量 changeflag 了。</span></span></span><br></pre></td></tr></table></figure>

<p><strong>正确方法3:</strong> 在不同的C文件中以<strong>static形式来声明同名全局变量</strong></p>
<hr>
<h5 id="c-命名空间"><a href="#c-命名空间" class="headerlink" title="c++命名空间"></a>c++命名空间</h5><p>namespace命名空间语法，定义格式为namespace  A {}，大括号是范围限定，也就是括号内是一个整体空间，可以有任何东西，如变量、函数等，括号内可以直接引用，而括号外的想相互访问必须指定<strong>空间名称+内部名称</strong>，namespace本质上就是改变全局变量或函数的链接属性，即改变作用域。</p>
<p><strong>定义:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test&#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line">test::<span class="built_in">func1</span>();</span><br><span class="line">test::<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">using</span> test::func1; <span class="comment">//单独声明命名空间中的func1函数</span></span><br><span class="line"><span class="built_in">func1</span>();            <span class="comment">//直接使用func1，无须添加其他的前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> test;  <span class="comment">//将整个命名空间全部声明</span></span><br><span class="line">func1（）;            <span class="comment">//访问空间内的函数1</span></span><br><span class="line">func2（）;            <span class="comment">//访问空间内的函数2</span></span><br></pre></td></tr></table></figure>

<p><strong>跨文件使用:</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215210345480.png" alt="image-20230215210345480"></p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h6><p><strong>命名空间只能全局范围内定义（以下错误写法)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> A&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间可嵌套命名空间</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123; <span class="type">int</span> a = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123; <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;	<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-如何在main函数前运行一个函数"><a href="#C-如何在main函数前运行一个函数" class="headerlink" title="C++如何在main函数前运行一个函数"></a>C++如何在main函数前运行一个函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Init function is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitWrapper</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InitWrapper s_initWrapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main function is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这种方法虽然可以在 <code>main()</code> 函数执行之前执行一个函数，但是由于全局变量的构造函数在程序启动时会被自动调用，因此在多个文件中定义全局变量时可能会引起链接错误。为了避免这个问题，可以将全局变量定义在一个独立的文件中，并在其他文件中使用该全局变量</p>
<hr>
<h5 id="Explicit和隐式类型转换"><a href="#Explicit和隐式类型转换" class="headerlink" title="Explicit和隐式类型转换"></a>Explicit和隐式类型转换</h5><p>隐式类型转换指的是一种自动进行的类型转换，将一个数据类型自动转换为另一个数据类型，而不需要显式地调用任何类型转换函数。</p>
<p>隐式类型转换在表达式求值时自动发生，可以将一个值从一种数据类型转换为另一种数据类型。例如，当一个<code>int</code>类型的值被赋值给一个<code>float</code>类型的变量时，就会发生隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> f = n; <span class="comment">// 隐式类型转换，将n从int类型转换为float类型</span></span><br></pre></td></tr></table></figure>

<p>此外，当表达式中出现多种数据类型时，也会发生隐式类型转换，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = n + f; <span class="comment">// 隐式类型转换，将n和f分别转换为double类型，然后执行加法运算</span></span><br></pre></td></tr></table></figure>

<p>虽然隐式类型转换可以方便地进行数据类型的转换，但是在某些情况下可能会引发一些不必要的错误或问题，因此需要谨慎使用。可以通过使用<code>explicit</code>关键字来限制某些类型转换的发生，使代码更加明确和安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        value = n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">//MyClass obj = n; // 错误，不能进行隐式类型转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(n)</span></span>; <span class="comment">// 正确，使用显式构造函数进行对象创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果去掉<code>explicit</code>关键字，则可以进行隐式类型转换，例如<code>MyClass obj = n;</code>就可以编译通过，将一个<code>int</code>类型的变量转换为<code>MyClass</code>类型的对象</p>
<h4 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h4><h5 id="⚠️进程运行时虚拟地址空间"><a href="#⚠️进程运行时虚拟地址空间" class="headerlink" title="⚠️进程运行时虚拟地址空间"></a>⚠️进程运行时虚拟地址空间</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png" alt="img" style="zoom: 67%;">

<ol>
<li><p><strong>data段：</strong>已初始化的全局变量和静态变量</p>
</li>
<li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</p>
</li>
<li><p><strong>bss段</strong>：未初始化的全局变量和静态变量</p>
</li>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>OS创建进程并分配私有进程空间, 然后OS加载器把可执行文件的数据段和代码段映射到进程的虚拟内存空间</li>
<li>加载器读入可执行程序的导入符号表, 根据符号表可以查找出该可执行程序的所有依赖的动态链接库。调用动态链接库的初始化函数</li>
<li>初始化全局变量和全局对象</li>
<li>进入可执行程序入口处开始执行</li>
</ol>
<hr>
<h5 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h5><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放</p>
<p><strong>堆</strong>，就是那些由malloc等分配的内存块</p>
<p><strong>自由存储区</strong>，就是那些由new分配的内存块，和堆是十分相似的</p>
<p><strong>静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改</p>
</li>
<li><p><strong>内存泄露</strong>：</p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数</p>
</li>
</ol>
<hr>
<h5 id="⚠️常量存放在内存的哪个位置？"><a href="#⚠️常量存放在内存的哪个位置？" class="headerlink" title="⚠️常量存放在内存的哪个位置？"></a>⚠️常量存放在内存的哪个位置？</h5><p>局部常量，存放在栈区；</p>
<p>全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</p>
<p>字面值常量, 比如字符串，放在常量区。</p>
<hr>
<h5 id="⚠️简述C-中内存对齐的使用场景"><a href="#⚠️简述C-中内存对齐的使用场景" class="headerlink" title="⚠️简述C++中内存对齐的使用场景"></a>⚠️简述C++中内存对齐的使用场景</h5><p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong>，对齐原则有四个：</p>
<ol>
<li><p>struct或union的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始</p>
</li>
<li><p>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(class a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)</p>
</li>
<li><p>sizeof(struct) &#x3D; 其内部“最宽基本类型成员”的整数倍。(基本类型不包括struct&#x2F;class&#x2F;uinon)</p>
</li>
<li><p>sizeof(union) &#x3D; 结构里面size最大元素的size，因为在某一时刻，union只有一个成员真正存储于该地址</p>
</li>
</ol>
<hr>
<h5 id="说下RAII-与智能指针之间的联系"><a href="#说下RAII-与智能指针之间的联系" class="headerlink" title="说下RAII, 与智能指针之间的联系"></a>说下RAII, 与智能指针之间的联系</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用RAII</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Agouzao&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Axigou&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// delete a; 堆内存忘记释放,多了可能引起内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用RAII改造后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T *a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n = <span class="number">1</span>) &#123; a = <span class="keyword">new</span> T[n]; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; </span><br><span class="line">        <span class="keyword">delete</span> []a;</span><br><span class="line">        a = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; <span class="comment">// 调用A构造创建a对象.是普通的栈内存对象.</span></span><br><span class="line">    <span class="comment">// 当其作用范围结束后,就会自动调用其析构函数释放a对象的内存</span></span><br><span class="line">    <span class="type">int</span> *ptr = a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;T[]&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n = <span class="number">1</span>) : <span class="built_in">a</span>(<span class="keyword">new</span> T[n]) &#123;&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a.<span class="built_in">get</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="type">int</span> *ptr = a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是为了理解RAII简单的实现了一下，实际操作中这么写还会出现很多问题. </p>
<p>RAII对象也可以进行复制，但是拷贝的时候必须要一并复制它所管理的资源。一般设置为不可拷贝是为了防止误拷贝时使用了自动生成的拷贝函数，自动生成的函数一般进行的是浅拷贝</p>
<p>简单的处理就是为A类定义一个父类，在父类中将拷贝构造、赋值操作符与new操作符重载声明为私有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAII升级版</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABase</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ABase</span>(<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认拷贝构造</span></span><br><span class="line">        ABase &amp;<span class="keyword">operator</span> = (<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认重载操作符</span></span><br><span class="line">        <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">// 防止子类new</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">        ~<span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>RAII与智能指针</strong></p>
<p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() : <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Resource&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Resource())</span></span>; <span class="comment">// 等价于 Resource* ptr = new Resource(); 	delete ptr; </span></span><br><span class="line">    <span class="comment">// 使用ptr管理Resource对象，无需手动调用delete释放资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// ptr在此处离开作用域，自动释放Resource对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="RAII补充"><a href="#RAII补充" class="headerlink" title="RAII补充"></a>RAII补充</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        m_size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span>[] m_data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++)  m_data[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 <code>testA</code> 函数中没有正确地删除 <code>a</code> 对象，就会导致数组的内存泄漏。例如，如果我们在 <code>testA</code> 函数中添加一个无限循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时程序会陷入无限循环，无法退出 <code>testA</code> 函数。当 <code>main</code> 函数结束时，<code>a</code> 对象并没有被正确地删除，导致数组的内存泄漏。</p>
<p><strong>RAII改写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        m_data = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(size);</span><br><span class="line">        m_size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) m_data[i] = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; m_data;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><h5 id="简述一下-C-重载和重写"><a href="#简述一下-C-重载和重写" class="headerlink" title="简述一下 C++重载和重写"></a>简述一下 C++重载和重写</h5><ul>
<li><p>重写:是指派生类中存在重新定义的函数。</p>
<p>其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>基类中被重写的函数必须有virtual修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a -&gt; <span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载</p>
<p>在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个<strong>具有不同参数（参数的类型，个数，顺序不同）的同名函数</strong>，根据参数列表确定调用哪个函数，重载的返回值类型可以不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;;     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="说说-C-重载和重写是如何实现的"><a href="#说说-C-重载和重写是如何实现的" class="headerlink" title="说说 C++ 重载和重写是如何实现的"></a>说说 C++ 重载和重写是如何实现的</h5><ul>
<li><p>重写</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数</li>
<li>有虚函数的<strong>类</strong>都有个一维的虚函数表叫做虚表，<strong>类的每个对象有一个指向虚表开始的虚指针</strong>。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚指针指向派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚指针指向的是父类的虚函数地址</li>
<li><strong>多态</strong>性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数</strong></p>
</li>
<li><p>重载</p>
<p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
</li>
</ul>
<hr>
<h5 id="说说C-构造函数有几种"><a href="#说说C-构造函数有几种" class="headerlink" title="说说C++构造函数有几种"></a>说说C++构造函数有几种</h5><p>C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li><p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()&#123; <span class="comment">//默认构造函数  </span></span><br><span class="line">            num=<span class="number">1001</span>;        </span><br><span class="line">            age=<span class="number">18</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">int</span> a):<span class="built_in">num</span>(n),<span class="built_in">age</span>(a)&#123;&#125; <span class="comment">//初始化构造函数  </span></span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="type">int</span> num;  </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Student s1; <span class="comment">//用默认构造函数初始化对象S1  </span></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">18</span>)</span></span>; <span class="comment">//用初始化构造函数初始化对象S2  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li><p>复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;     </span><br><span class="line">    <span class="type">int</span> i;     </span><br><span class="line">    <span class="type">int</span> *p; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> value)&#123;         </span><br><span class="line">            i = ai;         </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">int</span>(value);     </span><br><span class="line">        &#125;     </span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;         </span><br><span class="line">            <span class="keyword">delete</span> p;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t)&#123;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;i = t.i;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*t.p);     </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;     </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;     </span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>：只是对指针的拷贝，拷贝后两个指针指向同一个内存空间。修改其中任意的值,另一个值都会变化</p>
<p><strong>深拷贝</strong>：不但对指针进行拷贝, 且对指针指向的内容拷贝, 经过深拷贝后的指针是指向两个不同地址的指针。修改其中任意的值,另一个值不会变化</p>
</li>
<li><p>移动构造函数</p>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷</p>
<p>拷贝构造函数中，对于指针，我们采用深拷贝，<strong>而移动构造函数中，对于指针，我们采用浅拷贝。浅拷贝之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针 (如a-&gt; value) 置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</strong></p>
<p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)&#123; <span class="comment">// &amp;&amp; 是右值引用 	int num = 10;  int &amp;&amp; a = 10;     </span></span><br><span class="line">		p = a.p;</span><br><span class="line">		a.p = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123; <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ch;</span><br><span class="line">	<span class="function">Test <span class="title">c</span><span class="params">(move(p))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="只定义析构函数-会自动生成哪些构造函数"><a href="#只定义析构函数-会自动生成哪些构造函数" class="headerlink" title="只定义析构函数,会自动生成哪些构造函数"></a>只定义析构函数,会自动生成哪些构造函数</h5><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<blockquote>
<p>  默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作</p>
</blockquote>
<hr>
<h5 id="一个类默认会生成哪些函数"><a href="#一个类默认会生成哪些函数" class="headerlink" title="一个类默认会生成哪些函数"></a>一个类默认会生成哪些函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认会生成以下几个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.默认构造</span></span><br><span class="line"><span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.拷贝构造</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值运算符</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.析构函数（非虚）</span></span><br><span class="line">~<span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="哪些因素会影一个类对象的大小"><a href="#哪些因素会影一个类对象的大小" class="headerlink" title="哪些因素会影一个类对象的大小"></a>哪些因素会影一个类对象的大小</h5><p>对象大小 &#x3D; 虚函数指针 + 所有非静态数据成员大小 + 因对齐而多占的字节</p>
<blockquote>
<p>  静态成员变量是属于类的，而不是属于对象的。它们在内存中只有一份副本(虚表也是)，被所有该类的对象所共享。因此，无论该类有多少个对象，静态成员变量的内存占用量都是固定的</p>
</blockquote>
<hr>
<h5 id="继承一个类的对象的内存结构"><a href="#继承一个类的对象的内存结构" class="headerlink" title="继承一个类的对象的内存结构"></a>继承一个类的对象的内存结构</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br><span class="line"><span class="operator">|</span> vptr   </span><br><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br><span class="line"><span class="operator">|</span> Base class       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> members          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------|</span></span><br><span class="line"><span class="operator">|</span> Derived class    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> members 		   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br></pre></td></tr></table></figure>

<p>类的虚表放在程序的数据段（.data）, 类对象的虚指针放在对象内存的开头</p>
<hr>
<h5 id="继承两个类并重写了它们的虚函数的对象的内存结构"><a href="#继承两个类并重写了它们的虚函数的对象的内存结构" class="headerlink" title="继承两个类并重写了它们的虚函数的对象的内存结构"></a>继承两个类并重写了它们的虚函数的对象的内存结构</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">qux</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">baz</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> vptr <span class="keyword">to</span> A<span class="string">&#x27;s vtable      |</span></span><br><span class="line"><span class="string">|------------------------ |</span></span><br><span class="line"><span class="string">| A class members         |</span></span><br><span class="line"><span class="string">|------------------------ |</span></span><br><span class="line"><span class="string">| vptr to B&#x27;</span>s vtable      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> B class members         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> C class members         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h5><ol>
<li><p>向上转型本身就是安全的</p>
</li>
<li><p>向下转型:</p>
<p>(1) 可以使用强制转换, 这种转换不安全, 会导致数据的丢失, <strong>原因是父类的指针或者引用的内存中可能不包含子类的成员的内存</strong></p>
<p>(2) <code>dynamic_cast&lt;type_id&gt;(expression) </code>主要还是用于执行“安全的向下转型（safe downcasting）”，也即是基类对象的指针或引用转换为同一继承层次的其他指针或引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast&lt;type_id&gt;(expression) 把expression转换成type-id类型的对象</span></span><br><span class="line"><span class="comment">// type_id 必须是类的指针、类的引用或者void*</span></span><br><span class="line"><span class="comment">// 使用场景：我们想使用基类对象的指针或引用来调用某个派生类的操作，并且该操作不是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base *Pb = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	Derived* Pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(Pb);</span><br><span class="line">	Pd-&gt;<span class="built_in">func</span>();  <span class="comment">//将输出hello world!	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述下深拷贝和浅拷贝-如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝-如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝, 如何实现深拷贝"></a>简述下深拷贝和浅拷贝, 如何实现深拷贝</h5><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<p>深拷贝的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">deepCopyString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="type">char</span>* dest = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];  <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, len + <span class="number">1</span>);      <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;xxxxxx&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* aa = a.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">deepCopyString</span>(aa) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法2: 赋值运算符的重载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png" alt="img" style="zoom:50%;">

<hr>
<h5 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h5><ol>
<li><p>多态成员变量: 编译运行看左边</p>
</li>
<li><p>静态方法和变量：编译运行都看左边，同成员变量一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu *f = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f -&gt; num &lt;&lt; endl; <span class="comment">// 取Fu中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态成员方法: 编译看左边,运行看右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu* f1 = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f1-&gt; <span class="built_in">show</span>() &lt;&lt; endl; <span class="comment">// 用基类类型指针绑定派生类实例,调用的是子类重写后的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说为什么要虚析构-为什么不能虚构造"><a href="#说说为什么要虚析构-为什么不能虚构造" class="headerlink" title="说说为什么要虚析构, 为什么不能虚构造"></a>说说为什么要虚析构, 为什么不能虚构造</h5><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，</p>
<ol>
<li>用子类指针绑定子类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用父类指针绑定子类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构父类，不会析构子类对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。</strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li><p>不能虚构造：</p>
<p>虚函数需要一个虚表存储, 这个表的地址是存储在对象的内存空间开始的。如果将构造函数设置为虚函数，就需要到虚表中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</p>
</li>
</ol>
<hr>
<h5 id="构造函数中可以调用虚函数吗？"><a href="#构造函数中可以调用虚函数吗？" class="headerlink" title="构造函数中可以调用虚函数吗？"></a>构造函数中可以调用虚函数吗？</h5><p>可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数</p>
<hr>
<h5 id="说说模板类"><a href="#说说模板类" class="headerlink" title="说说模板类"></a>说说模板类</h5><ol>
<li>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
<li>模板具体化：<strong>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化</strong>。具体化时可以修改原模板的定义 [修改类内函数(不是重写)]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">sizeof</span>(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">int</span>&gt; intStruct; <span class="comment">// 4</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">double</span>&gt; doubleStruct; <span class="comment">// --8--</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">char</span>&gt; llStruct; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++ 类内可以定义引用数据成员吗？"></a>C++ 类内可以定义引用数据成员吗？</h5><p>c++类内可以定义引用成员变量，但要遵循以下规则：</p>
<ol>
<li>必须用初始化列表(构造)来初始化引用成员变量。否则会造成引用未初始化错误</li>
<li>构造函数的形参也必须是引用类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> &amp;target) :<span class="built_in">a</span>(target)&#123;  <span class="comment">//初始化列表</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>; <span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;</span><br><span class="line">	r.<span class="built_in">printA</span>(); <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> &amp;b = a; <span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">	r1.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️简述一下什么是常函数，有什么作用"><a href="#⚠️简述一下什么是常函数，有什么作用" class="headerlink" title="⚠️简述一下什么是常函数，有什么作用"></a>⚠️简述一下什么是常函数，有什么作用</h5><p>类的成员函数后面加 const（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），表明这个函数不会对这个类对象中的<strong>非静态数据成员</strong>作任何改变。</p>
<p><strong>非const类型的数据可以给const类型的变量赋值，反之则不成立</strong></p>
<p><strong>在实例化对象时添加const关键字，就是const对象，const对象只能访问类中的const成员变量和const成员函数</strong></p>
<hr>
<h5 id="说说-C-中什么是菱形继承问题，如何解决"><a href="#说说-C-中什么是菱形继承问题，如何解决" class="headerlink" title="说说 C++ 中什么是菱形继承问题，如何解决"></a>说说 C++ 中什么是菱形继承问题，如何解决</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png" alt="img" style="zoom:25%;">

<p>假设我们有类B和类C，它们都继承了相同的类A。<strong>另外我们还有类D，类D通过多重继承机制继承了类B和类C</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  *Animal类对应于图表的类A* */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;     </span><br><span class="line">    <span class="type">int</span> weight;      </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> weight; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Liger</span> : <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Liger lg;   <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span>   </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>();  <span class="comment">//   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在我们的继承结构中，<strong>我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象”lg”会包含Animal基类的两个子对象。</strong></p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用”lg.getWeight()”将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</p>
</li>
<li><p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;  <span class="comment">// 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了”virtual”关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Liger lg;  <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>  </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="虚继承多个父类的子类的内存结构"><a href="#虚继承多个父类的子类的内存结构" class="headerlink" title="虚继承多个父类的子类的内存结构"></a>虚继承多个父类的子类的内存结构</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.a = <span class="number">1</span>;</span><br><span class="line">  d.b = <span class="number">2</span>;</span><br><span class="line">  d.c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Derived</code> 类虚继承了 <code>Base1</code> 和 <code>Base2</code> 两个基类，并拥有一个自己独有的成员 <code>c</code>。由于 <code>Derived</code> 类使用了虚继承，因此在内存中它的布局与普通的继承方式有所不同。</p>
<p>以下是 <code>Derived</code> 对象的内存结构示意图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  虚基类子对象 <span class="number">1</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  虚基类子对象 <span class="number">2</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="type">int</span> c                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>虚基类子对象 1</code> 包含了 <code>Base1</code> 类的成员，而 <code>虚基类子对象 2</code> 包含了 <code>Base2</code> 类的成员。由于 <code>Base1</code> 和 <code>Base2</code> 都是虚基类，因此它们的成员在 <code>Derived</code> 类的对象中只存在一份，被 <code>虚基类子对象</code> 共享。</p>
<hr>
<h5 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h5><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，<strong>含有纯虚函数的类被称为抽象类</strong></li>
<li>虚函数可以被直接使用，也可以被子类重写以后，以多态的形式调用，而纯虚函数必须在子类中重写才可以使用，因为纯虚函数在基类有声明而没有定义。</li>
<li>虚函数的定义形式：virtual(){};纯虚函数的定义形式：virtual() &#x3D; 0;<strong>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，</strong>而且被两者修饰的函数生命周期也不一样</li>
</ol>
<hr>
<h5 id="⚠️C-友元函数和友元类（-friend）详解"><a href="#⚠️C-友元函数和友元类（-friend）详解" class="headerlink" title="⚠️C++友元函数和友元类（ friend）详解"></a>⚠️C++友元函数和友元类（ friend）详解</h5><p>友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> 返回值类型 函数名(参数表); <span class="comment">//将全局函数声明为友元</span></span><br><span class="line"><span class="keyword">friend</span> 返回值类型 其他类的类名::成员函数名(参数表); <span class="comment">//将其他类的成员函数声明为友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能把其他类的私有成员函数声明为友元. </span></span><br><span class="line"><span class="comment">// 友元具有单向性, 不具有传递性和继承性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>;  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️C-中哪些函数不能被声明为虚函数"><a href="#⚠️C-中哪些函数不能被声明为虚函数" class="headerlink" title="⚠️C++ 中哪些函数不能被声明为虚函数"></a>⚠️C++ 中哪些函数不能被声明为虚函数</h5><p>常见的不不能声明为虚函数的有：普通函数（不定义在类里），静态成员函数，内联成员函数，构造函数，友元函数</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>略</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态绑定,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
<p>static函数是在编译时期绑定,而虚函数的特性是运行时才动态联编,两者矛盾</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<hr>
<h5 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h5><p>模板的声明或定义只能在全局，命名空间或类范围内进行。</p>
<p>不能在局部范围，函数内进行，比如不能在<strong>main</strong>函数中声明或定义一个模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替</span></span><br><span class="line">ClassName A = <span class="keyword">new</span> <span class="built_in">ClassName</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h4><h5 id="请说说-STL-的基本组成部分"><a href="#请说说-STL-的基本组成部分" class="headerlink" title="请说说 STL 的基本组成部分"></a>请说说 STL 的基本组成部分</h5><p>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>广义上讲</strong>，STL分为3类：算法、容器、迭代器，容器和算法通过迭代器可以进行无缝地连接。</p>
<p><strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）</p>
<ol>
<li><p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了()的类</p>
</li>
<li><p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3种适配器：Container Adaptor、Iterator Adaptor、Function Adaptor</p>
</li>
<li><p>空间配制器（Allocator）</p>
<p> 为STL提供空间配置的系统。其中主要工作包括两部分</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<hr>
<h5 id="请说说-STL-中常见的容器-并介绍一下实现原理"><a href="#请说说-STL-中常见的容器-并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器, 并介绍一下实现原理"></a>请说说 STL 中常见的容器, 并介绍一下实现原理</h5><ol>
<li><strong>序列式容器</strong></li>
</ol>
<p>所谓序列式容器，其中的元素都是可序的，但是未必都是有序的</p>
<p>（1）vector ：动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
<p>（2）deque ：双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在两端增删元素具有较佳的性能</p>
<p>（3）list ：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取</p>
<ol start="2">
<li><strong>关联式容器</strong></li>
</ol>
<p>关联式容器，每笔数据（每个数据）都有一个键值（key）和一个实值（value）</p>
<blockquote>
<p>  关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()</p>
</blockquote>
<p>关联式容器: set、map、multiset、multimap底层均以RB-tree（红黑树）完成</p>
<p>（1）set&#x2F;multiset ：set 即集合。set中不允许相同元素，multiset中允许存在相同元素</p>
<p>（2）map&#x2F;multimap ：map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素</p>
<ol start="3">
<li><strong>容器适配器</strong></li>
</ol>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个stack。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。stack和queue基于deque实现，priority_queue基于vector实现</p>
<p>（1）stack  </p>
<p>（2）queue ：队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p>
<p>（3）priority_queue：优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p>
<hr>
<h5 id="两种C-类对象实例化方式的异同"><a href="#两种C-类对象实例化方式的异同" class="headerlink" title="两种C++类对象实例化方式的异同"></a>两种C++类对象实例化方式的异同</h5><ol>
<li>在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 <code>Test test;</code>另一种是通过new来实例化一个类对象，如 <code>Test *pTest = new Test();</code>那么，这两种方式有什么异同点呢？</li>
</ol>
<pre><code>我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。



那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间

（2）对于第二种方式来说, new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间
</code></pre>
<hr>
<h5 id="⚠️迭代器用过吗？什么时候会失效？"><a href="#⚠️迭代器用过吗？什么时候会失效？" class="headerlink" title="⚠️迭代器用过吗？什么时候会失效？"></a>⚠️迭代器用过吗？什么时候会失效？</h5><ul>
<li><p>针对数组型数据结构<br>数组型结构有vector、deque等，由于它们的元素是分配在连续的内存中，当进行insert和erase操作，都会使得插入点和删除点之后的元素挪位置，插入点和删除掉之后的迭代器全部失效。</p>
<p>解决方法就是更新迭代器，对于删除，erase（）返回的是下一个有效迭代器的值，可以通过<strong>iter&#x3D;vec.erase(iter)</strong>;来避免迭代器失效。insert同理，insert返回的是插入元素的迭代器的值。<br>注意：在deque容器首部或者尾部插入元素不会使得任何迭代器失效，在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效，在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效</p>
</li>
<li><p>针对链表型数据结构<br>如list容器，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<p>解决办法有两种，一种是erase(iter)会返回下一个有效迭代器的值，可以通过<strong>iter&#x3D;vec.erase(iter)</strong>;来避免迭代器失效，另一种方法是通过**erase(iter++)**；来避免迭代器失效，(顺便说一下，erase(iter++)避免迭代器失效的原理，先把iter传值到erase里面，然后iter自增，在失效前已经自增，然后执行erase将自增前的迭代器删除，自增前的迭代器失效），对于插入不会使迭代器失效。</p>
</li>
<li><p>针对树形数据结构<br>如map, set, multimap, multiset， 它们是使用红黑树来存储数据，插入不会使得任何迭代器失效，删除会使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<p><strong>解决方法：由于erase（）返回值为void，所以要采用erase(iter++)；来避免迭代器失效。</strong></p>
</li>
</ul>
<hr>
<h5 id="说说-STL-中-resize-和-reserve-的区别"><a href="#说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="说说 STL 中 resize 和 reserve 的区别"></a>说说 STL 中 resize 和 reserve 的区别</h5><ol>
<li><p>首先必须弄清楚两个概念：</p>
<p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象</p>
<p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</p>
</li>
<li><p>resize和reserve区别主要有以下几点：</p>
<p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert()或push_back()等创建对象</p>
<p>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小</p>
</li>
</ol>
<hr>
<h5 id="char-和string的区别"><a href="#char-和string的区别" class="headerlink" title="char*和string的区别"></a>char*和string的区别</h5><p><code>char*</code> 和 <code>std::string</code> 都可以用来表示字符串，但它们之间有一些区别：</p>
<ol>
<li>字符串长度</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动计算字符串的长度，并且在操作字符串时需要确保不超过字符串的长度，否则可能会导致内存越界等问题。而 <code>std::string</code> 则可以自动维护字符串的长度信息，并提供了一些方便的成员函数来操作字符串，比如 <code>size()</code>、<code>append()</code> 等，可以避免手动计算字符串长度的烦恼。</p>
<ol>
<li>内存管理</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动分配和释放字符串内存，并且需要注意内存泄漏和指针悬挂等问题。而 <code>std::string</code> 则使用了动态内存管理，它会自动分配和释放内存，可以避免这些问题。</p>
<ol>
<li>字符串拷贝</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动实现字符串拷贝函数，比如 <code>strcpy()</code>、<code>strncpy()</code> 等。而 <code>std::string</code> 则提供了重载的赋值运算符和拷贝构造函数，可以方便地进行字符串的拷贝和赋值操作。</p>
<hr>
<h5 id="数组与vector的对比"><a href="#数组与vector的对比" class="headerlink" title="数组与vector的对比"></a>数组与vector的对比</h5><p>1、数组名与vector名</p>
<p>数组名和vector名是有区别的，数组名不仅表示数组的名称，还代表了数组的首地址，数组名有时候可看作指针，并使用一些类似于指针的操作，例如初始化了一个数组 int a[10]；可进行如下操作，a+4、*(a+5)等来访问a中的数据。而vector名的话就仅仅只是vector的名称了，它没有类似于数组名的那些操作</p>
<p>2、大小能否变化</p>
<p>数组的大小在初始化后就固定不变，而vector可以通过push_back或pop等操作进行变化。</p>
<p>3、初始化</p>
<p>数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而vector可以。</p>
<p>4、执行效率</p>
<p>数组 &gt; vector  主要原因是vector的扩容过程要消耗大量的时间。</p>
<hr>
<h5 id="⚠️vector-的-部分STL-源码"><a href="#⚠️vector-的-部分STL-源码" class="headerlink" title="⚠️vector 的 部分STL 源码"></a>⚠️vector 的 部分STL 源码</h5><p>  vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li><p>新增元素</p>
<p> Vector通过一个连续的数组存放元素，如果内存已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index &#x3D; iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="type">const</span> T&amp; t )</span> </span>&#123;    </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_)&#123;   </span><br><span class="line">        <span class="keyword">if</span> (size_==capacity_)&#123;    </span><br><span class="line">            <span class="type">int</span> capa=<span class="built_in">calculateCapacity</span>();    </span><br><span class="line">            <span class="built_in">newCapacity</span>(capa);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="built_in">sizeof</span>(T));    </span><br><span class="line">        buf[index]=t;   </span><br><span class="line">        size_++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<p>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index &#x3D; iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素  </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();      </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)&#123;         </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="built_in">sizeof</span>(T));          </span><br><span class="line">        buf[--size_]=<span class="built_in">T</span>();     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h4><h5 id="⚠️说说-C-14、C-17、C-20-新特性"><a href="#⚠️说说-C-14、C-17、C-20-新特性" class="headerlink" title="⚠️说说 C++14、C++17、C++20 新特性"></a>⚠️说说 C++14、C++17、C++20 新特性</h5><ol>
<li>C++14: <ul>
<li>函数返回值类型推导</li>
<li>lambda参数auto</li>
<li>变量模板</li>
<li>别名模板</li>
<li>constexpr的限制</li>
<li>[[<code>deprecated</code>]]标记</li>
<li>二进制字面量与整形字面量分隔符</li>
<li>std::make_unique</li>
<li>std::shared_timed_mutex与std::shared_lock</li>
<li>std::integer_sequence</li>
<li>std::exchange</li>
<li>std::quoted</li>
</ul>
</li>
<li>C++17: <ul>
<li>构造函数模板推导</li>
<li>结构化绑定</li>
<li>if-switch语句初始化</li>
<li>内联变量</li>
<li>折叠表达式</li>
<li>constexpr lamda表达式</li>
<li>namespace嵌套</li>
<li>__has_include预处理表达式</li>
<li>在lambda表达式用*this捕获对象副本</li>
<li>新增Attribute</li>
<li>字符串转换</li>
<li>std::variant</li>
<li>std::optional</li>
</ul>
</li>
<li>C++20:<ul>
<li>新增关键字(keywords)</li>
<li>新增标识符(Identifies)</li>
<li>模块(Modules)</li>
<li>Ranges</li>
<li>协程(Coroutines)</li>
<li>Concepts</li>
<li>Lambda 表达式的更新</li>
<li>常量表达式(<code>constexpr</code>) 的更新</li>
<li>原子(Atomic)智能指针</li>
<li>自动合流(Joining), 可中断(Cancellable) 的线程</li>
<li>C++20 同步(Synchronization)库</li>
</ul>
</li>
</ol>
<hr>
<h5 id="说说-C-11-新特性"><a href="#说说-C-11-新特性" class="headerlink" title="说说 C++11 新特性"></a>说说 C++11 新特性</h5><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）初始化方法可以拓展到任意类</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针 &amp; 空指针 nullptr（原来NULL）</p>
<p>（6）基于范围的for循环</p>
<p>（7）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（1）无序容器（哈希表 hashtable）用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（2）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（3）Lambda表达式</p>
</li>
</ol>
<p><strong>详细：</strong></p>
<ol>
<li><p>统一的初始化方法</p>
<p>  C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;     </span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private     </span></span><br><span class="line">    Foo a3 = &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    Foo a4 &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a5 = &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a6 &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<strong>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化</strong></p>
</li>
<li><p>成员变量默认初始化</p>
<p>好处：构建一个类的对象不需要用构造函数初始化成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值  </span></span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    B b;  </span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字  </p>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();   <span class="comment">// auto i = v.begin();  </span></span><br></pre></td></tr></table></figure>

<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>; <span class="comment">//x类型被推断为int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x; <span class="comment">//cx被推断为 const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;rx = x; <span class="comment">//rx被推断为const int &amp;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>auto 原理 : 调用类模板传参</p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// auto pos = container.begin()的推断等价于如下调用模板的推断</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deducePos</span><span class="params">(T pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deducePos</span>(container.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>decltype  求表达式的类型</p>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>(1)为什么要有decltype</p>
<p><strong>auto 要求变量必须初始化，而 decltype 不要求</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<p>(2)代码示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int </span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double </span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针 </p>
<p>见下⬇️</p>
</li>
<li><p>空指针 nullptr（原来NULL）</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> *a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> *a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>nullptr空指针常数可以转换为任意类型的指针类型</p>
<p>在c++中 <code>(void *)</code> 不能转化为任意类型的指针，即 <code>int *p = (void*)</code>是错误的，但<code>int *p = nullptr</code>是正确的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;1&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;2&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);  <span class="comment">//输出1，c++中NULL为整数0</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);  <span class="comment">//输出2，nullptr 为空指针常量。是指针类型</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于范围的for循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;  <span class="comment">//使用基于范围的for循环</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要使用引用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : arr)&#123;</span><br><span class="line">    std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用和move语义 </p>
<p>(1) 右值引用</p>
<p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// 正确, 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值</span></span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p><strong>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>; <span class="comment">// 和常量左值引用不同的是，右值引用还可以对右值进行修改   </span></span><br></pre></td></tr></table></figure>

<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成</p>
<p>(2) move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能<strong>很简单，就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值；但对于使用迭代器遍历容器中存储的元素，执行效率较低</li>
</ul>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table>
<thead>
<tr>
<th align="left">无序容器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unordered_map</td>
<td align="left">存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式  </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
</li>
<li><p>Lambda匿名函数</p>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式</p>
<p>(1) 定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p><code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型  &#123; 函数体; &#125;;</code></p>
<blockquote>
<p>  a.  [ ] 捕获外部变量</p>
<p>  b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略</p>
<p>  c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字</p>
<p>  **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</p>
<p>  d. noexcept&#x2F;throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型</p>
<p>  e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”</p>
<p>  f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式捕获（两种）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数</span></span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mp[a] == mp[b] ? a &lt; b : mp[a] &gt; mp[b];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说-C-中的智能指针"><a href="#说说-C-中的智能指针" class="headerlink" title="说说 C++中的智能指针"></a>说说 C++中的智能指针</h5><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong> 其中auto_ptr被C++11弃用。</p>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间,智能指针本质是类模板。</p>
<ol>
<li>shared_ptr</li>
</ol>
<pre><code> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放)

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//构建 2 个智能指针     </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;     </span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;     </span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="comment">//输出 p2 指向的数据    </span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针     </span></span><br><span class="line">    <span class="keyword">if</span> (p1) cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;     <span class="comment">//以上操作，并不会影响 p2     </span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      程序运行结果：          10  p1 为空  10  1  */</span>    </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p>weak_ptr</p>
<p>它只可以从一个 shared_ptr或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的变化</p>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放</p>
<p>weak_ptr和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了</p>
<p>我们把类A里面的shared_ptr pb_; 改为 weak_ptr pb _ ; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p><strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code> pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();   </code></p>
</li>
<li><p>auto_ptr</p>
<p>C++98的方案，C++11已经弃用. 采用所有权模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题</p>
</li>
<li><p>unique_ptr（替换auto_ptr）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 2 allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中1留下悬挂的unique_ptr(pu1)，这可能导致危害</span></span><br><span class="line"><span class="comment">// 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数, 该函数创建的临时对象在其所有权让给 pu3 后就会被销毁</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="智能指针有内存泄露风险吗"><a href="#智能指针有内存泄露风险吗" class="headerlink" title="智能指针有内存泄露风险吗"></a>智能指针有内存泄露风险吗</h5><p>有,<strong>当两个类对象中各自有一个 shared_ptr 指向对方</strong>时，会造成循环引用，使引用计数失效，从而导致内存泄露。 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr</p>
<p>weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针</p>
<p>weak_ptr不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问</p>
<hr>
<h5 id="⚠️说说三种智能指针原理和使用场景和线程安全"><a href="#⚠️说说三种智能指针原理和使用场景和线程安全" class="headerlink" title="⚠️说说三种智能指针原理和使用场景和线程安全"></a>⚠️说说三种智能指针原理和使用场景和线程安全</h5><ol>
<li><p><strong>实现原理:</strong> 所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的析构函数会删除该对象。然后，让赋值操作转让所有权。这就是用于 auto_ptr 和 unique_ptr 的策略.但 unique_ptr 的策略更严格，unique_ptr 能够在编译期识别错误。 </p>
<p>跟踪引用特定对象的智能指针计数，这称为引用计数（reference counting）。例如，赋值时，计数将加 1，而指针过期时，计数将减 1. 仅当最后一个指针过期时，才调用 delete。这是 shared_ptr 采用的策略</p>
</li>
<li><p><strong>使用场景:</strong> 如果程序要使用多个指向同一个对象的指针，应该选择 shared_ptr； </p>
<p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr; 如果使用 new分配内存，应该选择 unique_ptr; 如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p>
</li>
<li><p><strong>线程安全:</strong> <strong>shared_ptr 加减引用计数是原子操作，只要shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了。所以 shared_ptr 在多线程下引用计数也是安全的.</strong></p>
<p><strong>但是指向对象的指针不是线程安全的，使用 shared_ptr 访问资源不是线程安全的，需要手动加锁解锁。智能指针的拷贝也不是线程安全的</strong></p>
</li>
</ol>
<hr>
<h5 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h5><p>是指在函数调用过程中，将参数以原始形式（左值或右值）转发到另一个函数，而不会改变它们的值类别（左值或右值）。在C++中，可以使用std::forward函数实现完美转发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_print</span><span class="params">(T&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    forward_print(a);       <span class="comment">// 输出：lvalue: 1</span></span><br><span class="line">    forward_print(<span class="number">2</span>);       <span class="comment">// 输出：rvalue: 2</span></span><br><span class="line">    forward_print(std::<span class="built_in">move</span>(a)); <span class="comment">// 输出：rvalue: 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个示例中，我们定义了两个打印函数，一个接受左值引用，一个接受右值引用。</span></span><br><span class="line"><span class="comment">// 然后我们定义了一个函数模板forward_print，使用完美转发来将参数转发给打印函数。</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h5><p>C++11引入了<code>constexpr</code>（常量表达式）关键字，它表示表达式的值可以在编译期间计算，并且在运行时不会改变。</p>
<p>使用<code>constexpr</code>修饰的变量或函数可以在编译期间进行求值，这使得它们比运行时计算更加高效，同时还可以帮助我们避免一些运行时错误。在一些场景下，使用<code>constexpr</code>可以提高代码的可读性和可维护性，因为它可以使得一些常量在编译期间计算而不需要在运行时计算。</p>
<p>例如，下面是一个使用<code>constexpr</code>的示例代码，其中计算了斐波那契数列的第n项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">fib</span>(N);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci number #&quot;</span> &lt;&lt; N &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器可以在编译期间计算<code>fib(N)</code>的值，并将结果赋值给常量<code>result</code>。在运行时，程序输出斐波那契数列的第10项的值：55。</p>
<p>需要注意的是，<code>constexpr</code>并不是万能的，它有一些限制条件，例如被修饰的函数必须满足编译期间可以进行求值的要求，不能包含运行时的操作，例如I&#x2F;O操作、动态内存分配等。在使用<code>constexpr</code>时，需要仔细考虑这些限制条件，以确保代码的正确性和性能。</p>
<h3 id="1️⃣操作系统"><a href="#1️⃣操作系统" class="headerlink" title="1️⃣操作系统"></a>1️⃣操作系统</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="说一说常用的-Linux-命令"><a href="#说一说常用的-Linux-命令" class="headerlink" title="说一说常用的 Linux 命令"></a>说一说常用的 Linux 命令</h5><p>cd：切换当前目录 </p>
<p>ls：查看当前文件与目录 </p>
<p>touch: 创建新文件</p>
<p>grep：通常与管道命令一起使用，用于对一些命令的输出进行筛选加工 </p>
<p>cp：是在同一个linux系统上，在不同的目录之间复制文件</p>
<blockquote>
<p>  scp：是在不同linux系统之间来回复制文件；</p>
</blockquote>
<p>mv：移动文件或文件夹 </p>
<p>rm：删除文件或文件夹 </p>
<blockquote>
<p>  rm -rf test1    可删除非空文件或文件夹  </p>
<p>  rmdir 只能删除空文件夹</p>
</blockquote>
<p>ps：查看进程情况 </p>
<p>tar：对文件进行解压缩</p>
<p>cat：查看文件内容</p>
<p>top：查看操作系统的信息，如进程、CPU占用率、内存信息等（实时） </p>
<blockquote>
<ol>
<li><code>PID</code>：进程的唯一标识符；</li>
<li><code>USER</code>：进程所属的用户名；</li>
<li><code>%CPU</code>：进程使用 CPU 的占比；</li>
<li><code>%MEM</code>：进程使用内存的占比；</li>
<li><code>VSZ</code>：进程的虚拟内存大小（单位为 KB）；</li>
<li><code>RSS</code>：进程正在使用的物理内存大小（单位为 KB）；</li>
<li><code>TTY</code>：进程所属的终端；</li>
<li><code>STAT</code>：进程状态，如 R（运行）、S（睡眠）、D（不可中断的睡眠）等；</li>
<li><code>START</code>：进程启动的时间；</li>
<li><code>TIME</code>：进程使用 CPU 的累计时间；</li>
<li><code>COMMAND</code>：进程启动时的命令。</li>
</ol>
</blockquote>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150925539.png" alt="image-20230323150925539"></p>
<p>free：查看内存使用情况  -m以MB为单位显示</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150826237.png" alt="image-20230323150826237"></p>
<p>pwd：显示当前工作目录</p>
<p>chmod: 修改用户权限	</p>
<p>chown: 更改或文件的所有权转让给指定的用户名</p>
<p>echo: 将一些数据移到文件中。如果要将文本 “Hello, 我的名字叫 John” 添加到名为 name.txt 的文件中，<code> echo Hello,my name is John &gt;&gt; name.txt</code></p>
<p>ldd: <code>ldd [OPTION] FILE</code>  查看libstdc++.so.6依赖的动态库的详细信息</p>
<blockquote>
<p>  ldd -v &#x2F;home&#x2F;libstdc++.so.6</p>
</blockquote>
<blockquote>
<p>  –help 获取指令帮助信息；<br>  –version 打印指令版本号；<br>  -d,–data-relocs 执行重定位和报告任何丢失的对象；<br>  -r, –function-relocs 执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；<br>  -u, –unused 打印未使用的直接依赖；<br>  -v, –verbose 详细信息模式，打印所有相关信息；</p>
</blockquote>
<hr>
<h5 id="查看进程运行状态、查看内存使用情况、tar解压文件"><a href="#查看进程运行状态、查看内存使用情况、tar解压文件" class="headerlink" title="查看进程运行状态、查看内存使用情况、tar解压文件"></a>查看进程运行状态、查看内存使用情况、tar解压文件</h5><ol>
<li><p>查看进程运行状态的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps aux | grep PID </span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323152150339.png" alt="image-20230323152150339"></p>
</li>
<li><p>查看内存使用情况的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">// 查看内存使用情况 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>查看进程运行状态、查看内存使用情况的指令均可使用top指令</strong></p>
<ol start="3">
<li>tar解压文件的参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>压缩 -cvf</span><br><span class="line">tar -cvf xxx.tar /data : 仅打包</span><br><span class="line">tar -zcvf xxx.tar /data : 打包后，以gzip方式压缩</span><br><span class="line">tar -jcvf xxx.tar /data : 打包后，以bzip2方式压缩</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>解压 -xvf</span><br><span class="line">先进入需要解压缩的文件夹下</span><br><span class="line">cd /tmp/data</span><br><span class="line">tar -xvf xxx.tar : 解包</span><br><span class="line">tar -zxvf xxx.tar : 解压gzip压缩文件</span><br><span class="line">tar -jxvf xxx.tar : 解压bzip2压缩文件</span><br><span class="line">tar -zxvf xxx.tar.gz etc/passwd :只解压部分文件夹</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="查找一个字符串是否在文件中"><a href="#查找一个字符串是否在文件中" class="headerlink" title="查找一个字符串是否在文件中"></a>查找一个字符串是否在文件中</h5><ul>
<li><p>如果在给定的文件中搜索某个字符串， 直接<code>grep “main” ./main.c</code>即可；</p>
</li>
<li><p>如果你要搜索某个特定的字符串，而不确定这个字符串可能会在哪个文件中出现，那只能在某个大的目录下递归搜索：<code>grep -r &quot;main&quot; ./</code></p>
</li>
<li><p>如果只指定-r来搜索，有时候可能会打印出很多无用的错误的信息，这会严重干扰你在搜索结果中查找你想要的信息。所以我们要用<code>grep -rs &quot;main&quot; ./</code>使用-s选项可以帮助我们将这些因为文件不存在或者文件不可读而打印出来的错误信息统统去除掉；</p>
</li>
<li><p>如果你想知道字符串所在的行号，那一定要指定-n选项：<code>grep -nrs &quot;main&quot; ./</code></p>
</li>
<li><p>可是很多时候你按照上面指定的条件进行搜索，在搜索结果中可能仍然有很多不是你想要的。比如你要搜索的字符串是”main”，而要搜索结果中你可能会看到很多诸如”main_function”， “mainly”等等这些包含”main”的更长的字符串。此时我们就需要借助于-w这个命令选项来过滤。<code>grep -nrws &quot;main&quot; ./</code></p>
</li>
</ul>
<hr>
<h5 id="查找本机一个端口号的状态"><a href="#查找本机一个端口号的状态" class="headerlink" title="查找本机一个端口号的状态"></a>查找本机一个端口号的状态</h5><p>netstat 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例1：列出所有端口</span></span><br><span class="line">netstat -a      <span class="comment"># 列出所有端口</span></span><br><span class="line">netstat -at     <span class="comment"># 列出所有TCP端口</span></span><br><span class="line">netstat -au    <span class="comment"># 列出所有UDP端口</span></span><br><span class="line">netstat -ax    <span class="comment"># 列出所有unix端口</span></span><br><span class="line">netstat -atnlp    <span class="comment"># 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例2：显示每个协议的统计信息</span></span><br><span class="line">netstat -s     <span class="comment"># 显示所有端口的统计信息</span></span><br><span class="line">netstat -st    <span class="comment"># 显示所有TCP的统计信息</span></span><br><span class="line">netstat -su    <span class="comment"># 显示所有UDP的统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例3：显示核心路由信息</span></span><br><span class="line">netstat -r     <span class="comment"># 显示所有端口的统计信息</span></span><br><span class="line">netstat -rn    <span class="comment"># 显示所有TCP的统计信息</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="如何判断远程服务的端口有没有开启"><a href="#如何判断远程服务的端口有没有开启" class="headerlink" title="如何判断远程服务的端口有没有开启"></a>如何判断远程服务的端口有没有开启</h5><p>telnet 命令可以测试远程主机是否可以访问指定的端口。在命令行中输入 “telnet 远程主机IP 端口号”，如果能够建立连接，说明该端口已经开启。例如，如果要测试远程主机的 80 端口是否开启，可以在命令行中输入 <code>telnet 远程主机IP 80</code>，如果成功建立连接，则说明该端口已经开启。</p>
<hr>
<h5 id="文件权限怎么修改"><a href="#文件权限怎么修改" class="headerlink" title="文件权限怎么修改"></a>文件权限怎么修改</h5><h6 id="文字设定法设置权限-ugoa"><a href="#文字设定法设置权限-ugoa" class="headerlink" title="文字设定法设置权限(ugoa)"></a>文字设定法设置权限(ugoa)</h6><p><code>chmod [操作对象] [操作符号] [权限] [文件|目录] </code></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png" alt="image-20221128220607286"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png" alt="image-20221128220621457"></p>
<p>chmod u+w a	添加所有者对a文件的写入权限</p>
<p>chmod u-r a	取消所有者对a文件的读取权限</p>
<p>chmod g&#x3D;w a	重新分配同组用户对a文件有写入的权限</p>
<p>chmod u+rw,g+r,o+rwx a	添加所有者为读取、写入权限;同组用户为读取权限;其他用户读取、写入和执行的权限</p>
<p>chmod a-rwx a	取消所有用户的读取、写入和执行权限</p>
<h6 id="数字设定法设置权限-ugo"><a href="#数字设定法设置权限-ugo" class="headerlink" title="数字设定法设置权限(ugo)"></a>数字设定法设置权限(ugo)</h6><p><code>chmod [n1n2n3] [文件|目录]</code></p>
<blockquote>
<p>  n1表示用户所有者的权限 ，n2表示组群所有者的权限，n3表示其它用户的权限。</p>
</blockquote>
<ul>
<li><p>文件和目录的权限表中用r、w、x这三个字符来为用户所有者、组群所有者和其它用户设置权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需3个数字。</p>
</li>
<li><p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。</p>
</li>
<li><p>所有数字属性的格式应该是三个0～7的数，其顺序是<strong>u、g、o</strong></p>
</li>
</ul>
<blockquote>
<p>  r：对应数值4	w：对应数值2	x：对应数值1	-：对应数值0</p>
</blockquote>
<blockquote>
<p>  若该文件为目录则第一位用d标志，否则用-标志</p>
</blockquote>
<blockquote>
<p>  -rwx——：用数字表示为700</p>
<p>  -rwxr–r–：用数字表示为744</p>
<p>  -rw-rw-r-x：用数字表示为665</p>
<p>  drwx–x–x：用数字表示为711</p>
<p>  drwx——：用数字表示为700</p>
</blockquote>
<blockquote>
<p>  chmod 777 a	所有用户拥有读取、写入和执行的权限</p>
<p>  chmod (00)7 a	设置a文件权限，其他用户拥有读取、写入和执行的权限</p>
</blockquote>
<h6 id="特殊权限-SUID-SGID-Sticky"><a href="#特殊权限-SUID-SGID-Sticky" class="headerlink" title="特殊权限(SUID SGID Sticky)"></a>特殊权限(SUID SGID Sticky)</h6><p>（1）SUID: 以用户所有者身份来执行一个可执行文件; 对一个目录无影响</p>
<p>（2）SGID: 以组群所有者身份来执行一个可执行文件; 对一个目录，在该目录中创建的任意新文件的所属组与该目录的所属组相同</p>
<p>（3）Sticky: 对一个可执行文件无影响, 对目录设置Sticky后，尽管其它用户有写权限，也必须由所有者执行删除和移动等操作</p>
<p><strong>文字设定法设置特殊权限</strong></p>
<p>chmod u+s a	添加a文件的特殊权限为SUID</p>
<p>chmod g+s a	添加a文件的特殊权限为SGID</p>
<p>chmod o+t a	添加a文件的特殊权限为Sticky</p>
<p><strong>数字设定法设置特殊权限</strong></p>
<p>chmod 4000 a	设置文件a具有SUID权限</p>
<p>chmod 2000 a	设置文件a具有SGID权限</p>
<p>chmod 1000 a	设置文件a具有Sticky权限</p>
<p>chmod 7000 a	设置文件a具有SUID，SGID和Sticky权限</p>
<hr>
<h5 id="如何以root权限运行某个程序"><a href="#如何以root权限运行某个程序" class="headerlink" title="如何以root权限运行某个程序"></a>如何以root权限运行某个程序</h5><p>su:  切换成root, 但不改变当前工作目录和环境变量</p>
<p>su-:  切换成root, 改变当前工作目录和环境变量为root的</p>
<p>sudo:  一种权限管理机制，授权给哪个用户可以以管理员的身份执行什么命令</p>
<blockquote>
<p>  sudo [选项] [-u 新使用者账号] 要执行的命令</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chown root 文件</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chmod u+s 文件</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="什么是大端小端-如何判断"><a href="#什么是大端小端-如何判断" class="headerlink" title="什么是大端小端, 如何判断"></a>什么是大端小端, 如何判断</h5><p>小端模式：低的有效字节存储在低的内存地址。小端一般为主机字节序；X86结构和大多数ARM都为小端模式</p>
<p>大端模式：高的有效字节存储在低的内存地址。大端为网络字节序</p>
<p><strong>如何判断：我们可以根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span>&#123;   </span><br><span class="line">        <span class="type">char</span> c;  <span class="comment">// 一个字节，低地址</span></span><br><span class="line">        <span class="type">int</span> i;  <span class="comment">// 四个字节，高地址</span></span><br><span class="line">    &#125;;  </span><br><span class="line">    test t; t.i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> (t.c == <span class="number">1</span>);  <span class="comment">//如果是小端,则t.c为1; 反之是大端  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="字节序转换函数-IP转换函数"><a href="#字节序转换函数-IP转换函数" class="headerlink" title="字节序转换函数, IP转换函数"></a>字节序转换函数, IP转换函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从主机字节序到网络字节序的转换函数: </span></span><br><span class="line">htons <span class="comment">// 主机端口 -&gt; 网络端口</span></span><br><span class="line">htonl  <span class="comment">// 转换IP的，IP地址32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络字节序到主机字节序的转换函数</span></span><br><span class="line">ntohs</span><br><span class="line">ntohl</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inet_pton  <span class="comment">// &quot;192.168.12.1&quot; -&gt; 整数</span></span><br><span class="line">inet_ntop  <span class="comment">// 整数 -&gt; IP字符串</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️简述Linux内核态与用户态"><a href="#⚠️简述Linux内核态与用户态" class="headerlink" title="⚠️简述Linux内核态与用户态"></a>⚠️简述Linux内核态与用户态</h5><p>用户态是应用程序的运行环境。在用户态，程序可以直接访问应用程序的内存空间，但不能直接访问操作系统的内存空间和硬件资源。</p>
<p>内核态是操作系统的运行环境，通常指的是内核代码所运行的环境。在内核态，操作系统可以直接访问系统的内存空间和硬件资源，执行一些敏感的操作，如修改页表、打开中断等，这些操作需要更高的权限。</p>
<p>当一个程序需要执行一些需要特权级别较高的操作时，需要通过系统调用进入内核态，由操作系统代表该程序执行相关操作。进入内核态的步骤如下：</p>
<ol>
<li>进入内核态<strong>：共有三种方式：a、</strong>系统调用<strong>。b、</strong>异常<strong>。c、</strong>设备中断</li>
<li>CPU从用户态切换到内核态，将用户程序的当前状态（如寄存器值）保存到内核栈中。</li>
<li>操作系统根据系统调用号确定需要执行的操作，并检查参数的合法性。</li>
<li>操作系统执行需要的操作，如果需要返回结果，则将结果保存到用户程序指定的内存地址中。</li>
<li>操作系统从内核态切换回用户态，恢复用户程序的状态（如寄存器值），继续执行用户程序。</li>
</ol>
<p>需要注意的是，进入内核态和从内核态返回到用户态的过程涉及到CPU寄存器和堆栈的切换和保存，因此会带来一定的开销。为了提高系统性能，操作系统通常会尽量减少用户态和内核态之间的切换次数，尽可能在用户态完成所有操作。</p>
<hr>
<h5 id="虚拟地址到物理地址怎么映射的"><a href="#虚拟地址到物理地址怎么映射的" class="headerlink" title="虚拟地址到物理地址怎么映射的"></a>虚拟地址到物理地址怎么映射的</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207131212493.png" alt="image-20230207131212493" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png" alt="image-20221205224538889" style="zoom:50%;">

<hr>
<h5 id="说说堆栈溢出是什么-会怎么样"><a href="#说说堆栈溢出是什么-会怎么样" class="headerlink" title="说说堆栈溢出是什么, 会怎么样"></a>说说堆栈溢出是什么, 会怎么样</h5><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。常指调用堆栈溢出，本质上一种数据结构的满溢情况。堆栈溢出可以理解为两个方面：<strong>堆溢出和栈溢出。</strong></p>
<ol>
<li>堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error</li>
<li>栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error</li>
</ol>
<hr>
<h5 id="⚠️说说进程-线程-协程是什么-区别？"><a href="#⚠️说说进程-线程-协程是什么-区别？" class="headerlink" title="⚠️说说进程,线程,协程是什么,区别？"></a>⚠️说说进程,线程,协程是什么,区别？</h5><ol>
<li><p><strong>进程</strong>：进程则是程序的运行实例，包括程序计数器、堆栈和变量值</p>
</li>
<li><p><strong>线程</strong>：一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务</p>
</li>
<li><p><strong>协程</strong>：协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行的</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多. 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用</p>
</li>
<li><p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程</p>
<p>（2）一个进程挂掉，对应的线程挂掉；一个进程挂掉，不会影响其他进程</p>
<p>（3）进程是系统资源分配的最小单位；线程CPU调度的最小单位</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少</p>
<p>（5）进程在执行时拥有独立的内存单元; 多个线程共享进程的内存；但每个线程拥有自己的栈和.text段</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</p>
<p>（7）通信方式不一样</p>
</li>
<li><p><strong>线程与协程的区别：</strong></p>
<p>（1）切换开销更少。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小</p>
<p>（2）协程不需要多线程的锁机制，因为协程从属于线程，不存在同时写变量冲突</p>
<p>（3）协程占用内存少。执行协程只需要极少的栈内存（4～5KB），而线程栈的大小为1MB ;</p>
<p>如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</p>
<ol>
<li><strong>在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。</strong></li>
<li><strong>对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。</strong></li>
</ol>
</li>
</ol>
<hr>
<h5 id="lock-guard-和-unique-lock-区别，使用案例"><a href="#lock-guard-和-unique-lock-区别，使用案例" class="headerlink" title="lock_guard 和 unique_lock 区别，使用案例"></a>lock_guard 和 unique_lock 区别，使用案例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lock_guard：被设计为在作用域结束时自动释放锁，从而防止忘记解锁的错误。</span></span><br><span class="line"><span class="comment">// 由于其简单性和效率，lock_guard 通常用于保护共享数据的简单操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    A ++; <span class="comment">// 对共享资源进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt --)&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">        t1.<span class="built_in">join</span>();</span><br><span class="line">        t2.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; A; <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unique_lock是一个更为灵活和功能更强大的锁定类。unique_lock 允许你手动地锁定和解锁</span></span><br><span class="line"><span class="comment">// 此外还支持时间限制、递归锁定、条件变量等功能。通常用于需要更复杂的线程同步操作的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 生产数据</span></span><br><span class="line">    data_ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!data_ready) cv.<span class="built_in">wait</span>(lock); <span class="comment">// 等待数据准备好</span></span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line"><span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;     </span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> data_queue.<span class="built_in">size</span>() &lt; <span class="number">10</span>; &#125;); <span class="comment">// 等待队列有空闲位置    </span></span><br><span class="line">        data_queue.<span class="built_in">push</span>(i); <span class="comment">// 生产数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    is_end = <span class="literal">true</span>; <span class="comment">// 生产结束</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>() || is_end; &#125;); <span class="comment">// 等待队列非空或生产者结束</span></span><br><span class="line">        <span class="keyword">if</span> (!data_queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 消费数据</span></span><br><span class="line">            <span class="type">int</span> data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_end &amp;&amp; data_queue.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">// 判断是否结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程"><a href="#什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程" class="headerlink" title="什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程"></a>什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</h5><ol>
<li><p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，子进程残留资源(PCB) 存放于内核中，占用系统资源，这种进程称为僵尸进程。</p>
<p><strong>如何解决僵尸进程:</strong></p>
<p>(1) 一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的</p>
<p>(2) <strong>使用kill命令杀死其父进程(使僵尸进程变成孤儿进程)</strong></p>
<p>打开终端并输入下面命令:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> Z </span><br></pre></td></tr></table></figure>

<p>会列出进程表中所有僵尸进程的详细内容。然后输入命令：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">kill</span> -<span class="variable">s</span> <span class="variable">SIGCHLD</span> <span class="function"><span class="title">pid</span>(父进程<span class="variable">pid</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说什么是守护进程-如何实现？"><a href="#说说什么是守护进程-如何实现？" class="headerlink" title="说说什么是守护进程, 如何实现？"></a>说说什么是守护进程, 如何实现？</h5><p><strong>守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务</strong></p>
<ol>
<li>创建子进程，父进程退出</li>
<li>setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </li>
<li>改变当前目录为根目录</li>
<li>重设文件权限掩码</li>
<li>关闭文件描述符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说进程通信的方式有哪些"><a href="#说说进程通信的方式有哪些" class="headerlink" title="说说进程通信的方式有哪些"></a>说说进程通信的方式有哪些</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png" alt="image-20221206023051122"></p>
<hr>
<h5 id="进程通信中的管道实现原理是什么"><a href="#进程通信中的管道实现原理是什么" class="headerlink" title="进程通信中的管道实现原理是什么"></a>进程通信中的管道实现原理是什么</h5><p>操作系统在内核中开辟一块<strong>缓冲区</strong>（<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制，半双工。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程）。管道本质是一种文件</p>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。读端由描述字fd[0]表示，称其为管道读端；写端由描述字fd[1]来表示。一般文件的 I&#x2F;O 函数都可以用于管道，如close()、read()、write()等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT  0      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT 1          </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="comment">//创建管道         </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];         </span><br><span class="line">    <span class="built_in">pipe</span>(fd);         </span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">//创建子进程, 父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;             </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);             </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);         </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程           </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端            </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);           </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));           </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);       </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="comment">//执行父进程           </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端             </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);             </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">255</span>];           </span><br><span class="line">        <span class="type">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in">sizeof</span>(buf));           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);       </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207143613149.png" alt="image-20230207143613149"></p>
<hr>
<h5 id="⚠️共享内存"><a href="#⚠️共享内存" class="headerlink" title="⚠️共享内存"></a>⚠️共享内存</h5><p>共享内存允许多个进程共享物理内存的同一块区域。这种IPC 机制无需内核介入。所有要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管道是一种存在于内核的文件)，这种IPC技术的速度更快</p>
<p><strong>共享内存使用步骤</strong></p>
<ol>
<li>调用<code>shmget()</code>这个调用将返回后续调用中需要用到的共享内存标识符</li>
<li>使用<code>shmat()</code>和当前进程进行关联, 返回已开辟的内存的首地址</li>
<li>调用<code>shmdt() </code>来分离共享内存段。在此之后，进程就无法再引用这块共享内存了。这是可选的，并且在进程终止时会自动完成这一步</li>
<li>调用<code>shmctl()</code>来删除共享内存段。只有当前所有附加内存段的进程都与之分离后,内存段才会销毁。只有一个进程需要执行这一步</li>
</ol>
<hr>
<h5 id="⚠️简述mmap的原理和使用场景-6参数"><a href="#⚠️简述mmap的原理和使用场景-6参数" class="headerlink" title="⚠️简述mmap的原理和使用场景(6参数)"></a>⚠️简述mmap的原理和使用场景(6参数)</h5><p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件映射到进程的虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size; 什么意思</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<p><strong>使用场景</strong>：</p>
<ol>
<li>进程对同一块区域频繁读写操作或者大规模数据传输；</li>
<li>进程间相互通信</li>
</ol>
<hr>
<h5 id="说说常见信号"><a href="#说说常见信号" class="headerlink" title="说说常见信号"></a>说说常见信号</h5><table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。包括浮点运算错误，溢出及除0</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody></table>
<hr>
<h5 id="⚠️如何保护一个进程不被杀死，具体的代码实现"><a href="#⚠️如何保护一个进程不被杀死，具体的代码实现" class="headerlink" title="⚠️如何保护一个进程不被杀死，具体的代码实现"></a>⚠️如何保护一个进程不被杀死，具体的代码实现</h5><ol>
<li><p>拦截 SIGTERM &#x2F; SIGHUP 信号来保护进程不被杀死</p>
</li>
<li><p>fork()一个子线程，在子线程里setsid()</p>
</li>
<li><p>setsid  .&#x2F;a</p>
</li>
<li><p>nohup .&#x2F;a</p>
</li>
<li><p>.&#x2F;a &amp; 	切换到后台运行【ls看不到, ctrl + c取消不了，fg切换回前台】</p>
</li>
</ol>
<hr>
<h5 id="进程-线程的中断切换过程是怎样的？"><a href="#进程-线程的中断切换过程是怎样的？" class="headerlink" title="进程, 线程的中断切换过程是怎样的？"></a>进程, 线程的中断切换过程是怎样的？</h5><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换</p>
<ol>
<li><p><strong>进程上下文切换</strong></p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的PCB有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的<strong>地址转换</strong>和<strong>存储保护信息</strong></p>
<p>​    <strong>切换页目录以使用新的地址空间</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）</strong></p>
<p>（6）根据被选中进程恢复处理器现场</p>
</li>
<li><p><strong>线程上下文切换</strong></p>
<p>（1）保护被中断线程的处理器现场信息</p>
<p>（2）修改被中断线程的TCB有关信息，如线程状态等</p>
<p>（3）把被中断线程的线程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的线程</p>
<p>（5）根据被选中线程设置操作系统用到的<strong>存储保护信息</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（切换堆栈，以及各寄存器）</strong></p>
<p>（6）根据被选中线程恢复处理器现场</p>
</li>
</ol>
<hr>
<h5 id="死锁产生条件以及如何解决死锁"><a href="#死锁产生条件以及如何解决死锁" class="headerlink" title="死锁产生条件以及如何解决死锁"></a>死锁产生条件以及如何解决死锁</h5><ol>
<li><p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁</p>
</li>
<li><p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>： </p>
<p>（1）<strong>互斥</strong></p>
<p>（2）<strong>请求保持</strong></p>
<p>（3）<strong>不可剥夺</strong>：进程已获得的资源，只能自己释放，不可剥夺；</p>
<p>（4）<strong>环路等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li><p><strong>如何解决</strong>：</p>
<p>（1）资源一次性分配：从而解决请求保持的问题</p>
<p>（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</p>
</li>
</ol>
<hr>
<h5 id="⚠️在Linux中，让程序在系统开启时自启动"><a href="#⚠️在Linux中，让程序在系统开启时自启动" class="headerlink" title="⚠️在Linux中，让程序在系统开启时自启动"></a>⚠️在Linux中，让程序在系统开启时自启动</h5><ol>
<li><strong>使用rc.local文件</strong></li>
</ol>
<p>在Linux系统中，rc.local是一个启动脚本，可以在系统启动时自动运行。</p>
<p>如，如果要在系统启动时启动Apache Web服务器，可以在rc.local文件中添加以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/apachectl start</span><br></pre></td></tr></table></figure>

<p>注意：如果使用了Systemd，则rc.local可能不再适用。</p>
<ol start="2">
<li><strong>使用Systemd服务</strong></li>
</ol>
<p>Systemd是Linux系统中最新的init系统之一。使用systemd服务管理器，可以在系统启动时自动启动指定的程序。可以创建一个新的systemd服务文件，并在其中指定要自启动的程序。例如，如果要在系统启动时启动Nginx Web服务器，可以创建一个名为nginx.service的文件，并将其放置在&#x2F;etc&#x2F;systemd&#x2F;system目录中，然后在文件中添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/kill -s TERM <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>是指计算机在执行指令的过程中，由于硬件设备的需要或者其他原因，被迫中断当前的工作而转而去处理其他的工作。</p>
<p>在操作系统中，中断是一种重要的机制，它允许计算机在运行应用程序时响应外部事件或者硬件设备的请求。当外部事件或者硬件设备需要操作系统的处理时，会向处理器发送一个中断信号，处理器会立即暂停正在执行的程序，转而执行与中断信号相对应的中断处理程序（也称为中断服务程序或者中断处理例程）。</p>
<ol>
<li>硬件中断：由于硬件设备出现故障或需要处理某些事务而引发的中断，例如磁盘操作完成、网络数据传输完成等。</li>
<li>软件中断：由于软件程序需要访问操作系统的某些服务或资源而引发的中断，例如系统调用、异常等。</li>
<li>外部中断：由外部设备发送的信号或事件引发的中断，例如键盘输入、鼠标点击等。</li>
<li>内部中断：由CPU内部的错误或操作引发的中断，例如除零错误、页故障等。</li>
<li>陷阱：由于用户进程在执行时意外触发了操作系统预定义的异常条件而引发的中断，例如系统调用等。</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230327182127099.png" alt="image-20230327182127099"></p>
<hr>
<h5 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h5><p>锁是用来实现多线程同步的一种机制，常见的锁包括以下几种：</p>
<ol>
<li>互斥锁：也称为 Mutex，是一种最基本的锁。它是一种二进制锁，只有两种状态：锁定和非锁定。多个线程同时尝试获取该锁时，只有一个线程能够成功获取，其他线程需要等待该线程释放锁才能尝试获取。</li>
<li>读写锁：也称为 RWLock，是一种特殊的锁。它可以允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁的使用可以提高程序的并发性能。</li>
<li>自旋锁：也称为 SpinLock，是一种非阻塞锁。它是通过忙等待的方式来实现的，当一个线程需要获取该锁时，如果锁已经被其他线程持有，该线程会一直忙等待，直到锁被释放。自旋锁的等待是忙等待，因此适合用于锁被持有时间很短的情况下。</li>
<li>条件变量：是一种基于线程等待和通知机制的锁。当一个线程需要等待某个条件成立时，它会通过条件变量进入阻塞状态，等待其他线程通知条件成立。当条件成立时，其他线程通过条件变量通知等待的线程，使其从阻塞状态中唤醒并继续执行。</li>
<li>信号量：是一种计数器，用来控制多个线程对共享资源的访问。当计数器为 0 时，线程需要等待，否则可以继续执行。</li>
<li>屏障：也称为 Barrier，是一种同步机制。它可以保证多个线程在某个点上同步执行，当所有线程到达该点时，才能继续执行下一步操作。</li>
</ol>
<hr>
<h5 id="自旋锁和条件变量的区别"><a href="#自旋锁和条件变量的区别" class="headerlink" title="自旋锁和条件变量的区别"></a>自旋锁和条件变量的区别</h5><p>自旋锁和条件变量都是用来实现多线程同步的机制，但它们的实现方式和作用有所不同。</p>
<p>自旋锁是一种非阻塞锁，它是通过忙等待的方式来实现的。当一个线程需要获取自旋锁时，如果锁已经被其他线程持有，那么该线程会一直忙等待，直到锁被释放。由于自旋锁的等待是忙等待，所以在锁被持有的时间很短的情况下，自旋锁的效率很高。但是当锁被持有的时间很长时，忙等待会浪费大量的 CPU 资源，因此自旋锁不适合用于长时间的等待。</p>
<p>条件变量是一种阻塞锁，它是基于线程等待和通知机制来实现的。当一个线程需要等待某个条件成立时，它会通过条件变量进入阻塞状态，等待其他线程通知条件成立。当条件成立时，其他线程通过条件变量通知等待的线程，使其从阻塞状态中唤醒并继续执行。因为条件变量是基于线程等待和通知机制实现的，所以它不会浪费 CPU 资源，适合用于长时间的等待。</p>
<hr>
<h5 id="零拷贝-amp-DMA"><a href="#零拷贝-amp-DMA" class="headerlink" title="零拷贝 &amp; DMA"></a>零拷贝 &amp; DMA</h5><p>比如想实现一个下载功能，服务端的任务就是：将服务器主机磁盘中的文件从已连接的socket中发出去，关键代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = read(diskfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">	write(sockfd, buf, n);</span><br></pre></td></tr></table></figure>

<p>以上过程包括四次内核态切换和2次DMA<br><strong>read</strong>:将数据从磁盘读取到内核缓存区中，在拷贝到用户缓冲区<br><strong>write</strong>:先将数据写入到socket缓冲区中，最后写入网卡设备</p>
<p>DMA本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，<strong>其过程不需要CPU的参与</strong></p>
<p>如何实现零拷贝？</p>
<p>零拷贝并不是没有拷贝数据，而是减少用户态&#x2F;内核态的切换次数以及内存拷贝次数；实现零拷贝主要有两种方式分别是</p>
<ol>
<li><p>mmap </p>
</li>
<li><p>sendfile</p>
</li>
</ol>
<h3 id="2️⃣计算机网络"><a href="#2️⃣计算机网络" class="headerlink" title="2️⃣计算机网络"></a>2️⃣计算机网络</h3><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端(被动接受连接的角色)</span></span><br><span class="line"><span class="number">1.</span>创建一个用于监听客户端连接的套接字(文件描述符)【lfd】</span><br><span class="line"><span class="number">2.</span>将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)【【serveraddr要设置IP、端口、协议】lfd与serversaddr绑定】</span><br><span class="line">	-客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span>设置监听，lfd开始工作</span><br><span class="line"><span class="number">4.</span>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字【clientaddr只要定义, cfd【cfd与clientaddr通信】】</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bind() </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET; <span class="comment">// 网络协议</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.12.1&quot;, &amp;serveraddr.sin_addr.s_addr); // IP</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 服务器开发时可写,表示服务器端任何IP都可以被客户端访问</span></span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 8为连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.accept()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd  = <span class="built_in">accept</span>(listenfd, (sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span> *)len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 获取客户端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示客户端断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字【clientfd】</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定连接的服务器的IP和端口【serveraddr要设置IP、端口、协议【clientfd与serveraddr连接，用clientfd通信】】</span><br><span class="line"><span class="number">3.</span>连接成功了，客户端可以直接和服务器通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">4.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clientfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %d\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示服务器断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="listen-里的backlog参数"><a href="#listen-里的backlog参数" class="headerlink" title="listen() 里的backlog参数"></a>listen() 里的backlog参数</h5><p>backlog：等待连接队列的最大长度。当有客户端请求连接时，如果已连接的客户端数量达到了backlog值，新的连接请求将被拒绝。</p>
<p><code>backlog</code>参数对于管理服务器性能和连接处理非常重要。如果<code>backlog</code>设置得太低，服务器可能无法处理所有传入的连接请求，导致连接丢失或响应时间缓慢。如果<code>backlog</code>设置得太高，服务器可能会消耗过多的资源来管理大量的挂起连接。</p>
<hr>
<h5 id="accept-在三次握手哪里"><a href="#accept-在三次握手哪里" class="headerlink" title="accept() 在三次握手哪里"></a>accept() 在三次握手哪里</h5><p><strong>accept()需要给此次连接分配资源。</strong>设想一个情景，若有10000个客户端都和该服务端进行连接，发送SYN，服务端收到之后，这些客户端却不再理会服务端的回复，然而此时服务端的资源却都用accept()分配了。这就是所谓的“DDOS攻击”。  <strong>为了解决这个问题，accept() 放在三次握手之后。</strong></p>
<hr>
<h5 id="防范SYN攻击（DDOS的一种）"><a href="#防范SYN攻击（DDOS的一种）" class="headerlink" title="防范SYN攻击（DDOS的一种）"></a>防范SYN攻击（DDOS的一种）</h5><ol>
<li>配置防火墙规则：可以配置防火墙规则，限制每个IP地址对服务器的连接数，以及每个端口的连接数，从而减少SYN攻击对服务器的影响。</li>
<li>启用SYN Cookie：可以在服务器上启用SYN Cookie功能。当服务器收到大量的SYN数据包时，它会在内存中创建一个SYN Cookie，用于保存客户端的状态信息。当客户端返回ACK数据包时，服务器可以使用该SYN Cookie恢复客户端的状态，完成连接的建立，从而避免了SYN攻击。</li>
<li>加强网络监控：可以使用网络监控工具，如IDS（入侵检测系统）、IPS（入侵防御系统）等，实时监控网络流量，及时发现并阻止SYN攻击。</li>
<li>调整服务器性能：可以通过增加服务器性能，如增加CPU、内存、网络带宽等，提高服务器抵御SYN攻击的能力。</li>
</ol>
<h4 id="网络理论"><a href="#网络理论" class="headerlink" title="网络理论"></a>网络理论</h4><h5 id="应用层-gt-传输层-gt-网络层-gt-链路层"><a href="#应用层-gt-传输层-gt-网络层-gt-链路层" class="headerlink" title="(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)"></a>(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)</h5><p>我们就以一个HTTP请求数据包为例子来说明.发送数据的计算机叫做<strong>源主机</strong>，接收数据的计算机叫做<strong>目标主机</strong></p>
<p><strong>应用层</strong><br>首先一个HTTP数据包在应用层中大概包含HTTP协议的版本号、各种字段属性值、最后是包含的要发送的实际数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131442484.png" alt="image-20230227131442484" style="zoom:20%;">

<p><strong>传输层</strong></p>
<p>传输层对应着有UDP和TCP两种协议，HTTP采用的是TCP协议，因为TCP能够提供差错控制。</p>
<p>每一种应用层协议都对应着一个端口号，接着应用层会将HTTP数据包委托给传输层来进一步包装</p>
<blockquote>
<p>  传输层会为将HTTP数据包包装上源端口号和目的端口号等信息。</p>
<p>  <strong>目的端口号</strong>是为了在数据包到达目的计算机的时候让其了解需要将数据包交给什么应用层协议进行处理。</p>
<p>  <strong>源端口号</strong>是为了让目标计算机想要返回数据的时候，知道给源计算机的哪个应用层协议发送数据</p>
</blockquote>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131536296.png" alt="image-20230227131536296" style="zoom:20%;">

<p>如果HTTP报文超过了<strong>数据链路层</strong>规定的最大传输单元MTU,TCP会对HTTP报文进行拆解, 将HTTP报文拆分成多个满足传输要求的报文并包装，这些报文之间是有先后顺序的，TCP对这些报文进行顺序编号，保证数据的正确读</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131834043.png" alt="image-20230227131834043" style="zoom:25%;">

<p><strong>网络层</strong></p>
<p>会为其加入源IP和目标IP等信息。	<strong>源IP</strong> 指的是源计算机的IP	<strong>目标IP</strong> 指的是目标计算机的IP</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131924338.png" alt="image-20230227131924338" style="zoom: 33%;">

<p><strong>数据链路层</strong><br>在数据链路层中会在数据包中<strong>加入发送方MAC地址和接收方MAC地址。</strong><br><strong>发送方MAC地址</strong> 就是源计算机的MAC地址。<br><strong>接收方MAC地址</strong> 并不是目标计算机的MAC地址。而是数据包的下一跳的MAC地址，也就是网关的地址，也可以说是第一个转发的路由器的端口mac地址</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132509995.png" alt="image-20230227132509995"></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132827930.png" alt="image-20230227132827930" style="zoom:25%;">

<blockquote>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
<p>  <strong>交换机</strong><br>  数据包首先会发送到交换机中，交换机工作在MAC层，是一个二层网络设备。</p>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
<p>  交换机中有一个MAC缓存表，会存储MAC地址和对应的转发端口号</p>
<p>  交换机在接收到数据包后, 会取出接收方MAC地址, 查看其是否存在缓存, 如存在缓存, 就通过其对应的端口号将数据包发送出去</p>
<p>  如果不存在, 就向所有端口号发出数据包</p>
</blockquote>
<h5 id="链路层-gt-网络层-gt-传输层-gt-应用层"><a href="#链路层-gt-网络层-gt-传输层-gt-应用层" class="headerlink" title="(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)"></a>(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)</h5><ol>
<li><strong>路由器——路由转发</strong></li>
</ol>
<blockquote>
<p>  数据包出了交换机就算是出了家门了，开始进入路由器。</p>
<p>  数据包通过端口进入路由器，执行以下步骤：<br>  1、 路由器首先会检查数据包的接收方MAC地址是否等于路由器端口的MAC地址，如果等于就接收，如果不等于就抛弃。<br>  2、 路由器去除头部的MAC包装，暴露出IP地址信息，取出目标IP地址，然后查看路由表。</p>
<p>  <strong>取出路由表中的记录与目标IP地址挨个进行检验，检验过程如下：</strong></p>
<p>  将记录中的子网掩码与目标IP地址进行&amp;运算，如果等于记录中的目标网络，说明存在当前路由器可以到达目标IP地址，就通过记录中对应的端口转发出去, 在转发出去之前需要包装MAC地址</p>
<p>  3、 如果路由表中不存在对应的目标地址，那么就会通过默认路由发出去，默认路由的目标地址和子网掩码都是 <strong>0.0.0.0</strong>，MAC的包装和上述一样。</p>
<p>  4、 如果同时存在多个符合的路由，就按照最长掩码匹配原则，选择掩码中1最多的路由进行转发</p>
</blockquote>
<blockquote>
<p>  从路由转发的过程来看，<strong>源IP地址和目标IP地址一直不变，发送方MAC地址和接收方MAC地址一直在变。</strong></p>
</blockquote>
<ol start="2">
<li><strong>到达目标计算机</strong><br>就这样通过路由器的不断转发，数据包会到达与目标计算机直连的路由器。</li>
</ol>
<blockquote>
<p>  此时，路由器中目标IP地址对应的路由记录中的下一跳IP地址 就是 目标IP地址。</p>
<p>  这个时候，路由表会将目标IP地址的MAC地址当作目的MAC地址，将路由器转发端口对应的MAC地址当作源MAC地址，然后通过端口将MAC帧发送到 路由器端口对应的子网中。</p>
<p>  路由器子网是由多个交换机构成的局域网，交换机只会通过MAC地址缓存将数据包转发给对应的端口，如果没有对应的缓存，就转发给所有的端口。</p>
<p>  这样的话，数据包就会转发到了目标计算机中</p>
</blockquote>
<ol start="3">
<li><strong>目标计算机在收到数据包后会将数据包从下层往上层拆封。</strong></li>
</ol>
<blockquote>
<p>  1、 首先是数据链路层，目标计算机会将MAC包装信息去除，取出接收方MAC地址，查看是否和自己的MAC地址一致，如果不一致，就抛弃。</p>
<p>  2、 接着是网络层，将IP包装信息去除，取出目标IP地址，查看是否与自己的IP地址一致，如果不一致，就抛弃。</p>
<p>  3、 接着是传输层，会取出目标端口号，通过端口号获取对应的进程，将数据包交给对应的进程。比如HTTP数据包的目标端口号是80，就会交给HTTP进程，HTTP会调用其业务逻辑，将返回的数据包装成数据包通过源IP地址发送给源计算机。</p>
</blockquote>
<h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161432357.png" alt="image-20230210161432357"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103852887.png" alt="image-20230227103852887"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230406225101735.png" alt="image-20230406225101735"></p>
<p><strong>广播域就是说，如果站点发出一个广播信号后能接收到这个信号的范围，通常来说一个局域网就是一个广播域。（用路由器连接的除外）。冲突域是一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域</strong></p>
<p><strong>三种模型对比</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161511598.png" alt="image-20230210161511598"></p>
<hr>
<h5 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手 &amp; 四次挥手"></a>TCP三次握手 &amp; 四次挥手</h5><p><strong>三次握手(发生在客户端connect()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AB3FC1B1325FA341A39644BA061FA439.jpeg" alt="img" style="zoom:50%;">

<p>三次握手完成，成功建立连接，开始传输数据</p>
<blockquote>
<p>  总结：传输层TCP是全双工的，但是其上层应用层可能是半双工的。每一个层次都有自己的双工模式，传输层有传输层的双工模式，应用层有应用层的双工模式。下层的双工模式是支持上层双工模式的上限。比如下层支持半双工，上层顶多支持半双工，不可能支持全双工。tcp是全双工的，但它的上层可能支持半双工，比如http1.1，也有可能支持全双工，比如http2.0</p>
</blockquote>
<p><strong>四次挥手(发生在两端close()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg" alt="img" style="zoom:50%;">

<hr>
<h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230208211405978.png" alt="image-20230208211405978"></p>
<hr>
<h5 id="TCP流量控制：滑动窗口"><a href="#TCP流量控制：滑动窗口" class="headerlink" title="TCP流量控制：滑动窗口"></a><strong>TCP流量控制：滑动窗口</strong></h5><p>在流量控制中那些已经被客户端发送但是还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口，随着TCP协议的运行、数据的运输，这个窗口在序号空间向前滑动，因此这个窗口被称为滑动窗口。 </p>
<p>可以将整个报文段分为四组 </p>
<ol>
<li>已被确认的分组</li>
<li>已发送但未被确认的分组</li>
<li>接下来可以分发的分组</li>
<li>超出窗口长度之后的待使用的分组</li>
</ol>
<hr>
<h5 id="TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复"><a href="#TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复" class="headerlink" title="TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复"></a>TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183029287.png" alt="image-20230301183029287" style="zoom: 40%;">

<hr>
<h5 id="⚠️说说-TCP-粘包"><a href="#⚠️说说-TCP-粘包" class="headerlink" title="⚠️说说 TCP 粘包"></a>⚠️说说 TCP 粘包</h5><p>TCP基于字节流，无法判断发送方报文段边界 </p>
<p>多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包</p>
<p>发送端可能堆积了两次数据，每次100字节一共在发送缓存堆积了200字节的数据，而接收方在接收缓存中一次读取120字节的数据，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。 解决粘包的方法： </p>
<ol>
<li>发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界 </li>
<li>数据包末尾加上\r\n标记，模仿FTP协议，但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界 </li>
<li>数据包头部加上数据包的长度</li>
</ol>
<hr>
<h5 id="TCP-和-UDP-可以同时绑定相同的端口吗"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗?"></a>TCP 和 UDP 可以同时绑定相同的端口吗?</h5><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块(TCP &#x2F; UDP)处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 8888号端口，UDP 也可以有一个 8888 号端口</p>
<p>运行这两个程序后，通过 netstat 命令可以看到，TCP 和 UDP 是可以同时绑定同一个端口号的</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181113760.png" alt="image-20230302181113760"></p>
<hr>
<h5 id="多个-TCP-服务进程可以绑定同一个端口吗"><a href="#多个-TCP-服务进程可以绑定同一个端口吗" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗?"></a>多个 TCP 服务进程可以绑定同一个端口吗?</h5><p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是 “Address already in use”</p>
<p>没有设置端口复用的socket在当 TCP 服务进程重启时，服务端处于 TIME_WAIT 状态，在TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误</p>
<p>解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是<strong>：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong></p>
<p>SO_REUSEADDR 的另外一个作用是绑定的 IP地址 + 端口时，只要 IP 地址不是exactly相同，那么允许绑定。</p>
<hr>
<h5 id="同一客户端可以-bind-同一个端口吗？"><a href="#同一客户端可以-bind-同一个端口吗？" class="headerlink" title="同一客户端可以 bind 同一个端口吗？"></a>同一客户端可以 bind 同一个端口吗？</h5><p>客户端在执行 connect() 的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</p>
<p>所以，客户端的端口选择的发生在 connect ()，内核会随机选择一个端口</p>
<p>当客户端与服务端完成 TCP 连接建立后，我们可以通过 netstat 命令查看 TCP 连接<br><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182404371.png" alt="image-20230302182404371"></p>
<blockquote>
<p>  上面客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？</p>
</blockquote>
<p>正确的理解是，TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题</p>
<hr>
<h5 id="多个客户端可以-bind-同一个端口吗？"><a href="#多个客户端可以-bind-同一个端口吗？" class="headerlink" title="多个客户端可以 bind 同一个端口吗？"></a>多个客户端可以 bind 同一个端口吗？</h5><p>如果多个客户端同时绑定的 IP 地址和端口都是相同的，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果一个绑定在 192.168.1.100:6666, 一个绑定在 192.168.1.200:6666, 因为 IP 不相同, 所以执行 bind() 的时候, 能正常绑定。</p>
<hr>
<h5 id="⚠️客户端connect函数选择端口号的过程"><a href="#⚠️客户端connect函数选择端口号的过程" class="headerlink" title="⚠️客户端connect函数选择端口号的过程"></a>⚠️客户端connect函数选择端口号的过程</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/b0b1814b7ed7990ea54c117fbff29599.jpeg" alt="img" style="zoom: 50%;">

<hr>
<h5 id="产生大量CLOSE-WAIT原因和解决"><a href="#产生大量CLOSE-WAIT原因和解决" class="headerlink" title="产生大量CLOSE_WAIT原因和解决"></a>产生大量CLOSE_WAIT原因和解决</h5><ol>
<li>服务器迟迟无法进行第三次挥手，从而导致CLOSE_WAIT状态的堆积。(正确关闭套接字连接)</li>
<li>网络问题：在网络故障或不稳定的情况下，连接关闭可能会失败，导致CLOSE_WAIT状态的出现</li>
<li>使用阻塞式I&#x2F;O：当服务器端使用阻塞式I&#x2F;O时，如果有某个连接上的数据未被及时处理，则可能会导致连接被阻塞，从而导致CLOSE_WAIT状态的堆积</li>
<li>过多的并发连接：如果服务器端同时处理大量的并发连接，可能会导致连接的处理不及时，从而导致CLOSE_WAIT状态的堆积</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法1: 正确关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(socket_fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法2: 在发送数据时，如果发生错误，应该及时关闭套接字，而不是等待数据发送完毕</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(socket_fd, buffer, buffer_size, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="产生大量TIME-WAIT原因和解决"><a href="#产生大量TIME-WAIT原因和解决" class="headerlink" title="产生大量TIME_WAIT原因和解决"></a>产生大量TIME_WAIT原因和解决</h5><ol>
<li>大量短连接：如果一个应用程序频繁地打开和关闭TCP连接，就会产生大量的TIME_WAIT状态。这是因为在TIME_WAIT状态下，操作系统会保留连接信息，直到超时时间到期。如果一个应用程序频繁打开和关闭连接，就会导致大量TIME_WAIT状态堆积。</li>
<li>网络延迟：在网络延迟比较大的情况下，连接关闭时可能需要更长的时间来等待所有的数据包到达。在这种情况下，TIME_WAIT状态会持续更长的时间，从而导致大量TIME_WAIT状态的出现。</li>
<li>连接负载：当服务器处理大量并发连接时，TIME_WAIT状态的数量可能会增加。这是因为每个连接在关闭后都会变成TIME_WAIT状态，如果有大量连接，就会产生大量TIME_WAIT状态。</li>
</ol>
<p>解决办法: 优化内核参数，让服务器能够快速回收和重用那些TIME_WAIT的资源</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%编辑内核文件/etc/sysctl.conf，加入以下内容：</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span>    <span class="comment">%表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span>      <span class="comment">%表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span>    <span class="comment">%表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line">net.ipv4.tcp_fin_timeout      <span class="comment">%修改系默认的 TIMEOUT连接超时 时间</span></span><br><span class="line"></span><br><span class="line">执行 /sbin/sysctl -p 让参数生效</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="HTTP请求报文-amp-响应报文"><a href="#HTTP请求报文-amp-响应报文" class="headerlink" title="HTTP请求报文&amp;响应报文"></a>HTTP请求报文&amp;响应报文</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152923685.png" alt="image-20230209152923685" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span>   </span><br><span class="line">-----------------------↑请求行,↓请求头部---------------------------</span><br><span class="line">Host: https:<span class="comment">//www.baidu.com</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">86.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">86.0</span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,*<span class="comment">/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Cookie: BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; __yjs_duid=1_d05d52b14af4a339210722080a668ec2161****694782; BD\_HOME=1; H_PS_PSSID=33514_33257_33273_31660_33570_26350; BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br><span class="line"><span class="comment">-----------------------------↓请求体-----------------------------</span></span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152937850.png" alt="image-20230209152937850" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">-----------------------↑状态行,↓响应头部---------------------------</span><br><span class="line">Bdpagetype: <span class="number">1</span></span><br><span class="line">Bdqid: <span class="number">0xf3c9743300024ee4</span></span><br><span class="line">Cache-Control: <span class="keyword">private</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf<span class="number">-8</span></span><br><span class="line">Date: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Expires: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line">Set-Cookie: BDSVRTM=<span class="number">13</span>; path=/</span><br><span class="line">Set-Cookie: BD_HOME=<span class="number">1</span>; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=<span class="number">33514</span>_33257_33273_31660_33570_26350; path=/; domain=.baidu.com Strict-Transport-Security: max-age=<span class="number">172800</span></span><br><span class="line">Traceid: <span class="number">161</span>****<span class="number">0751284122890175</span>****<span class="number">9583927635684</span></span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">-----------------------------↓响应体-----------------------------</span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="一次HTTP请求响应的流程"><a href="#一次HTTP请求响应的流程" class="headerlink" title="一次HTTP请求响应的流程"></a>一次HTTP请求响应的流程</h5><p>​		浏览器先查看<strong>浏览器缓存</strong>, 如果缓存中有, 会直接在屏幕中显示页面内容</p>
<ul>
<li>域名解析:浏览器查询 DNS，获取域名对应的IP地址:	浏览器先在本地DNS服务器进行查询, 如果本地域名服务器并未缓存该域名对应IP，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得对应的IP后，向服务器请求建立TCP链接，发起三次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
<hr>
<h5 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h5><p>1.无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。（传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低）</p>
<p>2.无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为。（优点解放服务器，但可能每次请求会传输大量重复的内容信息）</p>
<hr>
<h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置</li>
<li>DELETE：删除文件，与PUT相反，删除对应URI位置文件。</li>
<li>HEAD：获得报文头部，与GET类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法</li>
</ul>
<hr>
<h5 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h5><ol>
<li><p>get重点在从服务器上获取资源；post重点在向服务器发送数据；</p>
</li>
<li><p>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等 </p>
<p>post传输数据将字段与对应值封存在请求体中发送给服务器，这个过程对用户是不可见的</p>
</li>
<li><p>Get传输的数据量小，因为受URL长度限制，但效率较高</p>
<p>Post可以传输大量数据，所以上传文件时只能用Post方式</p>
</li>
<li><p>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码</p>
<p>post支持标准字符集，可以正确传递中文字符</p>
</li>
</ol>
<hr>
<h5 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h5><ul>
<li>1xx：表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<hr>
<h5 id="Http的keepalive字段"><a href="#Http的keepalive字段" class="headerlink" title="Http的keepalive字段"></a>Http的keepalive字段</h5><p>既然上面提到了HTTP是基于请求与响应的，且最主要的两个特点就是无连接和无状态，但需要说明的是，虽然是无连接的，但其底层也就是传输层大多却是基于 TCP面向连接的通信方式，因此，这里的无连接指的是：当server端和client端进行通讯的时候，client端向server端发起请 求，server端接收请求之后返回给client端一个响应，之后就会断开不再继续保持连接了；这样有一个好处就是对于只有一次访问的连接来说不仅节省 资源还很高效，但很明显，如果client端还想继续多次访问server端就需要重新建立连接也就是会多次进行TCP的“三次握手，四次挥手”的过程， 这样一来并没有节省资源而且还很低效，因此使用keep-alive（又称持久连接、连接重用）可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，避免了建立或者重新建立连接的次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高http服务器的吞吐率</p>
<p>HTTP 1.0 中keep-alive默认是关闭的，需要在HTTP头加入”Connection: Keep-Alive”，才能启用Keep-Alive；</p>
<p>HTTP 1.1中默认启用Keep-Alive，如果加入”Connection: close “则关闭。目前大部分浏览器都是用HTTP 1.1协议</p>
<p>keepalive_timeout时间值意味着：一个http产生的TCP连接在传送完最后一个响应后，还需要保持keepalive_timeout 时间后才开始关闭这个连接；如果在这个时间内client端还有请求发过来，那么server端会继续给予响应，如果keepalive_timeout时间计时结束后，就会进入TCP释放连接的解读那，因此也就会结束掉这次的通信。</p>
<hr>
<h5 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h5><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况（会在后台开启http守护进程，一个http守护进程消耗是5MB内存的话）</p>
<p>例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket 创建也是对资源的浪费。</p>
<p>而像 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<hr>
<h5 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h5><p>Http协议运行在TCP之上，明文传输；Https是身披SSL外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>1）Http端口号80, Https是443</p>
<p>2）Https由于加解密处理消耗更多的CPU和内存资源</p>
<p>3）Https通信需要证书，而证书一般需要向认证机构购买 </p>
<p>4）Https的加密机制是一种结合对称加密和非对称加密的混合加密机制</p>
<hr>
<h5 id="HTTPS握手步骤"><a href="#HTTPS握手步骤" class="headerlink" title="HTTPS握手步骤"></a>HTTPS握手步骤</h5><ol>
<li>客户端向服务器发出HTTPS连接请求。</li>
<li>服务器将自己的<strong>数字证书（含公钥）</strong>发送给客户端。</li>
<li>客户端验证证书的有效性。客户端从服务器中获取证书链（证书颁发机构的证书）来验证服务器的数字证书是否有效。验证包括检查证书是否过期、是否被吊销，以及证书中的信息是否和服务器匹配等</li>
<li>如果证书验证通过，则客户端使用服务器证书中的公钥来生成一个随机密钥，该密钥将用于后续的加密通信。</li>
<li>客户端将生成的随机密钥用服务器证书中的公钥进行加密，然后发送给服务器。</li>
<li>服务器使用自己的私钥解密客户端发送过来的随机密钥。</li>
<li>客户端和服务器使用该随机密钥进行加密和解密，从而保证HTTPS通信的安全性。</li>
</ol>
<hr>
<h5 id="⚠️对称加密与非对称加密"><a href="#⚠️对称加密与非对称加密" class="headerlink" title="⚠️对称加密与非对称加密"></a>⚠️对称加密与非对称加密</h5><ul>
<li><p>对称加密是指加密和解密使用同一个密钥的方式</p>
</li>
<li><p>非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送方使用对方的公钥进行加密处理，接收方接收到加密信息后，使用自己的私钥进行解密。</p>
</li>
</ul>
<p>由于非对称加密的方式不需要发送用来解密的私钥, 所以可以保证安全性, 但是慢; 所以我们还是要用对称加密来传送消息, 对称加密所使用的密钥我们可以通过非对称加密的方式发送出去</p>
<hr>
<h5 id="HTTP1-x-和-HTTP2-0-的区别"><a href="#HTTP1-x-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.x 和 HTTP2.0 的区别"></a>HTTP1.x 和 HTTP2.0 的区别</h5><ul>
<li>二进制格式：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</li>
<li>多路复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面</li>
<li>头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小</li>
</ul>
<hr>
<h5 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h5><ul>
<li><p>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了</p>
</li>
<li><p>压缩发送的数据：将文本数据进行压缩，减少带宽</p>
</li>
<li><p>SSL加速：SSL协议对HTTP协议进行加密，在通道内加密并加速</p>
</li>
<li><p>HTTP请求复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理。也是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMjQ0Mzg=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<hr>
<h5 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h5><p><strong>是一种基于 TCP 的协议，在客户端和服务器之间建立双向通信的通道，是长连接，可以在不需要刷新页面或进行轮询的情况下实时传输数据。</strong>客户端和服务器就可以通过该连接进行实时通信。</p>
<p>此外，WebSocket 协议的数据传输是二进制的，传输效率更高，而且支持跨域通信，可以在不同的域名和端口之间建立连接。</p>
<p>WebSocket 协议的使用场景非常广泛，例如在线聊天室、多人游戏、实时数据传输等。可以使用 WebSocket API 在客户端和服务器之间建立 WebSocket 连接，从而实现实时通信的功能。</p>
<hr>
<h6 id="WebSocket-API-有哪些"><a href="#WebSocket-API-有哪些" class="headerlink" title="WebSocket API 有哪些"></a>WebSocket API 有哪些</h6><ol>
<li><p><code>WebSocket</code> 对象：WebSocket API 的核心对象，用于创建 WebSocket 连接、发送和接收数据。</p>
</li>
<li><p><code>onopen</code> 事件：WebSocket 连接成功建立时触发的事件</p>
</li>
<li><p><code>onmessage</code> 事件：接收到 WebSocket 数据时触发的事件</p>
</li>
<li><p><code>onclose</code> 事件：WebSocket 连接关闭时触发的事件</p>
</li>
<li><p><code>onerror</code> 事件：WebSocket 出错时触发的事件</p>
</li>
<li><p><code>send()</code> 方法：用于向 WebSocket 服务器发送数据</p>
</li>
<li><p><code>close()</code> 方法：用于关闭 WebSocket 连接</p>
</li>
</ol>
<hr>
<h6 id="C-中如何实现websocket协议"><a href="#C-中如何实现websocket协议" class="headerlink" title="C++中如何实现websocket协议"></a>C++中如何实现websocket协议</h6><p>在 C++ 中实现 WebSocket 协议，通常需要使用一个第三方库来处理 WebSocket 的底层协议。以下是一些常用的 C++ WebSocket 库</p>
<ol>
<li>libwebsockets：一个小型、轻量级的 C 语言库，用于实现 WebSockets 协议和 HTTP 协议。</li>
<li>WebSocket++：一个基于 Asio 的 I&#x2F;O  C++ WebSocket 库，支持客户端和服务器端的 WebSocket 连接。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是使用 WebSocket++ 库在 C++ 中实现 WebSocket 服务器的示例代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/config/asio_no_tls.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/server.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> websocketpp::server&lt;websocketpp::config::asio&gt; server;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_message</span><span class="params">(server* s, websocketpp::connection_hdl hdl, server::message_ptr msg)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">get_payload</span>() &lt;&lt; std::endl;</span><br><span class="line">  s-&gt;<span class="built_in">send</span>(hdl, msg-&gt;<span class="built_in">get_payload</span>(), msg-&gt;<span class="built_in">get_opcode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  server echo_server;</span><br><span class="line">  echo_server.<span class="built_in">set_message_handler</span>(&amp;on_message);</span><br><span class="line">  echo_server.<span class="built_in">init_asio</span>();</span><br><span class="line">  echo_server.<span class="built_in">listen</span>(<span class="number">9002</span>);</span><br><span class="line">  echo_server.<span class="built_in">start_accept</span>();</span><br><span class="line">  echo_server.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，使用 WebSocket++ 库创建一个 WebSocket 服务器，监听端口号 9002，并在收到消息时打印消息内容。使用 <code>init_asio()</code> 方法初始化 Asio I&#x2F;O 系统，使用 <code>start_accept()</code> 方法开始接收连接请求，使用 <code>run()</code> 方法等待连接和消息。</p>
<hr>
<h6 id="HTTP-协议和-websocket-协议的区别"><a href="#HTTP-协议和-websocket-协议的区别" class="headerlink" title="HTTP 协议和 websocket 协议的区别"></a>HTTP 协议和 websocket 协议的区别</h6><p>HTTP协议和WebSocket协议都是应用层协议，但是它们有一些重要的区别。</p>
<ol>
<li>连接方式： HTTP协议是一种请求-响应协议，客户端发送请求给服务器端，服务器端响应请求，然后断开连接。这种连接方式被称为”短连接”。而WebSocket协议是一种全双工协议，客户端和服务器端之间可以保持长时间的连接，并且可以在任何时间发送数据。这种连接方式被称为”长连接”。</li>
<li>数据格式： <strong>HTTP协议传输的数据格式是纯文本格式，通常使用JSON或XML格式。</strong>而WebSocket协议可以传输任何格式的数据，例如二进制数据、文本数据等。</li>
<li>性能： HTTP协议每次请求都需要重新建立连接，这会带来额外的延迟。而WebSocket协议可以在一次连接中传输多个请求和响应，从而可以提高传输效率和性能。</li>
<li>安全性： HTTP协议的安全性较低，通常需要使用SSL协议来加密数据。而WebSocket协议可以在建立连接时使用SSL协议进行加密，从而保证传输的数据安全。</li>
</ol>
<p>总的来说，WebSocket协议比HTTP协议更适合实时通信和数据传输。但是由于WebSocket协议相对于HTTP协议较新，支持程度和兼容性有时可能存在问题</p>
<hr>
<h5 id="说说ARP协议"><a href="#说说ARP协议" class="headerlink" title="说说ARP协议"></a>说说ARP协议</h5><p>ARP是根据IP地址获取其物理地址的协议</p>
<p>工作原理：</p>
<p>源主机在向目标主机发送IP包前，通过广播ARP请求包， 若源主机不知道目标主机的MAC地址，源主机就会广播一个ARP请求包，请求包中有目标主机的IP，以太网中的所有计算机都会接受到这个请求，而正常情况下只有目标主机会给出ARP应答包，包中就填充上了目标主机的MAC地址，并回复给源主机。源主机得到应答后将目标主机的MAC地址存入本机ARP高速缓存中以便下次使用</p>
<hr>
<h5 id="说说NAT协议"><a href="#说说NAT协议" class="headerlink" title="说说NAT协议"></a>说说NAT协议</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183418866.png" alt="image-20230301183418866" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183448058.png" alt="image-20230301183448058" style="zoom:50%;">

<hr>
<h5 id="Session、Cookie"><a href="#Session、Cookie" class="headerlink" title="Session、Cookie"></a>Session、Cookie</h5><p>同：Cookie和Session都是客户端与服务器之间保持状态的解决方案</p>
<p>不同：</p>
<p>1）cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>2）Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
<p>3）Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全</p>
<hr>
<h5 id="⚠️国内访问不了谷歌的技术原因"><a href="#⚠️国内访问不了谷歌的技术原因" class="headerlink" title="⚠️国内访问不了谷歌的技术原因"></a>⚠️国内访问不了谷歌的技术原因</h5><ol>
<li><p><strong>IP封锁</strong>：IP封锁是一种网络安全措施，用于阻止某个特定的IP地址或一组IP地址访问某个网站或网络资源。封锁可以通过防火墙、路由器或其他网络设备进行实现。</p>
<blockquote>
<p>  IP封锁通常用于以下几种情况：</p>
<ol>
<li>防止恶意攻击：当网络管理员检测到某个IP地址正在进行恶意攻击，可以将该IP地址封锁以防止攻击者继续攻击</li>
<li>防止垃圾邮件：当网络管理员检测到某个IP地址正在发送大量垃圾邮件时，可以将该IP地址封锁</li>
<li>防止滥用：当网络管理员检测到某个IP地址正在滥用某个服务时，可以将该IP地址封锁</li>
</ol>
</blockquote>
<blockquote>
<p>  要进行IP封锁，可以使用以下方法：</p>
<ol>
<li>防火墙：网络管理员可以使用防火墙来封锁特定的IP地址。防火墙可以根据规则集或白名单&#x2F;黑名单来进行配置，以阻止或允许特定的IP地址或IP地址范围的访问。</li>
<li>路由器：网络管理员可以使用路由器来封锁特定的IP地址。路由器可以使用访问控制列表（ACL）来限制特定的IP地址或IP地址范围的访问。</li>
<li>应用程序：网络管理员可以使用应用程序来封锁特定的IP地址。一些应用程序提供了IP黑名单或IP过滤器功能，可以在应用程序层面上封锁特定的IP地址。</li>
</ol>
</blockquote>
</li>
<li><p><strong>DNS劫持</strong>：在中国，政府使用DNS劫持来屏蔽谷歌等国外网站。当用户输入被屏蔽的网站的域名时，政府会将其DNS解析请求重定向到另一个地址，通常是一个被政府控制的服务器，而不是实际的DNS服务器。这意味着用户将无法访问被屏蔽的网站，因为他们的计算机将连接到错误的服务器，而不是正确的目标网站。</p>
</li>
</ol>
<hr>
<h5 id="⚠️国内可以通过什么技术手段访问谷歌"><a href="#⚠️国内可以通过什么技术手段访问谷歌" class="headerlink" title="⚠️国内可以通过什么技术手段访问谷歌"></a>⚠️国内可以通过什么技术手段访问谷歌</h5><ol>
<li>虚拟私人网络（VPN）：VPN 的工作原理是建立一个加密通道，在这个加密通道中，数据被加密并封装在一个特定的协议中，这个协议可以保证数据的完整性和机密性。可以避免网络上的拦截、监视、截获和篡改等安全问题</li>
<li>正向代理服务器：代理服务器是一种充当中间人的服务器，它会将用户的互联网请求转发到目标网站，从而帮助用户绕过封锁。用户可以在互联网上找到许多公开的代理服务器，或者使用自己的私人代理服务器，以访问被屏蔽的谷歌网站。</li>
</ol>
<hr>
<h5 id="⚠️VPN和代理服务器的区别"><a href="#⚠️VPN和代理服务器的区别" class="headerlink" title="⚠️VPN和代理服务器的区别"></a>⚠️VPN和代理服务器的区别</h5><p>国内可以通过什么技术手段访问谷歌？ VPN和代理服务器</p>
<p>(简单来说 VPN就是更安全的正向代理)</p>
<p>VPN和代理服务器都可以帮助用户绕过封锁，访问被屏蔽的网站和应用程序。</p>
<ol>
<li>加密方式&amp;安全性：VPN使用的是点对点的加密方式，通过建立加密的隧道，保护用户的互联网连接和数据安全。而代理服务器则不提供加密功能，只是将用户的互联网请求转发到目标网站，因此用户的数据可能会在传输过程中被窃取或篡改。</li>
<li>稳定性：VPN比代理服务器更稳定，因为VPN连接通常由专业的VPN服务提供商管理和维护，保证服务器的稳定性和可靠性。而代理服务器可能来自于各种来源，如公开代理服务器和私人代理服务器，其稳定性和可靠性不如VPN。</li>
<li>使用难度：代理服务器相对于VPN使用较为简单，只需要将浏览器或其他应用程序的代理设置更改为代理服务器的IP地址和端口号即可。而VPN需要先下载和安装VPN客户端，然后设置连接参数，相对来说稍微复杂一些。</li>
</ol>
<hr>
<h5 id="防火墙的原理"><a href="#防火墙的原理" class="headerlink" title="防火墙的原理"></a>防火墙的原理</h5><p>防火墙是一种网络安全设备，它可以监控和控制网络通信，以保护计算机网络免受恶意攻击和未经授权的访问。防火墙通常作为一个网络边界设备，位于内部网络和外部网络之间。</p>
<p>防火墙的原理基于路由器访问控制列表（ACL），它可以允许或拒绝网络流量通过特定端口和协议。当流量进入防火墙时，它会根据预定义的规则来决定是否允许流量通过。如果流量满足规则，则它会被允许通过防火墙，否则它会被阻止或丢弃。</p>
<p>总的来说，防火墙通过监控和控制网络流量来保护网络免受恶意攻击和未经授权的访问。其基本原理是使用ACL来决定哪些流量可以通过防火墙，而哪些流量应被阻止或丢弃。</p>
<hr>
<h5 id="⚠️运营商给用户限速的类型和原理"><a href="#⚠️运营商给用户限速的类型和原理" class="headerlink" title="⚠️运营商给用户限速的类型和原理"></a>⚠️运营商给用户限速的类型和原理</h5><p>带宽限制(限制用户每秒钟可以传输的数据量)、时间限制、流量限制、服务限制</p>
<p><strong>限速的底层原理</strong></p>
<ol>
<li>流量控制：运营商会对用户的网络流量进行控制，限制其流量的带宽或流量速率。一般来说，运营商会在核心路由器或边缘路由器上设置策略，根据用户的套餐类型、用量等因素进行流量控制。</li>
<li>调度算法：运营商通过调度算法来控制网络资源的分配，以保证整个网络的公平性和平衡性。常见的调度算法包括最小带宽保证、公平队列调度、公平带宽分配</li>
<li>数据包标记：运营商还可以通过给数据包打上不同的标记，实现不同的服务质量级别。例如，将数据包标记为低优先级的，就会被放入低优先级队列中，从而减少其处理优先级，达到限速的效果。</li>
<li>限速设备：运营商在网络中还可以设置专门的限速设备，例如调度器、速率控制器等，通过对数据包进行筛选和处理，实现对用户网速的限制</li>
</ol>
<hr>
<h5 id="⚠️常见的流量控制算法"><a href="#⚠️常见的流量控制算法" class="headerlink" title="⚠️常见的流量控制算法"></a>⚠️常见的流量控制算法</h5><ol>
<li><p><strong>漏桶：</strong>水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率，（因为漏桶的漏出速率是固定的参数，所以，即使网络中不存在资源冲突(没有发生拥塞)，漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率</p>
</li>
<li><p><strong>令牌桶算法</strong>：和漏桶效果一样但方向相反的算法，更加容易理解。随着时间流逝，系统会按恒定时间间隔往桶里加入Token(想象和漏洞漏水相反，有个水龙头在不断的加水)，如果桶已经满了就不再加了，新请求来临时，会各自拿走一个Token，如果没有Token可拿了就阻塞或者拒绝服务。令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量。</p>
</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/1011415-20170701192633914-1313517581-20230303141645878.jpg" alt="img"></p>
<h3 id="3️⃣数据库"><a href="#3️⃣数据库" class="headerlink" title="3️⃣数据库"></a>3️⃣数据库</h3><h4 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h4><hr>
<h5 id="⚠️MySQL体系架构"><a href="#⚠️MySQL体系架构" class="headerlink" title="⚠️MySQL体系架构"></a>⚠️MySQL体系架构</h5><p>网络连接层、服务层、存储引擎层和系统文件层</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218115419272.png" alt="image-20230218115419272" style="zoom: 33%;">

<p><strong>一、网络连接层</strong></p>
<p>客户端连接器：提供与MySQL服务器建立连接的支持。如 Java&#x2F;C通过各自API与MySQL建立连接</p>
<p><strong>二、服务层</strong></p>
<p>服务层是MySQL Server的核心，主要包含六个部分</p>
<ul>
<li><p><strong>系统管理和控制工具：</strong>例如备份恢复、安全管理、集群管理【集群就是指一组相互独立的计算机，利用网络组成的一个较大的计算机服务系统，每个集群节点（即每台计算机）都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序，系统资源和数据，并以单一系统的模式加以管理。当用户请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器】</p>
</li>
<li><p><strong>连接池</strong>：负责存储和管理客户端与数据库服务器的连接，一个线程负责管理一个连接</p>
</li>
<li><p><strong>SQL接口：</strong>用于接收客户端发送的各种SQL命令，并且返回用户需要的查询结果</p>
</li>
<li><p><strong>解析器：</strong>负责检查请求的SQL语句的合法性</p>
</li>
<li><p><strong>查询优化器：</strong>当解析树通过语法检查后，将交由优化器将其转化为执行计划，然后与存储引擎交互</p>
</li>
<li><p><strong>缓存：</strong>缓存机制是由表缓存，记录缓存，权限缓存，引擎缓存组成。如果查询语句有命中的结果，则直接在查询缓冲中取数据</p>
</li>
</ul>
<p><strong>三、存储引擎层</strong></p>
<p><strong>负责MySQL中的数据存储和提取，与底层系统文件交互。</strong>服务器中的查询执行引擎通过接口和存储引擎进项通信，接口屏蔽了不同存储引擎的差异</p>
<p><strong>四、系统文件层</strong></p>
<p>负责将数据库的数据和日志存储在文件系统中，并完成与存储引擎的交互，是文件的物理存储层。主要包括日志文件，数据文件，配置文件，socket文件等</p>
<hr>
<h5 id="SQL语句运行机制"><a href="#SQL语句运行机制" class="headerlink" title="SQL语句运行机制"></a>SQL语句运行机制</h5><p><strong>①建立连接</strong>：通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么</p>
<p><strong>②查询缓存：</strong>如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询缓存或者没有查询到SQL 语句则会由解析器进行语法语义解析</p>
<p><strong>③解析：</strong>将客户端发送的SQL进行语法解析。</p>
<p><strong>④查询优化：</strong>根据解析结果生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）</p>
<p><strong>⑤执行引擎执行 SQL 语句：</strong>此时执行引擎会根据 SQL 语句得到查询结果并返回给客户端。若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存中</p>
<hr>
<h5 id="数据库事物特性-ACID"><a href="#数据库事物特性-ACID" class="headerlink" title="数据库事物特性(ACID)"></a>数据库事物特性(ACID)</h5><p>原 一 隔 持 ；原子性和隔离性 -&gt; 推出一致性，持久性应对系统崩溃</p>
<p>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</p>
<p>隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的</p>
<p>持久性：指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</p>
<hr>
<h5 id="⚠️数据库并发一致性问题：丢读不幻"><a href="#⚠️数据库并发一致性问题：丢读不幻" class="headerlink" title="⚠️数据库并发一致性问题：丢读不幻"></a>⚠️数据库并发一致性问题：丢读不幻</h5><p>​	  丢 (丢失修改) 	读(读脏数据)  	不(不可重复读)【一次事务内的两次读数值不同】	幻(幻影读)</p>
<ul>
<li>丢失修改：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失</li>
<li>读脏数据：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。</li>
<li>幻读与不可重复读类似。它发生在<strong>一个</strong>事务（T1）读取了<strong>几行数据</strong>，接着<strong>另一个</strong>并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<hr>
<h5 id="⚠️当前读和快照读"><a href="#⚠️当前读和快照读" class="headerlink" title="⚠️当前读和快照读"></a>⚠️当前读和快照读</h5><p><strong>快照读：普通的 select 语句</strong></p>
<p>它是基于多版本并发控制即 MVCC机制，快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p>
<p>如下的操作是快照读：不加锁的 select 操作（前提是隔离级别不是串行化，串行化的是当前读）</p>
<p><strong>当前读：能读到所有已经提交的记录的最新值</strong></p>
<p>它读取的记录都是数据库中当前的最新版本，会对当前读取的数据进行加锁，防止其他事务修改数据，是一种悲观锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> … <span class="keyword">for</span> <span class="keyword">update</span> # 当前读</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️两个事务并行提交一定会幻读吗"><a href="#⚠️两个事务并行提交一定会幻读吗" class="headerlink" title="⚠️两个事务并行提交一定会幻读吗"></a>⚠️两个事务并行提交一定会幻读吗</h5><p>在RR(可重复读)隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的</p>
<p><strong>因此，幻读在“当前读”下才会出现。</strong></p>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 引入了新的锁，也就是间隙锁 (Gap Lock)</p>
<p>间隙锁就是，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体</p>
<hr>
<h5 id="说下mysql死锁"><a href="#说下mysql死锁" class="headerlink" title="说下mysql死锁"></a>说下mysql死锁</h5><p>假设有一个名为“accounts”的表，其中包含两个字段“id”和“balance”，并且有两个事务在同时更新“accounts”表中的行</p>
<ul>
<li>事务1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>事务2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，可以在两个事务中按照相同的顺序获取锁定资源，例如，都先锁定id&#x3D;1的行再锁定id&#x3D;2的行。或者可以使用MySQL的死锁检测机制，自动选择其中一个事务回滚，以解除死锁</p>
<hr>
<h5 id="数据库锁类型"><a href="#数据库锁类型" class="headerlink" title="数据库锁类型"></a>数据库锁类型</h5><ol>
<li><strong>表级锁</strong></li>
</ol>
<p>（1）锁定粒度大，锁冲突概率高、并发度低</p>
<p>（2）好处是不会出现死锁、开销小、获取锁和释放锁的速度很快</p>
<p>（3）使用表级锁定的主要是MyISAM等一些非事务性存储引擎，适用于以查询为主，少量更新的应用</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230219191007830.png" alt="image-20230219191007830"></p>
<blockquote>
<p>  意向锁：加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。（防止另一个事务逐行判断是否加锁）是InnoDB自动加的，不需用户干预。意向锁不会与行级的读&#x2F;写锁互斥</p>
</blockquote>
<ol start="2">
<li><strong>行级锁</strong></li>
</ol>
<p>（1）好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；</p>
<p>（2）缺点是开销大、加锁慢，行级锁容易发生死锁；</p>
<p>（3）使用行级锁定的主要是InnoDB存储引擎。适用于对事务完整性要求较高的系统</p>
<blockquote>
<p>  InnoDB行级锁类型：读锁、写锁</p>
</blockquote>
<ol start="3">
<li><strong>页面锁</strong></li>
</ol>
<p>（1）介于行级锁和表级锁之间</p>
<p>（2）会发生死锁</p>
<hr>
<h5 id="关于锁的常见问题"><a href="#关于锁的常见问题" class="headerlink" title="关于锁的常见问题"></a>关于锁的常见问题</h5><ol>
<li>InnoDB存储引擎什么时候会锁住整张表，什么时候或只锁住一行呢？</li>
</ol>
<p><strong>只有通过索引条件查询数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong></p>
<ol start="2">
<li>mysql读锁和写锁</li>
</ol>
<p>用select 命令时触发读锁，当使用update,delete,insert时触发写锁，并且使用rollback或commit后解除本次锁定</p>
<ol start="3">
<li>InnoDB行锁的3种算法：</li>
</ol>
<p>Record Lock： 锁定单个索引记录</p>
<p>Gap Lock ：锁定一个范围，但不包含记录本身</p>
<p>Next-Key Lock：锁定一个范围，并且锁定记录本身</p>
<p><strong>所以 Next-KeyLocks &#x3D; Gap锁+ Recordlock锁</strong></p>
<blockquote>
<p>  Next-Key Locks是 MySQL 的 InnoDB 引擎的一种锁实现。MVCC (多版本的并发控制协议。最大的优点是读不加锁，因此读写不冲突，并发性能好)不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
</blockquote>
<hr>
<h5 id="数据库封锁协议"><a href="#数据库封锁协议" class="headerlink" title="数据库封锁协议"></a>数据库封锁协议</h5><ol>
<li>三级封锁协议(一级:写前加X	 	二级:写前加X读前加S,读完释放 	   三级:写前加X读前加,S锁事务结束释放)	  </li>
<li>两段锁协议(加锁与解锁串行)</li>
</ol>
<hr>
<h5 id="数据库隔离级别：未-提-可-可"><a href="#数据库隔离级别：未-提-可-可" class="headerlink" title="数据库隔离级别：未 提 可 可"></a>数据库隔离级别：未 提 可 可</h5><p>1、读未提交：顾名思义，就是一个事务可以读取另一个未提交事务的数据</p>
<p>2、读已提交：一个事务要等另一个事务提交后才能读取数据</p>
<p>3、可重复读： 在开始读取数据（事务开启）时，不再允许修改操作</p>
<p>4、串行化：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，一般不使用</p>
<p><strong>并行性依次降低，安全性依次提高</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png" alt="image-20230129192103478"></p>
<hr>
<h5 id="1NF-2NF-3NF-BCNF"><a href="#1NF-2NF-3NF-BCNF" class="headerlink" title="1NF	 		2NF		 3NF 		BCNF"></a>1NF	 		2NF		 3NF 		BCNF</h5><p>对于 A-&gt;B(A推出B)，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p>
<p>A-&gt;B: B依赖于A</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230413593.png" alt="image-20230323230413593"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230607279.png" alt="image-20230323230607279"></p>
<p><strong>BCNF：</strong>设关系模式R是1NF。如果对于R的每个函数依赖X-&gt;Y，X必为候选键，则R是BCNF范式。</p>
<hr>
<h5 id="超键-候选键-主键"><a href="#超键-候选键-主键" class="headerlink" title="超键, 候选键, 主键"></a>超键, 候选键, 主键</h5><p>**超键(super key):**在关系中能唯一标识元组的属性集称为关系模式的超键<br>**候选键(candidate key):**不含有多余属性的超键称为候选键<br>**主键(primary key):**用户选作元组标识的一个候选键 </p>
<hr>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><h6 id="什么是索引？优缺点？"><a href="#什么是索引？优缺点？" class="headerlink" title="什么是索引？优缺点？"></a>什么是索引？优缺点？</h6><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。</p>
<p>它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的 数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。</p>
<p>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小</p>
<hr>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><strong>普通索引：</strong></p>
<p>普通索引是mysql里最基本的索引，没有什么特殊性，在任何一列上都能进行创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>);</span><br><span class="line"><span class="comment">-- 例子 length默认我们可以忽略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> <span class="keyword">user</span>(name);</span><br></pre></td></tr></table></figure>

<p><strong>主键索引</strong></p>
<p><strong>复合索引(组合索引)：</strong></p>
<p>指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。</p>
<p>复合索引的使用复合最左原则。举个例子 我们使用 phone和name创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(column1,column2);</span><br><span class="line"><span class="comment">-- 例子 </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_phone_name <span class="keyword">ON</span> <span class="keyword">user</span>(phone,name);</span><br></pre></td></tr></table></figure>

<p>我们看下面的查询语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段才能够进行匹配。而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。</p>
<p><strong>全文索引：</strong></p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。</p>
<p>它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。正常情况下我们也不会使用到全文索引，因为这不是mysql的专长。</p>
<p><strong>空间索引：</strong></p>
<p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>创建空间索引的列必须声明为NOT NULL，只能在存储引擎为MYISAM的表中创建。</p>
<hr>
<h6 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h6><ol>
<li>B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。	辅助索引的叶子节点的 data 域记录着主键的值，需要先查找到主键值，然后再到主索引中进行查找。	</li>
<li>哈希索引，能以 O(1) 时间进行查找，但是失去了有序性。</li>
</ol>
<p>	</p>
<hr>
<h6 id="如何创建及保存MySQL的索引？"><a href="#如何创建及保存MySQL的索引？" class="headerlink" title="如何创建及保存MySQL的索引？"></a>如何创建及保存MySQL的索引？</h6><p>在创建表的时候创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX UniqIdx(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在已存在的表上创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在已经存在的表中创建索引，可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句或者<span class="keyword">CREATE</span> INDEX语句。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx (bookId);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx <span class="keyword">ON</span> book (bookId);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="如何判断索引有没有生效？"><a href="#如何判断索引有没有生效？" class="headerlink" title="如何判断索引有没有生效？"></a>如何判断索引有没有生效？</h6><p>使用EXPLAIN语句, 假设已创建了book表, 并已经在其year_publication字段上建立了普通索引, 执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication = 1990; </span><br></pre></td></tr></table></figure>

<p>EXPLAIN语句将为我们输出详细的SQL执行信息, 其中：</p>
<ul>
<li>possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key行是MySQL实际选用的索引。</li>
</ul>
<p>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</p>
<hr>
<h6 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h6><p>MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN [EXTENDED] SELECT select_options</span><br></pre></td></tr></table></figure>

<p>使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：</p>
<ul>
<li>id：SELECT识别符。这是SELECT的查询序列号。</li>
<li>select_type：表示SELECT语句的类型。</li>
<li>table：表示查询的表。</li>
<li>type：表示表的连接类型。</li>
<li>possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key：是MySQL实际选用的索引。</li>
<li>key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。</li>
<li>ref：给出了关联关系中另一个数据表里的数据列名。</li>
<li>rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>Extra：提供了与关联操作有关的信息。</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC。。DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="⚠️索引优化"><a href="#⚠️索引优化" class="headerlink" title="⚠️索引优化"></a>⚠️索引优化</h6><ol>
<li><p>独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引</p>
</li>
<li><p>多列索引	要注意索引列的顺序：让选择性最强的索引列放在前面</p>
</li>
<li><p>前缀索引：例如下面 SQL 语句不能使用索引。select * from doc where title like ‘%XX’</p>
<p>而非前导模糊查询则可以使用索引，如下面的 SQL 语句。select * from doc where title like ‘XX%’</p>
</li>
<li><p>覆盖索引：如果有一个查询包含了所有索引的列，我们称之为覆盖索引</p>
</li>
</ol>
<hr>
<h6 id="应该建立索引的条件"><a href="#应该建立索引的条件" class="headerlink" title="应该建立索引的条件"></a>应该建立索引的条件</h6><ol>
<li>在经常使用在 WHERE 子句中的列上面创建索引</li>
<li>在经常用在连接的列上, 这些列主要是一些外键</li>
<li>在经常需要根据范围进行搜索的列上创建索引</li>
<li>在经常需要排序的列上创建索引</li>
</ol>
<hr>
<h6 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h6><p>索引的优点</p>
<ol>
<li>通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度</li>
<li>可以加速表和表之间的连接</li>
<li>加快分组和排序</li>
</ol>
<p>索引的缺点</p>
<ol>
<li>索引有可能降低查询性能，带来磁盘的开销和处理开销等</li>
<li>太多的索引，让设计不稳定</li>
<li>不便维护</li>
<li>数据修改需求&gt;检索需求时，索引会降低性能</li>
</ol>
<hr>
<h6 id="索引的最左前缀问题"><a href="#索引的最左前缀问题" class="headerlink" title="索引的最左前缀问题"></a>索引的最左前缀问题</h6><p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<hr>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。   </li>
<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎放弃使用索引而进行全表扫描。</li>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’   </li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)   </li>
<li>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引2</li>
<li>多使用LIMIT 避免使用SELECT *</li>
</ol>
<hr>
<h5 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h5><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<hr>
<h5 id="⚠️InnoDB体系结构"><a href="#⚠️InnoDB体系结构" class="headerlink" title="⚠️InnoDB体系结构"></a>⚠️InnoDB体系结构</h5><p>innodb的体系架构就是由多个内存块组成的缓冲池及多个后台线程构成</p>
<p>缓冲池缓存磁盘数据（解决cpu速度和磁盘速度的严重不匹配问题）</p>
<p>后台进程保证缓存池和磁盘数据的一致性（读取、刷新），并保证数据异常宕机时能恢复到正常状态</p>
<p>缓冲池主要分为三个部分：redo <em>log buffer、innodb_buffer_pool、innodb_additional_mem_pool。</em></p>
<ul>
<li>innodb_buffer_pool由包含数据、索引、insert buffer ,adaptive hash index,lock 信息及数据字典。</li>
<li>redo log buffer用来缓存重做日志</li>
<li>additional memory pool:用来缓存LRU链表、等待、锁等数据结构</li>
</ul>
<p>后台进程分为：master thread，IO thread，purge thread，page cleaner thread</p>
<ul>
<li>master thread负责刷新缓存数据到磁盘并协调调度其它后台进程</li>
<li>IO thread 分为 insert buffer、log、read、write进程。分别用来处理insert buffer、重做日志、读写请求的IO回调</li>
<li>purge thread用来回收undo 页</li>
<li>page cleaner thread用来刷新脏页</li>
</ul>
<p>master thread根据服务器的压力分为了每一秒及每十秒的操作。每一秒的操作包括：刷新重做日志、根据过去一秒的磁盘吞吐量来判断是否需要merge insert buffer、根据脏页在缓冲池中占比是否超过最大脏页占比及是否开启自适应刷新来刷新脏页。每十秒的操作包括：根据过去10秒的磁盘吞吐量来刷新脏页，刷新重做日志，回收undo 页，再根据脏页占比是否超过70%刷新定量脏页</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218122345750.png" alt="image-20230218122345750" style="zoom:50%;">

<hr>
<h5 id="⚠️说说-InnoDB-的-MVCC"><a href="#⚠️说说-InnoDB-的-MVCC" class="headerlink" title="⚠️说说 InnoDB 的 MVCC"></a>⚠️说说 InnoDB 的 MVCC</h5><p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。</p>
<p>MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构： </p>
<ol>
<li><p>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log（可以实现事务的回滚操作）的指针</p>
</li>
<li><p>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，形成一条版本链</p>
</li>
<li><p>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务A在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对事务A是否可见</p>
</li>
</ol>
<hr>
<h5 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h5><p>整数类型：TINY&#x2F;SMALL&#x2F;MEDIUM INT、INT、BIGINT</p>
<p>实数类型：FLOAT、DOUBLE、DECIMAL</p>
<p>字符串类型：CHAR、VARCHAR、TEXT、BLOB</p>
<p>枚举类型：ENUM</p>
<p>日期与时间：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<hr>
<h5 id="⚠️主从复制"><a href="#⚠️主从复制" class="headerlink" title="⚠️主从复制"></a>⚠️主从复制</h5><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p>主从复制的优点：</p>
<blockquote>
<p>  <strong>读写分离</strong>: 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>  读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
</blockquote>
<hr>
<h5 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h5><p><strong>关系型</strong></p>
<p>主要是指创建在关系模型上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>由关系数据结构、操作集合、完整性约束三部分组成</p>
<p><strong>—优点—</strong></p>
<p>1.事务处理—保持数据的一致性	2.标准化SQL, 数据更新的开销小	3.可以进行Join等复杂查询	4.基于严格的数学</p>
<p><strong>—缺点—</strong></p>
<p>1.性能	2.纵向扩展	3.贵</p>
<p><strong>非关系型</strong></p>
<p>—优点—</p>
<ol>
<li><p>简单的扩展（集群）</p>
</li>
<li><p>高性能（它们可以处理超大量的数据）：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作;</p>
</li>
<li><p>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本;</p>
</li>
<li><p>灵活的数据模型。不需要事先对存储数据建立字段。</p>
</li>
</ol>
<p>—缺点—</p>
<ol>
<li><p>不支持SQL的工业标准，将会对用户产生一定的学习和应用迁移成本;</p>
</li>
<li><p>不支持事务，很难保证数据一致性</p>
</li>
<li><p>现有产品的不够成熟：大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语;</p>
</li>
<li><p>不能支持比较复杂的查询</p>
</li>
<li><p>NoSQL 并不完全安全稳定，由于它基于内存，一旦停电或者机器故障数据就很容易丢失数据，其持久化能力也是有限的，而基于磁盘的数据库则不会出现这样的问题</p>
</li>
</ol>
<hr>
<h5 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h5><p>实体完整性：指表中行记录的非空、唯一且不重复</p>
<p>域完整性：指表中的列必须满足某种数据类型或约束。CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL都属于域完整性的范畴</p>
<p>参照完整性：修改表，与之相关联的表也随之改变 不一致的处理方法：拒绝执行 、级联操作 、设置为空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">  customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (customer_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">  order_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (order_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个外键约束确保了数据的完整性，因为它防止在orders表中插入一个不存在于customers表中的顾客ID。</p>
<hr>
<h5 id="对表的外键构建索引的好处"><a href="#对表的外键构建索引的好处" class="headerlink" title="对表的外键构建索引的好处"></a>对表的外键构建索引的好处</h5><p>为确保安全，在对主表操作时，需要对参照表进行加锁操作。如果外键没有索引，查找子记录就会很慢，引起全表扫描。且参照表被锁的时间很长，进而可能发生死锁。</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191931072.png" alt="image-20230129191931072"></p>
<p><strong>注：联合主键：就是用多个字段一起作为一张表的主键。</strong></p>
<hr>
<h5 id="一个好的模式分解具有哪些性质"><a href="#一个好的模式分解具有哪些性质" class="headerlink" title="一个好的模式分解具有哪些性质"></a>一个好的模式分解具有哪些性质</h5><p>无损连接分解和保持依赖</p>
<p>无损分解指的是对关系分解时，原关系模型中任意合法的列在分解之后应能通过自然联接运算恢复起来。</p>
<p>保持函数依赖指的是对关系分解时，原关系的闭包与分解后关系闭包的并集相等。</p>
<hr>
<h5 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h5><p>视图是从几个表或视图导出的表。是一个虚表。</p>
<p>数据库中只存放视图的定义，而不存放视图对应的数据。</p>
<p>视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化</p>
<hr>
<h5 id="⚠️MySQL分区分表"><a href="#⚠️MySQL分区分表" class="headerlink" title="⚠️MySQL分区分表"></a>⚠️MySQL分区分表</h5><p>MySQL分区是将一个大表分解成更小、更易于管理的部分的过程。分区可以提高查询性能、减少锁定冲突和减轻磁盘I&#x2F;O负载。分区可以按照不同的方式进行，其中包括水平分区和垂直分区。水平分区将表中的行分成不同的分区，而垂直分区将表中的列分成不同的分区。</p>
<p>MySQL分表是将一个大表拆分成多个小表的过程。这种做法可以解决单表数据量过大、索引效率低下的问题。分表一般按照某个条件（例如日期、区域、用户ID等）将数据分散到不同的表中。</p>
<p>下面是MySQL进行分区分表的步骤：</p>
<ol>
<li>创建分区表：使用CREATE TABLE语句创建分区表。</li>
<li>选择分区键：选择一个或多个用于分区的列。</li>
<li>定义分区：使用PARTITION BY子句指定如何将表分区，例如按照日期或地理位置进行分区。</li>
<li>分配数据：将数据插入分区表中。MySQL会根据分区键的值将数据插入正确的分区。</li>
<li>管理分区：可以使用ALTER TABLE语句管理分区，例如添加或删除分区。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    region <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    country <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="type">date</span> <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id, <span class="type">date</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(<span class="type">date</span>)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2015</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2016</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码创建了一个名为sales的分区表，包含六个列，其中id和<span class="type">date</span>列被指定为主键。分区键使用了<span class="type">date</span>列，按照年份进行分区。一共定义了<span class="number">8</span>个分区，每个分区包含小于指定年份的数据。</span><br><span class="line"></span><br><span class="line"># 将数据插入分区表中，MySQL会根据分区键的值将数据插入正确的分区，例如：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales (region, country, product, <span class="type">date</span>, amount)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2018-01-01&#x27;</span>, <span class="number">1000</span>),</span><br><span class="line">       (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;Japan&#x27;</span>, <span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="number">2000</span>),</span><br><span class="line">       (<span class="string">&#x27;Europe&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;2020-03-01&#x27;</span>, <span class="number">3000</span>),</span><br><span class="line">       (<span class="string">&#x27;North America&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Tablet&#x27;</span>, <span class="string">&#x27;2021-04-01&#x27;</span>, <span class="number">4000</span>),</span><br><span class="line">       (<span class="string">&#x27;South America&#x27;</span>, <span class="string">&#x27;Brazil&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2022-05-01&#x27;</span>, <span class="number">5000</span>);</span><br><span class="line"># 上述代码将五条数据插入到sales表中，MySQL会将它们分别插入到不同的分区中。</span><br><span class="line"></span><br><span class="line"># 可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句管理分区，例如添加或删除分区。以下是添加新分区的示例代码：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码向sales表添加了一个新分区p8，包含小于<span class="number">2023</span>年的数据。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="delete、drop、-truncate区别"><a href="#delete、drop、-truncate区别" class="headerlink" title="delete、drop、 truncate区别"></a>delete、drop、 truncate区别</h5><ul>
<li>truncate和delete只删除数据，不删除表结构;drop删除表结构</li>
<li>删除数据的速度: drop &gt; truncate &gt; delete</li>
<li>delete属于DML语言，需要事务管理，commit之后才能生效; drop 和truncate属于DDL语言，操作立刻生效，不可回滚</li>
<li>使用场合:不再需要表时使用drop语句;保留表删除所有记录用truncate语句;删除部分记录用delete语句</li>
</ul>
<hr>
<h5 id="exists和in的区别"><a href="#exists和in的区别" class="headerlink" title="exists和in的区别"></a>exists和in的区别</h5><p>下面将主查询的表称为外表;子查询的表称为内表。exists与in的主要区别如下:</p>
<ul>
<li><p>使用exists, 会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据;      in,会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据</p>
</li>
<li><p>内表大，用exists 效率较高;内表小，用in效率较高。</p>
</li>
<li><p>not exists的效率一般要高于not in</p>
</li>
</ul>
<hr>
<h5 id="说说触发器"><a href="#说说触发器" class="headerlink" title="说说触发器"></a>说说触发器</h5><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码</p>
<p>MySQL数据库中有六种触发器:</p>
<ul>
<li><p>Before Insert</p>
</li>
<li><p>After Insert</p>
</li>
<li><p>Before Update</p>
</li>
<li><p>After Update</p>
</li>
<li><p>Before Delete</p>
</li>
<li><p>After Delete</p>
</li>
</ul>
<hr>
<h5 id="⚠️堆表（HOT）和索引组织表（IOT）"><a href="#⚠️堆表（HOT）和索引组织表（IOT）" class="headerlink" title="⚠️堆表（HOT）和索引组织表（IOT）"></a>⚠️堆表（HOT）和索引组织表（IOT）</h5><p> ① 堆组织表，其索引中记录了记录所在位置 (文件号：页号：槽号)，查找的时候先找索引，然后再根据索引找到块中的行数据。索引和表数据是分离的</p>
<p> ② 索引组织表，其行数据以索引形式存放，因此找到索引，就等于找到了行数据。索引和数据是在一起的</p>
<p>堆表是一种数据库表的存储方式，它将新插入的行直接插入到表的末尾，而不像传统的B树索引那样插入到合适的位置。这使得插入操作更快，因为不需要寻找正确的位置进行插入，而是直接将数据追加到表的末尾，然后使用一个指针来指向该行。</p>
<p>HOT的优点是：</p>
<ol>
<li>快速的插入操作：由于新数据不需要寻找合适的位置，直接追加到表末尾，因此插入操作速度很快。</li>
<li>避免索引分裂：当表中的数据通过插入或删除操作引起页分裂时，B树索引需要进行数据重组，而HOT则避免了这种情况的发生。</li>
<li>适合高并发：由于插入操作的快速性和避免索引分裂的特点，HOT适合于高并发的应用场景。</li>
</ol>
<p>HOT的缺点是：</p>
<ol>
<li>读取操作效率较低：由于数据是随机存储的，因此读取操作需要扫描整个表，效率较低。</li>
<li>不支持有序查询：HOT不支持有序的查询，因为数据是随机存储的，因此必须扫描整个表才能得到有序的结果。</li>
</ol>
<hr>
<h5 id="关系数据库都有哪些操作-特点是什么"><a href="#关系数据库都有哪些操作-特点是什么" class="headerlink" title="关系数据库都有哪些操作,特点是什么?"></a>关系数据库都有哪些操作,特点是什么?</h5><p>◇查询:	选择、投影、连接、除、并、交、差</p>
<p>◇数据更新:	插入、删除、修改</p>
<p>关系操作的特点：	集合操作方式，即操作的对象和结果都是集合。</p>
<hr>
<h5 id="数据库（DDL，DML，DQL、DCL）"><a href="#数据库（DDL，DML，DQL、DCL）" class="headerlink" title="数据库（DDL，DML，DQL、DCL）"></a>数据库（DDL，DML，DQL、DCL）</h5><ol>
<li><p>数据查询语言DQL：SELECT…FROM…WHERE</p>
</li>
<li><p>数据管理语言DML [需事务管理]：INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据定义语言DDL [不需事务管理]</p>
<p>创建数据库中的各种对象—–表、视图、索引等 如：CREATE TABLE（表）&#x2F;VIEW（视图）&#x2F;INDEX（索引）</p>
</li>
<li><p>数据控制语言DCL：GRANT &#x2F; ROLLBACK &#x2F; COMMIT</p>
</li>
</ol>
<hr>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p><strong>使用关联多列索引时，跳过左边的右边的全部失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and c &#x3D; 3，索引a是最左边的，c是最右边的，而这里只写了a和c的条件，跳过了b,那b右边的c虽然写了条件c&#x3D;3但是查询的时候也用不上</p>
<p><strong>范围条件右边失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and b &gt; 2 and c &#x3D; 3，b是个范围条件，那么索引智能用到a和b，c是范围条件右边的内容，索引用不到</p>
<p>注意：a &#x3D; 1 and b &gt; 2 and c &#x3D; 3和a &#x3D; 1 and c &#x3D; 3 and b &gt; 2是一样的，a、b、c的顺序不是写sql条件时的顺序，而是建立索引时的顺序</p>
<p><strong>模糊查询like ‘%’在左边时失效</strong></p>
<p>例如:条件where name like ‘%a’,这里name这个索引时用不上的</p>
<p><strong>原理：</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230220214904180.png" alt="image-20230220214904180" style="zoom:50%;">

<hr>
<h5 id="B树-x2F-B-树"><a href="#B树-x2F-B-树" class="headerlink" title="B树&#x2F;B+树"></a>B树&#x2F;B+树</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182905354.png" alt="image-20230217182905354" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182934695.png" alt="image-20230217182934695" style="zoom:50%;">

<p>不同点：</p>
<ol>
<li><p>b树的叶子节点没有指针，b+树有，有指针可以更加方便范围查询，同一种范围查询，b树可能得多次从头节点开始遍历；</p>
</li>
<li><p>b树没有冗余索引，但是b+树有；</p>
</li>
<li><p>b树非叶子节点也存放数据，但是b+树只有叶子节点存放数据；</p>
</li>
<li><p>存放同样的数据，b树的高度可能比b+树要高。</p>
</li>
</ol>
<ul>
<li>B+树在B树中做了一个优化，因为每个磁盘块的大小都是有限的，如果在每个非叶子节点处都存放数据，那么每次获取到的磁盘块上的索引指针信息以及关键字信息将会很少，这样会增加我们的IO次数以及树结构的深度</li>
<li>B+树只在每个非叶子节点处只存放指针以及关键字信息，这样最大化的增加每个磁盘块存放的索引信息，可以更加有效的获取出相对应的地址信息，从而也降低了树结构的深度，而且叶子顶部节点允许互链减少了重新IO的次数</li>
<li>MYSQL引擎InnoDB就是按这种方式存放数据，存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</li>
</ul>
<hr>
<h5 id="说说B-树怎么实现索引-为什么选-B-树"><a href="#说说B-树怎么实现索引-为什么选-B-树" class="headerlink" title="说说B+ 树怎么实现索引, 为什么选 B+ 树"></a>说说B+ 树怎么实现索引, 为什么选 B+ 树</h5><p>索引本质上就是通过预排序+树型结构来加快检索的效率，而MySQL中使用InnoDB和MyISAM引擎时都使用了B+树实现索引</p>
<p>在数据库中，B+树索引还可以分为聚集索引和辅助索引，但不管是聚集索引还是辅助索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<hr>
<h5 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h5><p>首先，红黑树是一种近似平衡二叉树（不完全平衡），结点非黑即红的树，它的树高最高不会超过 2*log(n)，因此查找的时间复杂度为 O(log(n))，无论是增删改查，它的性能都十分稳定； </p>
<p>但是，红黑树本质还是二叉树，在数据量非常大时，需要访问+判断的节点数还是会比较多，同时数据是存在磁盘上的，访问需要进行磁盘IO，导致效率较低； 而B+树是多叉的，可以有效减少磁盘IO次数；同时B+树增加了叶子结点间的连接，能保证范围查询时找到起点和终点后快速取出需要的数据</p>
<hr>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230330220200112.png" alt="image-20230330220200112" style="zoom: 25%;">

<ol>
<li>每个节点都是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从任意一个节点到其子树中每个叶子节点的路径上包含相同数量的黑色节点（称为黑色平衡或黑高度）</li>
</ol>
<p>红黑树插入删除：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/475836398">链接</a></p>
<hr>
<h5 id="各种连接"><a href="#各种连接" class="headerlink" title="各种连接"></a>各种连接</h5><p><strong>内连接：</strong>只连接匹配的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 &#x3D; B.c3;</p>
<p><strong>自然连接</strong>：是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p>
<p><strong>左外连接：</strong>包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）以及右边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A left join B on A.c3 &#x3D; B.c3;</p>
<p><strong>右外连接：</strong>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）以及左边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A right join B on A.c3 &#x3D; B.c3;</p>
<p><strong>全外连接：</strong>包含左、右两个表的全部行，不管在另一边的表中是否存在与它们匹配的行</p>
<p>select A.c1,B.c2 from A full join B on A.c3 &#x3D; B.c3;</p>
<p><strong>（theta）连接：</strong>使用等值以外的条件来匹配左、右两个表中的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 !&#x3D; B.c3;</p>
<p><strong>交叉连接：</strong>生成笛卡尔积——它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行一一匹配</p>
<p>select A.c1,B.c2 from A,B;</p>
<hr>
<h5 id="数据库连接池优点"><a href="#数据库连接池优点" class="headerlink" title="数据库连接池优点"></a>数据库连接池优点</h5><p><strong>①资源重用</strong></p>
<p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。</p>
<p><strong>②更快的系统响应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p>
<p><strong>③强制收回被占用的连接，避免数据库连接泄露</strong></p>
<hr>
<h5 id="MySQL的慢查询优化有了解吗？"><a href="#MySQL的慢查询优化有了解吗？" class="headerlink" title="MySQL的慢查询优化有了解吗？"></a>MySQL的慢查询优化有了解吗？</h5><p>优化MySQL的慢查询，可以按照如下步骤进行：</p>
<p><strong>开启慢查询日志：</strong>在MySQL服务启动的时候使用<code>--log-slow-queries[=file_name]</code>启动慢查询日志。</p>
<p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p>
<p><strong>分析慢查询日志：</strong></p>
<p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p>
<p><strong>常见慢查询优化：</strong></p>
<ol>
<li><p>索引没起作用的情况</p>
<ul>
<li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</li>
<li>复合索引要注意最左匹配原则</li>
<li>若查询语句的查询条件中只有OR关键字，则当OR前后的两个条件中的列都是索引时，查询中才使用索引</li>
</ul>
</li>
<li><p>优化数据库结构</p>
<ul>
<li>对于列比较多的表，如果有些列的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</li>
</ul>
</li>
<li><p>优化LIMIT分页</p>
<p>当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p>
<p>用 between 优化 SELECT * FROM t_topic WHERE id BETWEEN 10000 AND 10020;</p>
</li>
</ol>
<hr>
<h5 id="Redo-log-Undo-log和Binlog"><a href="#Redo-log-Undo-log和Binlog" class="headerlink" title="Redo log, Undo log和Binlog"></a>Redo log, Undo log和Binlog</h5><p>都是数据库中常见的日志文件，但是它们在功能和使用方面有一些区别。</p>
<ol>
<li>Redo Log（重做日志）：它用于记录在事务执行过程中所做的更改操作，以便在数据库崩溃或重新启动时能够恢复未完成的事务。Redo Log是在内存中记录的，当事务提交时，将其刷入磁盘</li>
<li>Undo Log（撤销日志）：它记录了在事务执行过程中所做的更改操作的相反操作，以便在回滚事务时可以撤销这些更改操作。与Redo Log不同，Undo Log是在磁盘上记录的</li>
<li>Binlog（二进制日志）：它记录了所有对数据库的更改操作，包括DDL和DML语句。Binlog是在磁盘上记录的，可以用于数据库的备份、复制和恢复等操作</li>
</ol>
<p>主要区别在于：</p>
<ul>
<li>Redo Log和Undo Log主要用于恢复未完成的事务和回滚事务，而Binlog主要用于备份、复制和恢复等操作。</li>
<li>Redo Log和Undo Log是在数据库的服务器端生成的，而Binlog可以在任何MySQL客户端上生成。</li>
</ul>
<hr>
<h3 id="4️⃣设计模式"><a href="#4️⃣设计模式" class="headerlink" title="4️⃣设计模式"></a>4️⃣设计模式</h3><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="六种关系"><a href="#六种关系" class="headerlink" title="六种关系"></a>六种关系</h5><p>依赖</p>
<p>依赖关系是在运行过程中起作用的，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom: 67%;">

<p>关联</p>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定；体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。一般是长期性的，而且双方的关系一般是平等的</p>
<ul>
<li>类B以类属性的形式出现在关联类A中</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png" alt="在这里插入图片描述"></p>
<p>聚合</p>
<p>但是公司和员工就属于聚合关系了，因为公司没了员工还在</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>组合</p>
<p>组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="img" style="zoom:67%;">



<p>继承（extend）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>实现（implement）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">

<hr>
<h5 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png" alt="image-20230129223341112"></p>
<hr>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>懒汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> mutex;<span class="comment">//mutex mlock; 加锁互斥</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//mlock.lock();</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) instance = <span class="keyword">new</span> <span class="built_in">singleInstance</span>();</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//mlock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;; <span class="comment">// 它拥有一个私有构造函数，这确保用户无法通过new直接实例它</span></span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    <span class="type">static</span> singleInstance* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleInstance* singleInstance::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回静态成员变量 </span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123; <span class="comment">// 饿汉式，直接创建一个对象，不需要加锁</span></span><br><span class="line">        <span class="type">static</span> singleInstance instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回</span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="单例模式多线程"><a href="#单例模式多线程" class="headerlink" title="单例模式多线程"></a>单例模式多线程</h6><ul>
<li>解决方法加mutex</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221143214363.png" alt="image-20230221143214363"></p>
<hr>
<h5 id="请说说工厂设计模式"><a href="#请说说工厂设计模式" class="headerlink" title="请说说工厂设计模式"></a>请说说工厂设计模式</h5><p> 工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong></p>
<h6 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h6><p>  它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png" alt="img" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象,降低了耦合性</p>
<p><strong>缺点：</strong>就是要增加新的核类型时，就需要修改工厂类。这就违反了开闭原则</p>
<h6 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h6><p>  所谓工厂方法模式, 是指定义一个用于创建对象的接口, 让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png" alt="img" style="zoom: 33%;">

<p>  <strong>举例：</strong>这家生产处理器核的产家决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。  </p>
<p><strong>缺点：</strong>每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义</p>
<h6 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h6><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png" alt="image-20221116164855060" style="zoom:50%;">

<p><strong>举例：</strong>这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h6 id="⭐️三种工厂模式的区别"><a href="#⭐️三种工厂模式的区别" class="headerlink" title="⭐️三种工厂模式的区别"></a>⭐️三种工厂模式的区别</h6><p>简单工厂 ：用来生产同一产品族中的任意产品(对于增加新的产品，无能为力)</p>
<p>工厂方法 ：用来生产同一产品族中的固定产品(支持增加任意产品)</p>
<p>抽象工厂 ：按产品族抽象，这方便增加某个产品族内的具体产品；按具体产品抽象，这方便增加产品族；</p>
<hr>
<hr>
<hr>
<h3 id="5️⃣项目相关"><a href="#5️⃣项目相关" class="headerlink" title="5️⃣项目相关"></a>5️⃣项目相关</h3><h4 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h4><h5 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h5><p>此项目是基于Linux的轻量级多线程Web服务器，应用层实现了一个简单的HTTP服务器，利用多路IO复用，可以同时监听多个请求，使用线程池处理请求，使用模拟proactor模式，主线程负责监听，监听有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在请求队列上的工作线程被唤醒进行处理，使用状态机解析HTTP请求报文，将响应报文和资源文件写回通信的socket，并对系统进行了压力测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数   process() = process_read() + process_write()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，需要继续读取客户数据</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="定时器处理非活跃连接"><a href="#定时器处理非活跃连接" class="headerlink" title="定时器处理非活跃连接"></a>定时器处理非活跃连接</h6><p>设置SIGALRM信号处理函数, 设置一个定时器, 到期处理函数就往pipefd[1]里面写, epoll_wait就会由于pipefd[0]可以读而触发, 再设置timeout为true, 调用tick()函数删除非活跃连接, 然后再设置一个定时器. 以此重复. </p>
<hr>
<h6 id="主从状态机"><a href="#主从状态机" class="headerlink" title="主从状态机"></a>主从状态机</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227144327617.png" alt="image-20230227144327617"></p>
<p>主状态机：三种状态，标识解析位置</p>
<p>CHECK_STATE_REQUESTLINE，解析请求行</p>
<p>CHECK_STATE_HEADER，解析请求头</p>
<p>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</p>
<p>从状态机：三种状态，标识解析一行的读取状态</p>
<p>LINE_OK，完整读取一行</p>
<p>LINE_BAD，报文语法有误</p>
<p>LINE_OPEN，读取的行不完整</p>
<p>服务器处理HTTP请求的可能结果，报文解析的结果</p>
<p>NO_REQUEST          :   请求不完整，需要继续读取客户数据</p>
<p>GET_REQUEST         :   表示获得了一个完整的客户请求</p>
<p>BAD_REQUEST         :   表示客户请求语法错误</p>
<p>NO_RESOURCE         :   表示服务器没有资源</p>
<p>FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</p>
<p>FILE_REQUEST        :   文件请求,获取文件成功</p>
<p>INTERNAL_ERROR      :   表示服务器内部错误</p>
<p>CLOSED_CONNECTION   :   表示客户端已经关闭连接了</p>
<hr>
<h6 id="子线程如何提醒主线程"><a href="#子线程如何提醒主线程" class="headerlink" title="子线程如何提醒主线程"></a>子线程如何提醒主线程</h6><p>子线程调用<code>http_conn::process()</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向epoll中添加需要监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot )</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot) event.events |= EPOLLONESHOT; <span class="comment">// 防止同一个通信被不同的线程处理</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd); <span class="comment">// 设置文件描述符非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从epoll中移除监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，修改通信m_sockfd上event.events = EPOLLIN，让主线程继续读取客户数据 	那边wait到了就开始读</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);  <span class="comment">// 响应完，注册写事件，让主线程写入通信socket   那边wait到了就开始写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="服务器是怎么把静态资源传回客户端的"><a href="#服务器是怎么把静态资源传回客户端的" class="headerlink" title="服务器是怎么把静态资源传回客户端的"></a>服务器是怎么把静态资源传回客户端的</h6><p>首先客户端请求里有一个url，服务器端在解析请求首行的时候已经把他存在一个字符串m_url里了。然后我们要把存在服务器相应的资源目录地址拼接上m_url，判断有没有该文件以及该文件的访问权限。如果目标文件存在、对所有用户可读，且不是目录。则使用mmap将其映射到内存地址m_file_address处，并告诉调用者获取文件成功</p>
<p>最后由主线程执行write方法，将其传输给本次连接的socket</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write方法里 分散写，共有两块内存要写出去 m_write_buf 、 m_file_address</span></span><br><span class="line">temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, temp; <span class="comment">// rdset是用户自己维护的, temp是交给内核去修改的</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset); <span class="comment">//初始化，全置0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset); <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = rdset;</span><br><span class="line">        <span class="comment">// 调用select，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;temp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">// 这里我们设置的timeval为NULL，所以是阻塞型，ret不可能返回0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;temp))&#123;</span><br><span class="line">                <span class="comment">// 判断fd对应的标志位是0还是1 , 为1代表有新的客户端连接进来了</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到set中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i ++)&#123; <span class="comment">// lfd最先被监听，肯定在最前面</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;temp))&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h6><ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了默认是1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<hr>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">//需要检测读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>; <span class="comment">// 这里就是最大索引，而不是最大索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用 poll，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123; <span class="comment">// 有新客户端连接进来了，因为revents 返回的是 POLLIN ｜ POLLOUT</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将cfd加入到监听数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i ++)&#123; <span class="comment">// 0是lfd</span></span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)&#123; <span class="comment">// fds[i]可用</span></span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i ++)&#123; <span class="comment">// lfd最先被监听，为0</span></span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h6><ol>
<li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
</li>
<li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
</li>
<li><p><del>select支持的文件描述符数量太小了默认是1024</del></p>
</li>
<li><p><del>fds集合不能重用，每次都需要重置</del></p>
</li>
</ol>
<hr>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><h6 id="说说-epoll-的原理"><a href="#说说-epoll-的原理" class="headerlink" title="说说 epoll 的原理"></a>说说 epoll 的原理</h6><p>wait检测，有EPOLLIN就读，有EPOLLOUT就回</p>
<p>执行epoll_create会在内核中维护一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点</p>
<p>在执行epoll_ctl的add操作时,不仅将文件描述符放到红黑树上,而且也注册了回调函数, 内核在检测到某文件描述符可读&#x2F;可写时会调用回调函数,该回调函数将文件描述符放在就绪链表中</p>
<p><strong>epoll_wait只用观察就绪链表中有无数据即可,最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中,所以只用遍历依次处理即可</strong></p>
<blockquote>
<p>  epoll采用回调机制。造成的结果就是,随着fd的增加,select和poll的效率会线性降低,而epoll不会受到太大影响,除非活跃的socket很多</p>
</blockquote>
<hr>
<h6 id="说说epoll流程"><a href="#说说epoll流程" class="headerlink" title="说说epoll流程"></a>说说epoll流程</h6><ol>
<li>创建一个<code>epoll</code>对象，通过调用<code>epoll_create</code>函数来创建一个<code>epoll</code>实例。它会返回一个文件描述符，用于后续对<code>epoll</code>的操作</li>
<li>将需要监控的文件描述符添加到<code>epoll</code>对象中，通过调用<code>epoll_ctl</code>函数来添加和删除需要监听的文件描述符，可以通过传递参数<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_DEL</code>和<code>EPOLL_CTL_MOD</code>来进行添加、删除和修改操作</li>
<li>等待事件的发生，通过调用<code>epoll_wait</code>函数来等待<code>epoll</code>对象中的事件。该函数将会一直阻塞，直到有一个或多个文件描述符发生了指定的事件或者超时</li>
<li>处理事件，当<code>epoll_wait</code>函数返回后，可以遍历返回的<code>epoll_event</code>数组来处理所有的事件。<code>epoll_event</code>结构体中包含发生事件的文件描述符和事件类型</li>
<li>回到步骤3，等待下一个事件的发生</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//（2）将监听的文件描述符相关的检测信息加入到epoll实例中</span></span><br><span class="line">    epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN; </span><br><span class="line">    epev.data.fd = lfd; </span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line">    </span><br><span class="line">    epoll_event epevs[<span class="number">1024</span>]; <span class="comment">// 内核检测后会将已就绪的文件描述符放在这里面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>); <span class="comment">//（3）-1设置阻塞。只有设置了阻塞时，会返回0，代表超时了都没有检测到变化的文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(epevs[i].data.fd == lfd) &#123; <span class="comment">// 监听到了客户端的连接</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); <span class="comment">// 添加到epoll实例中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// epevs[i].data.fd == cfd  有数据到达，通信</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(epevs[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// （4）将此fd从红黑树中删除</span></span><br><span class="line">                    <span class="built_in">close</span>(epevs[i].data.fd); <span class="comment">// close(cfd)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">write</span>(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);<span class="comment">// （5）关闭epoll实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="epoll事件类型"><a href="#epoll事件类型" class="headerlink" title="epoll事件类型"></a>epoll事件类型</h6><p>epoll是一种高效的I&#x2F;O多路复用机制，在Linux系统上被广泛应用。它可以同时处理大量的socket连接，并且可以有效地减少系统开销。在epoll中，有四种不同的事件类型：</p>
<ol>
<li>EPOLLIN：读事件就绪。当socket接收到数据，就会触发这种事件。</li>
<li>EPOLLOUT：写事件就绪。当socket可以发送数据，就会触发这种事件。</li>
<li>EPOLLERR：错误事件。当socket出现错误，就会触发这种事件。</li>
<li>EPOLLHUP：挂起事件。当socket被挂起，就会触发这种事件。</li>
</ol>
<p>在epoll中，有两种就绪状态：读就绪和写就绪。当一个socket可以读取数据时，就会触发读就绪事件。而当一个socket可以发送数据时，就会触发写就绪事件</p>
<p>在epoll中，写完成事件指的是数据已经被完全写入socket缓冲区的事件，而写就绪事件指的是socket缓冲区中有足够的空间可以继续写入数据的事件。类似地，读完成事件指的是数据已经被完全读取的事件，而读就绪事件指的是socket缓冲区中有足够的数据可以读取的事件</p>
<hr>
<h6 id="epoll写就绪事件和写完成事件"><a href="#epoll写就绪事件和写完成事件" class="headerlink" title="epoll写就绪事件和写完成事件"></a>epoll写就绪事件和写完成事件</h6><p><code>epoll</code>中的写就绪事件是指一个文件描述符上的输出缓冲区可用空间已经超过一定阈值，<strong>此时可以向该文件描述符进行写操作（就是用该fd写出去）</strong>。在默认的水平触发模式下，只要输出缓冲区还有空闲空间，就会一直触发写就绪事件。而在边缘触发模式下，只有在输出缓冲区从空变为非空时才会触发写就绪事件。</p>
<p>在<code>epoll</code>中，写就绪事件可以通过监听<code>EPOLLOUT</code>事件来实现。当一个文件描述符的输出缓冲区可用空间大于一定阈值时，<code>epoll</code>会将该文件描述符上的<code>EPOLLOUT</code>事件加入到事件集合中，通知应用程序该文件描述符可以进行写操作了</p>
<p>在<code>epoll</code>中，写完成事件指的是一个文件描述符上的所有数据已经写入完毕，此时可以关闭该文件描述符或者等待更多的写操作。在默认的LT模式下，只要输出缓冲区还有空闲空间，就会一直触发写就绪事件，不管数据是否已经全部写入完毕。而在边缘触发模式下，只有当输出缓冲区从非空变为空时才会触发写完成事件。</p>
<p><code>epoll</code>中的写完成事件无法直接注册，需要通过一些技巧来实现。一种常用的方法是在注册<code>EPOLLOUT</code>事件时，将文件描述符关联一个状态标志，当输出缓冲区变为空时，将该状态标志设置为“写完成”，在处理<code>EPOLLOUT</code>事件时，检查该状态标志，如果为“写完成”，则认为所有数据已经写入完毕，可以进行相应的处理</p>
<hr>
<h6 id="epoll水平触发与边缘触发的区别"><a href="#epoll水平触发与边缘触发的区别" class="headerlink" title="epoll水平触发与边缘触发的区别"></a>epoll水平触发与边缘触发的区别</h6><p>LT模式（水平触发）: 同时支持 Block (读写操作完才返回)和 Nonblock Socket (读写不等待完毕就返回); 只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。LT模式通常需要使用阻塞I&#x2F;O，以确保程序能够正确处理事件。</p>
<p>而在ET（边缘触发）: 支持 Nonblock socket, 它只会提示一次,  直到下次再有数据流入之前都不会再提示了, 无论fd中是否还有数据可读。如果程序没有及时处理事件，事件会被丢失。ET模式通常需要使用非阻塞I&#x2F;O，以确保程序能够及时响应事件。</p>
<p><strong>场景上来说</strong>：</p>
<p>ET模式适用于需要高并发、高吞吐量的场景，例如网络编程中的服务器端。服务器需要及时响应大量的客户端请求，并发地处理多个请求。ET模式可以确保服务器能够及时响应客户端请求，并发地处理多个请求。</p>
<p>LT模式适用于需要保证数据的完整性和可靠性的场景，例如数据库、事务处理等。LT模式可以确保程序能够正确处理所有的事件，并保证数据的完整性和可靠性。</p>
<hr>
<h6 id="epoll是同步的还是异步的"><a href="#epoll是同步的还是异步的" class="headerlink" title="epoll是同步的还是异步的"></a>epoll是同步的还是异步的</h6><p>epoll既可以是同步的，也可以是异步的，这取决于它的使用方式。</p>
<p>在epoll的LT（Level Triggered）模式下，epoll_wait函数是同步的。这意味着当调用epoll_wait函数时，程序会一直等待，直到有事件发生，然后返回就绪的事件集合。</p>
<p>而在epoll的ET（Edge Triggered）模式下，epoll_wait函数是异步的。这意味着当调用epoll_wait函数时，如果有事件已经就绪，它会立即返回就绪的事件集合，如果没有就绪的事件，它会立即返回空集合，而不会阻塞等待事件的发生。</p>
<hr>
<h6 id="EPOLLONESHOT事件-保证线程安全"><a href="#EPOLLONESHOT事件-保证线程安全" class="headerlink" title="EPOLLONESHOT事件(保证线程安全)"></a>EPOLLONESHOT事件(保证线程安全)</h6><p>即使<strong>可以使用 ET 模式</strong>，一个socket 上的某个事件还是可能被触发多次。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，对此我们可以使用 epoll 的 EPOLLONESHOT 事件实现</p>
<p>对于注册了 EPOLLONESHOT 事件的文件描述符，<strong>操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次</strong>，<strong>除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件</strong>。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， <strong>该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发</strong>，进而让其他工作线程有机会继续处理这个 socket</p>
<hr>
<h5 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h5><p>IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
<p>无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png" alt="image-20221120132728012"></p>
<hr>
<h5 id="说说Reactor、Proactor模式"><a href="#说说Reactor、Proactor模式" class="headerlink" title="说说Reactor、Proactor模式"></a>说说Reactor、Proactor模式</h5><h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列(线程池)</strong></li>
<li>线程池中的某个线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入线程池</li>
<li>线程池上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png" alt="image-20221120194303146"></p>
<h6 id="同步IO的模拟Proactor"><a href="#同步IO的模拟Proactor" class="headerlink" title="同步IO的模拟Proactor"></a>同步IO的模拟Proactor</h6><p>使用同步I&#x2F;O方式模拟出Proactor模式。原理是:主线程执行数据读写操作,读写**(就是将socket上的数据(客户端传的http报文)读取至http类对象维护的读写缓冲区)**完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理</p>
<p>使用同步I&#x2F;O模型(以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait 等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理完客户请求，然后往epoll内核事件表中注册socket上的写完成事件</li>
<li>因为主线程调用epoll_wait 等待socket可写, 所以当socket可写时, epoll_wait 通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120203431492.png" alt="image-20221120203431492" style="zoom:50%;">



<hr>
<h5 id="将文件描述符设置为非阻塞有什么用"><a href="#将文件描述符设置为非阻塞有什么用" class="headerlink" title="将文件描述符设置为非阻塞有什么用"></a>将文件描述符设置为非阻塞有什么用</h5><p>将文件描述符设置为非阻塞可以使文件 I&#x2F;O 操作变得更加灵活和高效。</p>
<p>当文件描述符被设置为阻塞时，当进行 I&#x2F;O 操作时，程序会一直等待直到操作完成，如果操作需要花费很长时间（如从网络中读取大量数据），程序就会在等待操作完成时阻塞。这样可能会导致程序在等待 I&#x2F;O 操作完成时无法执行其他任务，从而影响整个程序的性能和响应能力。</p>
<p>相比之下，当文件描述符被设置为非阻塞时，I&#x2F;O 操作不会阻塞程序的执行。如果 I&#x2F;O 操作需要花费很长时间，程序可以继续执行其他任务。此外，当进行非阻塞 I&#x2F;O 操作时，如果数据还没有准备好或者无法立即写入，I&#x2F;O 操作将会立即返回并返回一个错误码（如 EAGAIN 或 EWOULDBLOCK），程序可以在稍后再次尝试 I&#x2F;O 操作，从而避免了长时间的等待阻塞。这种方法可以使程序更加高效和响应快速。</p>
<hr>
<h5 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h5><h6 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h6><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h6 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h6><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h6><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h6 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h6><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h6 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h6><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h6 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<hr>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>该项目使用线程池（同步模拟Proactor）并发处理用户请求，<strong>主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number; <span class="comment">// 线程的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> * m_threads; <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_max_requests; <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    </span><br><span class="line">    std::list&lt; T* &gt; m_workqueue; <span class="comment">// 请求队列 按理说应当叫 m_requestqueue</span></span><br><span class="line"></span><br><span class="line">    locker m_queuelocker; <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line"></span><br><span class="line">    sem m_queuestat; <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">bool</span> m_stop; <span class="comment">// 是否结束线程                     </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : </span><br><span class="line">        <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), </span><br><span class="line">        <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_detach</span>( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt; T &gt;::<span class="built_in">append</span>( T* request )&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt; T &gt;::<span class="built_in">worker</span>( <span class="type">void</span>* arg )&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt; T &gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) <span class="keyword">continue</span>;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h6 id="如何确定线程数量"><a href="#如何确定线程数量" class="headerlink" title="如何确定线程数量"></a>如何确定线程数量</h6><p>线程数量的确定需要考虑多种因素，如处理器核心数、内存大小、任务类型、线程间的依赖关系等。</p>
<ol>
<li>处理器核心数：线程数不宜超过处理器核心数，因为超过这个数量后，线程之间可能会竞争处理器资源，导致性能下降。</li>
<li>内存大小：每个线程需要占用一定的内存，因此线程数不能过多，否则会导致内存不足。</li>
<li>任务类型：如果任务是I&#x2F;O密集型的，例如网络通信或者文件读写等，线程数可以比较多，因为线程会在I&#x2F;O操作中阻塞，不会占用过多的处理器资源。而如果是CPU密集型的任务，例如图像处理或者计算密集型算法等，则线程数需要适当减少，避免CPU资源竞争。</li>
<li>线程间的依赖关系：如果任务中的线程之间存在依赖关系，需要根据依赖关系来确定线程数，避免出现死锁等问题。</li>
</ol>
<h6 id="线程数量与CPU核心数的关系"><a href="#线程数量与CPU核心数的关系" class="headerlink" title="线程数量与CPU核心数的关系"></a>线程数量与CPU核心数的关系</h6><p>如果任务是CPU密集型的，那么线程数不应该超过CPU核心数，因为过多的线程会导致线程之间的上下文切换，从而浪费CPU时间。此时，线程数可以根据CPU核心数进行适当调整，以充分利用CPU资源。</p>
<p>如果任务是I&#x2F;O密集型的，那么线程数可以适当增加，以充分利用CPU资源。此时，线程数可以根据CPU核心数和系统负载情况进行适当调整，以提高并发处理能力</p>
<h6 id="线程池中的工作线程是一直等待吗？"><a href="#线程池中的工作线程是一直等待吗？" class="headerlink" title="线程池中的工作线程是一直等待吗？"></a>线程池中的工作线程是一直等待吗？</h6><p>在run函数中，我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的 </p>
<h6 id="线程池工作线程处理完一个任务后的状态是什么？"><a href="#线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="线程池工作线程处理完一个任务后的状态是什么？"></a>线程池工作线程处理完一个任务后的状态是什么？</h6><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p>
<p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格</p>
<h6 id="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h6><p>本项目是通过对子线程循环调用来解决高并发的问题的</p>
<hr>
<h5 id="Nginx的负载均衡"><a href="#Nginx的负载均衡" class="headerlink" title="Nginx的负载均衡"></a>Nginx的负载均衡</h5><p>模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方的调度方法。</p>
<ul>
<li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响；</li>
<li>Weight：指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下；</li>
<li>ip_hash：每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题</li>
<li>fair：比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块</li>
<li>url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包</li>
</ul>
<p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p>
<ul>
<li>down：表示当前的server暂时不参与负载均衡；</li>
<li>backup：预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻；</li>
<li>max_fails：允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误；</li>
<li>fail_timeout：在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<hr>
<h5 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h5><p><code>upstream</code> 说白了就是做负载均衡，它可以帮助我们定义一组相同服务的别名，如<code>backend</code>，当请求到来的时候可以通过相关策略帮我们选一组服务提供响应。</p>
<p>目前只能被 <code>proxy_pass</code>，<code>fastcgi_pass</code>，<code>uwsgi_pass</code>，<code>scgi_pass</code>，<code>memcached_pass</code>，<code>grpc_pass</code> 使用。</p>
<hr>
<h5 id="读多写少的优化"><a href="#读多写少的优化" class="headerlink" title="读多写少的优化"></a>读多写少的优化</h5><ul>
<li><p>加读写锁</p>
<p>但是，只要加了锁，就会带来竞争，即使加的是读写锁，虽然读之间不互斥，但写一样会影响读，而且读写同时争夺锁的时候，锁优先分配给写。</p>
<p>例如，写的时候，要求所有的读请求阻塞住，等到写线程或协程释放锁之后才能读。如果写的临界区耗时比较大，则所有的读请求都会受影响，所有的读请求都在队列中等待处理，如果在下个更新周期来之前，服务能处理完这些读请求，可能情况没那么糟糕。但极端情况下，如果下个更新周期来了，读请求还没处理完，就会形成一个恶性循环，不断的有读请求在队列中等待，最终导致队列被挤满，服务出现假死，情况再恶劣一点的话，上游服务发现某个节点假死后，由于负载均衡策略，一般会重试请求其他节点，这时候其他节点的压力跟着增加了，最终导致整个系统出现雪崩。<br>因此，加锁在高并发场景下要尽量避免，如果避免不了，需要让锁的粒度尽量小，接近无锁（lock-free）更好，简单的对一大片临界区加锁，在高并发场景下不是一种合适的解决方案</p>
</li>
<li><p>双缓冲</p>
</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221161535855.png" alt="image-20230221161535855"></p>
<hr>
<h5 id="GDB-常见的调试命令"><a href="#GDB-常见的调试命令" class="headerlink" title="GDB 常见的调试命令"></a>GDB 常见的调试命令</h5><h6 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h6><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h6 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h6><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h6 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h6><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	每次调试时如果a, b值发生变化的话, 自动打印</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<hr>
<h5 id="提高WebServer的性能"><a href="#提高WebServer的性能" class="headerlink" title="提高WebServer的性能"></a>提高WebServer的性能</h5><ol>
<li>加机器</li>
<li>提升机器性能(内存, CPU)</li>
<li>拓展线程池的大小</li>
</ol>
<hr>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>假如我们刚刚上线一个网站，最多只有 10 个人同时访问，那么只需要把网站放到一台服务器上就够了，又叫 <strong>单机部署</strong> </p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131733787.png" alt="image-20230221131733787" style="zoom:33%;">

<p>随着我们网站的不断宣传，可能出现上万用户同时访问的情况。由于一台服务器的 CPU、内存、带宽等资源都是有限的，无法同时支撑那么多用户。因此可能需要多台服务器一起来扛，分摊用户的请求，又叫 <strong>集群部署</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131811712.png" alt="image-20230221131811712" style="zoom: 33%;">

<p>但这样有个问题，每个服务器都有一个不同的 IP 地址，想把用户的请求分摊到不同的服务器上，不能让用户自己去输入不同的 IP 访问。</p>
<p>因此，我们还需要一台 <strong>代理服务器</strong> ，对外提供 <strong>唯一</strong> 的入口，<strong>统一</strong> 接受用户的请求。再根据请求（或流量）的 <strong>特征</strong> ，依据一定的 <strong>算法</strong> ，将请求转发到内部的服务器集群中</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131913227.png" alt="image-20230221131913227" style="zoom:33%;">

<p>这样对于用户来说，始终通过一个域名访问网站即可，他完全感知不到你的网站到底部署到多少台服务器上、也不关心它是如何部署的。这便是 <strong>负载均衡</strong>（Load Balancing 简称 LB），是企业中最重要的高并发解决方案</p>
<p><strong>优点：</strong></p>
<p>提高整个系统的可用性，假如集群中有一台服务器挂了，代理服务器只要不再把请求转发给它就行了，集群中的其他服务器仍然能够正常地接受和处理请求</p>
<p>此外，负载均衡还能够减少用户等待响应的时间、通过并行提高整个系统的处理能力等</p>
<hr>
<h6 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h6><p>虽然通过代理服务器转发请求能够提升整个系统的并发访问数，但不要忘了，代理服务器本身的资源也是有限的啊！像比较常用的 Nginx 代理，能有个几万并发就撑死了。如果同时访问的用户量再大一点，不就忍不下了么？</p>
<p>而且代理服务器也存在挂掉的可能性，一旦它挂了，后果不堪设想。因此，我们可以将负载均衡进行分类，针对不同的场景来选择相对合适的实现方式。比较常见的分类方法是：根据 <strong>计算机网络七层模型</strong> ，按照负载均衡所属的网络层次去区分</p>
<ol>
<li><p><strong>二层负载均衡</strong>：二层指数据链路层，数据以数据帧的形式通过交换机进行传输。</p>
<p>这一层是没有 IP 地址概念的，只能用 MAC 地址对机器进行区分。因此负载均衡服务器会通过一个虚拟 MAC 地址接受请求，并通过改写报文目标 MAC 地址的方式将请求转发到具有不同 MAC 地址的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221132718380.png" alt="image-20230221132718380" style="zoom:33%;">
</li>
<li><p><strong>三层负载均衡</strong>：三层即网络层，这一层开始有了 IP 地址的概念，可以根据 IP 地址路由网络。</p>
<p>这一层的负载均衡设备会对外提供一个虚拟的 IP 地址（VIP）以接收请求，然后根据算法将请求转发到 IP 地址不同的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133036044.png" alt="image-20230221133036044" style="zoom:33%;">
</li>
<li><p><strong>四层即传输层</strong>：除了包含三层的 IP 地址信息之外，还多了源目端口号的概念，可以区分同一机器上不同的应用。</p>
<p>由于得到了更多的信息，这一层的负载均衡会更加灵活，对外提供一个虚拟的 IP 地址 + 端口号来接收请求，然后根据算法将请求转发到不同目标机器的不同端口上</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133148277.png" alt="image-20230221133148277" style="zoom:33%;">
</li>
<li><p><strong>七层指应用层</strong>：是计算机网络模型的最上层，因此能得到请求最为详细的信息，比如 HTTP 请求头等。</p>
<p>可以根据域名或主机 IP + 端口接收请求，并通过应用层信息（请求头、Cookie 等）灵活地转发请求，比如将手机端用户转发到服务器 A、桌面端用户转发到服务器 B 等</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133313580.png" alt="image-20230221133313580" style="zoom:33%;"></li>
</ol>
<hr>
<h6 id="负载均衡算法：一致性哈希"><a href="#负载均衡算法：一致性哈希" class="headerlink" title="负载均衡算法：一致性哈希"></a>负载均衡算法：一致性哈希</h6><ul>
<li><p><strong>哈希算法</strong></p>
<p>以分布式缓存为例，假设现在有3台缓存服务器(S0，S1，S2)，要将一些图片尽可能平均地分配到不同的服务器上，hash算法的做法是：</p>
<p>(1) 以图片的名称作为key，然后对其做hash运算。</p>
<p>(2) 将hash值对服务器数量进行求余，得到服务器编号，最后存入即可。</p>
<p>如：a.jpg 需要存入， 我们就得到hash(a.jpg) &#x3D; 5 ——-&gt; 5%3 &#x3D; 2 得到数据存入S2   思考:</p>
<p>上述HASH算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法</p>
</li>
<li><p><strong>一致性哈希算法</strong></p>
<p>也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：</p>
<ol>
<li>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</li>
<li>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</li>
<li>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135029847.png" alt="image-20230221135029847" style="zoom:40%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135135171.png" alt="image-20230221135135171" style="zoom:40%;"></li>
</ul>
<p>优点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135313611.png" alt="image-20230221135313611" style="zoom:50%;">

<p>哈希环的倾斜与虚拟节点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135454172.png" alt="image-20230221135454172" style="zoom:50%;">

<hr>
<h5 id="性能测试-Webbench"><a href="#性能测试-Webbench" class="headerlink" title="性能测试 Webbench"></a>性能测试 Webbench</h5><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出</p>
<p><code>webbench -c 1000 -t 60 http://172.16.208.129:8000/index.html</code> </p>
<p>每秒500个并发测试60秒</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120441103.png" alt="image-20230331120441103" style="zoom:50%;">

<p>每秒5000个并发测试60秒</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120745467.png" alt="image-20230331120745467" style="zoom:50%;">

<p>每秒10000个并发测试60秒</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331121001560.png" alt="image-20230331121001560" style="zoom:50%;">

<p>每秒15000个并发测试60秒</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331121710266.png" alt="image-20230331121710266" style="zoom:50%;">

<p>nginx配置后(设置event数量为63335后全部成功)</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331141852209.png" alt="image-20230331141852209" style="zoom: 33%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331142913248.png" alt="image-20230331142913248" style="zoom:50%;">

<p>对于服务器我们需要测试两个指标</p>
<ul>
<li>同时连接服务器的数量</li>
<li>每秒的接入量</li>
</ul>
<hr>
<h5 id="什么是QPS和TPS-如何计算"><a href="#什么是QPS和TPS-如何计算" class="headerlink" title="什么是QPS和TPS, 如何计算"></a>什么是QPS和TPS, 如何计算</h5><p>QPS和TPS都是衡量系统性能的指标，它们分别代表<strong>每秒钟处理的请求数量</strong>和<strong>事务处理数量</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">QPS <span class="operator">=</span> 请求数 <span class="operator">/</span> 时间 # 在<span class="number">1</span>秒钟内处理了<span class="number">100</span>个请求，则QPS为<span class="number">100</span></span><br><span class="line">TPS <span class="operator">=</span> 事务数 <span class="operator">/</span> 时间 # 通常用于衡量事务性系统的处理能力，例如交易处理系统</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="访问服务端延迟高的原因"><a href="#访问服务端延迟高的原因" class="headerlink" title="访问服务端延迟高的原因"></a>访问服务端延迟高的原因</h5><ol>
<li>服务端应用压力太大，确实处理不过来了</li>
<li>请求的资源太大</li>
<li>线程池配置的不合理，线程数配置的太少导致的请求积压</li>
<li>客户端网络原因，丢包、带宽限制、重传等</li>
<li>节点距离：需要跳转的网络节点越多，呈现在现实就是网络访问速度会越慢</li>
</ol>
<hr>
<h5 id="如何定位服务器性能瓶颈"><a href="#如何定位服务器性能瓶颈" class="headerlink" title="如何定位服务器性能瓶颈"></a>如何定位服务器性能瓶颈</h5><p>如果出现比较多的响应时间过长，首先要排查所有服务器是否存在资源使用瓶颈，</p>
<p>查看系统参数：内存、cpu、文件描述符、磁盘io、看内核态和用户态占用的cpu比率、火焰图</p>
<p><strong>查看内存(top) + jstack</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">top <span class="comment">// 使用top指令找到CPU使用最高的进程</span></span><br><span class="line">top -Hp <span class="number">6962</span> <span class="comment">// 使用 top -Hp 进程Id ，找到使用率最高的线程</span></span><br><span class="line">printf <span class="string">&quot;%x\n&quot;</span> <span class="number">2846</span> <span class="comment">// 将这些线程id转换为16进制的，printf “%x\n” 线程Id</span></span><br><span class="line">jstack <span class="number">6962</span> | grep a33 -A <span class="number">100</span> <span class="comment">// 打印进程堆栈信息 （6962是进程id，a33是线程id的对应的16进制）</span></span><br><span class="line"><span class="comment">// 这样就能找到导致CPU使用率飙高的具体的代码了。</span></span><br></pre></td></tr></table></figure>



<p><strong>查看端口状态(netstat)</strong></p>
<p><strong>抓包(tcpdump)</strong></p>
<blockquote>
<p>  host 192.168.130.1表示一台主机.    没有指明数据类型，那么默认就是host</p>
<p>  net 192.168.130.0表示一个网络网段</p>
<p>  port 80 指明端口号为80</p>
</blockquote>
<p><code>tcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host ! www.baidu.com  </code></p>
<p><code>tcpdump udp port 53</code> 监听本机udp的53端口的数据包</p>
<p><code>tcpdump tcp port 22 and host 192.168.56.210</code> 捕获主机192.168.56.210接收和发出的tcp协议的数据包</p>
<hr>
<h5 id="防止恶意请求，服务器端可以采取措施"><a href="#防止恶意请求，服务器端可以采取措施" class="headerlink" title="防止恶意请求，服务器端可以采取措施"></a><strong>防止恶意请求，服务器端可以采取措施</strong></h5><ol>
<li>在服务器端对所有输入进行验证, 确保只有有效的请求才会被处理. 可以使用正则表达式或其他验证库来验证输入</li>
<li>可以限制单个IP地址或用户在特定时间内访问服务器的次数。这可以防止暴力攻击和DDoS攻击等。</li>
<li>可以在敏感操作前要求用户输入验证码，这可以防止自动化脚本或机器人攻击。</li>
<li>可以使用HTTPS协议进行通信，这可以防止网络窃听和中间人攻击等。</li>
<li>可以在服务器上安装防火墙，来过滤不受欢迎的网络流量，包括恶意请求。</li>
<li>可以实时监控服务器端的请求日志，这可以帮助发现潜在的恶意请求和攻击。</li>
</ol>
<hr>
<h5 id="如何限制单个IP地址在特定时间内访问服务器的次数"><a href="#如何限制单个IP地址在特定时间内访问服务器的次数" class="headerlink" title="如何限制单个IP地址在特定时间内访问服务器的次数"></a>如何限制单个IP地址在特定时间内访问服务器的次数</h5><ol>
<li>配置防火墙规则：大多数防火墙都允许您设置规则以限制特定IP地址或用户在特定时间内的访问次数。您可以配置规则，使它们在指定时间内仅允许有限数量的请求通过。这是一个基于网络层面的解决方案，可以防止任何类型的请求访问服务器。</li>
<li>使用限流器：限流器是一个应用层面的解决方案，可以限制单个IP地址或用户在特定时间内访问服务器的次数。您可以配置限流器以允许每个IP地址或用户在指定的时间段内仅能发送有限数量的请求。这可以确保您的服务器不会被恶意请求攻击。</li>
<li>使用反向代理服务器：如果您使用反向代理服务器，您可以在代理服务器上设置规则以限制特定IP地址或用户在特定时间内访问服务器的次数。反向代理服务器可以充当服务器和客户端之间的中介，允许您在代理服务器上执行任意数量的控制和限制。</li>
</ol>
<hr>
<h5 id="服务器端限流"><a href="#服务器端限流" class="headerlink" title="服务器端限流"></a>服务器端限流</h5><p>一种防止服务器过载的措施。通过限制每个客户端在一定时间内可以发送到服务器的请求数量，可以避免某些恶意用户或脚本通过高速请求导致服务器宕机或运行缓慢</p>
<p>以下是实施服务器端限流的一些方法：</p>
<ol>
<li>客户端IP地址限制：限制来自单个IP地址的请求数量，这可以防止单个客户端对服务器进行过度请求。</li>
<li>并发连接数限制：限制服务器能够同时处理的连接数量，这可以防止服务器过载。</li>
<li>请求速率限制：限制客户端在一定时间内可以发送的请求数量，这可以防止DDoS攻击和暴力破解等。</li>
<li>Token Bucket算法：Token Bucket算法是一种常见的限流算法。服务器为每个客户端分配一个令牌桶，每个令牌代表一个请求。客户端在发送请求之前必须从令牌桶中获取令牌。如果令牌桶为空，则请求被拒绝。</li>
<li>漏桶算法：漏桶算法是另一种常见的限流算法。服务器维护一个固定大小的漏桶，每个请求被视为一个水滴。当一个请求到达时，服务器将水滴放入漏桶中。如果漏桶已经满了，则请求被拒绝。</li>
</ol>
<hr>
<h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><h5 id="分布式架构中handler和sender"><a href="#分布式架构中handler和sender" class="headerlink" title="分布式架构中handler和sender"></a>分布式架构中handler和sender</h5><p>具体来说，如果一个节点需要向其他节点发送消息，那么它就扮演 sender 角色。这个节点需要负责将消息打包成特定格式，然后将消息发送到目标节点。sender 节点需要考虑到网络状况、消息是否发送成功等问题，以确保消息能够被可靠地发送到目标节点。</p>
<p>如果一个节点需要接收并处理其他节点发送过来的消息，那么它就扮演 handler 角色。这个节点需要负责解析消息并根据消息的内容进行相应的处理。消息的处理可能包括更新本地数据、调用本地服务、向其他节点发送消息等操作。在处理消息的过程中，handler 节点需要考虑到系统的可用性、容错性等问题，以确保系统能够正常工作并避免数据丢失或错误。</p>
<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>在同步模式下，当一个调用发出后，调用者必须等待被调用者的响应，才能进行下一步操作。也就是说，在同步模式下，调用者会一直等待被调用者完成某个操作并返回结果，才会继续进行自己的操作。</p>
<p>而在异步模式下，当一个调用发出后，调用者可以继续进行自己的操作，不必等待被调用者的响应。被调用者在完成操作后，通过回调函数或者其他机制通知调用者操作已经完成，并返回结果。</p>
<p>在同步模式下，调用者需要等待被调用者返回结果，会导致调用者阻塞，降低系统的并发性能。而在异步模式下，调用者不需要等待被调用者返回结果，可以继续进行自己的操作，提高了系统的并发性能。但是异步模式也会带来一些额外的复杂性，例如需要使用回调函数或者其他机制处理被调用者返回的结果，这需要额外的编程工作。</p>
<p>在实际应用中，需要根据具体的场景和需求选择合适的执行模式。例如，对于需要进行网络通信的应用，通常会采用异步模式来提高并发性能。而对于需要进行复杂计算或者需要保证数据一致性的应用，通常会采用同步模式来保证正确性和可靠性。</p>
<h5 id="为什么发送-rpc-接收-rpc-push-channel-receive-channel-的时候一定不要持锁"><a href="#为什么发送-rpc-接收-rpc-push-channel-receive-channel-的时候一定不要持锁" class="headerlink" title="为什么发送 rpc, 接收 rpc, push channel, receive channel 的时候一定不要持锁"></a>为什么发送 rpc, 接收 rpc, push channel, receive channel 的时候一定不要持锁</h5><p>死锁是指两个或多个进程被永久地阻塞，因为它们都在等待对方释放资源。在RPC和通道通信中，死锁通常发生在以下情况下：</p>
<ol>
<li>发送RPC或push channel时持有锁：如果发送方在发送RPC或push channel之前持有锁，则在接收方没有准备好接收时，它将无法释放锁并阻塞，这可能导致死锁。</li>
<li>接收RPC或pop channel时持有锁：如果接收方在接收RPC或pop channel之前持有锁，则发送方无法在接收方已准备好接收之前释放锁，这也可能导致死锁。</li>
</ol>
<p>因此，为避免死锁，应该尽量避免在发送RPC、push channel、接收RPC、pop channel时持有锁。相反，应该使用异步或非阻塞的方法来发送和接收信息。如果必须使用锁，则应确保在发送和接收信息之前释放锁，以便其他进程可以访问共享资源。</p>
<h5 id="Raft节点设计和Make"><a href="#Raft节点设计和Make" class="headerlink" title="Raft节点设计和Make()"></a>Raft节点设计和Make()</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.RWMutex        <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	applyCh        <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	applyCond      *sync.Cond   <span class="comment">// used to wakeup applier goroutine after committing new entries</span></span><br><span class="line">	replicatorCond []*sync.Cond <span class="comment">// used to signal replicator goroutine to batch replicating entries</span></span><br><span class="line">	state          NodeState</span><br><span class="line"></span><br><span class="line">	currentTerm <span class="type">int</span></span><br><span class="line">	votedFor    <span class="type">int</span></span><br><span class="line">	logs        []Entry <span class="comment">// the first entry is a dummy entry which contains LastSnapshotTerm, LastSnapshotIndex and nil Command</span></span><br><span class="line"></span><br><span class="line">	commitIndex <span class="type">int</span></span><br><span class="line">	lastApplied <span class="type">int</span></span><br><span class="line">	nextIndex   []<span class="type">int</span></span><br><span class="line">	matchIndex  []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	electionTimer  *time.Timer</span><br><span class="line">	heartbeatTimer *time.Timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Make()：</p>
<ol>
<li><p>初始化</p>
</li>
<li><p>读取崩溃前的状态</p>
</li>
<li><p>replicator线程：共len(peer)-1个，分别管理对应peer的复制状态</p>
</li>
<li><p>ticker线程：触发 heartbeat timeout 和 election timeout</p>
</li>
<li><p>applier线程：向 applyCh 中 push 提交的日志并保证 exactly once</p>
</li>
</ol>
<h5 id="选leader"><a href="#选leader" class="headerlink" title="选leader"></a>选leader</h5><p>Candidate向其余节点发Request，其余节点handle该Request</p>
<h6 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(request *RequestVoteRequest, response *RequestVoteResponse) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">defer</span> rf.persist()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> request.Term &lt; rf.currentTerm || (request.Term == rf.currentTerm &amp;&amp; rf.votedFor != <span class="number">-1</span> &amp;&amp; rf.votedFor != request.CandidateId) &#123;</span><br><span class="line">		response.Term, response.VoteGranted = rf.currentTerm, <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> request.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.ChangeState(StateFollower)</span><br><span class="line">		rf.currentTerm, rf.votedFor = request.Term, <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !rf.isLogUpToDate(request.LastLogTerm, request.LastLogIndex) &#123;</span><br><span class="line">		response.Term, response.VoteGranted = rf.currentTerm, <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rf.votedFor = request.CandidateId</span><br><span class="line">	rf.electionTimer.Reset(RandomizedElectionTimeout())</span><br><span class="line">	response.Term, response.VoteGranted = rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker() &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.electionTimer.C: <span class="comment">// 改变状态为Candidate, rf.StartElection()</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.heartbeatTimer.C: <span class="comment">// rf.BroadcastHeartbeat(true)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Candidate 节点 StartElection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartElection() &#123;</span><br><span class="line">	request := rf.genRequestVoteRequest()</span><br><span class="line">	grantedVotes := <span class="number">1</span></span><br><span class="line">	rf.votedFor = rf.me</span><br><span class="line">	rf.persist() </span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 如果其他节点投票给了该 Candidate 节点，将 grantedVotes 的值 + 1。</span></span><br><span class="line">            <span class="comment">// 当 grantedVotes 的值大于等于半数节点时，该 Candidate 节点将成为新的 Leader，</span></span><br><span class="line">            <span class="comment">// 并向其他节点发送心跳消息，以确保它们都能知道自己的身份，并开始复制日志</span></span><br><span class="line">			response := <span class="built_in">new</span>(RequestVoteResponse)</span><br><span class="line">			<span class="keyword">if</span> rf.sendRequestVote(peer, request, response) &#123;</span><br><span class="line">				rf.mu.Lock()</span><br><span class="line">				<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">				<span class="keyword">if</span> rf.currentTerm == request.Term &amp;&amp; rf.state == StateCandidate &#123;</span><br><span class="line">					<span class="keyword">if</span> response.VoteGranted &#123;</span><br><span class="line">						grantedVotes += <span class="number">1</span></span><br><span class="line">						<span class="keyword">if</span> grantedVotes &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">							rf.ChangeState(StateLeader)</span><br><span class="line">							rf.BroadcastHeartbeat(<span class="literal">true</span>)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> response.Term &gt; rf.currentTerm &#123;</span><br><span class="line">						rf.ChangeState(StateFollower)</span><br><span class="line">						rf.currentTerm, rf.votedFor = response.Term, <span class="number">-1</span></span><br><span class="line">						rf.persist()</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>投票统计: 为了raft 结构体更干净,我在函数内定义一个变量并利用 go 的闭包来实现, 也可以在结构体中维护一个 votes 变量来实现</p>
</li>
<li><p>抛弃过期请求的回复：对于过期请求的回复，直接抛弃就行</p>
</li>
</ul>
<h5 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h5><p>leader节点send follower节点handle</p>
<p>Follower或者 leader节点 一旦有 advanceCommitIndexForFollower或 advanceCommitIndexForLeader，就触发 applyCond 条件变量的 Signal 方法；applier() 接收到这一信号，将需要应用的指令发送到 applyCh 通道中</p>
<p>applyCh是一个通道，负责将已提交的日志条目应用到节点状态机中。当节点收到一个已提交的日志条目时，它会将该日志条目中的命令发送到applyCh通道中。节点的状态机会从applyCh通道中读取已提交的命令，并执行该命令来改变自己的状态。</p>
<p>因此，applyCh的作用是将已提交的日志条目中的命令应用到节点状态机中，确保所有节点的状态机都执行相同的命令序列，从而保证整个集群的一致性。</p>
<blockquote>
<p>  对于异步 apply，其触发方式无非两种，leader 提交了新的日志或者 follower 通过 leader 发来的 leaderCommit 来更新 commitIndex。很多人实现的时候可能顺手就在这两处异步开启一个协程把 [lastApplied + 1, commitIndex] 的 entry push 到 applyCh 中，但其实这样子是可能重复发送 entry 的，原因是 push applyCh 的过程不能够持锁，那么这个 lastApplied 在没有 push 完之前就无法得到更新，从而可能被多次调用。</p>
<p>  考虑到异步 apply 时最耗时的步骤是 apply channel 和 apply 日志到状态机，其他的都不怎么耗费时间。因此我们完全可以只用一个 applier 协程，让其不断的把 [lastApplied + 1, commitIndex] 区间的日志 push 到 applyCh 中去。这样既可保证每一条日志只会被 exactly once 地 push 到 applyCh 中，也可以使得日志 apply 到状态机和 raft 提交新日志可以真正的并行。我认为这是一个较为优雅的异步 apply 实现</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将已经提交的指令应用到状态机中，从而使得该节点的状态与其他节点保持一致。</span></span><br><span class="line"><span class="comment">// 在 Raft 算法中，只有已经提交的指令才能够被应用到状态机中，因此该函数的实现非常重要。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier() &#123;</span><br><span class="line">	<span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		<span class="comment">// if there is no need to apply entries, just release CPU and wait other goroutine&#x27;s signal if they commit new entries</span></span><br><span class="line">		<span class="comment">// 如果没有需要应用的日志，则等待 applyCond 条件变量的信号</span></span><br><span class="line">		<span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">			rf.applyCond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将需要应用的日志从日志中复制出来</span></span><br><span class="line">		firstIndex, commitIndex, lastApplied := rf.getFirstLog().Index, rf.commitIndex, rf.lastApplied</span><br><span class="line">		entries := <span class="built_in">make</span>([]Entry, commitIndex-lastApplied)</span><br><span class="line">		<span class="built_in">copy</span>(entries, rf.logs[lastApplied+<span class="number">1</span>-firstIndex:commitIndex+<span class="number">1</span>-firstIndex])</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">		<span class="comment">// 将需要应用的指令发送到 applyCh 通道中</span></span><br><span class="line">		<span class="keyword">for</span> _, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">			rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">				CommandValid: <span class="literal">true</span>,</span><br><span class="line">				Command:      entry.Command,</span><br><span class="line">				CommandTerm:  entry.Term,</span><br><span class="line">				CommandIndex: entry.Index,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		DPrintf(<span class="string">&quot;&#123;Node %v&#125; applies entries %v-%v in term %v&quot;</span>, rf.me, rf.lastApplied, commitIndex, rf.currentTerm)</span><br><span class="line">		<span class="comment">// 使用Max(rf.)lastApplied, commitIndex)，而不是直接使用commitIndex来避免并发的InstallSnapshot rpc导致lastApplied回滚</span></span><br><span class="line">		rf.lastApplied = Max(rf.lastApplied, commitIndex)</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="handler-1"><a href="#handler-1" class="headerlink" title="handler"></a>handler</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(request *AppendEntriesRequest, response *AppendEntriesResponse) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据请求的 term 和节点自身的 currentTerm 进行比较。如果请求的 term 小于节点自身的 currentTerm，则说明请求已过期，直接返回响应，</span></span><br><span class="line">	<span class="keyword">if</span> request.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		response.Term, response.Success = rf.currentTerm, <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> request.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.currentTerm, rf.votedFor = request.Term, <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.ChangeState(StateFollower)</span><br><span class="line">	rf.electionTimer.Reset(RandomizedElectionTimeout())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查请求中的 PrevLogIndex 是否小于节点存储的第一条日志记录的 Index。如果是，则说明该请求不合法</span></span><br><span class="line">	<span class="comment">// 返回 response.Success 设置为 false，response.Term 设置为 0（作为无效的 term），并在日志中输出错误信息</span></span><br><span class="line">	<span class="keyword">if</span> request.PrevLogIndex &lt; rf.getFirstLog().Index &#123;</span><br><span class="line">		response.Term, response.Success = <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 PrevLogIndex 合法，函数接着调用 matchLog 函数比较 request.PrevLogIndex 和 request.PrevLogTerm 是否匹配，</span></span><br><span class="line">	<span class="comment">// 即检查是否存在一个日志条目，其索引等于 request.PrevLogIndex 且任期号为 request.PrevLogTerm。</span></span><br><span class="line">	<span class="keyword">if</span> !rf.matchLog(request.PrevLogTerm, request.PrevLogIndex) &#123;</span><br><span class="line">		response.Term, response.Success = rf.currentTerm, <span class="literal">false</span></span><br><span class="line">		lastIndex := rf.getLastLog().Index</span><br><span class="line">		<span class="comment">// 如果节点存储的最后一条日志记录的 Index &lt; request.PrevLogIndex，</span></span><br><span class="line">		<span class="comment">// 则说明 leader 发送的日志记录比 follower 存储的记录更多</span></span><br><span class="line">		<span class="keyword">if</span> lastIndex &lt; request.PrevLogIndex &#123;</span><br><span class="line">			<span class="comment">// response.ConflictTerm 设置为 -1，response.ConflictIndex 设置为 lastIndex+1 代表没有冲突的</span></span><br><span class="line">			response.ConflictTerm, response.ConflictIndex = <span class="number">-1</span>, lastIndex+<span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果节点存储的最后一条日志记录的 Index 大于等于 request.PrevLogIndex，则说明存在冲突的日志记录，</span></span><br><span class="line">			<span class="comment">// response.ConflictTerm 设置为该记录的任期号，response.ConflictIndex 设置为最后一个匹配记录的前一个记录的索引</span></span><br><span class="line">			firstIndex := rf.getFirstLog().Index</span><br><span class="line">			response.ConflictTerm = rf.logs[request.PrevLogIndex-firstIndex].Term</span><br><span class="line">			index := request.PrevLogIndex - <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> index &gt;= firstIndex &amp;&amp; rf.logs[index-firstIndex].Term == response.ConflictTerm &#123;</span><br><span class="line">				index--</span><br><span class="line">			&#125;</span><br><span class="line">			response.ConflictIndex = index</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 PrevLogIndex 和 PrevLogTerm 都匹配成功，则函数继续处理请求中的日志条目</span></span><br><span class="line">	<span class="comment">// 节点首先获取存储的第一条日志记录的 Index，并遍历请求中的所有条目</span></span><br><span class="line">	<span class="comment">// 如果 follower 中不存在与该条目具有相同索引和任期的日志条目，则将该日志条目及其之后的所有条目附加到 follower 节点的日志中</span></span><br><span class="line">	firstIndex := rf.getFirstLog().Index</span><br><span class="line">	<span class="keyword">for</span> index, entry := <span class="keyword">range</span> request.Entries &#123;</span><br><span class="line">		<span class="keyword">if</span> entry.Index-firstIndex &gt;= <span class="built_in">len</span>(rf.logs) || rf.logs[entry.Index-firstIndex].Term != entry.Term &#123;</span><br><span class="line">			rf.logs = shrinkEntriesArray(<span class="built_in">append</span>(rf.logs[:entry.Index-firstIndex], request.Entries[index:]...))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// follower 节点将自己的 commitIndex 设置为请求中的 LeaderCommit 和节点自身的 commitIndex 中的较小值</span></span><br><span class="line">    <span class="comment">// 并触发 applyCond 条件变量的 Signal 方法，通知 applyMsgs 协程有新的日志条目可以被应用到状态机中</span></span><br><span class="line">	rf.advanceCommitIndexForFollower(request.LeaderCommit) </span><br><span class="line"></span><br><span class="line">	response.Term, response.Success = rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="sender-1"><a href="#sender-1" class="headerlink" title="sender"></a>sender</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateOneRound(peer <span class="type">int</span>) &#123;</span><br><span class="line">    prevLogIndex := rf.nextIndex[peer] - <span class="number">1</span> <span class="comment">// 获取该peer节点的最新一条log的索引</span></span><br><span class="line">    <span class="comment">// 判断该值是否小于当前节点的第一个日志条目的索引</span></span><br><span class="line">	<span class="keyword">if</span> prevLogIndex &lt; rf.getFirstLog().Index &#123; <span class="comment">// 如果是，则说明目标节点上一次匹配的日志条目之前的日志条目已经被截断或压缩了</span></span><br><span class="line">        <span class="keyword">if</span> rf.sendInstallSnapshot(peer, request, response) &#123;</span><br><span class="line">            <span class="comment">// 用于处理从 follower 节点发送回来的 InstallSnapshot 请求的响应</span></span><br><span class="line">			rf.handleInstallSnapshotResponse(peer, request, response)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> rf.sendAppendEntries(peer, request, response) &#123;</span><br><span class="line">            <span class="comment">// 当 当前节点是 Leader 节点并且当前任期与发送 AppendEntries RPC 时的任期一致时，根据响应中的 Success 字段来更新 Leader 的状态</span></span><br><span class="line">			rf.handleAppendEntriesResponse(peer, request, response)</span><br><span class="line">            <span class="comment">// 【advanceCommitIndexForLeader()】</span></span><br><span class="line">            <span class="comment">// 表示 Raft 领导者节点在接收到来自多数派节点的确认日志条目的回复后，更新 commitIndex</span></span><br><span class="line">			<span class="comment">// 对 matchIndex 进行排序，取出中间位置的 matchIndex 值 newCommitIndex</span></span><br><span class="line">			<span class="comment">// 如果 newCommitIndex &gt; commitIndex，且 newCommitIndex 对应的日志条目的 term 等于当前节点的任期 currentTerm，</span></span><br><span class="line">			<span class="comment">// 就更新 commitIndex，并触发 applyCond 条件变量的 Signal 方法，通知 applyMsgs 协程有新的日志条目可以被应用到状态机中。</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h6 id="复制模型"><a href="#复制模型" class="headerlink" title="复制模型"></a>复制模型</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送心跳 或 日志复制请求 给其它节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastHeartbeat(isHeartBeat <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers </span><br><span class="line">		<span class="keyword">if</span> isHeartBeat &#123; <span class="comment">// 如果 isHeartBeat 为真，说明需要立即向对等节点发送心跳请求，以维持当前节点的领导地位</span></span><br><span class="line">			<span class="keyword">go</span> rf.replicateOneRound(peer)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// isHeartBeat 为假，说明不需要立即发送请求，而是等待一段时间，将多个日志条目打包发送</span></span><br><span class="line">            <span class="comment">// 这时，函数通过调用 replicatorCond[peer].Signal() 来通知replicator(peer)，表示当前节点准备好发送日志条目。</span></span><br><span class="line">			<span class="comment">// 在 replicatorCond 中，存储了每个对等节点的条件变量，replicator(peer) 会等待这个条件变量的信号，然后才会发送日志条目</span></span><br><span class="line">			rf.replicatorCond[peer].Signal()</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> rf.state != StateLeader &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	newLog := rf.appendNewEntry(command)</span><br><span class="line">	DPrintf(<span class="string">&quot;&#123;Node %v&#125; receives a new command[%v] to replicate in term %v&quot;</span>, rf.me, newLog, rf.currentTerm)</span><br><span class="line">	rf.BroadcastHeartbeat(<span class="literal">false</span>) <span class="comment">// 发送 日志复制请求 给其它节点</span></span><br><span class="line">	<span class="keyword">return</span> newLog.Index, newLog.Term, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(peer <span class="type">int</span>) &#123;</span><br><span class="line">	rf.replicatorCond[peer].L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.replicatorCond[peer].L.Unlock()</span><br><span class="line">    <span class="comment">// 检查该节点是否需要进行日志复制，如果不需要，则等待 replicatorCond 条件变量的信号</span></span><br><span class="line">    <span class="keyword">for</span> !rf.needReplicating(peer) &#123;</span><br><span class="line">        rf.replicatorCond[peer].Wait()</span><br><span class="line">    &#125;</span><br><span class="line">	rf.replicateOneRound(peer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> needReplicating(peer <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	rf.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> rf.state == StateLeader &amp;&amp; rf.matchIndex[peer] &lt; rf.getLastLog().Index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🌟 该服务表示，它已经创建了一个快照，其中包含到索引为止的所有信息</span></span><br><span class="line"><span class="comment">// 当进行快照后，该服务将不再需要包括给定索引（包括该索引）及之前的所有日志条目</span></span><br><span class="line"><span class="comment">// Raft should now 修剪 its log as much as possible</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123; <span class="comment">// index和snapshot，其中index表示快照所对应的日志索引，snapshot表示快照数据。</span></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	snapshotIndex := rf.getFirstLog().Index <span class="comment">// 首先获取当前已经持久化的快照的最后一个日志索引snapshotIndex</span></span><br><span class="line">	<span class="keyword">if</span> index &lt;= snapshotIndex &#123;</span><br><span class="line">		DPrintf(<span class="string">&quot;&#123;Node %v&#125; rejects replacing log with snapshotIndex %v as current snapshotIndex %v is larger in term %v&quot;</span>, rf.me, index, snapshotIndex, rf.currentTerm)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果index大于snapshotIndex，则将日志数组中index-snapshotIndex以及之后的日志保留，并将之前的日志全部删除，以达到压缩日志的目的</span></span><br><span class="line">	rf.logs = shrinkEntriesArray(rf.logs[index-snapshotIndex:])</span><br><span class="line">	rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span>                                      <span class="comment">// 将日志数组中第一个日志的命令设为nil，因为在这个位置之前的日志都已经被压缩掉了</span></span><br><span class="line">	rf.persister.SaveStateAndSnapshot(rf.encodeState(), snapshot) <span class="comment">// 将当前节点的状态以及快照数据进行持久化存储</span></span><br><span class="line">	DPrintf(<span class="string">&quot;&#123;Node %v&#125;&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; after replacing log with snapshotIndex %v as old snapshotIndex %v is smaller&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), index, snapshotIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="handler-2"><a href="#handler-2" class="headerlink" title="handler"></a>handler</h6><p>leader 向 peer 节点 send，peer 来 handle</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🌟 将快照安装到 rf 节点，以便使它能够跟上其它节点的日志条目 leader发送InstallSnapshotRequest, rf回InstallSnapshotResponse</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(request *InstallSnapshotRequest, response *InstallSnapshotResponse) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">defer</span> DPrintf(<span class="string">&quot;&#123;Node %v&#125;&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; before processing InstallSnapshotRequest %v and reply InstallSnapshotResponse %v&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), request, response)</span><br><span class="line"></span><br><span class="line">	response.Term = rf.currentTerm <span class="comment">// 设置响应的 Term 为当前节点的当前任期号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> request.Term &lt; rf.currentTerm &#123; <span class="comment">// 如果请求的任期号小于当前节点的任期号，说明 Leader 节点已经过时，直接返回</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果请求的任期号大于当前节点的任期号，将当前节点的任期号更新为请求的任期号，并清除投票给其它节点的标记。此时需要将状态持久化到磁盘上。</span></span><br><span class="line">	<span class="keyword">if</span> request.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.currentTerm, rf.votedFor = request.Term, <span class="number">-1</span></span><br><span class="line">		rf.persist()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将当前节点的状态切换为 Follower，并启动新一轮的选举计时器</span></span><br><span class="line">	rf.ChangeState(StateFollower)</span><br><span class="line">	rf.electionTimer.Reset(RandomizedElectionTimeout())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果请求中包含的最后一条日志的索引小于等于当前节点已提交的最后一条日志的索引，说明请求中的快照已经过时，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> request.LastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则，将请求中的快照应用到当前节点的状态机中。</span></span><br><span class="line">	<span class="comment">// 由于该方法是在后台 Goroutine 中执行的，因此需要将 ApplyMsg 发送到 applyCh 通道中，以通知主线程将快照应用到状态机中。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">			SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">			Snapshot:      request.Data,</span><br><span class="line">			SnapshotTerm:  request.LastIncludedTerm,</span><br><span class="line">			SnapshotIndex: request.LastIncludedIndex,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 🌟 意味着只有在某些条件满足时才会执行快照安装的操作</span></span><br><span class="line"><span class="comment">// 用于在一个服务想要切换到快照时检查快照是否仍然有效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	DPrintf(<span class="string">&quot;&#123;Node %v&#125; service calls CondInstallSnapshot with lastIncludedTerm %v and lastIncludedIndex %v to check whether snapshot is still valid in term %v&quot;</span>, rf.me, lastIncludedTerm, lastIncludedIndex, rf.currentTerm)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lastIncludedTerm和lastIncludedIndex表示快照的元信息，snapshot是快照的二进制数据</span></span><br><span class="line">	<span class="comment">// 如果lastIncludedIndex &lt;= 当前服务的commitIndex，说明快照已经无效</span></span><br><span class="line">	<span class="keyword">if</span> lastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">		DPrintf(<span class="string">&quot;&#123;Node %v&#125; rejects the snapshot which lastIncludedIndex is %v because commitIndex %v is larger&quot;</span>, rf.me, lastIncludedIndex, rf.commitIndex)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果快照没有过时，则需要进行安装。函数会更新当前节点的日志记录（logs）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果lastIncludedIndex &gt; 当前raft最后一个日志条目的索引号，则说明整个日志都被包含在快照中，因此可以直接将logs数组设置为只有一个空白的日志条目（即make([]Entry, 1)），并将这个条目的索引号和任期号都设为快照中的值。</span></span><br><span class="line">	<span class="keyword">if</span> lastIncludedIndex &gt; rf.getLastLog().Index &#123;</span><br><span class="line">		rf.logs = <span class="built_in">make</span>([]Entry, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果lastIncludedIndex &lt; 当前节点最后一个日志条目的索引号，则说明需要将logs数组中旧的日志条目删除，并将快照中包含的新的日志条目追加到logs数组的末尾。具体实现时，可以调用一个shrinkEntriesArray函数来完成这个操作。这个函数会删除logs数组中索引号小于lastIncludedIndex的所有条目，然后将剩余的条目返回。</span></span><br><span class="line">		rf.logs = shrinkEntriesArray(rf.logs[lastIncludedIndex-rf.getFirstLog().Index:])</span><br><span class="line">		rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// update dummy entry with lastIncludedTerm and lastIncludedIndex</span></span><br><span class="line">	rf.logs[<span class="number">0</span>].Term, rf.logs[<span class="number">0</span>].Index = lastIncludedTerm, lastIncludedIndex</span><br><span class="line">	<span class="comment">// 然后，函数会将lastApplied和commitIndex都设为lastIncludedIndex，因为这个节点现在已经应用了快照中的所有日志条目。</span></span><br><span class="line">	rf.lastApplied, rf.commitIndex = lastIncludedIndex, lastIncludedIndex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后，函数会将新的快照和当前节点的状态一起保存到磁盘上，以便以后的恢复</span></span><br><span class="line">	rf.persister.SaveStateAndSnapshot(rf.encodeState(), snapshot)</span><br><span class="line">	DPrintf(<span class="string">&quot;&#123;Node %v&#125;&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; after accepting the snapshot which lastIncludedTerm is %v, lastIncludedIndex is %v&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), lastIncludedTerm, lastIncludedIndex)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h6 id="sender-2"><a href="#sender-2" class="headerlink" title="sender"></a>sender</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateOneRound(peer <span class="type">int</span>) &#123;</span><br><span class="line">    prevLogIndex := rf.nextIndex[peer] - <span class="number">1</span> <span class="comment">// 获取该peer节点的最新一条log的索引</span></span><br><span class="line">    <span class="comment">// 判断该值是否小于当前节点的第一个日志条目的索引</span></span><br><span class="line">	<span class="keyword">if</span> prevLogIndex &lt; rf.getFirstLog().Index &#123; <span class="comment">// 如果是，则说明目标节点上一次匹配的日志条目之前的日志条目已经被截断或压缩了</span></span><br><span class="line">        <span class="keyword">if</span> rf.sendInstallSnapshot(peer, request, response) &#123;</span><br><span class="line">            <span class="comment">// 用于处理从 follower 节点发送回来的 InstallSnapshot 请求的响应</span></span><br><span class="line">			rf.handleInstallSnapshotResponse(peer, request, response)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> rf.sendAppendEntries(peer, request, response) &#123;</span><br><span class="line">            <span class="comment">// 当 当前节点是 Leader 节点并且当前任期与发送 AppendEntries RPC 时的任期一致时，根据响应中的 Success 字段来更新 Leader 的状态</span></span><br><span class="line">			rf.handleAppendEntriesResponse(peer, request, response)</span><br><span class="line">            <span class="comment">// 【advanceCommitIndexForLeader()】</span></span><br><span class="line">            <span class="comment">// 表示 Raft 领导者节点在接收到来自多数派节点的确认日志条目的回复后，更新 commitIndex</span></span><br><span class="line">			<span class="comment">// 对 matchIndex 进行排序，取出中间位置的 matchIndex 值 newCommitIndex</span></span><br><span class="line">			<span class="comment">// 如果 newCommitIndex &gt; commitIndex，且 newCommitIndex 对应的日志条目的 term 等于当前节点的任期 currentTerm，</span></span><br><span class="line">			<span class="comment">// 就更新 commitIndex，并触发 applyCond 条件变量的 Signal 方法，通知 applyMsgs 协程有新的日志条目可以被应用到状态机中。</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













































<hr>
<h4 id="工程问题"><a href="#工程问题" class="headerlink" title="工程问题"></a>工程问题</h4><h5 id="检测内存泄漏-用htop发现虚拟内存在涨"><a href="#检测内存泄漏-用htop发现虚拟内存在涨" class="headerlink" title="检测内存泄漏(用htop发现虚拟内存在涨)"></a>检测内存泄漏(用htop发现虚拟内存在涨)</h5><p>线上系统要做好热更新，方便随时打开内存调试。 <code>#if  mem = 1  #endif</code></p>
<h6 id="法一-malloc-stats-和-malloc-info-0-stdout"><a href="#法一-malloc-stats-和-malloc-info-0-stdout" class="headerlink" title="法一:  malloc_stats() 和 malloc_info(0, stdout)"></a><strong>法一:</strong>  malloc_stats() 和 malloc_info(0, stdout)</h6><p>检测具体函数的内存泄漏: gdb中打断点配合调用malloc_stats()函数 <code>call malloc_stats()</code></p>
<p>函数执行前后调用<code>call malloc_info(0, stdout)</code>输出内存,比较</p>
<h6 id="法二：宏定义"><a href="#法二：宏定义" class="headerlink" title="法二：宏定义"></a>法二：宏定义</h6><p>创建一个文件夹。每次malloc的时候在其中创建一个文件，文件名是本次malloc申请的内存地址。free的时候去该文件夹中查找与没有 那个名为那个地址的文件，有的话就删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _malloc(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%s:%d]_malloc:%ld,ptr:%p\n&quot;</span>, filename, line, size, p);</span><br><span class="line">    <span class="built_in">fflush</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _free(<span class="type">void</span> *p, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>)&#123; <span class="comment">// 删除失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;[-%s:%d]_free:%p\n&quot;, filename, line, p);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) _malloc(size, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) _free(ptr, __FILE__, __LINE__)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230222155844859.png" alt="image-20230222155844859"></p>
<h6 id="法三：-hook截获malloc和free-dlsym改成自定义的"><a href="#法三：-hook截获malloc和free-dlsym改成自定义的" class="headerlink" title="法三： hook截获malloc和free, dlsym改成自定义的"></a>法三： hook截获malloc和free, dlsym改成自定义的</h6> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">malloc_t</span> malloc_f; <span class="comment">// malloc_f 是 malloc_t 类型的函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="type">free_t</span> free_f;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> enable_malloc_hook = <span class="number">1</span>, enable_free_hook = <span class="number">1</span>; <span class="comment">// 防止malloc中循环调用malloc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_malloc_hook)&#123;</span><br><span class="line">        enable_malloc_hook = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *p = <span class="built_in">malloc_f</span>(size);</span><br><span class="line">        <span class="type">void</span> *caller = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%p]malloc --&gt; addr:%p size:%lu\n&quot;</span>, caller, p, size);</span><br><span class="line">        <span class="built_in">fflush</span>(fp);</span><br><span class="line"></span><br><span class="line">        enable_malloc_hook = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">malloc_f</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_free_hook)&#123;</span><br><span class="line">        enable_free_hook = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="built_in">free_f</span>(p);</span><br><span class="line">        </span><br><span class="line">        enable_free_hook = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">free_f</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有malloc和free包括第三方库中的，走我们自定义的那一段</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init_hook</span><span class="params">()</span></span>&#123;</span><br><span class="line">    malloc_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">// 获取 malloc 地址为 malloc_f, 因此调用malloc_f等价于调用malloc</span></span><br><span class="line">    free_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -o memleak_0 memleak_0.c -ldl -g </span></span><br><span class="line"><span class="comment">// addr2line -f -e  memleak_0 -a 0x4006d8   （-f表示file -e表示execute -a表示代码段地址）可以查看 内存泄漏的行数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init_hook</span>();</span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="法四：-mtrace"><a href="#法四：-mtrace" class="headerlink" title="法四： mtrace"></a>法四： mtrace</h6><p>mtrace() 函数中会为那些和动态内存分配有关的函数（譬如 malloc()、realloc()、memalign() 以及 free()）安装 “钩子（hook）” 函数，这些 hook 函数会为我们记录所有有关内存分配和释放的跟踪信息，而 muntrace() 则会卸载相应的 hook 函数。基于这些 hook 函数生成的调试跟踪信息，我们就可以分析是否存在 “内存泄露” 这类问题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">mtrace</span>();  <span class="comment">// 开始跟踪</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">muntrace</span>();   <span class="comment">// 结束跟踪，并生成日志信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test  <span class="comment">// 一定加上 -g 能够帮我们定位代码中的具体位置，否则看到的只是执行文件中的地址信息</span></span><br></pre></td></tr></table></figure>

<p>mtrace 机制需要我们实际运行一下程序，然后才能生成跟踪的日志，但在实际运行程序之前还有一件要做的事情是需要告诉 mtrace生成日志文件的路径。具体的方法是通过定义并导出一个环境变量 “MALLOC_TRACE”，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> MALLOC_TRACE=./test.log  <span class="comment">// 当前目录下</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200347354.png" alt="image-20230226200347354"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200602769.png" alt="image-20230226200602769"></p>
<hr>
<h5 id="查看链接了哪些动态库和第三方库有无内存泄漏"><a href="#查看链接了哪些动态库和第三方库有无内存泄漏" class="headerlink" title="查看链接了哪些动态库和第三方库有无内存泄漏"></a>查看链接了哪些动态库和第三方库有无内存泄漏</h5><ul>
<li>查看链接了哪些动态库</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ldd a.so	<span class="comment">//查看SO文件的动态链接库</span></span><br><span class="line">nm -D a.so	<span class="comment">//查看so文件的函数列表</span></span><br><span class="line">objdump -tT a.so	<span class="comment">//查看so文件的导出函数及源文件等信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Linux&#x2F;unix 提供了使用 dlopen 和 dlsym 方法动态加载库和调用函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开指定的动态库，返回的是该动态库的handle，在dlsym，dlclose中将继续使用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// RTLD_LAZY 暂缓决定，等有需要时再解出符号 </span></span><br><span class="line"><span class="comment">// RTLD_NOW 立即决定，返回前解除所有未决定的符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看错误信息</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">dlerror</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获得对应的函数或变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="comment">//关闭打开的动态库</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="c-程序崩溃定位方法"><a href="#c-程序崩溃定位方法" class="headerlink" title="c++程序崩溃定位方法"></a>c++程序崩溃定位方法</h5><ol>
<li><p>将程序设置为调试模式，可以给出程序在崩溃时所在行的提示信息;</p>
</li>
<li><p>编译时加入“<em>g”参数，确保可以生成足够的调试信息;</em></p>
</li>
<li><p>使用调试工具，比如 gdb，进一步定位到程序崩溃具体位置;</p>
</li>
<li><p>对崩溃关键点添加_print 语句，打印出变量值，分析程序运行流程;</p>
</li>
<li><p>如果能复现崩溃的情况，可以使用内存跟踪工具当程序崩溃时跟踪内存的变化，从而确定程序的崩溃原因;</p>
</li>
<li><p>如果有 linux 环境可以避免崩溃，可以使用 core 文件定位到程序崩溃所在代码片段。</p>
</li>
<li><p>使用调试器</p>
<p>使用调试器是定位程序崩溃的最常用方法之一。你可以使用诸如GDB（GNU调试器）或Visual Studio等调试器。调试器能够提供有关程序崩溃的详细信息，如程序的状态、变量值、函数调用堆栈等。</p>
</li>
<li><p>输出调试信息</p>
<p>在程序中插入调试信息，可以帮助你了解程序崩溃的位置和原因。你可以在关键位置打印变量的值或者调用函数，以确定程序执行到哪里就崩溃了。</p>
</li>
<li><p>内存检测工具</p>
<p>使用内存检测工具可以帮助你检测内存泄漏、野指针等问题。例如，使用Valgrind工具可以在Linux环境下检测内存问题。</p>
</li>
<li><p>静态代码分析工具</p>
<p>使用静态代码分析工具可以帮助你找到潜在的代码缺陷，例如未初始化的变量、函数调用不匹配等。例如，Cppcheck是一款常用的静态代码分析工具。</p>
</li>
<li><p>测试用例</p>
<p>编写测试用例可以帮助你定位程序崩溃的原因。测试用例应该包含各种输入和边界条件，以确保程序能够处理各种情况。如果测试用例能够触发程序崩溃，就可以进一步分析和修复问题。</p>
</li>
</ol>
<hr>
<h5 id="git-如何查看远程服务器分支"><a href="#git-如何查看远程服务器分支" class="headerlink" title="git 如何查看远程服务器分支"></a>git 如何查看远程服务器分支</h5><p>要查看远程服务器上的分支，可以使用 <code>git branch -r</code> 该命令会显示所有已知的远程分支列表。</p>
<p>如果你想查看特定远程分支的详细信息，可以使用 <code>git show &lt;remote-name&gt;/&lt;branch-name&gt;</code> 命令，其中 <code>remote-name</code> 是远程服务器的名称，<code>branch-name</code> 是要查看的分支名称。例如，要查看名为 <code>master</code> 的远程分支的详细信息，可以运行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git show origin/master</span><br></pre></td></tr></table></figure>

<p>请注意，在使用此命令之前，你需要先确保已经将远程分支拉取到本地仓库中，否则该命令将无法正常工作。可以使用 <code>git fetch</code> 命令将远程分支更新到本地仓库</p>
<h3 id="6️⃣其他"><a href="#6️⃣其他" class="headerlink" title="6️⃣其他"></a>6️⃣其他</h3><h4 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h4><h5 id="沙漏计时问题"><a href="#沙漏计时问题" class="headerlink" title="沙漏计时问题"></a>沙漏计时问题</h5><p>有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>两个沙漏同时倒置开始计时，等小沙漏漏完，大沙漏还剩<span class="number">2</span>分钟，这时倒置小沙漏继续计时；</span><br><span class="line"><span class="number">2.</span>大沙漏漏完小沙漏还剩<span class="number">4</span>分钟，再把大沙漏倒置继续计时；</span><br><span class="line"><span class="number">3.</span>小沙漏漏完大沙漏还剩<span class="number">4</span>分钟，这时准备工作已经完毕；</span><br><span class="line"><span class="number">4.</span>等待大沙漏漏完（<span class="number">4</span>分钟）+小沙漏（<span class="number">6</span>分钟）=<span class="number">10</span>分钟。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="吃药片问题"><a href="#吃药片问题" class="headerlink" title="吃药片问题"></a>吃药片问题</h5><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 把手上的三片药各自切成两半，分成两堆摆放；</span><br><span class="line"><span class="number">2.</span> 再取出一粒药片 A，也把它切成两半，然后在每一堆里加上半片的 A；</span><br><span class="line"><span class="number">3.</span> 现在，每一堆药片恰好包含两个半片的 A 和两个半片的 B；</span><br><span class="line"><span class="number">4.</span> 一天服用其中一堆即可。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="老鼠毒药问题"><a href="#老鼠毒药问题" class="headerlink" title="老鼠毒药问题"></a>老鼠毒药问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤一： 给所有瓶子转化为二进制</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0000000001</span></span><br><span class="line"><span class="number">2</span>：<span class="number">0000000010</span></span><br><span class="line"><span class="number">3</span>：<span class="number">0000000011</span></span><br><span class="line"><span class="number">4</span>：<span class="number">0000000100</span></span><br><span class="line">.....<span class="number">.1000</span>：<span class="number">1111101000</span> </span><br><span class="line"><span class="comment">// 步骤二： 让第i只老鼠喝二进制表示第i位为一的所有瓶子</span></span><br><span class="line"><span class="comment">// 一星期后看第几只老鼠死了, 比如第1,3,5只死了, 则毒药编号就是 1010100000</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="箱子开锁问题"><a href="#箱子开锁问题" class="headerlink" title="箱子开锁问题"></a>箱子开锁问题</h5><p>A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> A 把药放进箱子，用自己的锁把箱子锁上；</span><br><span class="line"><span class="number">2.</span> B 拿到箱子后，再在箱子上加一把自己的锁；</span><br><span class="line"><span class="number">3.</span> 箱子运回 A 后，A 取下自己的锁；</span><br><span class="line"><span class="number">4.</span> 箱子再运到 B 手中时，B 取下自己的锁，获得药物。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="人鬼过桥问题"><a href="#人鬼过桥问题" class="headerlink" title="人鬼过桥问题"></a>人鬼过桥问题</h5><p>有三个人跟三个鬼要过河，河上没桥只有条小船，然后船一次只能渡一个人和一个鬼，或者两个鬼和两个人，无论在哪边岸上，只有是人比鬼少的情况下（如两鬼一人，三鬼两人，三鬼一人），人会被鬼吃掉，然而船有一定需要人或鬼操作才能航行（要有人或鬼划船），问，如何安全的把三人三鬼渡过河对岸？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 先两鬼过去，再一鬼回来。此时，对面有一鬼，这边有三人两鬼；</span><br><span class="line"><span class="number">2.</span> 再两鬼过去，再一鬼回来。此时对面有两鬼，这边有三人一鬼；</span><br><span class="line"><span class="number">3.</span> 再两人过去，一人一鬼回来。此时，对面一人一鬼。这边两人两鬼；</span><br><span class="line"><span class="number">4.</span> 最后两人过去，一鬼回来。此时，对面三人，这边三鬼；</span><br><span class="line"><span class="number">5.</span> 剩下的就三个鬼，两个过去，一个回来再接另外一个鬼就结束了。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="赛马找最快的马匹"><a href="#赛马找最快的马匹" class="headerlink" title="赛马找最快的马匹"></a>赛马找最快的马匹</h5><p>25匹马5条跑道找最快的3匹马，需要跑几次？参考回答：7</p>
<p>64匹马8条跑道找最快的4匹马，需要跑几次？参考回答：11</p>
<p>25匹马5条跑道找最快的5匹马，需要跑几次？参考回答：最少8次最多9次</p>
<h6 id="25匹马5条跑道找最快的3匹马"><a href="#25匹马5条跑道找最快的3匹马" class="headerlink" title="25匹马5条跑道找最快的3匹马"></a>25匹马5条跑道找最快的3匹马</h6><p>将25匹马分成ABCDE5组，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5，这里比赛5次</p>
<p>第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1</p>
<p>D1，E1肯定进不了前3，直接排除掉。 第7次，B1 C1 A2 B2 A3比赛，可以找出第二，第三名</p>
<h6 id="64匹马8条跑道找最快的4匹马"><a href="#64匹马8条跑道找最快的4匹马" class="headerlink" title="64匹马8条跑道找最快的4匹马"></a><strong>64匹马8条跑道找最快的4匹马</strong></h6><p>第一步：全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名</p>
<p>第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马。这个时候总冠军已经诞生，它就是这场比赛第一名</p>
<p>第三步：可能是前四名的只能是下面淡黄色的9只，随机选出8匹马进行一次比赛</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230309193955191.png" alt="image-20230309193955191" style="zoom:50%;">

<p>第四步：上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，就和前三名比一比，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了</p>
<h4 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h4><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/" rel="prev" title="链表逆置合集">
      <i class="fa fa-chevron-left"></i> 链表逆置合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/06/CPP%E5%85%AB%E8%82%A1-%E4%BA%8C/" rel="next" title="CPP八股(二)">
      CPP八股(二) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0%EF%B8%8F%E2%83%A3C-x2F-C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">0️⃣C&#x2F;C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.</span> <span class="nav-text">C++ 中的四种类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">说说 C++中 struct 和 class 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">⚠️说说头文件双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8CC%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.4.</span> <span class="nav-text">说说C++结构体和C结构体的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9FC-%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8CC%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">导入C函数的关键字？C++编译时和C有何不同？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.6.</span> <span class="nav-text">⚠️简述C++从代码到可执行文件过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.7.</span> <span class="nav-text">说说 static关键字的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.8.</span> <span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.9.</span> <span class="nav-text">说说静态局部变量, 全局变量, 局部变量的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.10.</span> <span class="nav-text">⚠️说说什么是函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.11.</span> <span class="nav-text">nullptr可以调用成员函数吗？为什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.12.</span> <span class="nav-text">内联函数和函数的区别,内联函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.13.</span> <span class="nav-text">说说内联函数和宏的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.14.</span> <span class="nav-text">说说new和malloc的区别，底层实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete-%E5%92%8C-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.15.</span> <span class="nav-text">delete 和 free 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.16.</span> <span class="nav-text">说说const和define的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.17.</span> <span class="nav-text">常量指针和指针常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%90%8C%E5%90%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%9C%A8%E5%A4%9A%E4%B8%AAc%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%AC%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.18.</span> <span class="nav-text">⚠️同名全局变量在多个c文件中公用的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.19.</span> <span class="nav-text">c++命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.1.19.1.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E5%9C%A8main%E5%87%BD%E6%95%B0%E5%89%8D%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.20.</span> <span class="nav-text">C++如何在main函数前运行一个函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Explicit%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.21.</span> <span class="nav-text">Explicit和隐式类型转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">⚠️进程运行时虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">简述C++的内存管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">⚠️常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">⚠️简述C++中内存对齐的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8BRAII-%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">说下RAII, 与智能指针之间的联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII%E8%A1%A5%E5%85%85"><span class="nav-number">1.2.6.</span> <span class="nav-text">RAII补充</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.3.1.</span> <span class="nav-text">简述一下 C++重载和重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">说说 C++ 重载和重写是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.3.3.</span> <span class="nav-text">说说C++构造函数有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">只定义析构函数,会自动生成哪些构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">一个类默认会生成哪些函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E5%BD%B1%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">哪些因素会影一个类对象的大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.7.</span> <span class="nav-text">继承一个类的对象的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%B9%B6%E9%87%8D%E5%86%99%E4%BA%86%E5%AE%83%E4%BB%AC%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.8.</span> <span class="nav-text">继承两个类并重写了它们的虚函数的对象的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.3.9.</span> <span class="nav-text">简述下向上转型和向下转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.10.</span> <span class="nav-text">简述下深拷贝和浅拷贝, 如何实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.11.</span> <span class="nav-text">简述一下 C++ 中的多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">1.3.12.</span> <span class="nav-text">说说为什么要虚析构, 为什么不能虚构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.13.</span> <span class="nav-text">构造函数中可以调用虚函数吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.14.</span> <span class="nav-text">说说模板类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.15.</span> <span class="nav-text">C++ 类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.16.</span> <span class="nav-text">⚠️简述一下什么是常函数，有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.3.17.</span> <span class="nav-text">说说 C++ 中什么是菱形继承问题，如何解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%88%B6%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.18.</span> <span class="nav-text">虚继承多个父类的子类的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.19.</span> <span class="nav-text">说说C++中虚函数与纯虚函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FC-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%EF%BC%88-friend%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.20.</span> <span class="nav-text">⚠️C++友元函数和友元类（ friend）详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FC-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.21.</span> <span class="nav-text">⚠️C++ 中哪些函数不能被声明为虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.22.</span> <span class="nav-text">类模板和模板类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-STL"><span class="nav-number">1.4.</span> <span class="nav-text">C++STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">请说说 STL 的基本组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">请说说 STL 中常见的容器, 并介绍一下实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8DC-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.4.3.</span> <span class="nav-text">两种C++类对象实例化方式的异同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">⚠️迭代器用过吗？什么时候会失效？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.5.</span> <span class="nav-text">说说 STL 中 resize 和 reserve 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#char-%E5%92%8Cstring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.6.</span> <span class="nav-text">char*和string的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8Evector%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.7.</span> <span class="nav-text">数组与vector的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8Fvector-%E7%9A%84-%E9%83%A8%E5%88%86STL-%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.8.</span> <span class="nav-text">⚠️vector 的 部分STL 源码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">C++新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4-C-14%E3%80%81C-17%E3%80%81C-20-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">⚠️说说 C++14、C++17、C++20 新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">说说 C++11 新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.5.3.</span> <span class="nav-text">说说 C++中的智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E5%90%97"><span class="nav-number">1.5.4.</span> <span class="nav-text">智能指针有内存泄露风险吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4%E4%B8%89%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">⚠️说说三种智能指针原理和使用场景和线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">1.5.6.</span> <span class="nav-text">完美转发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#constexpr"><span class="nav-number">1.5.7.</span> <span class="nav-text">constexpr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">1️⃣操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.1.</span> <span class="nav-text">说一说常用的 Linux 命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%81%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E3%80%81tar%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">查看进程运行状态、查看内存使用情况、tar解压文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">2.1.3.</span> <span class="nav-text">查找一个字符串是否在文件中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%AC%E6%9C%BA%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.4.</span> <span class="nav-text">查找本机一个端口号的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BC%80%E5%90%AF"><span class="nav-number">2.1.5.</span> <span class="nav-text">如何判断远程服务的端口有没有开启</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9"><span class="nav-number">2.1.6.</span> <span class="nav-text">文件权限怎么修改</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90-ugoa"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">文字设定法设置权限(ugoa)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90-ugo"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">数字设定法设置权限(ugo)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90-SUID-SGID-Sticky"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">特殊权限(SUID SGID Sticky)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%A5root%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.7.</span> <span class="nav-text">如何以root权限运行某个程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD"><span class="nav-number">2.1.8.</span> <span class="nav-text">什么是大端小端, 如何判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-IP%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.9.</span> <span class="nav-text">字节序转换函数, IP转换函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0Linux%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">2.1.10.</span> <span class="nav-text">⚠️简述Linux内核态与用户态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E6%98%A0%E5%B0%84%E7%9A%84"><span class="nav-number">2.1.11.</span> <span class="nav-text">虚拟地址到物理地址怎么映射的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">2.1.12.</span> <span class="nav-text">说说堆栈溢出是什么, 会怎么样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.1.13.</span> <span class="nav-text">⚠️说说进程,线程,协程是什么,区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lock-guard-%E5%92%8C-unique-lock-%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.14.</span> <span class="nav-text">lock_guard 和 unique_lock 区别，使用案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.1.15.</span> <span class="nav-text">什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">2.1.16.</span> <span class="nav-text">说说什么是守护进程, 如何实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.1.17.</span> <span class="nav-text">说说进程通信的方式有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.18.</span> <span class="nav-text">进程通信中的管道实现原理是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.1.19.</span> <span class="nav-text">使用管道的四种特殊情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.1.20.</span> <span class="nav-text">⚠️共享内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0mmap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-6%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.21.</span> <span class="nav-text">⚠️简述mmap的原理和使用场景(6参数)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.1.22.</span> <span class="nav-text">说说常见信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.23.</span> <span class="nav-text">⚠️如何保护一个进程不被杀死，具体的代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.24.</span> <span class="nav-text">进程, 线程的中断切换过程是怎样的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">2.1.25.</span> <span class="nav-text">死锁产生条件以及如何解决死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9C%A8Linux%E4%B8%AD%EF%BC%8C%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%90%AF%E6%97%B6%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="nav-number">2.1.26.</span> <span class="nav-text">⚠️在Linux中，让程序在系统开启时自启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">2.1.27.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.1.28.</span> <span class="nav-text">锁的种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.29.</span> <span class="nav-text">自旋锁和条件变量的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D-amp-DMA"><span class="nav-number">2.1.30.</span> <span class="nav-text">零拷贝 &amp; DMA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">3.</span> <span class="nav-text">2️⃣计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">TCP通信流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#listen-%E9%87%8C%E7%9A%84backlog%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">listen() 里的backlog参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#accept-%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%93%AA%E9%87%8C"><span class="nav-number">3.1.3.</span> <span class="nav-text">accept() 在三次握手哪里</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E8%8C%83SYN%E6%94%BB%E5%87%BB%EF%BC%88DDOS%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%89"><span class="nav-number">3.1.4.</span> <span class="nav-text">防范SYN攻击（DDOS的一种）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA"><span class="nav-number">3.2.</span> <span class="nav-text">网络理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-gt-%E4%BC%A0%E8%BE%93%E5%B1%82-gt-%E7%BD%91%E7%BB%9C%E5%B1%82-gt-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">3.2.1.</span> <span class="nav-text">(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82-gt-%E7%BD%91%E7%BB%9C%E5%B1%82-gt-%E4%BC%A0%E8%BE%93%E5%B1%82-gt-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.2.2.</span> <span class="nav-text">(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.3.</span> <span class="nav-text">网络模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-amp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">TCP三次握手 &amp; 四次挥手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.5.</span> <span class="nav-text">TCP与UDP区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.2.6.</span> <span class="nav-text">TCP流量控制：滑动窗口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%85%A2%E5%BC%80%E5%A7%8B-amp-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0-amp-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">3.2.7.</span> <span class="nav-text">TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4-TCP-%E7%B2%98%E5%8C%85"><span class="nav-number">3.2.8.</span> <span class="nav-text">⚠️说说 TCP 粘包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="nav-number">3.2.9.</span> <span class="nav-text">TCP 和 UDP 可以同时绑定相同的端口吗?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-TCP-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="nav-number">3.2.10.</span> <span class="nav-text">多个 TCP 服务进程可以绑定同一个端口吗?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5-bind-%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.2.11.</span> <span class="nav-text">同一客户端可以 bind 同一个端口吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5-bind-%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.2.12.</span> <span class="nav-text">多个客户端可以 bind 同一个端口吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%AE%A2%E6%88%B7%E7%AB%AFconnect%E5%87%BD%E6%95%B0%E9%80%89%E6%8B%A9%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.13.</span> <span class="nav-text">⚠️客户端connect函数选择端口号的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8FCLOSE-WAIT%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="nav-number">3.2.14.</span> <span class="nav-text">产生大量CLOSE_WAIT原因和解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8FTIME-WAIT%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="nav-number">3.2.15.</span> <span class="nav-text">产生大量TIME_WAIT原因和解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-amp-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">3.2.16.</span> <span class="nav-text">HTTP请求报文&amp;响应报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.17.</span> <span class="nav-text">一次HTTP请求响应的流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="nav-number">3.2.18.</span> <span class="nav-text">HTTP协议特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.19.</span> <span class="nav-text">HTTP方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GET%E3%80%81POST%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.20.</span> <span class="nav-text">GET、POST区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.2.21.</span> <span class="nav-text">Http状态码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E7%9A%84keepalive%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.22.</span> <span class="nav-text">Http的keepalive字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.23.</span> <span class="nav-text">长连接和短连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E5%92%8CHttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.24.</span> <span class="nav-text">Http和Https的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTPS%E6%8F%A1%E6%89%8B%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.25.</span> <span class="nav-text">HTTPS握手步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">3.2.26.</span> <span class="nav-text">⚠️对称加密与非对称加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP1-x-%E5%92%8C-HTTP2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.27.</span> <span class="nav-text">HTTP1.x 和 HTTP2.0 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.28.</span> <span class="nav-text">HTTP优化方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebSocket-%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.29.</span> <span class="nav-text">WebSocket 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#WebSocket-API-%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.2.29.1.</span> <span class="nav-text">WebSocket API 有哪些</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0websocket%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.29.2.</span> <span class="nav-text">C++中如何实现websocket协议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E5%92%8C-websocket-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.29.3.</span> <span class="nav-text">HTTP 协议和 websocket 协议的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.30.</span> <span class="nav-text">说说ARP协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4NAT%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.31.</span> <span class="nav-text">说说NAT协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session%E3%80%81Cookie"><span class="nav-number">3.2.32.</span> <span class="nav-text">Session、Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.2.33.</span> <span class="nav-text">⚠️国内访问不了谷歌的技术原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9B%BD%E5%86%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C"><span class="nav-number">3.2.34.</span> <span class="nav-text">⚠️国内可以通过什么技术手段访问谷歌</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FVPN%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.35.</span> <span class="nav-text">⚠️VPN和代理服务器的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.36.</span> <span class="nav-text">防火墙的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%90%E8%90%A5%E5%95%86%E7%BB%99%E7%94%A8%E6%88%B7%E9%99%90%E9%80%9F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.37.</span> <span class="nav-text">⚠️运营商给用户限速的类型和原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.38.</span> <span class="nav-text">⚠️常见的流量控制算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%B8%8F%E2%83%A3%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">3️⃣数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA"><span class="nav-number">4.1.</span> <span class="nav-text">数据库理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FMySQL%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">⚠️MySQL体系架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.2.</span> <span class="nav-text">SQL语句运行机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9%E7%89%B9%E6%80%A7-ACID"><span class="nav-number">4.1.3.</span> <span class="nav-text">数据库事物特性(ACID)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A2%E8%AF%BB%E4%B8%8D%E5%B9%BB"><span class="nav-number">4.1.4.</span> <span class="nav-text">⚠️数据库并发一致性问题：丢读不幻</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">4.1.5.</span> <span class="nav-text">⚠️当前读和快照读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%B9%BB%E8%AF%BB%E5%90%97"><span class="nav-number">4.1.6.</span> <span class="nav-text">⚠️两个事务并行提交一定会幻读吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8Bmysql%E6%AD%BB%E9%94%81"><span class="nav-number">4.1.7.</span> <span class="nav-text">说下mysql死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.8.</span> <span class="nav-text">数据库锁类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.9.</span> <span class="nav-text">关于锁的常见问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.10.</span> <span class="nav-text">数据库封锁协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A%E6%9C%AA-%E6%8F%90-%E5%8F%AF-%E5%8F%AF"><span class="nav-number">4.1.11.</span> <span class="nav-text">数据库隔离级别：未 提 可 可</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1NF-2NF-3NF-BCNF"><span class="nav-number">4.1.12.</span> <span class="nav-text">1NF	 		2NF		 3NF 		BCNF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E4%B8%BB%E9%94%AE"><span class="nav-number">4.1.13.</span> <span class="nav-text">超键, 候选键, 主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.14.</span> <span class="nav-text">数据库索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">4.1.14.1.</span> <span class="nav-text">什么是索引？优缺点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.14.2.</span> <span class="nav-text">索引的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.14.3.</span> <span class="nav-text">索引的数据结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BF%9D%E5%AD%98MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">4.1.14.4.</span> <span class="nav-text">如何创建及保存MySQL的索引？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88%EF%BC%9F"><span class="nav-number">4.1.14.5.</span> <span class="nav-text">如何判断索引有没有生效？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EXPLAIN"><span class="nav-number">4.1.14.6.</span> <span class="nav-text">EXPLAIN</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">4.1.14.7.</span> <span class="nav-text">⚠️索引优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.1.14.8.</span> <span class="nav-text">应该建立索引的条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.14.9.</span> <span class="nav-text">索引的优缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.14.10.</span> <span class="nav-text">索引的最左前缀问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96"><span class="nav-number">4.1.15.</span> <span class="nav-text">sql优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM"><span class="nav-number">4.1.16.</span> <span class="nav-text">InnoDB和MyISAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FInnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.17.</span> <span class="nav-text">⚠️InnoDB体系结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4-InnoDB-%E7%9A%84-MVCC"><span class="nav-number">4.1.18.</span> <span class="nav-text">⚠️说说 InnoDB 的 MVCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.19.</span> <span class="nav-text">Mysql数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">4.1.20.</span> <span class="nav-text">⚠️主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.1.21.</span> <span class="nav-text">关系型数据库和非关系型数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.1.22.</span> <span class="nav-text">数据库完整性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%A1%A8%E7%9A%84%E5%A4%96%E9%94%AE%E6%9E%84%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">4.1.23.</span> <span class="nav-text">对表的外键构建索引的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%B4%A8"><span class="nav-number">4.1.24.</span> <span class="nav-text">一个好的模式分解具有哪些性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.25.</span> <span class="nav-text">视图的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FMySQL%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8"><span class="nav-number">4.1.26.</span> <span class="nav-text">⚠️MySQL分区分表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete%E3%80%81drop%E3%80%81-truncate%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.27.</span> <span class="nav-text">delete、drop、 truncate区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.28.</span> <span class="nav-text">exists和in的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">4.1.29.</span> <span class="nav-text">说说触发器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%A0%86%E8%A1%A8%EF%BC%88HOT%EF%BC%89%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%88IOT%EF%BC%89"><span class="nav-number">4.1.30.</span> <span class="nav-text">⚠️堆表（HOT）和索引组织表（IOT）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C-%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.1.31.</span> <span class="nav-text">关系数据库都有哪些操作,特点是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88DDL%EF%BC%8CDML%EF%BC%8CDQL%E3%80%81DCL%EF%BC%89"><span class="nav-number">4.1.32.</span> <span class="nav-text">数据库（DDL，DML，DQL、DCL）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">4.1.33.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B%E6%A0%91-x2F-B-%E6%A0%91"><span class="nav-number">4.1.34.</span> <span class="nav-text">B树&#x2F;B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4B-%E6%A0%91%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%B4%A2%E5%BC%95-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-B-%E6%A0%91"><span class="nav-number">4.1.35.</span> <span class="nav-text">说说B+ 树怎么实现索引, 为什么选 B+ 树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E7%94%A8-B-%E6%A0%91"><span class="nav-number">4.1.36.</span> <span class="nav-text">数据库为什么不用红黑树而用 B+ 树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.1.37.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.1.38.</span> <span class="nav-text">各种连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.39.</span> <span class="nav-text">数据库连接池优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">4.1.40.</span> <span class="nav-text">MySQL的慢查询优化有了解吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redo-log-Undo-log%E5%92%8CBinlog"><span class="nav-number">4.1.41.</span> <span class="nav-text">Redo log, Undo log和Binlog</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%B8%8F%E2%83%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">4️⃣设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">六种关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">5.1.2.</span> <span class="nav-text">面向对象设计原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.3.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">单例模式多线程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.4.</span> <span class="nav-text">请说说工厂设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.4.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.4.4.</span> <span class="nav-text">⭐️三种工厂模式的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%B8%8F%E2%83%A3%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">5️⃣项目相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#webserver"><span class="nav-number">6.1.</span> <span class="nav-text">webserver</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.1.1.</span> <span class="nav-text">介绍一下项目</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E8%B7%83%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">定时器处理非活跃连接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">主从状态机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8F%90%E9%86%92%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">子线程如何提醒主线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%A0%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">服务器是怎么把静态资源传回客户端的</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">6.1.2.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E7%BC%BA%E7%82%B9"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">select缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">6.1.3.</span> <span class="nav-text">poll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#poll%E7%BC%BA%E7%82%B9"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">poll缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">6.1.4.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-epoll-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">说说 epoll 的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4epoll%E6%B5%81%E7%A8%8B"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">说说epoll流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.4.3.</span> <span class="nav-text">epoll事件类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E5%86%99%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%86%99%E5%AE%8C%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.1.4.4.</span> <span class="nav-text">epoll写就绪事件和写完成事件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.4.5.</span> <span class="nav-text">epoll水平触发与边缘触发的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="nav-number">6.1.4.6.</span> <span class="nav-text">epoll是同步的还是异步的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EPOLLONESHOT%E4%BA%8B%E4%BB%B6-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.1.4.7.</span> <span class="nav-text">EPOLLONESHOT事件(保证线程安全)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">6.1.5.</span> <span class="nav-text">阻塞和非阻塞、同步和异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4Reactor%E3%80%81Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.</span> <span class="nav-text">说说Reactor、Proactor模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">Proactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5IO%E7%9A%84%E6%A8%A1%E6%8B%9FProactor"><span class="nav-number">6.1.6.3.</span> <span class="nav-text">同步IO的模拟Proactor</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">6.1.7.</span> <span class="nav-text">将文件描述符设置为非阻塞有什么用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unix%E3%80%81Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.</span> <span class="nav-text">Unix、Linux上的五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.1.</span> <span class="nav-text">阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.2.</span> <span class="nav-text">非阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">6.1.8.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="nav-number">6.1.8.4.</span> <span class="nav-text">信号驱动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.5.</span> <span class="nav-text">异步IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.8.6.</span> <span class="nav-text">⭐️5种IO模型的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.1.9.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">6.1.9.1.</span> <span class="nav-text">如何确定线程数量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E4%B8%8ECPU%E6%A0%B8%E5%BF%83%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.9.2.</span> <span class="nav-text">线程数量与CPU核心数的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="nav-number">6.1.9.3.</span> <span class="nav-text">线程池中的工作线程是一直等待吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.1.9.4.</span> <span class="nav-text">线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="nav-number">6.1.9.5.</span> <span class="nav-text">如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.1.10.</span> <span class="nav-text">Nginx的负载均衡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nginx%E9%85%8D%E7%BD%AE"><span class="nav-number">6.1.11.</span> <span class="nav-text">nginx配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.1.12.</span> <span class="nav-text">读多写少的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">6.1.13.</span> <span class="nav-text">GDB 常见的调试命令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8-x2F-%E9%80%80%E5%87%BA-x2F-%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">6.1.13.1.</span> <span class="nav-text">GDB命令-启动&#x2F;退出&#x2F;查看代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.13.2.</span> <span class="nav-text">GDB命令-断点操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">6.1.13.3.</span> <span class="nav-text">GDB命令-调试命令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E9%AB%98WebServer%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">6.1.14.</span> <span class="nav-text">提高WebServer的性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.1.15.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.15.1.</span> <span class="nav-text">负载均衡分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">6.1.15.2.</span> <span class="nav-text">负载均衡算法：一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Webbench"><span class="nav-number">6.1.16.</span> <span class="nav-text">性能测试 Webbench</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFQPS%E5%92%8CTPS-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="nav-number">6.1.17.</span> <span class="nav-text">什么是QPS和TPS, 如何计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BB%B6%E8%BF%9F%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.1.18.</span> <span class="nav-text">访问服务端延迟高的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">6.1.19.</span> <span class="nav-text">如何定位服务器性能瓶颈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E6%8E%AA%E6%96%BD"><span class="nav-number">6.1.20.</span> <span class="nav-text">防止恶意请求，服务器端可以采取措施</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E5%8D%95%E4%B8%AAIP%E5%9C%B0%E5%9D%80%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">6.1.21.</span> <span class="nav-text">如何限制单个IP地址在特定时间内访问服务器的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%99%90%E6%B5%81"><span class="nav-number">6.1.22.</span> <span class="nav-text">服务器端限流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Raft%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">Raft算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%ADhandler%E5%92%8Csender"><span class="nav-number">6.2.1.</span> <span class="nav-text">分布式架构中handler和sender</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">6.2.2.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%91%E9%80%81-rpc-%E6%8E%A5%E6%94%B6-rpc-push-channel-receive-channel-%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E6%8C%81%E9%94%81"><span class="nav-number">6.2.3.</span> <span class="nav-text">为什么发送 rpc, 接收 rpc, push channel, receive channel 的时候一定不要持锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Raft%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1%E5%92%8CMake"><span class="nav-number">6.2.4.</span> <span class="nav-text">Raft节点设计和Make()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89leader"><span class="nav-number">6.2.5.</span> <span class="nav-text">选leader</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#handler"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">handler</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sender"><span class="nav-number">6.2.5.2.</span> <span class="nav-text">sender</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="nav-number">6.2.6.</span> <span class="nav-text">日志复制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#handler-1"><span class="nav-number">6.2.6.1.</span> <span class="nav-text">handler</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sender-1"><span class="nav-number">6.2.6.2.</span> <span class="nav-text">sender</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.2.6.3.</span> <span class="nav-text">复制模型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">6.2.7.</span> <span class="nav-text">日志压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#handler-2"><span class="nav-number">6.2.7.1.</span> <span class="nav-text">handler</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sender-2"><span class="nav-number">6.2.7.2.</span> <span class="nav-text">sender</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">工程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E7%94%A8htop%E5%8F%91%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%A8%E6%B6%A8"><span class="nav-number">6.3.1.</span> <span class="nav-text">检测内存泄漏(用htop发现虚拟内存在涨)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%B8%80-malloc-stats-%E5%92%8C-malloc-info-0-stdout"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">法一:  malloc_stats() 和 malloc_info(0, stdout)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">法二：宏定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%B8%89%EF%BC%9A-hook%E6%88%AA%E8%8E%B7malloc%E5%92%8Cfree-dlsym%E6%94%B9%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84"><span class="nav-number">6.3.1.3.</span> <span class="nav-text">法三： hook截获malloc和free, dlsym改成自定义的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E5%9B%9B%EF%BC%9A-mtrace"><span class="nav-number">6.3.1.4.</span> <span class="nav-text">法四： mtrace</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%93%BE%E6%8E%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%9C%89%E6%97%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">6.3.2.</span> <span class="nav-text">查看链接了哪些动态库和第三方库有无内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">c++程序崩溃定位方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#git-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%94%AF"><span class="nav-number">6.3.4.</span> <span class="nav-text">git 如何查看远程服务器分支</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%B8%8F%E2%83%A3%E5%85%B6%E4%BB%96"><span class="nav-number">7.</span> <span class="nav-text">6️⃣其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">智力题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B2%99%E6%BC%8F%E8%AE%A1%E6%97%B6%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.1.</span> <span class="nav-text">沙漏计时问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%83%E8%8D%AF%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.2.</span> <span class="nav-text">吃药片问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.3.</span> <span class="nav-text">老鼠毒药问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%B1%E5%AD%90%E5%BC%80%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.4.</span> <span class="nav-text">箱子开锁问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%BA%E9%AC%BC%E8%BF%87%E6%A1%A5%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.5.</span> <span class="nav-text">人鬼过桥问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%9B%E9%A9%AC%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%84%E9%A9%AC%E5%8C%B9"><span class="nav-number">7.1.6.</span> <span class="nav-text">赛马找最快的马匹</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#25%E5%8C%B9%E9%A9%AC5%E6%9D%A1%E8%B7%91%E9%81%93%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%843%E5%8C%B9%E9%A9%AC"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">25匹马5条跑道找最快的3匹马</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#64%E5%8C%B9%E9%A9%AC8%E6%9D%A1%E8%B7%91%E9%81%93%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC"><span class="nav-number">7.1.6.2.</span> <span class="nav-text">64匹马8条跑道找最快的4匹马</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">7.2.</span> <span class="nav-text">场景题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E9%97%AE"><span class="nav-number">7.3.</span> <span class="nav-text">反问</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
