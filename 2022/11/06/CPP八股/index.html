<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="C++八股">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股">
<meta property="og:url" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="C++八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060.png">
<meta property="article:published_time" content="2022-11-06T14:21:59.000Z">
<meta property="article:modified_time" content="2022-12-01T18:42:16.806Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++八股 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++八股
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 22:21:59" itemprop="dateCreated datePublished" datetime="2022-11-06T22:21:59+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-02 02:42:16" itemprop="dateModified" datetime="2022-12-02T02:42:16+08:00">2022-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C++八股</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="C-x2F-C-基础"><a href="#C-x2F-C-基础" class="headerlink" title="C&#x2F;C++基础"></a>C&#x2F;C++基础</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><h5 id="简述下C-语言的特点"><a href="#简述下C-语言的特点" class="headerlink" title="简述下C++语言的特点"></a>简述下C++语言的特点</h5><ol>
<li><p>C++在C语言基础上引入了<strong>面对对象(三大特性:封装、继承、多态)<strong>的机制，同时也</strong>兼容C语言</strong></p>
</li>
<li><p>C++运行<strong>效率高</strong>，仅比汇编语言慢10%～20%</p>
</li>
<li><p>C++更加安全, 增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try catch</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dymatic_cast</span>&lt;type&gt;(a) <span class="comment">// 用于类之间的转型，满足2种形式，同一个类型，或者为父子关系，运行期间会做检查，转型失败会返回0并抛出bad_cast.</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(a) <span class="comment">// 这个其实和传统的C语言的强制转换是一样的，它不会做任何检查，如果转型失败就会发生未知错误。</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;type&gt;(a) <span class="comment">// 把a从const型转为非const型，常用于函数重载</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;type&gt;(a) <span class="comment">// 可进行任意转型，把a中的内存按找type的方式来解读，需要程序员保证转换的正确性。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）</p>
</li>
<li><p>C++是<strong>不断在发展</strong>的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda函数、右值引用、智能指针</p>
</li>
</ol>
<hr>
<h5 id="说说C语言和C-的区别"><a href="#说说C语言和C-的区别" class="headerlink" title="说说C语言和C++的区别"></a>说说C语言和C++的区别</h5><ol>
<li><p>C++<strong>面对对象</strong>；C是<strong>面对过程</strong></p>
</li>
<li><p>C是C++的子集，但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等</p>
</li>
<li><p>C不安全，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++<strong>更安全</strong>，如const常量、引用、cast转换、智能指针、try catch</p>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，实现了STL。相对于C语言的函数库<strong>更灵活、更通用</strong>。</p>
</li>
</ol>
<hr>
<h5 id="说说-C-中-struct-和-class-的区别"><a href="#说说-C-中-struct-和-class-的区别" class="headerlink" title="说说 C++中 struct 和 class 的区别"></a>说说 C++中 struct 和 class 的区别</h5><ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">  <span class="type">int</span> iNum; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;  </span><br><span class="line">  <span class="type">int</span> iNum; <span class="comment">// 默认访问控制权限是 private </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 默认是公有继承，而 class 是私有继承</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Y&amp; y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说头文件双引号””和尖括号-lt-gt-的区别"><a href="#说说头文件双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说头文件双引号””和尖括号&lt;&gt;的区别"></a>说说头文件双引号””和尖括号&lt;&gt;的区别</h5><ul>
<li>尖括号&lt;&gt;的头文件是<strong>系统文件</strong>，双引号””的头文件是<strong>自定义文件</strong></li>
<li>编译器预处理阶段查找头文件的路径不一样<ul>
<li>使用&lt;&gt;的头文件：编译器设置的头文件路径 -&gt; 系统变量</li>
<li>使用””的头文件：当前头文件目录 -&gt; 编译器设置的头文件路径 -&gt; 系统变量</li>
</ul>
</li>
</ul>
<hr>
<h5 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h5><ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制权限</td>
<td align="center">默认public，不能修改</td>
<td align="center">public&#x2F;private&#x2F;protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可从类或者其他结构体继承</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;  </span><br><span class="line">  <span class="type">int</span>  iAgeNum;  </span><br><span class="line">  string strName; </span><br><span class="line">&#125; <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Student2; <span class="comment">//C中取别名  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1; <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line"></span><br><span class="line">Student stu3;  <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="导入C函数的关键字？C-编译时和C有何不同？"><a href="#导入C函数的关键字？C-编译时和C有何不同？" class="headerlink" title="导入C函数的关键字？C++编译时和C有何不同？"></a>导入C函数的关键字？C++编译时和C有何不同？</h5><ol>
<li><p><strong>关键字：</strong>在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为<strong>extern “C”</strong>。加上extern “C”后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而非C++的</p>
</li>
<li><p><strong>编译区别：</strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时只包括<strong>函数名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述C-从代码到可执行文件过程"><a href="#简述C-从代码到可执行文件过程" class="headerlink" title="简述C++从代码到可执行文件过程"></a>简述C++从代码到可执行文件过程</h5><p> C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>
<ol>
<li><p>预编译</p>
<p>（1） 将所有的#define删除，并且展开所有的宏定义</p>
<p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p>
<p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p>
<p>（4） 过滤所有的注释</p>
<p>（5） 添加行号和文件名标识</p>
</li>
<li><p>编译</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树</p>
<p>（3） 语义分析：判断表达式是否有意义</p>
<p>（4） 代码优化</p>
<p>（5） 生成汇编代码</p>
</li>
<li><p>汇编    将汇编代码 -&gt; 机器码</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>
<p>链接分为静态链接和动态链接。</p>
<p>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p>
<p>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p>
</li>
</ol>
<hr>
<h5 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h5><ol>
<li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li>
<li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。</li>
<li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li>
<li><strong>静态成员函数和静态成员变量</strong>是类的一部分，可以被多个对象所共享，无法对一个对象中的非静态成员进行访问。</li>
</ol>
<hr>
<h5 id="说说静态变量什么时候初始化"><a href="#说说静态变量什么时候初始化" class="headerlink" title="说说静态变量什么时候初始化"></a>说说静态变量什么时候初始化</h5><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</p>
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</p>
<hr>
<h5 id="说说静态局部变量-全局变量-局部变量的特点"><a href="#说说静态局部变量-全局变量-局部变量的特点" class="headerlink" title="说说静态局部变量,全局变量,局部变量的特点"></a>说说静态局部变量,全局变量,局部变量的特点</h5><ol>
<li><p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p>
<p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</p>
<p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p>
<p>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</p>
<p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p>
</li>
<li><p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p>
</li>
<li><p><strong>生命周期</strong>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p>
</li>
</ol>
<hr>
<h5 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h5><ol>
<li><p>概念：</p>
<p>（1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 </p>
<p>（2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在<strong>内存中的地址</strong>。 指针名指向了内存的首地址。 </p>
</li>
<li><p>区别：</p>
<p>（1）<strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p>
<p>（2）<strong>存储方式</strong>：</p>
<p>  数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。</p>
<p>  指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>
<p>（3）<strong>求sizeof</strong>：</p>
<p>  数组所占存储空间的内存大小：sizeof（数组名）&#x2F;sizeof（数据类型）</p>
<p>  在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，sizeof(指针名)都是8。</p>
</li>
</ol>
<hr>
<h5 id="说说什么是函数指针"><a href="#说说什么是函数指针" class="headerlink" title="说说什么是函数指针"></a>说说什么是函数指针</h5><ol>
<li><strong>概念：</strong>函数指针就是<strong>指向函数</strong>的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li>
<li><strong>定义</strong>形式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in">int</span> (*f)(<span class="type">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compar)(<span class="type">const</span> <span class="type">void</span> *,<span class="type">const</span> <span class="type">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a , <span class="type">const</span> <span class="type">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in">sizeof</span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="nullptr可以调用成员函数吗？为什么？"><a href="#nullptr可以调用成员函数吗？为什么？" class="headerlink" title="nullptr可以调用成员函数吗？为什么？"></a>nullptr可以调用成员函数吗？为什么？</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以，因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this&#x3D;nullptr，运行出错。</p>
<hr>
<h5 id="说说使用指针需要注意什么"><a href="#说说使用指针需要注意什么" class="headerlink" title="说说使用指针需要注意什么"></a>说说使用指针需要注意什么</h5><ol>
<li>定义指针时，先初始化为NULL。</li>
<li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</li>
<li>不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</li>
<li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li>
<li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li>
<li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li>
</ol>
<hr>
<h5 id="说说什么是野指针-怎么产生的-如何避免？"><a href="#说说什么是野指针-怎么产生的-如何避免？" class="headerlink" title="说说什么是野指针,怎么产生的,如何避免？"></a>说说什么是野指针,怎么产生的,如何避免？</h5><ol>
<li><p><strong>概念：</strong>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</li>
<li><p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免办法：</strong></p>
<p>（1）初始化置NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置NULL</p>
<p>（4）使用智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说内联函数和函数的区别-内联函数的作用"><a href="#说说内联函数和函数的区别-内联函数的作用" class="headerlink" title="说说内联函数和函数的区别,内联函数的作用"></a>说说内联函数和函数的区别,内联函数的作用</h5><ol>
<li>内联函数比普通函数多了关键字<strong>inline</strong></li>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p>   <strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<hr>
<h5 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h5><ol>
<li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身</li>
<li><strong>宏函数</strong>是在预编译的时候字符串替换 ；<strong>而内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开</li>
<li><strong>宏定义</strong>是没有类型检查的，无论对还是错都是直接替换；<strong>而内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li>
</ol>
<hr>
<h5 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i++和++i的区别"></a>说说运算符i++和++i的区别</h5><ol>
<li><p><strong>效率不同</strong>：后置++执行速度比前置的慢</p>
</li>
<li><p><strong>i++ 不能作为左值，而++i 可以</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// int* p2 = &amp;(i++);//错误</span></span><br><span class="line">++i = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// i++ = 1;//错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说new和malloc的区别，各自底层实现原理"><a href="#说说new和malloc的区别，各自底层实现原理" class="headerlink" title="说说new和malloc的区别，各自底层实现原理"></a>说说new和malloc的区别，各自底层实现原理</h5><ol>
<li>new分配的内存空间所在位置是自由存储区，而malloc在堆上动态分配内存。自由存储区不仅可以是堆，还可以是静态存储区</li>
<li>new是操作符，而malloc是函数。</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li>
<li>new可以被重载；malloc不行</li>
<li>new分配内存更直接和安全。</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap()。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<p> (1) 创建一个新的对象</p>
<p> (2) 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
<p> (3) 执行构造函数（为这个新对象添加属性）</p>
<p> (4) 返回新对象</p>
<hr>
<h5 id="说说const和define的区别。"><a href="#说说const和define的区别。" class="headerlink" title="说说const和define的区别。"></a>说说const和define的区别。</h5><p>const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。区别有：</p>
<ol>
<li>const生效于编译的阶段；define生效于预处理阶段。</li>
<li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</li>
<li>const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</li>
</ol>
<hr>
<h5 id="说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a"><a href="#说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a" class="headerlink" title="说说const int *a, int const *a, const int a, int *const a, const int *const a"></a>说说const int *a, int const *a, const int a, int *const a, const int *const a</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">const</span> <span class="type">int</span> a;     <span class="comment">// 指的是a是一个常量，不允许修改</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// 同 const int *a;</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="number">5.</span> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> a;   <span class="comment">// 都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述C-有几种传值方式-区别是什么？"><a href="#简述C-有几种传值方式-区别是什么？" class="headerlink" title="简述C++有几种传值方式,区别是什么？"></a>简述C++有几种传值方式,区别是什么？</h5><ol>
<li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值</li>
<li>引用传递：形参在函数体内值发生变化，会影响实参的值</li>
<li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值</li>
</ol>
<blockquote>
<p>  值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> *b, <span class="type">int</span> &amp;c)</span></span>&#123;<span class="comment">//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    (*b) += <span class="number">1</span>;</span><br><span class="line">    c += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a= %d, b= %d, c= %d\n&quot;</span>,a,*b,c);<span class="comment">//a= 2, b= 2, c= 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *j = &amp;a;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testfunc</span>(i, j, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d, k= %d\n&quot;</span>,i,*j,k);<span class="comment">//i= 1, j= 2, k= 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h4><h5 id="进程运行时虚拟地址空间"><a href="#进程运行时虚拟地址空间" class="headerlink" title="进程运行时虚拟地址空间"></a>进程运行时虚拟地址空间</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png" alt="img" style="zoom: 67%;">

<ol>
<li><p><strong>data段：</strong>已初始化的全局变量和静态变量</p>
</li>
<li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</p>
</li>
<li><p><strong>bss段</strong>：未初始化的全局变量和静态变量</p>
</li>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中</li>
<li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。调用动态链接库的初始化函数</li>
<li>初始化应用程序的全局变量，对于全局对象自动调用构造函数</li>
<li>进入应用程序入口点函数开始执行</li>
</ol>
<p><strong>怎么判断数据分配在栈上还是堆上：</strong></p>
<p> malloc或new是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。</p>
<hr>
<h5 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h5><ol>
<li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li>
<li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li>
<li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li>
</ol>
<hr>
<h5 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h5><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p>
<p><strong>堆</strong>，就是那些由new分配的内存块，一般一个new就要对应一个delete。</p>
<p><strong>自由存储区</strong>，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。</p>
<p><strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
</li>
<li><p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）内存分配未成功，却使用了它。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>（5）释放了内存却继续使用它。</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为NULL</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用</p>
<p>（4）避免数字或指针的下标<strong>越界</strong></p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针</p>
</li>
<li><p><strong>内存泄露及解决办法</strong>：</p>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
</li>
</ol>
<hr>
<h5 id="请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</h5><p>局部常量，存放在栈区；</p>
<p>全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</p>
<p>字面值常量，比如字符串，放在常量区。</p>
<hr>
<h5 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h5><p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong>，对齐原则有四个：</p>
<ol>
<li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li>
<li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</li>
<li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li>
</ol>
<hr>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><h5 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h5><p>面向对象的三大特征是封装、继承、多态。</p>
<ol>
<li><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。不想给别人看到的，我们使用protected&#x2F;private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>
</li>
<li><p>继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。三种继承方式：</p>
<table>
<thead>
<tr>
<th align="left">继承方式</th>
<th align="left">private继承</th>
<th align="left">protected继承</th>
<th align="left">public继承</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基类的private成员</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
</tr>
<tr>
<td align="left">基类的protected成员</td>
<td align="left">变为private成员</td>
<td align="left">仍为protected成员</td>
<td align="left">仍为protected成员</td>
</tr>
<tr>
<td align="left">基类的public成员</td>
<td align="left">变为private成员</td>
<td align="left">变为protected成员</td>
<td align="left">仍为public成员</td>
</tr>
</tbody></table>
</li>
<li><p>多态：用父类型别的指针指向其子类的实例，然后<strong>通过父类的指针调用实际子类的成员函数</strong>。实现多态，有二种方式，重写，重载。</p>
</li>
</ol>
<hr>
<h5 id="成员访问限定符"><a href="#成员访问限定符" class="headerlink" title="成员访问限定符"></a>成员访问限定符</h5><table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">权限</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">可以被任意实体访问</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">只允许子类及本类的成员函数访问</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">只允许本类的成员函数访问</td>
</tr>
</tbody></table>
<hr>
<h5 id="简述一下-C-重载和重写"><a href="#简述一下-C-重载和重写" class="headerlink" title="简述一下 C++重载和重写"></a>简述一下 C++重载和重写</h5><ul>
<li><p>重写:是指派生类中存在重新定义的函数。</p>
<p>其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>基类中被重写的函数必须有virtual修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A&quot;</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B&quot;</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a -&gt; <span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载</p>
<p>在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个<strong>具有不同参数列（参数的类型，个数，顺序不同）的同名函数</strong>，根据参数列表确定调用哪个函数，重载不关心函数返回类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;;     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="说说-C-重载和重写是如何实现的"><a href="#说说-C-重载和重写是如何实现的" class="headerlink" title="说说 C++ 重载和重写是如何实现的"></a>说说 C++ 重载和重写是如何实现的</h5><ul>
<li><p>重写</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数</li>
<li>有虚函数的类都有个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。</li>
<li><strong>多态</strong>性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性</li>
<li>重写用虚函数来实现，结合动态绑定</li>
<li>纯虚函数是虚函数再加上 &#x3D; 0</li>
<li>抽象类是指包括至少一个纯虚函数的类</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容</strong></p>
</li>
<li><p>重载</p>
<p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
</li>
</ul>
<hr>
<h5 id="说说C-构造函数有几种"><a href="#说说C-构造函数有几种" class="headerlink" title="说说C++构造函数有几种"></a>说说C++构造函数有几种</h5><p>C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li><p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="comment">//默认构造函数  </span></span><br><span class="line">        <span class="built_in">Student</span>()&#123; </span><br><span class="line">            num=<span class="number">1001</span>;        </span><br><span class="line">            age=<span class="number">18</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//初始化构造函数  </span></span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">int</span> a):<span class="built_in">num</span>(n),<span class="built_in">age</span>(a)&#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="type">int</span> num;  </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//用默认构造函数初始化对象S1  </span></span><br><span class="line">    Student s1;  </span><br><span class="line">    <span class="comment">//用初始化构造函数初始化对象S2  </span></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">18</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li><p>复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;     </span><br><span class="line">    <span class="type">int</span> i;     </span><br><span class="line">    <span class="type">int</span> *p; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> value)&#123;         </span><br><span class="line">            i = ai;         </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">int</span>(value);     </span><br><span class="line">        &#125;     </span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;         </span><br><span class="line">            <span class="keyword">delete</span> p;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t)&#123;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;i = t.i;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*t.p);     </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//复制构造函数用于复制本类的对象 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;     </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;     </span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制构造函数默认实现的是值拷贝（浅拷贝）</p>
</li>
<li><p>移动构造函数</p>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷</p>
<p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</p>
<p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)&#123; <span class="comment">// &amp;&amp; 是右值引用 	int num = 10;  int &amp;&amp; a = 10;     </span></span><br><span class="line">		p = a.p;</span><br><span class="line">		a.p = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ch;</span><br><span class="line">	<span class="function">Test <span class="title">c</span><span class="params">(move(p))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="拷贝构造函数的参数是什么传递方式-为什么"><a href="#拷贝构造函数的参数是什么传递方式-为什么" class="headerlink" title="*拷贝构造函数的参数是什么传递方式,为什么"></a>*拷贝构造函数的参数是什么传递方式,为什么</h5><ol>
<li><p>拷贝构造函数的参数必须使用引用传递</p>
</li>
<li><p>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p>
<p>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p>
</li>
</ol>
<hr>
<h5 id="拷贝构造和移动构造的不同"><a href="#拷贝构造和移动构造的不同" class="headerlink" title="拷贝构造和移动构造的不同"></a>拷贝构造和移动构造的不同</h5><p>拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针</p>
<hr>
<h5 id="只定义析构函数-会自动生成哪些构造函数"><a href="#只定义析构函数-会自动生成哪些构造函数" class="headerlink" title="只定义析构函数,会自动生成哪些构造函数"></a>只定义析构函数,会自动生成哪些构造函数</h5><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<blockquote>
<p>  默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作</p>
</blockquote>
<hr>
<h5 id="一个类默认会生成哪些函数"><a href="#一个类默认会生成哪些函数" class="headerlink" title="一个类默认会生成哪些函数"></a>一个类默认会生成哪些函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认会生成以下几个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无参的构造函数</span></span><br><span class="line"><span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.拷贝构造函数</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值运算符</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.析构函数（非虚）</span></span><br><span class="line">~<span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-C-类对象的初始化顺序-有多重继承情况下的顺序"><a href="#说说-C-类对象的初始化顺序-有多重继承情况下的顺序" class="headerlink" title="说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序"></a>说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序</h5><p>父类构造函数 –&gt; 成员类对象构造函数 –&gt; 自身构造函数</p>
<blockquote>
<p>  其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序</p>
<p>  析构顺序和构造顺序相反</p>
</blockquote>
<hr>
<h5 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h5><ol>
<li><p>子类转换为父类：向上转型，使用<code>dynamic_cast&lt;type_id&gt;(expression)</code>，这种转换相对来说比较安全不会有数据的丢失；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用场景：我们想使用基类对象的指针或引用来调用某个派生类的操作，并且该操作不是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base *Pb = <span class="keyword">new</span> Derived;</span><br><span class="line">	Derived* Pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(Pb);</span><br><span class="line">	Pd-&gt;<span class="built_in">func</span>();  <span class="comment">//将输出hello world!	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</p>
</li>
</ol>
<hr>
<h5 id="简述下深拷贝和浅拷贝-如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝-如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝, 如何实现深拷贝"></a>简述下深拷贝和浅拷贝, 如何实现深拷贝</h5><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<p>深拷贝的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STRING</span>(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法1:拷贝构造函数</span></span><br><span class="line">    <span class="comment">//_str = s._str;</span></span><br><span class="line">    _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法2: 赋值运算符的重载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png" alt="img" style="zoom:50%;">

<hr>
<h5 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h5><ol>
<li><p>多态成员变量:编译运行看左边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f.num &lt;&lt; endl; <span class="comment">// 取Fu中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态成员方法:编译看左边,运行看右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu f1 = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f1.<span class="built_in">show</span>() &lt;&lt; endl; <span class="comment">// 实际类型是Zi,调用的是子类重写后的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说为什么要虚析构-为什么不能虚构造"><a href="#说说为什么要虚析构-为什么不能虚构造" class="headerlink" title="说说为什么要虚析构, 为什么不能虚构造"></a>说说为什么要虚析构, 为什么不能虚构造</h5><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，</p>
<p>可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。</strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li><p>不能虚构造：</p>
<ol>
<li>从存储空间角度：虚函数需要一个虚表存储, 这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到虚表中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</li>
</ol>
</li>
</ol>
<hr>
<h5 id="说说模板类"><a href="#说说模板类" class="headerlink" title="说说模板类"></a>说说模板类</h5><ol>
<li>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
<li>模板具体化：<strong>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化</strong>。具体化时可以修改原模板的定义</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">sizeof</span>(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">int</span>&gt; intStruct; <span class="comment">// 4</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">double</span>&gt; doubleStruct; <span class="comment">// --8--</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">char</span>&gt; llStruct; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++ 类内可以定义引用数据成员吗？"></a>C++ 类内可以定义引用数据成员吗？</h5><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p>
<ol>
<li>不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误</li>
<li>构造函数的形参也必须是引用类型</li>
<li>不能在构造函数里初始化，必须在初始化列表中进行初始化 （冒号后的就叫初始化列表）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> &amp;target) :<span class="built_in">a</span>(target)&#123;  <span class="comment">//初始化列表</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;</span><br><span class="line">	r.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line">	<span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">	r1.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述一下什么是常函数，有什么作用"><a href="#简述一下什么是常函数，有什么作用" class="headerlink" title="简述一下什么是常函数，有什么作用"></a>简述一下什么是常函数，有什么作用</h5><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。</p>
<p>在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；</p>
<p>没有 const 修饰的成员函数，对数据成员则是可读可写的。</p>
<p>除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">CStu</span>()&#123;</span><br><span class="line">        a = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//a = 13; //常函数不能修改数据成员</span></span><br><span class="line">        cout &lt;&lt;a &lt;&lt; <span class="string">&quot;I am show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CStu st;</span><br><span class="line">    st.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-C-中什么是菱形继承问题，如何解决"><a href="#说说-C-中什么是菱形继承问题，如何解决" class="headerlink" title="说说 C++ 中什么是菱形继承问题，如何解决"></a>说说 C++ 中什么是菱形继承问题，如何解决</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png" alt="img" style="zoom:25%;">

<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  *Animal类对应于图表的类A* */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;     </span><br><span class="line">    <span class="type">int</span> weight;      </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> weight; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Liger</span> : <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Liger lg;   <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span>   </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>();  <span class="comment">//   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象”lg”会包含Animal基类的两个子对象。</p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用”lg.getWeight()”将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</p>
</li>
<li><p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;  <span class="comment">// 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了”virtual”关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Liger lg;  <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>  </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说什么是虚继承"><a href="#说说什么是虚继承" class="headerlink" title="说说什么是虚继承"></a>说说什么是虚继承</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/King_weng/article/details/112180275?ops_request_misc=&request_id=&biz_id=102&utm_term=C++%20%E8%99%9A%E7%BB%A7%E6%89%BF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-112180275.nonecase&spm=1018.2226.3001.4187">传送门</a></p>
<hr>
<h5 id="简述一下虚函数和纯虚函数-以及实现原理"><a href="#简述一下虚函数和纯虚函数-以及实现原理" class="headerlink" title="简述一下虚函数和纯虚函数, 以及实现原理"></a><strong>简述一下虚函数和纯虚函数, 以及实现原理</strong></h5><p>C++中的虚函数的作用主要是实现了多态的机制</p>
<p>关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。<strong>虚函数必须是基类的非静态成员函数</strong></p>
<p>在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，<strong>在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型</strong>, 以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;PersonName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">    <span class="comment">//基类调用子类的函数</span></span><br><span class="line">    person-&gt;<span class="built_in">GetName</span>();<span class="comment">//StudentName:xiaosi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但<strong>要求任何派生类都要定义自己的实现方法</strong>。<strong>将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象</strong></p>
<p>所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h5><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li>
<li>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</li>
<li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li>
<li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</li>
<li>虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } &#x3D; 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li>
</ol>
<hr>
<h5 id="仿函数了解吗？有什么作用"><a href="#仿函数了解吗？有什么作用" class="headerlink" title="仿函数了解吗？有什么作用"></a>仿函数了解吗？有什么作用</h5><ol>
<li>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Func myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;helloworld!</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：假设有一个vector<string>,你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：</string></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LengthIsLessThanFive</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()&lt;<span class="number">5</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res=<span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), LengthIsLessThanFive);</span><br></pre></td></tr></table></figure>

<p>其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LenthIsLessThan</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterThan</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ShorterThan</span><span class="params">(<span class="type">int</span> maxLength)</span> : length(maxLength) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; length;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-友元函数和友元类（-friend）详解"><a href="#C-友元函数和友元类（-friend）详解" class="headerlink" title="C++友元函数和友元类（ friend）详解"></a>C++友元函数和友元类（ friend）详解</h5><p>C++ 设计者认为， 如果有的程序员真的非常怕麻烦，就是想在类的成员函数外部直接访问对象的私有成员，那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++ 就有了<strong>友元（friend）</strong>的概念。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span>  返回值类型  函数名(参数表); <span class="comment">//将全局函数声明为友元</span></span><br><span class="line"><span class="keyword">friend</span>  返回值类型  其他类的类名::成员函数名(参数表); <span class="comment">//将其他类的成员函数声明为友元</span></span><br><span class="line"><span class="comment">// 但是，不能把其他类的私有成员函数声明为友元</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>;  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-中哪些函数不能被声明为虚函数"><a href="#C-中哪些函数不能被声明为虚函数" class="headerlink" title="C++ 中哪些函数不能被声明为虚函数"></a>C++ 中哪些函数不能被声明为虚函数</h5><p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>略</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<hr>
<h5 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h5><p>模板的声明或定义只能在全局，命名空间或类范围内进行。</p>
<p>不能在局部范围，函数内进行，比如不能在<strong>main</strong>函数中声明或定义一个模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ClassName 的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替</span></span><br><span class="line">ClassName A = <span class="keyword">new</span> <span class="built_in">ClassName</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h4><h5 id="请说说-STL-的基本组成部分"><a href="#请说说-STL-的基本组成部分" class="headerlink" title="请说说 STL 的基本组成部分"></a>请说说 STL 的基本组成部分</h5><p> 标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p>  <strong>广义上讲</strong>，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。</p>
<p>  <strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）</p>
<ol>
<li><p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了操作符的struct</p>
</li>
<li><p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3种适配器：Container Adaptor、Iterator Adaptor、Function Adaptor</p>
</li>
<li><p>空间配制器（Allocator）</p>
<p> 为STL提供空间配置的系统。其中主要工作包括两部分</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<hr>
<h5 id="请说说-STL-中常见的容器-并介绍一下实现原理"><a href="#请说说-STL-中常见的容器-并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器, 并介绍一下实现原理"></a>请说说 STL 中常见的容器, 并介绍一下实现原理</h5><ol>
<li><strong>序列式容器</strong></li>
</ol>
<p>所谓序列式容器，其中的元素都是可序的，但是未必都是有序的</p>
<p>（1）vector ：动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
<p>（2）deque ：双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能</p>
<p>（3）list ：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取</p>
<ol start="2">
<li><strong>关联式容器</strong></li>
</ol>
<p>关联式容器，每笔数据（每个数据）都有一个键值（key）和一个实值（value）</p>
<p>特点：<br>  当元素被插入到关联式容器中时，容器内部数据结构（RB-tree或hash-table等）依据其键值大小，以某种特定规则将这个元素放置于适当位置；<br>  关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()、begin()、end()等操作。</p>
<p>底层实现：<br>  关联式容器的内部结构是一个balanced binary tree（平衡二叉树），以便获得良好的搜索效率。balanced binary tree有许多种类，包括AVL-tree、RB-tree、AA-tree，其中最被广泛应用于STL的是RB-tree（红黑树）。<br>  set、map、multiset、multimap底层均以RB-tree（红黑树）完成。RB-tree（红黑树）也是一个独立容器，但并不开放给外界使用。</p>
<p>（1）set&#x2F;multiset ：set 即集合。set中不允许相同元素，multiset中允许存在相同元素</p>
<p>（2）map&#x2F;multimap ：map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素</p>
<ol start="3">
<li><strong>容器适配器</strong></li>
</ol>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个stack。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。stack和queue基于deque实现，priority_queue基于vector实现</p>
<p>（1）stack  </p>
<p>（2）queue ：队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p>
<p>（3）priority_queue：优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p>
<hr>
<h5 id="说说-STL-中-map、hashtable、deque、list-的实现原理"><a href="#说说-STL-中-map、hashtable、deque、list-的实现原理" class="headerlink" title="说说 STL 中 map、hashtable、deque、list 的实现原理"></a>说说 STL 中 map、hashtable、deque、list 的实现原理</h5><p>map（红黑树）、hashtable（函数映射）、deque（双向队列）、list（双向链表）</p>
<ol>
<li><p>map实现原理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作</p>
</li>
<li><p>hashtable（也称散列表，直译作哈希表）实现原理</p>
<p>hashtable采用了<strong>函数映射的思想</strong>记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找</p>
</li>
</ol>
<hr>
<h5 id="两种C-类对象实例化方式的异同"><a href="#两种C-类对象实例化方式的异同" class="headerlink" title="两种C++类对象实例化方式的异同"></a>两种C++类对象实例化方式的异同</h5><ol>
<li>在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过new来实例化一个类对象，如 Test *pTest &#x3D; new Test；那么，这两种方式有什么异同点呢？</li>
</ol>
<pre><code>我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。



那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间

（2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间
</code></pre>
<hr>
<h5 id="迭代器用过吗？什么时候会失效？"><a href="#迭代器用过吗？什么时候会失效？" class="headerlink" title="迭代器用过吗？什么时候会失效？"></a>迭代器用过吗？什么时候会失效？</h5><ol>
<li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li>
<li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</li>
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</li>
</ol>
<hr>
<h5 id="说一下STL中迭代器的作用-有指针为何还要迭代器？"><a href="#说一下STL中迭代器的作用-有指针为何还要迭代器？" class="headerlink" title="说一下STL中迭代器的作用, 有指针为何还要迭代器？"></a>说一下STL中迭代器的作用, 有指针为何还要迭代器？</h5><ol>
<li><p>迭代器的作用</p>
<p>（1）用于指向顺序容器和关联容器中的元素</p>
<p>（2）通过迭代器可以读取它指向的元素</p>
<p>（3）通过非const迭代器还可以修改其指向的元素</p>
</li>
<li><p>迭代器和指针的区别</p>
<p>  <strong>迭代器不是指针，是类模板，表现的像指针。</strong>他只是模拟了指针的一些功能，重载了指针的一些操作符，++、–等。迭代器本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li><p>迭代器产生的原因</p>
<p>  Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//一个存放int元素的数组，一开始里面没有元素  </span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator i; <span class="comment">//常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//v.begin()表示v第一个元素迭代器指针，++i指向下一个元素   </span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//*i表示迭代器指向的元素  </span></span><br><span class="line">    cout &lt;&lt; endl;   </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator r; <span class="comment">//反向迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (r = v.<span class="built_in">rbegin</span>(); r != v.<span class="built_in">rend</span>(); r++)   </span><br><span class="line">        cout &lt;&lt; *r &lt;&lt; <span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator j; <span class="comment">//非常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (j = v.<span class="built_in">begin</span>();j != v.<span class="built_in">end</span>();j++)   </span><br><span class="line">        *j = <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();i++)   </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      运行结果：   1,2,3,4,   4,3,2,1,   100,100,100,100, */</span> </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-STL-中-resize-和-reserve-的区别"><a href="#说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="说说 STL 中 resize 和 reserve 的区别"></a>说说 STL 中 resize 和 reserve 的区别</h5><ol>
<li><p>首先必须弄清楚两个概念：</p>
<p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象</p>
<p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</p>
</li>
<li><p>resize和reserve区别主要有以下几点：</p>
<p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert()或push_back()等创建对象</p>
<p>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小</p>
<p>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值(默认为0);reserve只带一个参数，表示容器预留的大小</p>
</li>
</ol>
<hr>
<h5 id="说说-map和-unordered-map-的区别"><a href="#说说-map和-unordered-map-的区别" class="headerlink" title="说说 map和 unordered_map 的区别"></a>说说 map和 unordered_map 的区别</h5><ol>
<li><p>map实现机理</p>
<p>  map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照BST存储的，使用中序遍历可将键值按照从小到大遍历出来</p>
</li>
<li><p>unordered_map实现机理</p>
<p>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O(1)，其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的</p>
</li>
</ol>
<hr>
<h5 id="说说-vector-和-list-的区别-分别适用于什么场景？"><a href="#说说-vector-和-list-的区别-分别适用于什么场景？" class="headerlink" title="说说 vector 和 list 的区别, 分别适用于什么场景？"></a>说说 vector 和 list 的区别, 分别适用于什么场景？</h5><p><strong>vector：一维数组</strong></p>
<p>  特点：在堆中分配内存，动态数组，元素连续存放，有保留内存，如果减少大小后内存也不会释放</p>
<p>  扩容方式：</p>
<blockquote>
<p>  （1）当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加</p>
<p>  （2）新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同</p>
</blockquote>
<p>  优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)</p>
<p>  缺点：由于开辟一段连续的空间, 所以插入删除会需要对数据进行移动比较麻烦, 时间复杂度O(n), 另外当空间不足时还需要进行扩容</p>
<p>  <strong>list：双向链表</strong></p>
<p>  特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问</p>
<p>  优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)</p>
<p>  缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n), 没有提供[]操作符的重载</p>
<hr>
<h5 id="vector-的-部分STL-源码"><a href="#vector-的-部分STL-源码" class="headerlink" title="vector 的 部分STL 源码"></a>vector 的 部分STL 源码</h5><p>  vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li><p>新增元素</p>
<p>  Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index&#x3D;iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="type">const</span> T&amp; t )</span> </span>&#123;    </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_)&#123;   </span><br><span class="line">        <span class="keyword">if</span> (size_==capacity_)&#123;    </span><br><span class="line">            <span class="type">int</span> capa=<span class="built_in">calculateCapacity</span>();    </span><br><span class="line">            <span class="built_in">newCapacity</span>(capa);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="built_in">sizeof</span>(T));    </span><br><span class="line">        buf[index]=t;   </span><br><span class="line">        size_++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<p> 删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index&#x3D;iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素  </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();      </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)&#123;         </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="built_in">sizeof</span>(T));          </span><br><span class="line">        buf[--size_]=<span class="built_in">T</span>();     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述-STL-中的-map-的实现原理"><a href="#简述-STL-中的-map-的实现原理" class="headerlink" title="简述 STL 中的 map 的实现原理"></a>简述 STL 中的 map 的实现原理</h5><p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>map的特性如下</p>
<p>（1）map以RBTree作为底层容器；</p>
<p>（2）所有元素都是键+值存在；</p>
<p>（3）不允许键重复；</p>
<p>（4）所有元素是通过键进行自动排序的；</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p>
<hr>
<h5 id="说下-map-和-set-有什么区别-分别是怎么实现的？"><a href="#说下-map-和-set-有什么区别-分别是怎么实现的？" class="headerlink" title="说下 map 和 set 有什么区别, 分别是怎么实现的？"></a>说下 map 和 set 有什么区别, 分别是怎么实现的？</h5><p>同：</p>
<ol>
<li>都是一种关联式容器</li>
<li>以RBTree作为底层容器</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
</ol>
<p>不同：</p>
<ol>
<li><p>set的元素的只有key没有value，value就是key</p>
</li>
<li><p>不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</p>
</li>
<li><p>map中所有元素都是键+值存在</p>
</li>
<li><p>map的键是不能修改的，但是其键对应的值是可以修改的</p>
</li>
</ol>
<hr>
<h5 id="说说-push-back-和-emplace-back-的区别"><a href="#说说-push-back-和-emplace-back-的区别" class="headerlink" title="说说 push_back 和 emplace_back 的区别"></a>说说 push_back 和 emplace_back 的区别</h5><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p>
<hr>
<h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h4><h5 id="说说-C-11-的新特性有哪些"><a href="#说说-C-11-的新特性有哪些" class="headerlink" title="说说 C++11 的新特性有哪些"></a>说说 C++11 的新特性有哪些</h5><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）统一的初始化方法</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字  用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针 shared_ptr</p>
<p>（6）空指针 nullptr（原来NULL）</p>
<p>（7）基于范围的for循环</p>
<p>（8）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）无序容器（哈希表）用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）Lambda表达式</p>
</li>
</ol>
<p><strong>详细：</strong></p>
<ol>
<li><p>统一的初始化方法</p>
<p>  C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>  <strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;     </span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private     </span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;     </span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;     </span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;     </span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<strong>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</strong></p>
</li>
<li><p>成员变量默认初始化</p>
<p>好处：构建一个类的对象不需要用构造函数初始化成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值  </span></span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    B b;  </span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字  </p>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;     </span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();   <span class="comment">// auto i = v.begin();  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义迭代器 i 的时候, 类型书写比较冗长, 容易出错。然而有了 auto 类型推导, 我们大可不必这样, 只写一个 auto 即可</p>
</li>
<li><p>decltype  求表达式的类型</p>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>(1)为什么要有decltype</p>
<p>因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value; <span class="keyword">decltype</span>(exp) varname = value;</span><br></pre></td></tr></table></figure>

<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p>
<p>auto 根据”&#x3D;”右边的初始值 value 推导出变量的类型; decltype 根据 exp 表达式推导出变量的类型, 跟”&#x3D;”右边的 value 没关系</p>
<p>另外，auto 要求变量必须初始化，而 decltype 不要求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<p>(2)代码示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int </span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double </span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针 </p>
</li>
<li><p>空指针 nullptr（原来NULL）</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>); <span class="comment">// 二义性	C++中是这样定义NULL的 #define NULL 0</span></span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">    程序运行结果：        </span></span><br><span class="line"><span class="comment">    int n</span></span><br><span class="line"><span class="comment">    void*c</span></span><br><span class="line"><span class="comment">*/</span>          </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于范围的for循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;  <span class="comment">//使用基于范围的for循环</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要使用引用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : arr)&#123;</span><br><span class="line">    std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用和move语义 </p>
<p>(1) 右值引用</p>
<p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>; <span class="comment">// 和常量左值引用不同的是，右值引用还可以对右值进行修改   </span></span><br></pre></td></tr></table></figure>

<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成</p>
<p>(2) move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值；但对于使用迭代器遍历容器中存储的元素，执行效率较低</li>
</ul>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table>
<thead>
<tr>
<th align="left">无序容器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unordered_map</td>
<td align="left">存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式  </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
</li>
<li><p>Lambda匿名函数</p>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式</p>
<p>(1) 定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p><code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型  &#123; 函数体; &#125;;</code></p>
<blockquote>
<p>  a.  [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”</p>
<p>  所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量</p>
<p>  b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略</p>
<p>  c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字</p>
<p>  **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</p>
<p>  d. noexcept&#x2F;throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型</p>
<p>  e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”</p>
<p>  f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num + <span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// 1 2 3 4 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说-C-中的智能指针"><a href="#说说-C-中的智能指针" class="headerlink" title="说说 C++中的智能指针"></a>说说 C++中的智能指针</h5><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong> 其中auto_ptr被C++11弃用。</p>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间</p>
<ol>
<li>shared_ptr</li>
</ol>
<pre><code> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放)

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//构建 2 个智能指针     </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;     </span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;     </span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="comment">//输出 p2 指向的数据    </span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针     </span></span><br><span class="line">    <span class="keyword">if</span> (p1) cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;     <span class="comment">//以上操作，并不会影响 p2     </span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      程序运行结果：          10  p1 为空  10  1  */</span>    </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li>weak_ptr</li>
</ol>
<pre><code> 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

 weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放

 weak_ptr和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

 **注意**：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，`pa-&gt;pb_-&gt;print();` pb是一个weak_ptr，应该先把它转化为shared_ptr，如：`shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();   `
</code></pre>
<ol start="3">
<li><p>auto_ptr</p>
<p>C++98的方案，C++11已经弃用. 采用所有权模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题</p>
</li>
<li><p>unique_ptr（替换auto_ptr）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 2 allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中1留下悬挂的unique_ptr(pu1)，这可能导致危害</span></span><br><span class="line"><span class="comment">// 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数, 该函数创建的临时对象在其所有权让给 pu3 后就会被销毁</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="六种关系-依赖-关联-聚合-组合-继承-实现"><a href="#六种关系-依赖-关联-聚合-组合-继承-实现" class="headerlink" title="六种关系: 依赖,关联,聚合,组合,继承,实现"></a>六种关系: 依赖,关联,聚合,组合,继承,实现</h5><p>依赖</p>
<p>依赖关系是在运行过程中起作用的，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom: 67%;">

<p>关联</p>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定；体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。一般是长期性的，而且双方的关系一般是平等的</p>
<ul>
<li>类B以类属性的形式出现在关联类A中</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d.png" alt="在这里插入图片描述"></p>
<p>聚合</p>
<p>但是公司和员工就属于聚合关系了，因为公司没了员工还在</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>组合</p>
<p>组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:67%;">



<p>继承（extend）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>实现（implement）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4.png" alt="在这里插入图片描述" style="zoom:67%;">

<hr>
<hr>
<h5 id="请说说工厂设计模式"><a href="#请说说工厂设计模式" class="headerlink" title="请说说工厂设计模式"></a>请说说工厂设计模式</h5><p> 工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong></p>
<h6 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="(1) 简单工厂模式"></a>(1) 简单工厂模式</h6><p>  它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A.png" alt="img" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象,降低了耦合性</p>
<p><strong>缺点：</strong>就是要增加新的核类型时，就需要修改工厂类。这就违反了开闭原则</p>
<h6 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="(2) 工厂方法模式"></a>(2) 工厂方法模式</h6><p>  所谓工厂方法模式, 是指定义一个用于创建对象的接口, 让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A.png" alt="img" style="zoom: 33%;">

<p>  <strong>举例：</strong>这家生产处理器核的产家决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。  </p>
<p><strong>缺点：</strong>每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义</p>
<h6 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="(3) 抽象工厂模式"></a>(3) 抽象工厂模式</h6><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060.png" alt="image-20221116164855060" style="zoom:50%;">

<p><strong>举例：</strong>这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h6 id="三种工厂模式的区别"><a href="#三种工厂模式的区别" class="headerlink" title="三种工厂模式的区别"></a>三种工厂模式的区别</h6><p>简单工厂 ：用来生产同一产品族中的任意产品(对于增加新的产品，无能为力)</p>
<p>工厂方法 ：用来生产同一产品族中的固定产品(支持增加任意产品)</p>
<p>抽象工厂 ：按产品族抽象，这方便增加某个产品族内的具体产品；按具体产品抽象，这方便增加产品族；</p>
<hr>
<hr>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/" rel="prev" title="链表逆置合集">
      <i class="fa fa-chevron-left"></i> 链表逆置合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/" rel="next" title="链表之链表排序合集">
      链表之链表排序合集 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-x2F-C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">C&#x2F;C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8BC-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">简述下C++语言的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">说说C语言和C++的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">说说 C++中 struct 和 class 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.4.</span> <span class="nav-text">说说头文件双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8CC%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">说说C++结构体和C结构体的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9FC-%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8CC%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">导入C函数的关键字？C++编译时和C有何不同？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.7.</span> <span class="nav-text">简述C++从代码到可执行文件过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.8.</span> <span class="nav-text">说说 static关键字的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.9.</span> <span class="nav-text">说说静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.10.</span> <span class="nav-text">说说静态局部变量,全局变量,局部变量的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.</span> <span class="nav-text">说说数组和指针的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.12.</span> <span class="nav-text">说说什么是函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">nullptr可以调用成员函数吗？为什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.14.</span> <span class="nav-text">说说使用指针需要注意什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88-%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.1.15.</span> <span class="nav-text">说说什么是野指针,怎么产生的,如何避免？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.16.</span> <span class="nav-text">说说内联函数和函数的区别,内联函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.17.</span> <span class="nav-text">说说内联函数和宏函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%90%E7%AE%97%E7%AC%A6i-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.18.</span> <span class="nav-text">说说运算符i++和++i的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.19.</span> <span class="nav-text">说说new和malloc的区别，各自底层实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.20.</span> <span class="nav-text">说说const和define的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a"><span class="nav-number">1.1.21.</span> <span class="nav-text">说说const int *a, int const *a, const int a, int *const a, const int *const a</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.22.</span> <span class="nav-text">简述C++有几种传值方式,区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程运行时虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">简述一下堆和栈的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">简述C++的内存管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.5.</span> <span class="nav-text">简述C++中内存对齐的使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.1.</span> <span class="nav-text">简述一下面向对象的三大特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">成员访问限定符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.3.3.</span> <span class="nav-text">简述一下 C++重载和重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.3.4.</span> <span class="nav-text">说说 C++ 重载和重写是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.3.5.</span> <span class="nav-text">说说C++构造函数有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.6.</span> <span class="nav-text">*拷贝构造函数的参数是什么传递方式,为什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.3.7.</span> <span class="nav-text">拷贝构造和移动构造的不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.8.</span> <span class="nav-text">只定义析构函数,会自动生成哪些构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.9.</span> <span class="nav-text">一个类默认会生成哪些函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F-%E6%9C%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.10.</span> <span class="nav-text">说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.3.11.</span> <span class="nav-text">简述下向上转型和向下转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.12.</span> <span class="nav-text">简述下深拷贝和浅拷贝, 如何实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.13.</span> <span class="nav-text">简述一下 C++ 中的多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">1.3.14.</span> <span class="nav-text">说说为什么要虚析构, 为什么不能虚构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.15.</span> <span class="nav-text">说说模板类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.16.</span> <span class="nav-text">C++ 类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.17.</span> <span class="nav-text">简述一下什么是常函数，有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.3.18.</span> <span class="nav-text">说说 C++ 中什么是菱形继承问题，如何解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.19.</span> <span class="nav-text">说说什么是虚继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.20.</span> <span class="nav-text">简述一下虚函数和纯虚函数, 以及实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.21.</span> <span class="nav-text">说说C++中虚函数与纯虚函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.22.</span> <span class="nav-text">仿函数了解吗？有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%EF%BC%88-friend%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.23.</span> <span class="nav-text">C++友元函数和友元类（ friend）详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.24.</span> <span class="nav-text">C++ 中哪些函数不能被声明为虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.25.</span> <span class="nav-text">类模板和模板类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-STL"><span class="nav-number">1.4.</span> <span class="nav-text">C++STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">请说说 STL 的基本组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">请说说 STL 中常见的容器, 并介绍一下实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-map%E3%80%81hashtable%E3%80%81deque%E3%80%81list-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">说说 STL 中 map、hashtable、deque、list 的实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8DC-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.4.4.</span> <span class="nav-text">两种C++类对象实例化方式的异同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">迭代器用过吗？什么时候会失效？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BSTL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8-%E6%9C%89%E6%8C%87%E9%92%88%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">说一下STL中迭代器的作用, 有指针为何还要迭代器？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.7.</span> <span class="nav-text">说说 STL 中 resize 和 reserve 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-map%E5%92%8C-unordered-map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.8.</span> <span class="nav-text">说说 map和 unordered_map 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-vector-%E5%92%8C-list-%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">说说 vector 和 list 的区别, 分别适用于什么场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vector-%E7%9A%84-%E9%83%A8%E5%88%86STL-%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.10.</span> <span class="nav-text">vector 的 部分STL 源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-STL-%E4%B8%AD%E7%9A%84-map-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.11.</span> <span class="nav-text">简述 STL 中的 map 的实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8B-map-%E5%92%8C-set-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.12.</span> <span class="nav-text">说下 map 和 set 有什么区别, 分别是怎么实现的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-push-back-%E5%92%8C-emplace-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.13.</span> <span class="nav-text">说说 push_back 和 emplace_back 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">C++新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-11-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.5.1.</span> <span class="nav-text">说说 C++11 的新特性有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.5.2.</span> <span class="nav-text">说说 C++中的智能指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB-%E4%BE%9D%E8%B5%96-%E5%85%B3%E8%81%94-%E8%81%9A%E5%90%88-%E7%BB%84%E5%90%88-%E7%BB%A7%E6%89%BF-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">六种关系: 依赖,关联,聚合,组合,继承,实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">请说说工厂设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">(1) 简单工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">(2) 工厂方法模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">(3) 抽象工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">三种工厂模式的区别</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
