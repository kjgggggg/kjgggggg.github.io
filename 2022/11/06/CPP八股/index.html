<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="C++八股">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股">
<meta property="og:url" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="C++八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/E9B05EC1EBA75193D715B4A05B0B4E4D.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192017776.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192039819.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191931072.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191753177.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png">
<meta property="article:published_time" content="2022-11-06T14:21:59.000Z">
<meta property="article:modified_time" content="2023-01-30T12:44:46.672Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++八股 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++八股
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 22:21:59" itemprop="dateCreated datePublished" datetime="2022-11-06T22:21:59+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-30 20:44:46" itemprop="dateModified" datetime="2023-01-30T20:44:46+08:00">2023-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C++八股</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="C-x2F-C-基础"><a href="#C-x2F-C-基础" class="headerlink" title="C&#x2F;C++基础"></a>C&#x2F;C++基础</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><h5 id="简述下C-语言的特点"><a href="#简述下C-语言的特点" class="headerlink" title="简述下C++语言的特点"></a>简述下C++语言的特点</h5><ol>
<li><p>C++在C语言基础上引入了<strong>面对对象(三大特性:封装、继承、多态)<strong>的机制，同时也</strong>兼容C语言</strong></p>
</li>
<li><p>C++运行<strong>效率高</strong>，仅比汇编语言慢10%～20%</p>
</li>
<li><p>C++更加安全, 增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try catch</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dymatic_cast</span>&lt;type&gt;(a) <span class="comment">// 用于类之间的转型，满足2种形式，同一个类型，或者为父子关系，运行期间会做检查，转型失败会返回0并抛出bad_cast.</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(a) <span class="comment">// 这个其实和传统的C语言的强制转换是一样的，它不会做任何检查，如果转型失败就会发生未知错误。</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;type&gt;(a) <span class="comment">// 把a从const型转为非const型，常用于函数重载</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;type&gt;(a) <span class="comment">// 可进行任意转型，把a中的内存按找type的方式来解读，需要程序员保证转换的正确性。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）</p>
</li>
<li><p>C++是<strong>不断在发展</strong>的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda函数、右值引用、智能指针</p>
</li>
</ol>
<hr>
<h5 id="说说C语言和C-的区别"><a href="#说说C语言和C-的区别" class="headerlink" title="说说C语言和C++的区别"></a>说说C语言和C++的区别</h5><ol>
<li><p>C++<strong>面对对象</strong>；C是<strong>面对过程</strong></p>
</li>
<li><p>C是C++的子集，但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等</p>
</li>
<li><p>C不安全，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++<strong>更安全</strong>，如const常量、引用、cast转换、智能指针、try catch</p>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，实现了STL。相对于C语言的函数库<strong>更灵活、更通用</strong>。</p>
</li>
</ol>
<hr>
<h5 id="说说-C-中-struct-和-class-的区别"><a href="#说说-C-中-struct-和-class-的区别" class="headerlink" title="说说 C++中 struct 和 class 的区别"></a>说说 C++中 struct 和 class 的区别</h5><ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">  <span class="type">int</span> iNum; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;  </span><br><span class="line">  <span class="type">int</span> iNum; <span class="comment">// 默认访问控制权限是 private </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 默认是公有继承，而 class 是私有继承</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Y&amp; y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说头文件双引号””和尖括号-lt-gt-的区别"><a href="#说说头文件双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说头文件双引号””和尖括号&lt;&gt;的区别"></a>说说头文件双引号””和尖括号&lt;&gt;的区别</h5><ul>
<li>尖括号&lt;&gt;的头文件是<strong>系统文件</strong>，双引号””的头文件是<strong>自定义文件</strong></li>
<li>编译器预处理阶段查找头文件的路径不一样<ul>
<li>使用&lt;&gt;的头文件：编译器设置的头文件路径 -&gt; 系统变量</li>
<li>使用””的头文件：当前头文件目录 -&gt; 编译器设置的头文件路径 -&gt; 系统变量</li>
</ul>
</li>
</ul>
<hr>
<h5 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h5><ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制权限</td>
<td align="center">默认public，不能修改</td>
<td align="center">public&#x2F;private&#x2F;protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可从类或者其他结构体继承</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;  </span><br><span class="line">  <span class="type">int</span>  iAgeNum;  </span><br><span class="line">  string strName; </span><br><span class="line">&#125; <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Student2; <span class="comment">//C中取别名  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1; <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line"></span><br><span class="line">Student stu3;  <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="导入C函数的关键字？C-编译时和C有何不同？"><a href="#导入C函数的关键字？C-编译时和C有何不同？" class="headerlink" title="导入C函数的关键字？C++编译时和C有何不同？"></a>导入C函数的关键字？C++编译时和C有何不同？</h5><ol>
<li><p><strong>关键字：</strong>在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为<strong>extern “C”</strong>。加上extern “C”后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而非C++的</p>
</li>
<li><p><strong>编译区别：</strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时只包括<strong>函数名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述C-从代码到可执行文件过程"><a href="#简述C-从代码到可执行文件过程" class="headerlink" title="简述C++从代码到可执行文件过程"></a>简述C++从代码到可执行文件过程</h5><p> C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>
<ol>
<li><p>预编译</p>
<p>（1） 将所有的#define删除，并且展开所有的宏定义</p>
<p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p>
<p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p>
<p>（4） 过滤所有的注释</p>
<p>（5） 添加行号和文件名标识</p>
</li>
<li><p>编译</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树</p>
<p>（3） 语义分析：判断表达式是否有意义</p>
<p>（4） 代码优化</p>
<p>（5） 生成汇编代码</p>
</li>
<li><p>汇编    将汇编代码 -&gt; 机器码</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>
<p>链接分为静态链接和动态链接。</p>
<p>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p>
<p>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p>
</li>
</ol>
<hr>
<h5 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h5><ol>
<li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li>
<li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。</li>
<li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li>
<li><strong>静态成员函数和静态成员变量</strong>是类的一部分，可以被多个对象所共享，无法对一个对象中的非静态成员进行访问。</li>
</ol>
<hr>
<h5 id="说说静态变量什么时候初始化"><a href="#说说静态变量什么时候初始化" class="headerlink" title="说说静态变量什么时候初始化"></a>说说静态变量什么时候初始化</h5><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</p>
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</p>
<hr>
<h5 id="说说静态局部变量-全局变量-局部变量的特点"><a href="#说说静态局部变量-全局变量-局部变量的特点" class="headerlink" title="说说静态局部变量,全局变量,局部变量的特点"></a>说说静态局部变量,全局变量,局部变量的特点</h5><ol>
<li><p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p>
<p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</p>
<p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p>
<p>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</p>
<p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p>
</li>
<li><p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p>
</li>
<li><p><strong>生命周期</strong>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p>
</li>
</ol>
<hr>
<h5 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h5><ol>
<li><p>概念：</p>
<p>（1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 </p>
<p>（2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在<strong>内存中的地址</strong>。 指针名指向了内存的首地址。 </p>
</li>
<li><p>区别：</p>
<p>（1）<strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p>
<p>（2）<strong>存储方式</strong>：</p>
<p>  数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。</p>
<p>  指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>
<p>（3）<strong>求sizeof</strong>：</p>
<p>  数组所占存储空间的内存大小：sizeof（数组名）&#x2F;sizeof（数据类型）</p>
<p>  在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，sizeof(指针名)都是8。</p>
</li>
</ol>
<hr>
<h5 id="说说什么是函数指针"><a href="#说说什么是函数指针" class="headerlink" title="说说什么是函数指针"></a>说说什么是函数指针</h5><ol>
<li><strong>概念：</strong>函数指针就是<strong>指向函数</strong>的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li>
<li><strong>定义</strong>形式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in">int</span> (*f)(<span class="type">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compar)(<span class="type">const</span> <span class="type">void</span> *,<span class="type">const</span> <span class="type">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a , <span class="type">const</span> <span class="type">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in">sizeof</span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="nullptr可以调用成员函数吗？为什么？"><a href="#nullptr可以调用成员函数吗？为什么？" class="headerlink" title="nullptr可以调用成员函数吗？为什么？"></a>nullptr可以调用成员函数吗？为什么？</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以，因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this&#x3D;nullptr，运行出错。</p>
<hr>
<h5 id="说说使用指针需要注意什么"><a href="#说说使用指针需要注意什么" class="headerlink" title="说说使用指针需要注意什么"></a>说说使用指针需要注意什么</h5><ol>
<li>定义指针时，先初始化为NULL。</li>
<li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</li>
<li>不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</li>
<li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li>
<li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li>
<li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li>
</ol>
<hr>
<h5 id="说说什么是野指针-怎么产生的-如何避免？"><a href="#说说什么是野指针-怎么产生的-如何避免？" class="headerlink" title="说说什么是野指针,怎么产生的,如何避免？"></a>说说什么是野指针,怎么产生的,如何避免？</h5><ol>
<li><p><strong>概念：</strong>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</li>
<li><p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免办法：</strong></p>
<p>（1）初始化置NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置NULL</p>
<p>（4）使用智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说内联函数和函数的区别-内联函数的作用"><a href="#说说内联函数和函数的区别-内联函数的作用" class="headerlink" title="说说内联函数和函数的区别,内联函数的作用"></a>说说内联函数和函数的区别,内联函数的作用</h5><ol>
<li>内联函数比普通函数多了关键字<strong>inline</strong></li>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p>   <strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<hr>
<h5 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h5><ol>
<li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身</li>
<li><strong>宏函数</strong>是在预编译的时候字符串替换 ；<strong>而内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开</li>
<li><strong>宏定义</strong>是没有类型检查的，无论对还是错都是直接替换；<strong>而内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li>
</ol>
<hr>
<h5 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i++和++i的区别"></a>说说运算符i++和++i的区别</h5><ol>
<li><p><strong>效率不同</strong>：后置++执行速度比前置的慢</p>
</li>
<li><p><strong>i++ 不能作为左值，而++i 可以</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// int* p2 = &amp;(i++);//错误</span></span><br><span class="line">++i = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// i++ = 1;//错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说new和malloc的区别，各自底层实现原理"><a href="#说说new和malloc的区别，各自底层实现原理" class="headerlink" title="说说new和malloc的区别，各自底层实现原理"></a>说说new和malloc的区别，各自底层实现原理</h5><ol>
<li>new分配的内存空间所在位置是自由存储区，而malloc在堆上动态分配内存。自由存储区不仅可以是堆，还可以是静态存储区</li>
<li>new是操作符，而malloc是函数。</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li>
<li>new可以被重载；malloc不行</li>
<li>new分配内存更直接和安全。</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap()。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<p> (1) 创建一个新的对象</p>
<p> (2) 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
<p> (3) 执行构造函数（为这个新对象添加属性）</p>
<p> (4) 返回新对象</p>
<hr>
<h5 id="说说const和define的区别。"><a href="#说说const和define的区别。" class="headerlink" title="说说const和define的区别。"></a>说说const和define的区别。</h5><p>const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。区别有：</p>
<ol>
<li>const生效于编译的阶段；define生效于预处理阶段。</li>
<li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</li>
<li>const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</li>
</ol>
<hr>
<h5 id="说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a"><a href="#说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a" class="headerlink" title="说说const int *a, int const *a, const int a, int *const a, const int *const a"></a>说说const int *a, int const *a, const int a, int *const a, const int *const a</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">const</span> <span class="type">int</span> a;     <span class="comment">// 指的是a是一个常量，不允许修改</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// 同 const int *a;</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="number">5.</span> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> a;   <span class="comment">// 都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述C-有几种传值方式-区别是什么？"><a href="#简述C-有几种传值方式-区别是什么？" class="headerlink" title="简述C++有几种传值方式,区别是什么？"></a>简述C++有几种传值方式,区别是什么？</h5><ol>
<li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值</li>
<li>引用传递：形参在函数体内值发生变化，会影响实参的值</li>
<li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值</li>
</ol>
<blockquote>
<p>  值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> *b, <span class="type">int</span> &amp;c)</span></span>&#123;<span class="comment">//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    (*b) += <span class="number">1</span>;</span><br><span class="line">    c += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a= %d, b= %d, c= %d\n&quot;</span>,a,*b,c);<span class="comment">//a= 2, b= 2, c= 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *j = &amp;a;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testfunc</span>(i, j, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d, k= %d\n&quot;</span>,i,*j,k);<span class="comment">//i= 1, j= 2, k= 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h4><h5 id="进程运行时虚拟地址空间"><a href="#进程运行时虚拟地址空间" class="headerlink" title="进程运行时虚拟地址空间"></a>进程运行时虚拟地址空间</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png" alt="img" style="zoom: 67%;">

<ol>
<li><p><strong>data段：</strong>已初始化的全局变量和静态变量</p>
</li>
<li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</p>
</li>
<li><p><strong>bss段</strong>：未初始化的全局变量和静态变量</p>
</li>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中</li>
<li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。调用动态链接库的初始化函数</li>
<li>初始化应用程序的全局变量，对于全局对象自动调用构造函数</li>
<li>进入应用程序入口点函数开始执行</li>
</ol>
<p><strong>怎么判断数据分配在栈上还是堆上：</strong></p>
<p> malloc或new是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。</p>
<hr>
<h5 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h5><ol>
<li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li>
<li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li>
<li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li>
</ol>
<hr>
<h5 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h5><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p>
<p><strong>堆</strong>，就是那些由new分配的内存块，一般一个new就要对应一个delete。</p>
<p><strong>自由存储区</strong>，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。</p>
<p><strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
</li>
<li><p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）内存分配未成功，却使用了它。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>（5）释放了内存却继续使用它。</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为NULL</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用</p>
<p>（4）避免数字或指针的下标<strong>越界</strong></p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针</p>
</li>
<li><p><strong>内存泄露及解决办法</strong>：</p>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
</li>
</ol>
<hr>
<h5 id="请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</h5><p>局部常量，存放在栈区；</p>
<p>全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</p>
<p>字面值常量，比如字符串，放在常量区。</p>
<hr>
<h5 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h5><p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong>，对齐原则有四个：</p>
<ol>
<li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li>
<li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</li>
<li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li>
</ol>
<hr>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><h5 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h5><p>面向对象的三大特征是封装、继承、多态。</p>
<ol>
<li><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。不想给别人看到的，我们使用protected&#x2F;private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>
</li>
<li><p>继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。三种继承方式：</p>
<table>
<thead>
<tr>
<th align="left">继承方式</th>
<th align="left">private继承</th>
<th align="left">protected继承</th>
<th align="left">public继承</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基类的private成员</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
</tr>
<tr>
<td align="left">基类的protected成员</td>
<td align="left">变为private成员</td>
<td align="left">仍为protected成员</td>
<td align="left">仍为protected成员</td>
</tr>
<tr>
<td align="left">基类的public成员</td>
<td align="left">变为private成员</td>
<td align="left">变为protected成员</td>
<td align="left">仍为public成员</td>
</tr>
</tbody></table>
</li>
<li><p>多态：用父类型别的指针指向其子类的实例，然后<strong>通过父类的指针调用实际子类的成员函数</strong>。实现多态，有二种方式，重写，重载。</p>
</li>
</ol>
<hr>
<h5 id="成员访问限定符"><a href="#成员访问限定符" class="headerlink" title="成员访问限定符"></a>成员访问限定符</h5><table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">权限</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">可以被任意实体访问</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">只允许子类及本类的成员函数访问</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">只允许本类的成员函数访问</td>
</tr>
</tbody></table>
<hr>
<h5 id="简述一下-C-重载和重写"><a href="#简述一下-C-重载和重写" class="headerlink" title="简述一下 C++重载和重写"></a>简述一下 C++重载和重写</h5><ul>
<li><p>重写:是指派生类中存在重新定义的函数。</p>
<p>其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>基类中被重写的函数必须有virtual修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A&quot;</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B&quot;</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a -&gt; <span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载</p>
<p>在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个<strong>具有不同参数列（参数的类型，个数，顺序不同）的同名函数</strong>，根据参数列表确定调用哪个函数，重载不关心函数返回类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;;     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="说说-C-重载和重写是如何实现的"><a href="#说说-C-重载和重写是如何实现的" class="headerlink" title="说说 C++ 重载和重写是如何实现的"></a>说说 C++ 重载和重写是如何实现的</h5><ul>
<li><p>重写</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数</li>
<li>有虚函数的类都有个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。</li>
<li><strong>多态</strong>性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性</li>
<li>重写用虚函数来实现，结合动态绑定</li>
<li>纯虚函数是虚函数再加上 &#x3D; 0</li>
<li>抽象类是指包括至少一个纯虚函数的类</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容</strong></p>
</li>
<li><p>重载</p>
<p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
</li>
</ul>
<hr>
<h5 id="说说C-构造函数有几种"><a href="#说说C-构造函数有几种" class="headerlink" title="说说C++构造函数有几种"></a>说说C++构造函数有几种</h5><p>C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li><p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="comment">//默认构造函数  </span></span><br><span class="line">        <span class="built_in">Student</span>()&#123; </span><br><span class="line">            num=<span class="number">1001</span>;        </span><br><span class="line">            age=<span class="number">18</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//初始化构造函数  </span></span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">int</span> a):<span class="built_in">num</span>(n),<span class="built_in">age</span>(a)&#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="type">int</span> num;  </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//用默认构造函数初始化对象S1  </span></span><br><span class="line">    Student s1;  </span><br><span class="line">    <span class="comment">//用初始化构造函数初始化对象S2  </span></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">18</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li><p>复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;     </span><br><span class="line">    <span class="type">int</span> i;     </span><br><span class="line">    <span class="type">int</span> *p; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> value)&#123;         </span><br><span class="line">            i = ai;         </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">int</span>(value);     </span><br><span class="line">        &#125;     </span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;         </span><br><span class="line">            <span class="keyword">delete</span> p;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t)&#123;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;i = t.i;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*t.p);     </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//复制构造函数用于复制本类的对象 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;     </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;     </span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>：只是对指针的拷贝，拷贝后两个指针指向同一个内存空间。</p>
<p><strong>深拷贝</strong>：不但对指针进行拷贝, 且对指针指向的内容拷贝, 经过深拷贝后的指针是指向两个不同地址的指针。</p>
<p><strong>重点：系统默认生成的拷贝构造函数是<em>浅拷贝</em></strong></p>
</li>
<li><p>移动构造函数</p>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷</p>
<p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</p>
<p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)&#123; <span class="comment">// &amp;&amp; 是右值引用 	int num = 10;  int &amp;&amp; a = 10;     </span></span><br><span class="line">		p = a.p;</span><br><span class="line">		a.p = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ch;</span><br><span class="line">	<span class="function">Test <span class="title">c</span><span class="params">(move(p))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="拷贝构造函数的参数是什么传递方式-为什么"><a href="#拷贝构造函数的参数是什么传递方式-为什么" class="headerlink" title="*拷贝构造函数的参数是什么传递方式,为什么"></a>*拷贝构造函数的参数是什么传递方式,为什么</h5><ol>
<li><p>拷贝构造函数的参数必须使用引用传递</p>
</li>
<li><p>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p>
<p>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p>
</li>
</ol>
<hr>
<h5 id="拷贝构造和移动构造的不同"><a href="#拷贝构造和移动构造的不同" class="headerlink" title="拷贝构造和移动构造的不同"></a>拷贝构造和移动构造的不同</h5><p>拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针</p>
<hr>
<h5 id="只定义析构函数-会自动生成哪些构造函数"><a href="#只定义析构函数-会自动生成哪些构造函数" class="headerlink" title="只定义析构函数,会自动生成哪些构造函数"></a>只定义析构函数,会自动生成哪些构造函数</h5><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<blockquote>
<p>  默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作</p>
</blockquote>
<hr>
<h5 id="一个类默认会生成哪些函数"><a href="#一个类默认会生成哪些函数" class="headerlink" title="一个类默认会生成哪些函数"></a>一个类默认会生成哪些函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认会生成以下几个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无参的构造函数</span></span><br><span class="line"><span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.拷贝构造函数</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值运算符</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.析构函数（非虚）</span></span><br><span class="line">~<span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-C-类对象的初始化顺序-有多重继承情况下的顺序"><a href="#说说-C-类对象的初始化顺序-有多重继承情况下的顺序" class="headerlink" title="说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序"></a>说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序</h5><p>父类构造函数 –&gt; 成员类对象构造函数 –&gt; 自身构造函数</p>
<blockquote>
<p>  其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序</p>
<p>  析构顺序和构造顺序相反</p>
</blockquote>
<hr>
<h5 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h5><ol>
<li><p>向上转型（即派生类指针或引用类型转换为其基类类型），本身就是安全的，尽管可以使用dynamic_cast进行转换，但这是没必要的， 普通的转换已经可以达到目的</p>
</li>
<li><p>向下转型:</p>
<p>(1) 可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</p>
<p>(2) <code>dynamic_cast&lt;type_id&gt;(expression) </code>主要还是用于执行“安全的向下转型（safe downcasting）”，也即是基类对象的指针或引用转换为同一继承层次的其他指针或引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast&lt;type_id&gt;(expression) 把expression转换成type-id类型的对象</span></span><br><span class="line"><span class="comment">// type_id 必须是类的指针、类的引用或者void*</span></span><br><span class="line"><span class="comment">// 使用场景：我们想使用基类对象的指针或引用来调用某个派生类的操作，并且该操作不是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base *Pb = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	Derived* Pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(Pb);</span><br><span class="line">	Pd-&gt;<span class="built_in">func</span>();  <span class="comment">//将输出hello world!	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述下深拷贝和浅拷贝-如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝-如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝, 如何实现深拷贝"></a>简述下深拷贝和浅拷贝, 如何实现深拷贝</h5><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<p>深拷贝的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STRING</span>(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法1:拷贝构造函数</span></span><br><span class="line">    <span class="comment">//_str = s._str;</span></span><br><span class="line">    _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法2: 赋值运算符的重载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png" alt="img" style="zoom:50%;">

<hr>
<h5 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h5><ol>
<li><p>多态成员变量: 编译运行看左边</p>
</li>
<li><p>静态方法和变量：编译运行都看左边，同成员变量一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu *f = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f -&gt; num &lt;&lt; endl; <span class="comment">// 取Fu中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态成员方法: 编译看左边,运行看右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu* f1 = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f1-&gt;<span class="built_in">show</span>() &lt;&lt; endl; <span class="comment">// 用基类类型指针绑定派生类实例,调用的是子类重写后的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说为什么要虚析构-为什么不能虚构造"><a href="#说说为什么要虚析构-为什么不能虚构造" class="headerlink" title="说说为什么要虚析构, 为什么不能虚构造"></a>说说为什么要虚析构, 为什么不能虚构造</h5><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，</p>
<p>可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。</strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li><p>不能虚构造：</p>
<p>虚函数需要一个虚表存储, 这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到虚表中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</p>
</li>
</ol>
<hr>
<h5 id="说说模板类"><a href="#说说模板类" class="headerlink" title="说说模板类"></a>说说模板类</h5><ol>
<li>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
<li>模板具体化：<strong>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化</strong>。具体化时可以修改原模板的定义</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">sizeof</span>(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">int</span>&gt; intStruct; <span class="comment">// 4</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">double</span>&gt; doubleStruct; <span class="comment">// --8--</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">char</span>&gt; llStruct; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++ 类内可以定义引用数据成员吗？"></a>C++ 类内可以定义引用数据成员吗？</h5><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p>
<ol>
<li>不能用默认构造函数初始化，必须提供构造函数(初始化列表中)来初始化引用成员变量。否则会造成引用未初始化错误</li>
<li>构造函数的形参也必须是引用类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> &amp;target) :<span class="built_in">a</span>(target)&#123;  <span class="comment">//初始化列表</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;</span><br><span class="line">	r.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line">	<span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">	r1.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述一下什么是常函数，有什么作用"><a href="#简述一下什么是常函数，有什么作用" class="headerlink" title="简述一下什么是常函数，有什么作用"></a>简述一下什么是常函数，有什么作用</h5><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。</p>
<p>在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；</p>
<p>没有 const 修饰的成员函数，对数据成员则是可读可写的。</p>
<p>除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">CStu</span>()&#123;</span><br><span class="line">        a = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//a = 13; //常函数不能修改数据成员</span></span><br><span class="line">        cout &lt;&lt;a &lt;&lt; <span class="string">&quot;I am show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CStu st;</span><br><span class="line">    st.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-C-中什么是菱形继承问题，如何解决"><a href="#说说-C-中什么是菱形继承问题，如何解决" class="headerlink" title="说说 C++ 中什么是菱形继承问题，如何解决"></a>说说 C++ 中什么是菱形继承问题，如何解决</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png" alt="img" style="zoom:25%;">

<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  *Animal类对应于图表的类A* */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;     </span><br><span class="line">    <span class="type">int</span> weight;      </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> weight; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Liger</span> : <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Liger lg;   <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span>   </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>();  <span class="comment">//   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象”lg”会包含Animal基类的两个子对象。</p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用”lg.getWeight()”将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</p>
</li>
<li><p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;  <span class="comment">// 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了”virtual”关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Liger lg;  <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>  </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说什么是虚继承"><a href="#说说什么是虚继承" class="headerlink" title="说说什么是虚继承"></a>说说什么是虚继承</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/King_weng/article/details/112180275?ops_request_misc=&request_id=&biz_id=102&utm_term=C++%20%E8%99%9A%E7%BB%A7%E6%89%BF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-112180275.nonecase&spm=1018.2226.3001.4187">传送门</a></p>
<hr>
<h5 id="简述一下虚函数和纯虚函数-以及实现原理"><a href="#简述一下虚函数和纯虚函数-以及实现原理" class="headerlink" title="简述一下虚函数和纯虚函数, 以及实现原理"></a><strong>简述一下虚函数和纯虚函数, 以及实现原理</strong></h5><p>C++中的虚函数的作用主要是实现了多态的机制</p>
<p>关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。<strong>虚函数必须是基类的非静态成员函数</strong></p>
<p>在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，<strong>在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型</strong>, 以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;PersonName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">    <span class="comment">//基类调用子类的函数</span></span><br><span class="line">    person-&gt;<span class="built_in">GetName</span>();<span class="comment">//StudentName:xiaosi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但<strong>要求任何派生类都要定义自己的实现方法</strong>。<strong>将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象</strong></p>
<p>所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h5><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，<strong>含有纯虚函数的类被称为抽象类</strong>，而只含有虚函数的类不能被称为抽象类。</li>
<li>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</li>
<li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li>
<li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</li>
<li>虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } &#x3D; 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li>
</ol>
<hr>
<h5 id="仿函数了解吗？有什么作用"><a href="#仿函数了解吗？有什么作用" class="headerlink" title="仿函数了解吗？有什么作用"></a>仿函数了解吗？有什么作用</h5><ol>
<li>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Func myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;helloworld!</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>仿函数既能像普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息</strong>。我们可以举个例子：假设有一个vector<string>,你的任务是统计长度小于5的string的个数，如果使用函数的话，你的代码可能长成这样：</string></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LengthIsLessThanFive</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; <span class="number">5</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LenthIsLessThan</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-友元函数和友元类（-friend）详解"><a href="#C-友元函数和友元类（-friend）详解" class="headerlink" title="C++友元函数和友元类（ friend）详解"></a>C++友元函数和友元类（ friend）详解</h5><p>C++ 设计者认为， 如果有的程序员真的非常怕麻烦，就是想在类的成员函数外部直接访问对象的私有成员，那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++ 就有了<strong>友元（friend）</strong>的概念。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span>  返回值类型  函数名(参数表); <span class="comment">//将全局函数声明为友元</span></span><br><span class="line"><span class="keyword">friend</span>  返回值类型  其他类的类名::成员函数名(参数表); <span class="comment">//将其他类的成员函数声明为友元</span></span><br><span class="line"><span class="comment">// 但是，不能把其他类的私有成员函数声明为友元</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>;  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-中哪些函数不能被声明为虚函数"><a href="#C-中哪些函数不能被声明为虚函数" class="headerlink" title="C++ 中哪些函数不能被声明为虚函数"></a>C++ 中哪些函数不能被声明为虚函数</h5><p>常见的不不能声明为虚函数的有：普通函数（不定义在类里），静态成员函数，内联成员函数，构造函数，友元函数</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>略</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<hr>
<h5 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h5><p>模板的声明或定义只能在全局，命名空间或类范围内进行。</p>
<p>不能在局部范围，函数内进行，比如不能在<strong>main</strong>函数中声明或定义一个模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ClassName 的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替</span></span><br><span class="line">ClassName A = <span class="keyword">new</span> <span class="built_in">ClassName</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h4><h5 id="请说说-STL-的基本组成部分"><a href="#请说说-STL-的基本组成部分" class="headerlink" title="请说说 STL 的基本组成部分"></a>请说说 STL 的基本组成部分</h5><p> 标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p>  <strong>广义上讲</strong>，STL分为3类：算法、容器、迭代器，容器和算法通过迭代器可以进行无缝地连接。</p>
<p>  <strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）</p>
<ol>
<li><p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了操作符的struct</p>
</li>
<li><p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3种适配器：Container Adaptor、Iterator Adaptor、Function Adaptor</p>
</li>
<li><p>空间配制器（Allocator）</p>
<p> 为STL提供空间配置的系统。其中主要工作包括两部分</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<hr>
<h5 id="请说说-STL-中常见的容器-并介绍一下实现原理"><a href="#请说说-STL-中常见的容器-并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器, 并介绍一下实现原理"></a>请说说 STL 中常见的容器, 并介绍一下实现原理</h5><ol>
<li><strong>序列式容器</strong></li>
</ol>
<p>所谓序列式容器，其中的元素都是可序的，但是未必都是有序的</p>
<p>（1）vector ：动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
<p>（2）deque ：双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能</p>
<p>（3）list ：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取</p>
<ol start="2">
<li><strong>关联式容器</strong></li>
</ol>
<p>关联式容器，每笔数据（每个数据）都有一个键值（key）和一个实值（value）</p>
<blockquote>
<p>  关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()、begin()、end()等操作</p>
</blockquote>
<p>关联式容器: set、map、multiset、multimap底层均以RB-tree（红黑树）完成</p>
<p>（1）set&#x2F;multiset ：set 即集合。set中不允许相同元素，multiset中允许存在相同元素</p>
<p>（2）map&#x2F;multimap ：map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素</p>
<ol start="3">
<li><strong>容器适配器</strong></li>
</ol>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个stack。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。stack和queue基于deque实现，priority_queue基于vector实现</p>
<p>（1）stack  </p>
<p>（2）queue ：队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p>
<p>（3）priority_queue：优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p>
<hr>
<h5 id="说说-STL-中-map-hashtable-deque-list-的实现原理"><a href="#说说-STL-中-map-hashtable-deque-list-的实现原理" class="headerlink" title="说说 STL 中 map, hashtable, deque, list 的实现原理"></a>说说 STL 中 map, hashtable, deque, list 的实现原理</h5><p>map（红黑树）、hashtable（函数映射）、deque（双向队列）、list（双向链表）</p>
<ol>
<li><p>map实现原理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作</p>
</li>
<li><p>hashtable（也称散列表，直译作哈希表）实现原理</p>
<p>hashtable采用了<strong>函数映射的思想</strong>记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找</p>
</li>
</ol>
<hr>
<h5 id="两种C-类对象实例化方式的异同"><a href="#两种C-类对象实例化方式的异同" class="headerlink" title="两种C++类对象实例化方式的异同"></a>两种C++类对象实例化方式的异同</h5><ol>
<li>在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 <code>Test test();</code>另一种是通过new来实例化一个类对象，如 <code>Test *pTest = new Test();</code>那么，这两种方式有什么异同点呢？</li>
</ol>
<pre><code>我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。



那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间

（2）对于第二种方式来说, new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间
</code></pre>
<hr>
<h5 id="迭代器用过吗？什么时候会失效？"><a href="#迭代器用过吗？什么时候会失效？" class="headerlink" title="迭代器用过吗？什么时候会失效？"></a>迭代器用过吗？什么时候会失效？</h5><ol>
<li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li>
<li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</li>
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</li>
</ol>
<hr>
<h5 id="说一下STL中迭代器的作用-有指针为何还要迭代器？"><a href="#说一下STL中迭代器的作用-有指针为何还要迭代器？" class="headerlink" title="说一下STL中迭代器的作用, 有指针为何还要迭代器？"></a>说一下STL中迭代器的作用, 有指针为何还要迭代器？</h5><ol>
<li><p>迭代器的作用</p>
<p>（1）用于指向顺序容器和关联容器中的元素</p>
<p>（2）通过迭代器可以读取它指向的元素</p>
<p>（3）通过非const迭代器还可以修改其指向的元素</p>
</li>
<li><p>迭代器和指针的区别</p>
<p><strong>迭代器不是指针，是类模板，表现的像指针。</strong>他只是模拟了指针的一些功能，重载了指针的一些操作符，++、–等。迭代器本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li><p>迭代器产生的原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//一个存放int元素的数组，一开始里面没有元素  </span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator i; <span class="comment">//常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//v.begin()表示v第一个元素迭代器指针，++i指向下一个元素   </span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//*i表示迭代器指向的元素  </span></span><br><span class="line">    cout &lt;&lt; endl;   </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator r; <span class="comment">//反向迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (r = v.<span class="built_in">rbegin</span>(); r != v.<span class="built_in">rend</span>(); r++)   </span><br><span class="line">        cout &lt;&lt; *r &lt;&lt; <span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator j; <span class="comment">//非常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (j = v.<span class="built_in">begin</span>();j != v.<span class="built_in">end</span>();j++)   </span><br><span class="line">        *j = <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();i++)   </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      运行结果：   1,2,3,4,   4,3,2,1,   100,100,100,100, */</span> </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-STL-中-resize-和-reserve-的区别"><a href="#说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="说说 STL 中 resize 和 reserve 的区别"></a>说说 STL 中 resize 和 reserve 的区别</h5><ol>
<li><p>首先必须弄清楚两个概念：</p>
<p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象</p>
<p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</p>
</li>
<li><p>resize和reserve区别主要有以下几点：</p>
<p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert()或push_back()等创建对象</p>
<p>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小</p>
<p>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值(默认为0);reserve只带一个参数，表示容器预留的大小</p>
</li>
</ol>
<hr>
<h5 id="说说-map和-unordered-map-的区别"><a href="#说说-map和-unordered-map-的区别" class="headerlink" title="说说 map和 unordered_map 的区别"></a>说说 map和 unordered_map 的区别</h5><ol>
<li><p>map实现机理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照BST存储的，使用中序遍历可将键值按照从小到大遍历出来</p>
</li>
<li><p>unordered_map实现机理</p>
<p>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O(1)，其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的</p>
</li>
</ol>
<hr>
<h5 id="说说-vector-和-list-的区别-分别适用于什么场景？"><a href="#说说-vector-和-list-的区别-分别适用于什么场景？" class="headerlink" title="说说 vector 和 list 的区别, 分别适用于什么场景？"></a>说说 vector 和 list 的区别, 分别适用于什么场景？</h5><p><strong>vector：一维数组</strong></p>
<p>  特点：在堆中分配内存，动态数组，元素连续存放，有保留内存，如果减少大小后内存也不会释放</p>
<p>  扩容方式：</p>
<blockquote>
<p>  （1）当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加</p>
<p>  （2）新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同</p>
</blockquote>
<p>  优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)</p>
<p>  缺点：由于开辟一段连续的空间, 所以插入删除会需要对数据进行移动比较麻烦, 时间复杂度O(n), 另外当空间不足时还需要进行扩容</p>
<p>  <strong>list：双向链表</strong></p>
<p>  特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问</p>
<p>  优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)</p>
<p>  缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n), 没有提供[]操作符的重载</p>
<hr>
<h5 id="vector-的-部分STL-源码"><a href="#vector-的-部分STL-源码" class="headerlink" title="vector 的 部分STL 源码"></a>vector 的 部分STL 源码</h5><p>  vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li><p>新增元素</p>
<p>  Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index &#x3D; iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="type">const</span> T&amp; t )</span> </span>&#123;    </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_)&#123;   </span><br><span class="line">        <span class="keyword">if</span> (size_==capacity_)&#123;    </span><br><span class="line">            <span class="type">int</span> capa=<span class="built_in">calculateCapacity</span>();    </span><br><span class="line">            <span class="built_in">newCapacity</span>(capa);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="built_in">sizeof</span>(T));    </span><br><span class="line">        buf[index]=t;   </span><br><span class="line">        size_++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<p> 删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index &#x3D; iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素  </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();      </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)&#123;         </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="built_in">sizeof</span>(T));          </span><br><span class="line">        buf[--size_]=<span class="built_in">T</span>();     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述-STL-中的-map-的实现原理"><a href="#简述-STL-中的-map-的实现原理" class="headerlink" title="简述 STL 中的 map 的实现原理"></a>简述 STL 中的 map 的实现原理</h5><p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>map的特性如下</p>
<p>（1）map以RBTree作为底层容器；</p>
<p>（2）所有元素都是键+值存在；</p>
<p>（3）不允许键重复；</p>
<p>（4）所有元素是通过键进行自动排序的；</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p>
<hr>
<h5 id="说下-map-和-set-有什么区别-分别是怎么实现的？"><a href="#说下-map-和-set-有什么区别-分别是怎么实现的？" class="headerlink" title="说下 map 和 set 有什么区别, 分别是怎么实现的？"></a>说下 map 和 set 有什么区别, 分别是怎么实现的？</h5><p>同：</p>
<ol>
<li>都是一种关联式容器</li>
<li>以RBTree作为底层容器</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
</ol>
<p>不同：</p>
<ol>
<li><p>set的元素的只有key没有value，value就是key</p>
</li>
<li><p>不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</p>
</li>
<li><p>map中所有元素都是键+值存在</p>
</li>
<li><p>map的键是不能修改的，但是其键对应的值是可以修改的</p>
</li>
</ol>
<hr>
<h5 id="说说-push-back-和-emplace-back-的区别"><a href="#说说-push-back-和-emplace-back-的区别" class="headerlink" title="说说 push_back 和 emplace_back 的区别"></a>说说 push_back 和 emplace_back 的区别</h5><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p>
<hr>
<h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h4><h5 id="说说-C-11-的新特性有哪些"><a href="#说说-C-11-的新特性有哪些" class="headerlink" title="说说 C++11 的新特性有哪些"></a>说说 C++11 的新特性有哪些</h5><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）初始化方法可以拓展到任意类</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针</p>
<p>（6）空指针 nullptr（原来NULL）</p>
<p>（7）基于范围的for循环</p>
<p>（8）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）无序容器（哈希表）用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）Lambda表达式</p>
</li>
</ol>
<p><strong>详细：</strong></p>
<ol>
<li><p>统一的初始化方法</p>
<p>  C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;     </span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private     </span></span><br><span class="line">    Foo a3 = &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    Foo a4 &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a5 = &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a6 &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<strong>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化</strong></p>
</li>
<li><p>成员变量默认初始化</p>
<p>好处：构建一个类的对象不需要用构造函数初始化成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值  </span></span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    B b;  </span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字  </p>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();   <span class="comment">// auto i = v.begin();  </span></span><br></pre></td></tr></table></figure>

<p>定义迭代器 i 的时候, 类型书写比较冗长, 容易出错。然而有了 auto 类型推导, 我们大可不必这样, 只写一个 auto 即可</p>
</li>
<li><p>decltype  求表达式的类型</p>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>(1)为什么要有decltype</p>
<p><strong>auto 要求变量必须初始化，而 decltype 不要求</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<p>(2)代码示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int </span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double </span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针 </p>
<p>见下⬇️</p>
</li>
<li><p>空指针 nullptr（原来NULL）</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>空指针常数可以转换为任意类型的指针类型</p>
<p>在c++中 <code>(void *)</code> 不能转化为任意类型的指针，即 <code>int *p=(void*)</code>是错误的，但<code>int *p = nullptr</code>是正确的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;1&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;2&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);  <span class="comment">//输出1，c++中NULL为整数0</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//输出2，nullptr 为空指针常量。是指针类型</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于范围的for循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;  <span class="comment">//使用基于范围的for循环</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要使用引用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : arr)&#123;</span><br><span class="line">    std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用和move语义 </p>
<p>(1) 右值引用</p>
<p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>; <span class="comment">// 和常量左值引用不同的是，右值引用还可以对右值进行修改   </span></span><br></pre></td></tr></table></figure>

<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成</p>
<p>(2) move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能<strong>很简单，就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值；但对于使用迭代器遍历容器中存储的元素，执行效率较低</li>
</ul>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table>
<thead>
<tr>
<th align="left">无序容器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unordered_map</td>
<td align="left">存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式  </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
</li>
<li><p>Lambda匿名函数</p>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式</p>
<p>(1) 定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p><code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型  &#123; 函数体; &#125;;</code></p>
<blockquote>
<p>  a.  [ ] 捕获外部变量</p>
<p>  b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略</p>
<p>  c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字</p>
<p>  **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</p>
<p>  d. noexcept&#x2F;throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型</p>
<p>  e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”</p>
<p>  f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式捕获（两种）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说-C-中的智能指针"><a href="#说说-C-中的智能指针" class="headerlink" title="说说 C++中的智能指针"></a>说说 C++中的智能指针</h5><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong> 其中auto_ptr被C++11弃用。</p>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间</p>
<ol>
<li>shared_ptr</li>
</ol>
<pre><code> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放)

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//构建 2 个智能指针     </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;     </span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;     </span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="comment">//输出 p2 指向的数据    </span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针     </span></span><br><span class="line">    <span class="keyword">if</span> (p1) cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;     <span class="comment">//以上操作，并不会影响 p2     </span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      程序运行结果：          10  p1 为空  10  1  */</span>    </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li>weak_ptr</li>
</ol>
<pre><code> 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

 weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放

 weak_ptr和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

 **注意**：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，`pa-&gt;pb_-&gt;print();` pb是一个weak_ptr，应该先把它转化为shared_ptr，如：`shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();   `
</code></pre>
<ol start="3">
<li><p>auto_ptr</p>
<p>C++98的方案，C++11已经弃用. 采用所有权模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题</p>
</li>
<li><p>unique_ptr（替换auto_ptr）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 2 allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中1留下悬挂的unique_ptr(pu1)，这可能导致危害</span></span><br><span class="line"><span class="comment">// 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数, 该函数创建的临时对象在其所有权让给 pu3 后就会被销毁</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数"><a href="#Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数" class="headerlink" title="Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数"></a>Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数</h5><ol>
<li><p>查看进程运行状态的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps -aux | grep PID</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存使用情况的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">// 查看内存使用情况</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>查看进程运行状态、查看内存使用情况的指令均可使用top指令</strong></p>
<ol start="3">
<li>tar解压文件的参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">五个命令中必选一个:      </span><br><span class="line">-c: 建立压缩档案      </span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件 </span><br><span class="line">这几个参数是可选的:      </span><br><span class="line">-z：有gzip属性的      </span><br><span class="line">-j：有bz2属性的      </span><br><span class="line">-Z：有compress属性的      </span><br><span class="line">-v：显示所有过程      </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>压缩</span><br><span class="line">tar -cvf xxx.tar /data : 仅打包</span><br><span class="line">tar -zcvf xxx.tar /data : 打包后，以gzip方式压缩</span><br><span class="line">tar -jcvf xxx.tar /data : 打包后，以bzip2方式压缩</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>解压缩</span><br><span class="line">先进入需要解压缩的文件夹下</span><br><span class="line">cd /tmp/data</span><br><span class="line">tar -xvf xxx.tar : 解包</span><br><span class="line">tar -zxvf xxx.tar : 解压gzip压缩文件</span><br><span class="line">tar -jxvf xxx.tar : 解压bzip2压缩文件</span><br><span class="line">tar -zxvf xxx.tar.gz etc/passwd :只解压部分文件夹</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="文件权限怎么修改"><a href="#文件权限怎么修改" class="headerlink" title="文件权限怎么修改"></a>文件权限怎么修改</h5><h6 id="文字设定法设置权限"><a href="#文字设定法设置权限" class="headerlink" title="文字设定法设置权限"></a>文字设定法设置权限</h6><p><code>chmod [操作对象] [操作符号] [权限] [文件|目录] </code></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png" alt="image-20221128220607286"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png" alt="image-20221128220621457"></p>
<p>chmod u+w a	添加所有者对a文件的写入权限</p>
<p>chmod u-r a	取消所有者对a文件的读取权限</p>
<p>chmod g&#x3D;w a	重新分配同组用户对a文件有写入的权限</p>
<p>chmod u+rw,g+r,o+rwx a	添加所有者为读取、写入权限;同组用户为读取权限;其他用户读取、写入和执行的权限</p>
<p>chmod a-rwx a	取消所有用户的读取、写入和执行权限</p>
<h6 id="数字设定法设置权限"><a href="#数字设定法设置权限" class="headerlink" title="数字设定法设置权限"></a>数字设定法设置权限</h6><p><code>chmod [n1n2n3] [文件|目录]</code></p>
<blockquote>
<p>  n1表示用户所有者的权限 ，n2表示组群所有者的权限，n3表示其它用户的权限。</p>
</blockquote>
<ul>
<li><p>文件和目录的权限表中用r、w、x这三个字符来为用户所有者、组群所有者和其它用户设置权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需3个数字。</p>
</li>
<li><p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。</p>
</li>
<li><p>所有数字属性的格式应该是三个0～7的数，其顺序是u、g、o。</p>
</li>
</ul>
<blockquote>
<p>  r：对应数值4</p>
<p>  w：对应数值2</p>
<p>  x：对应数值1</p>
<p>  -：对应数值0</p>
</blockquote>
<blockquote>
<p>  -rwx——：用数字表示为700； </p>
<p>  -rwxr–r–：用数字表示为744； </p>
<p>  -rw-rw-r-x：用数字表示为665；</p>
<p>  drwx–x–x：用数字表示为711；</p>
<p>  drwx——：用数字表示为700。</p>
</blockquote>
<blockquote>
<p>  chmod 777 a	所有用户拥有读取、写入和执行的权限</p>
<p>  chmod 7 a	设置a文件权限，其他用户拥有读取、写入和执行的权限</p>
</blockquote>
<h6 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h6><p>（1）SUID</p>
<p>对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的用户所有者身份来执行；对一个目录无影响</p>
<p>（2）SGID</p>
<p>对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的组群所有者身份来执行；对一个目录，在该目录中创建的任意新文件的所属组与该目录的所属组相同。</p>
<p>（3）Sticky</p>
<p>对一个可执行文件无影响；对目录设置Sticky之后，尽管其它用户有写权限，也必须由文件所有者执行删除和移动等操作</p>
<p><strong>文字设定法设置特殊权限</strong></p>
<p>chmod u+s a	添加a文件的特殊权限为SUID</p>
<p>chmod g+s a	添加a文件的特殊权限为SGID</p>
<p>chmod o+t a	添加a文件的特殊权限为Sticky</p>
<p><strong>数字设定法设置特殊权限</strong></p>
<p>chmod 4000 a	设置文件a具有SUID权限</p>
<p>chmod 2000 a	设置文件a具有SGID权限</p>
<p>chmod 1000 a	设置文件a具有Sticky权限</p>
<p>chmod 7000 a	设置文件a具有SUID，SGID和Sticky权限</p>
<hr>
<h5 id="如何以root权限运行某个程序"><a href="#如何以root权限运行某个程序" class="headerlink" title="如何以root权限运行某个程序"></a>如何以root权限运行某个程序</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chown root 文件</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chmod u+s 文件</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="什么是大端小端-如何判断"><a href="#什么是大端小端-如何判断" class="headerlink" title="什么是大端小端, 如何判断"></a>什么是大端小端, 如何判断</h5><p>小端模式：低的有效字节存储在低的存储器地址。小端一般为主机字节序；常用的X86结构、很多的ARM、DSP都为小端模式</p>
<p>大端模式：高的有效字节存储在低的存储器地址。大端为网络字节序</p>
<p><strong>如何判断：我们可以根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span>&#123;   </span><br><span class="line">        <span class="type">char</span> c;  <span class="comment">// 一个字节，低地址</span></span><br><span class="line">        <span class="type">int</span> i;  <span class="comment">// 四个字节，高地址</span></span><br><span class="line">    &#125;;  </span><br><span class="line">    test t; t.i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> (t.c == <span class="number">1</span>);  <span class="comment">//如果是小端,则t.c为1; 反之是大端  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述Linux内核态与用户态"><a href="#简述Linux内核态与用户态" class="headerlink" title="简述Linux内核态与用户态"></a>简述Linux内核态与用户态</h5><ol>
<li><strong>内核态与用户态</strong>：<strong>内核态</strong>（系统态）与<strong>用户态</strong>是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。</li>
<li><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</li>
<li><strong>为什么区分内核态与用户态</strong>：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑</li>
</ol>
<hr>
<h5 id="虚拟地址到物理地址怎么映射的"><a href="#虚拟地址到物理地址怎么映射的" class="headerlink" title="虚拟地址到物理地址怎么映射的"></a>虚拟地址到物理地址怎么映射的</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png" alt="image-20221205224538889"></p>
<hr>
<h5 id="说说堆栈溢出是什么-会怎么样"><a href="#说说堆栈溢出是什么-会怎么样" class="headerlink" title="说说堆栈溢出是什么, 会怎么样"></a>说说堆栈溢出是什么, 会怎么样</h5><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。常指调用堆栈溢出，本质上一种数据结构的满溢情况。堆栈溢出可以理解为两个方面：<strong>堆溢出和栈溢出。</strong></p>
<ol>
<li>堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error</li>
<li>栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error</li>
</ol>
<hr>
<h5 id="说说进程-线程-协程是什么-区别？"><a href="#说说进程-线程-协程是什么-区别？" class="headerlink" title="说说进程,线程,协程是什么,区别？"></a>说说进程,线程,协程是什么,区别？</h5><ol>
<li><p><strong>进程</strong>：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值</p>
</li>
<li><p><strong>线程</strong>：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务</p>
</li>
<li><p><strong>协程</strong>：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行</p>
</li>
<li><p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程</p>
<p>（2）一个进程挂掉，对应的线程挂掉；一个进程挂掉，不会影响其他进程</p>
<p>（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少</p>
<p>（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</p>
<p>（7）通信方式不一样</p>
</li>
<li><p><strong>线程与协程的区别：</strong></p>
<p>（1）切换开销更少。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小</p>
<p>（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高</p>
<p>（3）协程占用内存少。执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB</p>
</li>
</ol>
<hr>
<h5 id="请你说说什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程"><a href="#请你说说什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程" class="headerlink" title="请你说说什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程"></a>请你说说什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</h5><ol>
<li><p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，子进程残留资源(PCB) 存放于内核中，占用系统资源，这种进程称为僵尸进程。</p>
<p><strong>如何解决僵尸进程:</strong></p>
<p>(1) 一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的</p>
<p>(2) <strong>使用kill命令杀死其父进程</strong></p>
<p>打开终端并输入下面命令:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> Z </span><br></pre></td></tr></table></figure>

<p>会列出进程表中所有僵尸进程的详细内容。然后输入命令：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">kill</span> -<span class="variable">s</span> <span class="variable">SIGCHLD</span> <span class="function"><span class="title">pid</span>(父进程<span class="variable">pid</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说什么是守护进程-如何实现？"><a href="#说说什么是守护进程-如何实现？" class="headerlink" title="说说什么是守护进程, 如何实现？"></a>说说什么是守护进程, 如何实现？</h5><p><strong>守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务</strong></p>
<ol>
<li>创建子进程，父进程退出</li>
<li>setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </li>
<li>改变当前目录为根目录</li>
<li>重设文件权限掩码</li>
<li>关闭文件描述符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说进程通信的方式有哪些"><a href="#说说进程通信的方式有哪些" class="headerlink" title="说说进程通信的方式有哪些"></a>说说进程通信的方式有哪些</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png" alt="image-20221206023051122"></p>
<hr>
<h5 id="进程通信中的管道实现原理是什么"><a href="#进程通信中的管道实现原理是什么" class="headerlink" title="进程通信中的管道实现原理是什么"></a>进程通信中的管道实现原理是什么</h5><p>操作系统在内核中开辟一块<strong>缓冲区</strong>（称为<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制，半双工。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程）。管道本质是一种文件</p>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。读端由描述字fd[0]表示，称其为管道读端；写端由描述字fd[1]来表示。一般文件的 I&#x2F;O 函数都可以用于管道，如close()、read()、write()等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT  0      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT 1          </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="comment">//创建管道         </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];         </span><br><span class="line">    <span class="built_in">pipe</span>(fd);         </span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">//创建子进程, 父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;             </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);             </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);         </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程           </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端            </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);           </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));           </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);       </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="comment">//执行父进程           </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端             </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);             </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">255</span>];           </span><br><span class="line">        <span class="type">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in">sizeof</span>(buf));           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);       </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述mmap的原理和使用场景"><a href="#简述mmap的原理和使用场景" class="headerlink" title="简述mmap的原理和使用场景"></a>简述mmap的原理和使用场景</h5><p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size;</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<p><strong>使用场景</strong>：</p>
<ol>
<li>对同一块区域频繁读写操作；</li>
<li>可用于实现用户空间和内核空间的高效交互</li>
<li>可提供进程间共享内存及相互通信</li>
<li>可实现高效的大规模数据传输。</li>
</ol>
<hr>
<h5 id="说说常见信号"><a href="#说说常见信号" class="headerlink" title="说说常见信号"></a>说说常见信号</h5><table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody></table>
<hr>
<h5 id="进程-线程的中断切换过程是怎样的？"><a href="#进程-线程的中断切换过程是怎样的？" class="headerlink" title="进程, 线程的中断切换过程是怎样的？"></a>进程, 线程的中断切换过程是怎样的？</h5><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换</p>
<ol>
<li><p><strong>进程上下文切换</strong></p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的PCB有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的地址转换和存储保护信息</p>
<p>​    <strong>切换页目录以使用新的地址空间</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）</strong></p>
<p>（6）根据被选中进程恢复处理器现场</p>
</li>
<li><p><strong>线程上下文切换</strong></p>
<p>（1）保护被中断线程的处理器现场信息</p>
<p>（2）修改被中断线程的TCB有关信息，如线程状态等</p>
<p>（3）把被中断线程的线程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的线程</p>
<p>（5）根据被选中线程设置操作系统用到的存储保护信息</p>
<p>​    <strong>切换内核栈和硬件上下文（切换堆栈，以及各寄存器）</strong></p>
<p>（6）根据被选中线程恢复处理器现场</p>
</li>
</ol>
<hr>
<h5 id="进程五状态模型"><a href="#进程五状态模型" class="headerlink" title="进程五状态模型"></a>进程五状态模型</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/E9B05EC1EBA75193D715B4A05B0B4E4D.png" alt="img"></p>
<hr>
<h5 id="死锁产生条件以及如何解决死锁"><a href="#死锁产生条件以及如何解决死锁" class="headerlink" title="死锁产生条件以及如何解决死锁"></a>死锁产生条件以及如何解决死锁</h5><ol>
<li><p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁</p>
</li>
<li><p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>： </p>
<p>（1）<strong>互斥</strong></p>
<p>（2）<strong>请求保持</strong></p>
<p>（3）<strong>不可剥夺</strong>：进程已获得的资源，只能自己释放，不可剥夺；</p>
<p>（4）<strong>环路等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li><p><strong>如何解决</strong>：</p>
<p>（1）资源一次性分配：从而解决请求保持的问题</p>
<p>（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</p>
</li>
</ol>
<hr>
<h5 id="epoll水平触发与边缘触发的区别"><a href="#epoll水平触发与边缘触发的区别" class="headerlink" title="epoll水平触发与边缘触发的区别"></a>epoll水平触发与边缘触发的区别</h5><p>LT模式（水平触发）下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</p>
<p>而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。</p>
<hr>
<h5 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h5><p>IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
<p>无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png" alt="image-20221120132728012"></p>
<hr>
<h5 id="说说Reactor、Proactor模式"><a href="#说说Reactor、Proactor模式" class="headerlink" title="说说Reactor、Proactor模式"></a>说说Reactor、Proactor模式</h5><h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列。(线程池)</strong></li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png" alt="image-20221120194303146"></p>
<hr>
<h5 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h5><h6 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h6><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h6 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h6><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h6><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h6 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h6><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当10事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h6 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h6><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h6 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h4><h5 id="数据库事物特性-ACID"><a href="#数据库事物特性-ACID" class="headerlink" title="数据库事物特性(ACID)"></a>数据库事物特性(ACID)</h5><p>​	  原 一 隔 持 ；原子性和隔离性-&gt;推出一致性，持久性应对系统崩溃。</p>
<hr>
<h5 id="数据库并发一致性问题"><a href="#数据库并发一致性问题" class="headerlink" title="数据库并发一致性问题"></a>数据库并发一致性问题</h5><p>​	  丢 (丢失修改)  读(读脏数据)  不(不可重复读)【一次事务内的两次读数值不同】	 幻(幻影读)</p>
<ul>
<li>丢失修改：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li>
<li>读脏数据：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。</li>
<li>幻读与不可重复读类似。它发生在<strong>一个</strong>事务（T1）读取了<strong>几行数据</strong>，接着<strong>另一个</strong>并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<hr>
<h5 id="数据库封锁类型"><a href="#数据库封锁类型" class="headerlink" title="数据库封锁类型"></a>数据库封锁类型</h5><ol>
<li>读写锁(写锁X 读锁S) 	</li>
<li>意向锁(加入IX和IS)</li>
</ol>
<p>数据库封锁协议</p>
<ol>
<li>三级封锁协议(一级:写前加X	 	二级:写前加X读前加S,读完释放 	   三级:与二级一样,S锁事务结束释放)	  </li>
<li>两段锁协议(加锁与解锁串行)</li>
</ol>
<hr>
<h5 id="数据库隔离级别：未-提-可-可"><a href="#数据库隔离级别：未-提-可-可" class="headerlink" title="数据库隔离级别：未 提 可 可"></a>数据库隔离级别：未 提 可 可</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png" alt="image-20230129192103478"></p>
<hr>
<h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p> 是 MySQL 的 InnoDB 引擎的一种锁实现。MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<hr>
<h5 id="数据库关系理论设计"><a href="#数据库关系理论设计" class="headerlink" title="数据库关系理论设计"></a>数据库关系理论设计</h5><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<hr>
<h5 id="1NF-2NF-3NF-BCNF"><a href="#1NF-2NF-3NF-BCNF" class="headerlink" title="1NF	 		2NF		 3NF 		BCNF"></a>1NF	 		2NF		 3NF 		BCNF</h5><p>A-&gt;B: B依赖于A</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192017776.png" alt="image-20230129192017776"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192039819.png" alt="image-20230129192039819"></p>
<p><strong>BCNF：</strong>设关系模式R是1NF。如果对于R的每个函数依赖X-&gt;Y，X必为候选键，则R是BCNF范式。</p>
<hr>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><h6 id="什么是索引？优缺点？"><a href="#什么是索引？优缺点？" class="headerlink" title="什么是索引？优缺点？"></a>什么是索引？优缺点？</h6><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。</p>
<p>它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的 数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。</p>
<p>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小</p>
<hr>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><strong>普通索引：</strong></p>
<p>普通索引是mysql里最基本的索引，没有什么特殊性，在任何一列上都能进行创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(length));</span><br><span class="line"><span class="comment">-- 例子 length默认我们可以忽略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> <span class="keyword">user</span>(name);</span><br></pre></td></tr></table></figure>

<p><strong>主键索引</strong></p>
<p><strong>复合索引(组合索引)：</strong></p>
<p>指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。</p>
<p>复合索引的使用复合最左原则。举个例子 我们使用 phone和name创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span>  INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(column1(length),column2(length));</span><br><span class="line"><span class="comment">-- 例子 </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_phone_name <span class="keyword">ON</span> <span class="keyword">user</span>(phone,name);</span><br></pre></td></tr></table></figure>

<p>我们看下面的查询语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段才能够进行匹配。而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。</p>
<p><strong>全文索引：</strong></p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。</p>
<p>它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。正常情况下我们也不会使用到全文索引，因为这不是mysql的专长。</p>
<p><strong>空间索引：</strong></p>
<p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>创建空间索引的列必须声明为NOT NULL，只能在存储引擎为MYISAM的表中创建。</p>
<hr>
<h6 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h6><ol>
<li>B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。	辅助索引的叶子节点的 data 域记录着主键的值，需要先查找到主键值，然后再到主索引中进行查找。	</li>
<li>哈希索引，能以 O(1) 时间进行查找，但是失去了有序性。</li>
</ol>
<p>	</p>
<hr>
<h6 id="如何创建及保存MySQL的索引？"><a href="#如何创建及保存MySQL的索引？" class="headerlink" title="如何创建及保存MySQL的索引？"></a>如何创建及保存MySQL的索引？</h6><p>在创建表的时候创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX UniqIdx(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在已存在的表上创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在已经存在的表中创建索引，可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句或者CREATEINDEX语句。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx (bookId);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx <span class="keyword">ON</span> book (bookId);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="如何判断索引有没有生效？"><a href="#如何判断索引有没有生效？" class="headerlink" title="如何判断索引有没有生效？"></a>如何判断索引有没有生效？</h6><p>使用EXPLAIN语句, 假设已创建了book表, 并已经在其year_publication字段上建立了普通索引, 执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication=1990;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN语句将为我们输出详细的SQL执行信息, 其中：</p>
<ul>
<li>possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key行是MySQL实际选用的索引。</li>
</ul>
<p>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</p>
<hr>
<h6 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h6><p>MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN [EXTENDED] SELECT select_options</span><br></pre></td></tr></table></figure>

<p>使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：</p>
<ul>
<li>id：SELECT识别符。这是SELECT的查询序列号。</li>
<li>select_type：表示SELECT语句的类型。</li>
<li>table：表示查询的表。</li>
<li>type：表示表的连接类型。</li>
<li>possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key：是MySQL实际选用的索引。</li>
<li>key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。</li>
<li>ref：给出了关联关系中另一个数据表里的数据列名。</li>
<li>rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>Extra：提供了与关联操作有关的信息。</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC。。DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h6><ol>
<li>独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</li>
<li>多列索引	</li>
<li>索引列的顺序：让选择性最强的索引列放在前面。		</li>
<li>前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。	</li>
<li>覆盖索引：索引包含所有需要查询的字段的值。</li>
</ol>
<hr>
<h6 id="应该建立索引的条件"><a href="#应该建立索引的条件" class="headerlink" title="应该建立索引的条件"></a>应该建立索引的条件</h6><ol>
<li>在经常使用在 WHERE 子句中的列上面创建索引</li>
<li>在作为主键的列上</li>
<li>在经常用在连接的列上，这些列主要是一些外键</li>
<li>在经常需要根据范围进行搜索的列上创建索引</li>
<li>在经常需要排序的列上创建索引</li>
</ol>
<hr>
<h6 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h6><ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度</li>
<li>可以加速表和表之间的连接</li>
<li>加快分组和排序</li>
</ol>
<hr>
<h6 id="索引的问题"><a href="#索引的问题" class="headerlink" title="索引的问题"></a>索引的问题</h6><ol>
<li>索引有可能降低查询性能，带来磁盘的开销和处理开销等</li>
<li>太多的索引，让设计不稳定</li>
<li>对于大量数据检索，索引效率反而更低</li>
<li>不便维护</li>
<li>数据修改需求&gt;检索需求时，索引会降低性能</li>
</ol>
<hr>
<h6 id="索引的最左前缀问题"><a href="#索引的最左前缀问题" class="headerlink" title="索引的最左前缀问题"></a>索引的最左前缀问题</h6><p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<hr>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。   </li>
<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎放弃使用索引而进行全表扫描。</li>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’   </li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)   </li>
<li>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>多使用LIMIT 避免使用SELECT *</li>
</ol>
<hr>
<h5 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h5><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<hr>
<h5 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h5><p>整数类型：TINY&#x2F;SMALL&#x2F;MEDIUM INT INT BIGINT</p>
<p>实数类型：FLOAT、DOUBLE、DECIMAL</p>
<p>字符串类型：CHAR、VARCHAR、TEXT、BLOB</p>
<p>枚举类型：ENUM</p>
<p>日期与时间：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<hr>
<h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<hr>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<hr>
<h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>主要是指创建在关系模型上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。</p>
<p>—优点—</p>
<p>1.事务处理—保持数据的一致性</p>
<p>2.标准化SQL，数据更新的开销小</p>
<p>3.可以进行Join等复杂查询。</p>
<p>4.基于严格的数学</p>
<p>—缺点—</p>
<p>1.性能 2.纵向扩展 3.贵</p>
<hr>
<h5 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h5><p>—优点—</p>
<ol>
<li><p>简单的扩展（集群）</p>
</li>
<li><p>高性能（它们可以处理超大量的数据）：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作;</p>
</li>
<li><p>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本;</p>
</li>
<li><p>灵活的数据模型。不需要事先对存储数据建立字段。</p>
</li>
</ol>
<p>—缺点—</p>
<ol>
<li><p>不提供对SQL的支持：如果不支持SQL这样的工业标准，将会对用户产生一定的学习和应用迁移成本;</p>
</li>
<li><p>不支持事务，很难保证数据一致性</p>
</li>
<li><p>现有产品的不够成熟：大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语;</p>
</li>
<li><p>不能支持比较复杂的查询</p>
</li>
<li><p>NoSQL 并不完全安全稳定，由于它基于内存，一旦停电或者机器故障数据就很容易丢失数据，其持久化能力也是有限的，而基于磁盘的数据库则不会出现这样的问题</p>
</li>
</ol>
<hr>
<h5 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h5><p>实体完整性：指表中行的完整性。主要用于保证操作的数据（记录）非空、唯一且不重复。</p>
<p>域完整性：指数据库表中的列必须满足某种特定的数据类型或约束。CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL都属于域完整性的范畴。</p>
<p>参照完整性：修改表，与之相关联的表也随之改变 不一致的处理方法：拒绝执行 、级联操作 、设置为空</p>
<hr>
<h5 id="对表的外键构建索引的做法非常普遍，已被认为是常识，这样做会避免出现哪些问题？"><a href="#对表的外键构建索引的做法非常普遍，已被认为是常识，这样做会避免出现哪些问题？" class="headerlink" title="对表的外键构建索引的做法非常普遍，已被认为是常识，这样做会避免出现哪些问题？"></a>对表的外键构建索引的做法非常普遍，已被认为是常识，这样做会避免出现哪些问题？</h5><p>为确保安全，在对主表操作时，需要对参照表进行加锁操作。如果外键没有索引，查找子记录就会很慢，引起全表扫描。且参照表被锁的时间很长，进而可能发生死锁。</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191931072.png" alt="image-20230129191931072"></p>
<p><strong>所谓的一张表多个主键，我们称之为联合主键。</strong></p>
<p><strong>注：联合主键：就是用多个字段一起作为一张表的主键。</strong></p>
<hr>
<h5 id="一个好的模式分解具有哪些性质"><a href="#一个好的模式分解具有哪些性质" class="headerlink" title="一个好的模式分解具有哪些性质"></a>一个好的模式分解具有哪些性质</h5><p>无损连接分解和保持依赖</p>
<p>无损分解指的是对关系分解时，原关系模型中任意合法的列在分解之后应能通过自然联接运算恢复起来。</p>
<p>保持函数依赖指的是对关系分解时，原关系的闭包与分解后关系闭包的并集相等。</p>
<hr>
<h5 id="高级数据结构中哪些适用于内存，哪些适用于磁盘"><a href="#高级数据结构中哪些适用于内存，哪些适用于磁盘" class="headerlink" title="高级数据结构中哪些适用于内存，哪些适用于磁盘"></a>高级数据结构中哪些适用于内存，哪些适用于磁盘</h5><p>二叉搜索树、多维数组、广义表、红黑树都适用于内存；B+树，B树适用于磁盘</p>
<hr>
<h5 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h5><p>视图是从一个或几个基本表（或视图）导出的表。是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据。视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化</p>
<hr>
<h5 id="数据模型-x3D-数据结构-数据操作-数据的完整性约束"><a href="#数据模型-x3D-数据结构-数据操作-数据的完整性约束" class="headerlink" title="数据模型 &#x3D; 数据结构 + 数据操作 + 数据的完整性约束"></a>数据模型 &#x3D; 数据结构 + 数据操作 + 数据的完整性约束</h5><hr>
<h5 id="什么是分区（Partition）？根据分区键（Partition-Key）的类型分类，分区有哪几种类型？"><a href="#什么是分区（Partition）？根据分区键（Partition-Key）的类型分类，分区有哪几种类型？" class="headerlink" title="什么是分区（Partition）？根据分区键（Partition Key）的类型分类，分区有哪几种类型？"></a>什么是分区（Partition）？根据分区键（Partition Key）的类型分类，分区有哪几种类型？</h5><p>分区：就是把一张表的数据分成N个区块</p>
<p>数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。将表的数据均衡分摊到不同的硬盘，或服务器中，实际上还是一张表。</p>
<p>特性：分区能够提高并发性和并行性，从而增强系统架构的可伸缩性</p>
<p>分类：水平，垂直</p>
<hr>
<h5 id="简述SQL执行的过程"><a href="#简述SQL执行的过程" class="headerlink" title="简述SQL执行的过程"></a>简述SQL执行的过程</h5><p>1）解析： 1⃣️语法检查：检查 SQL 拼写是否符合语法规范 2⃣️语义检查：检查访问对象是否符合存在及用户是否具有相应权限 3⃣️共享池检查：在共享池中检查是否有完全相同的之前完全解析好的，如果存在，跳过后面步骤，直接运行</p>
<p>2）优化		3）生成		4）执行</p>
<hr>
<h5 id="delete、drop、-truncate区别"><a href="#delete、drop、-truncate区别" class="headerlink" title="delete、drop、 truncate区别"></a>delete、drop、 truncate区别</h5><ul>
<li>truncate和delete只删除数据，不删除表结构;drop删除表结构</li>
<li>删除数据的速度: drop &gt; truncate &gt; delete</li>
<li>delete属于DML语言，需要事务管理，commit之后才能生效; drop 和truncate属于DDL语言，操作立刻生效，不可回滚</li>
<li>使用场合:不再需要表时使用drop语句;保留表删除所有记录用truncate语句;删除部分记录用delete语句</li>
</ul>
<hr>
<h5 id="Mysql中exists和in的区别"><a href="#Mysql中exists和in的区别" class="headerlink" title="Mysql中exists和in的区别"></a>Mysql中exists和in的区别</h5><p>下面将主查询的表称为外表;子查询的表称为内表。exists与in的主要区别如下:</p>
<ul>
<li><p>子查询使用exists, 会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据;      in,会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据</p>
</li>
<li><p>内表大，用exists 效率较高;内表小，用in效率较高。</p>
</li>
<li><p>not exists的效率一般要高于not in</p>
</li>
</ul>
<hr>
<h5 id="什么是触发器，MySQL都有哪些触发器"><a href="#什么是触发器，MySQL都有哪些触发器" class="headerlink" title="什么是触发器，MySQL都有哪些触发器?"></a>什么是触发器，MySQL都有哪些触发器?</h5><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码</p>
<p>MySQL数据库中有六种触发器:</p>
<ul>
<li><p>Before Insert</p>
</li>
<li><p>After Insert</p>
</li>
<li><p>Before Update</p>
</li>
<li><p>After Update</p>
</li>
<li><p>Before Delete</p>
</li>
<li><p>After Delete</p>
</li>
</ul>
<hr>
<h5 id="堆表（HOT）和索引组织表（IOT）"><a href="#堆表（HOT）和索引组织表（IOT）" class="headerlink" title="堆表（HOT）和索引组织表（IOT）"></a>堆表（HOT）和索引组织表（IOT）</h5><p> ① 堆组织表，其索引中记录了记录所在位置的rowid(比如，文件号：页号：槽号)，查找的时候先找索引，然后再根据索引rowid找到块中的行数据。索引和表数据是分离的</p>
<p> ② 索引组织表，其行数据以索引形式存放，因此找到索引，就等于找到了行数据。索引和数据是在一起的</p>
<hr>
<h5 id="关系数据库都有哪些操作-特点是什么"><a href="#关系数据库都有哪些操作-特点是什么" class="headerlink" title="关系数据库都有哪些操作,特点是什么?"></a>关系数据库都有哪些操作,特点是什么?</h5><p>◇查询:	选择、投影、连接、除、并、交、差</p>
<p>◇数据更新:	插入、删除、修改</p>
<p>关系操作的特点：	集合操作方式，即操作的对象和结果都是集合。</p>
<hr>
<h5 id="数据库（DDL，DML，DQL、DCL）"><a href="#数据库（DDL，DML，DQL、DCL）" class="headerlink" title="数据库（DDL，DML，DQL、DCL）"></a>数据库（DDL，DML，DQL、DCL）</h5><ol>
<li><p>数据查询语言DQL</p>
<p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;  FROM &lt;表或视图名&gt;  WHERE &lt;查询条件&gt;</p>
</li>
<li><p>数据管理语言DML</p>
<p>INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据定义语言DDL</p>
<p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：    CREATE TABLE（表）&#x2F;VIEW（视图）&#x2F;INDEX（索引）&#x2F;SYN（同义词）&#x2F;CLUSTER（簇）</p>
</li>
<li><p>数据控制语言DCL</p>
<p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制　　数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ul>
<li>GRANT：授权。　　</li>
<li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK 回滚命令使数据库状态回到上次最后提交的状态。其格式为：SQL&gt;ROLLBACK;　　</li>
<li>COMMIT [WORK]：提交。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p><strong>使用关联多列索引时，跳过左边的右边的全部失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and c &#x3D; 3，索引a是最左边的，c是最右边的，而这里只写了a和c的条件，跳过了b,那b右边的c虽然写了条件c&#x3D;3但是查询的时候也用不上</p>
<p><strong>范围条件右边失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and b &gt; 2 and c &#x3D; 3，b是个范围条件，那么索引智能用到a和b，c是范围条件右边的内容，索引用不到</p>
<p>注意：a &#x3D; 1 and b &gt; 2 and c &#x3D; 3和a &#x3D; 1 and c &#x3D; 3 and b &gt; 2是一样的，a、b、c的顺序不是写sql条件时的顺序，而是建立索引时的顺序</p>
<p><strong>模糊查询like ‘%’在左边时失效</strong></p>
<p>例如:条件where name like ‘%a’,这里name这个索引时用不上的</p>
<hr>
<h5 id="B树-x2F-B-树"><a href="#B树-x2F-B-树" class="headerlink" title="B树&#x2F;B+树"></a>B树&#x2F;B+树</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191753177.png" alt="image-20230129191753177"></p>
<hr>
<h5 id="各种连接"><a href="#各种连接" class="headerlink" title="各种连接"></a>各种连接</h5><p><strong>内连接：</strong>只连接匹配的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 &#x3D; B.c3;</p>
<p><strong>自然连接</strong>：是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p>
<p><strong>左外连接：</strong>包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）以及右边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A left join B on A.c3 &#x3D; B.c3;</p>
<p><strong>右外连接：</strong>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）以及左边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A right join B on A.c3 &#x3D; B.c3;</p>
<p><strong>全外连接：</strong>包含左、右两个表的全部行，不管在另一边的表中是否存在与它们匹配的行</p>
<p>select A.c1,B.c2 from A full join B on A.c3 &#x3D; B.c3;</p>
<p><strong>（theta）连接：</strong>使用等值以外的条件来匹配左、右两个表中的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 !&#x3D; B.c3;</p>
<p><strong>交叉连接：</strong>生成笛卡尔积——它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行一一匹配</p>
<p>select A.c1,B.c2 from A,B;</p>
<hr>
<h5 id="数据库连接池优点"><a href="#数据库连接池优点" class="headerlink" title="数据库连接池优点"></a>数据库连接池优点</h5><p><strong>①资源重用</strong></p>
<p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。</p>
<p><strong>②更快的系统响应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p>
<p><strong>③强制收回被占用的连接，避免数据库连接泄露</strong></p>
<hr>
<h5 id="MySQL的慢查询优化有了解吗？"><a href="#MySQL的慢查询优化有了解吗？" class="headerlink" title="MySQL的慢查询优化有了解吗？"></a>MySQL的慢查询优化有了解吗？</h5><p>优化MySQL的慢查询，可以按照如下步骤进行：</p>
<p><strong>开启慢查询日志：</strong>在MySQL服务启动的时候使用<code>--log-slow-queries[=file_name]</code>启动慢查询日志。</p>
<p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p>
<p><strong>分析慢查询日志：</strong></p>
<p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p>
<p><strong>常见慢查询优化：</strong></p>
<ol>
<li><p>索引没起作用的情况</p>
<ul>
<li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</li>
<li>MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。</li>
<li>查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。</li>
</ul>
</li>
<li><p>优化数据库结构</p>
<ul>
<li>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</li>
</ul>
</li>
<li><p>分解关联查询</p>
<p>很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。</p>
</li>
<li><p>优化LIMIT分页</p>
<p>当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p>
</li>
</ol>
<hr>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="六种关系"><a href="#六种关系" class="headerlink" title="六种关系"></a>六种关系</h5><p>依赖</p>
<p>依赖关系是在运行过程中起作用的，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom: 67%;">

<p>关联</p>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定；体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。一般是长期性的，而且双方的关系一般是平等的</p>
<ul>
<li>类B以类属性的形式出现在关联类A中</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png" alt="在这里插入图片描述"></p>
<p>聚合</p>
<p>但是公司和员工就属于聚合关系了，因为公司没了员工还在</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>组合</p>
<p>组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="img" style="zoom:67%;">



<p>继承（extend）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>实现（implement）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">

<hr>
<h5 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png" alt="image-20230129223341112"></p>
<hr>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>懒汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="type">pthread_mutex_t</span> mutex;<span class="comment">//mutex mlock; 加锁互斥</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//mlock.lock();</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">singleInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//mlock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;; <span class="comment">// 它拥有一个私有构造函数，这确保用户无法通过new直接实例它</span></span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    <span class="type">static</span> singleInstance* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleInstance* singleInstance::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回静态成员变量 </span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123; <span class="comment">// 饿汉式，直接创建一个对象，不需要加锁</span></span><br><span class="line">        <span class="type">static</span> singleInstance instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回</span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="请说说工厂设计模式"><a href="#请说说工厂设计模式" class="headerlink" title="请说说工厂设计模式"></a>请说说工厂设计模式</h5><p> 工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong></p>
<h6 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h6><p>  它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png" alt="img" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象,降低了耦合性</p>
<p><strong>缺点：</strong>就是要增加新的核类型时，就需要修改工厂类。这就违反了开闭原则</p>
<h6 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h6><p>  所谓工厂方法模式, 是指定义一个用于创建对象的接口, 让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png" alt="img" style="zoom: 33%;">

<p>  <strong>举例：</strong>这家生产处理器核的产家决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。  </p>
<p><strong>缺点：</strong>每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义</p>
<h6 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h6><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png" alt="image-20221116164855060" style="zoom:50%;">

<p><strong>举例：</strong>这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h6 id="⭐️三种工厂模式的区别"><a href="#⭐️三种工厂模式的区别" class="headerlink" title="⭐️三种工厂模式的区别"></a>⭐️三种工厂模式的区别</h6><p>简单工厂 ：用来生产同一产品族中的任意产品(对于增加新的产品，无能为力)</p>
<p>工厂方法 ：用来生产同一产品族中的固定产品(支持增加任意产品)</p>
<p>抽象工厂 ：按产品族抽象，这方便增加某个产品族内的具体产品；按具体产品抽象，这方便增加产品族；</p>
<hr>
<hr>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/" rel="prev" title="链表逆置合集">
      <i class="fa fa-chevron-left"></i> 链表逆置合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/" rel="next" title="链表之链表排序合集">
      链表之链表排序合集 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-x2F-C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">C&#x2F;C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8BC-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">简述下C++语言的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">说说C语言和C++的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">说说 C++中 struct 和 class 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.4.</span> <span class="nav-text">说说头文件双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8CC%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">说说C++结构体和C结构体的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9FC-%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8CC%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">导入C函数的关键字？C++编译时和C有何不同？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.7.</span> <span class="nav-text">简述C++从代码到可执行文件过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.8.</span> <span class="nav-text">说说 static关键字的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.9.</span> <span class="nav-text">说说静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.10.</span> <span class="nav-text">说说静态局部变量,全局变量,局部变量的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.</span> <span class="nav-text">说说数组和指针的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.12.</span> <span class="nav-text">说说什么是函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">nullptr可以调用成员函数吗？为什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.14.</span> <span class="nav-text">说说使用指针需要注意什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88-%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.1.15.</span> <span class="nav-text">说说什么是野指针,怎么产生的,如何避免？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.16.</span> <span class="nav-text">说说内联函数和函数的区别,内联函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.17.</span> <span class="nav-text">说说内联函数和宏函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%90%E7%AE%97%E7%AC%A6i-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.18.</span> <span class="nav-text">说说运算符i++和++i的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.19.</span> <span class="nav-text">说说new和malloc的区别，各自底层实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.20.</span> <span class="nav-text">说说const和define的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a"><span class="nav-number">1.1.21.</span> <span class="nav-text">说说const int *a, int const *a, const int a, int *const a, const int *const a</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.22.</span> <span class="nav-text">简述C++有几种传值方式,区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程运行时虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">简述一下堆和栈的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">简述C++的内存管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.5.</span> <span class="nav-text">简述C++中内存对齐的使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.1.</span> <span class="nav-text">简述一下面向对象的三大特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">成员访问限定符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.3.3.</span> <span class="nav-text">简述一下 C++重载和重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.3.4.</span> <span class="nav-text">说说 C++ 重载和重写是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.3.5.</span> <span class="nav-text">说说C++构造函数有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.6.</span> <span class="nav-text">*拷贝构造函数的参数是什么传递方式,为什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.3.7.</span> <span class="nav-text">拷贝构造和移动构造的不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.8.</span> <span class="nav-text">只定义析构函数,会自动生成哪些构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.9.</span> <span class="nav-text">一个类默认会生成哪些函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F-%E6%9C%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.10.</span> <span class="nav-text">说说 C++ 类对象的初始化顺序,有多重继承情况下的顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.3.11.</span> <span class="nav-text">简述下向上转型和向下转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.12.</span> <span class="nav-text">简述下深拷贝和浅拷贝, 如何实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.13.</span> <span class="nav-text">简述一下 C++ 中的多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">1.3.14.</span> <span class="nav-text">说说为什么要虚析构, 为什么不能虚构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.15.</span> <span class="nav-text">说说模板类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.16.</span> <span class="nav-text">C++ 类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.17.</span> <span class="nav-text">简述一下什么是常函数，有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.3.18.</span> <span class="nav-text">说说 C++ 中什么是菱形继承问题，如何解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.19.</span> <span class="nav-text">说说什么是虚继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.20.</span> <span class="nav-text">简述一下虚函数和纯虚函数, 以及实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.21.</span> <span class="nav-text">说说C++中虚函数与纯虚函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.22.</span> <span class="nav-text">仿函数了解吗？有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%EF%BC%88-friend%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.23.</span> <span class="nav-text">C++友元函数和友元类（ friend）详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.24.</span> <span class="nav-text">C++ 中哪些函数不能被声明为虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.25.</span> <span class="nav-text">类模板和模板类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-STL"><span class="nav-number">1.4.</span> <span class="nav-text">C++STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">请说说 STL 的基本组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">请说说 STL 中常见的容器, 并介绍一下实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-map-hashtable-deque-list-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">说说 STL 中 map, hashtable, deque, list 的实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8DC-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.4.4.</span> <span class="nav-text">两种C++类对象实例化方式的异同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">迭代器用过吗？什么时候会失效？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BSTL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8-%E6%9C%89%E6%8C%87%E9%92%88%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">说一下STL中迭代器的作用, 有指针为何还要迭代器？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.7.</span> <span class="nav-text">说说 STL 中 resize 和 reserve 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-map%E5%92%8C-unordered-map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.8.</span> <span class="nav-text">说说 map和 unordered_map 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-vector-%E5%92%8C-list-%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">说说 vector 和 list 的区别, 分别适用于什么场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vector-%E7%9A%84-%E9%83%A8%E5%88%86STL-%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.10.</span> <span class="nav-text">vector 的 部分STL 源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-STL-%E4%B8%AD%E7%9A%84-map-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.11.</span> <span class="nav-text">简述 STL 中的 map 的实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8B-map-%E5%92%8C-set-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.12.</span> <span class="nav-text">说下 map 和 set 有什么区别, 分别是怎么实现的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-push-back-%E5%92%8C-emplace-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.13.</span> <span class="nav-text">说说 push_back 和 emplace_back 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">C++新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-11-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.5.1.</span> <span class="nav-text">说说 C++11 的新特性有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.5.2.</span> <span class="nav-text">说说 C++中的智能指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">2.1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%81%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%81tar%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">文件权限怎么修改</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">文字设定法设置权限</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">数字设定法设置权限</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">特殊权限</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%A5root%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">如何以root权限运行某个程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD"><span class="nav-number">2.1.4.</span> <span class="nav-text">什么是大端小端, 如何判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Linux%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">2.1.5.</span> <span class="nav-text">简述Linux内核态与用户态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E6%98%A0%E5%B0%84%E7%9A%84"><span class="nav-number">2.1.6.</span> <span class="nav-text">虚拟地址到物理地址怎么映射的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">2.1.7.</span> <span class="nav-text">说说堆栈溢出是什么, 会怎么样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.1.8.</span> <span class="nav-text">说说进程,线程,协程是什么,区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.1.9.</span> <span class="nav-text">请你说说什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">2.1.10.</span> <span class="nav-text">说说什么是守护进程, 如何实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.1.11.</span> <span class="nav-text">说说进程通信的方式有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.12.</span> <span class="nav-text">进程通信中的管道实现原理是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0mmap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.13.</span> <span class="nav-text">简述mmap的原理和使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.1.14.</span> <span class="nav-text">说说常见信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.15.</span> <span class="nav-text">进程, 线程的中断切换过程是怎样的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.16.</span> <span class="nav-text">进程五状态模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">2.1.17.</span> <span class="nav-text">死锁产生条件以及如何解决死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.18.</span> <span class="nav-text">epoll水平触发与边缘触发的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">2.1.19.</span> <span class="nav-text">阻塞和非阻塞、同步和异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4Reactor%E3%80%81Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.20.</span> <span class="nav-text">说说Reactor、Proactor模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.20.1.</span> <span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.20.2.</span> <span class="nav-text">Proactor模式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unix%E3%80%81Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.21.</span> <span class="nav-text">Unix、Linux上的五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.21.1.</span> <span class="nav-text">阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.21.2.</span> <span class="nav-text">非阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">2.1.21.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="nav-number">2.1.21.4.</span> <span class="nav-text">信号驱动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.21.5.</span> <span class="nav-text">异步IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.21.6.</span> <span class="nav-text">⭐️5种IO模型的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA"><span class="nav-number">3.1.</span> <span class="nav-text">数据库理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9%E7%89%B9%E6%80%A7-ACID"><span class="nav-number">3.1.1.</span> <span class="nav-text">数据库事物特性(ACID)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.2.</span> <span class="nav-text">数据库并发一致性问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">数据库封锁类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A%E6%9C%AA-%E6%8F%90-%E5%8F%AF-%E5%8F%AF"><span class="nav-number">3.1.4.</span> <span class="nav-text">数据库隔离级别：未 提 可 可</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Next-Key-Locks"><span class="nav-number">3.1.5.</span> <span class="nav-text">Next-Key Locks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E7%90%86%E8%AE%BA%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.1.6.</span> <span class="nav-text">数据库关系理论设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1NF-2NF-3NF-BCNF"><span class="nav-number">3.1.7.</span> <span class="nav-text">1NF	 		2NF		 3NF 		BCNF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.8.</span> <span class="nav-text">数据库索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">什么是索引？优缺点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">索引的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.8.3.</span> <span class="nav-text">索引的数据结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BF%9D%E5%AD%98MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">3.1.8.4.</span> <span class="nav-text">如何创建及保存MySQL的索引？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88%EF%BC%9F"><span class="nav-number">3.1.8.5.</span> <span class="nav-text">如何判断索引有没有生效？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EXPLAIN"><span class="nav-number">3.1.8.6.</span> <span class="nav-text">EXPLAIN</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.8.7.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.1.8.8.</span> <span class="nav-text">应该建立索引的条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">3.1.8.9.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.8.10.</span> <span class="nav-text">索引的问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.8.11.</span> <span class="nav-text">索引的最左前缀问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.9.</span> <span class="nav-text">sql优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM"><span class="nav-number">3.1.10.</span> <span class="nav-text">InnoDB和MyISAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.11.</span> <span class="nav-text">Mysql数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.12.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">3.1.13.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.14.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Nosql"><span class="nav-number">3.1.15.</span> <span class="nav-text">Nosql</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">3.1.16.</span> <span class="nav-text">数据库完整性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%A1%A8%E7%9A%84%E5%A4%96%E9%94%AE%E6%9E%84%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%81%9A%E6%B3%95%E9%9D%9E%E5%B8%B8%E6%99%AE%E9%81%8D%EF%BC%8C%E5%B7%B2%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E5%B8%B8%E8%AF%86%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%81%9A%E4%BC%9A%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.1.17.</span> <span class="nav-text">对表的外键构建索引的做法非常普遍，已被认为是常识，这样做会避免出现哪些问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%B4%A8"><span class="nav-number">3.1.18.</span> <span class="nav-text">一个好的模式分解具有哪些性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E5%93%AA%E4%BA%9B%E9%80%82%E7%94%A8%E4%BA%8E%E5%86%85%E5%AD%98%EF%BC%8C%E5%93%AA%E4%BA%9B%E9%80%82%E7%94%A8%E4%BA%8E%E7%A3%81%E7%9B%98"><span class="nav-number">3.1.19.</span> <span class="nav-text">高级数据结构中哪些适用于内存，哪些适用于磁盘</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.20.</span> <span class="nav-text">视图的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-x3D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">3.1.21.</span> <span class="nav-text">数据模型 &#x3D; 数据结构 + 数据操作 + 数据的完整性约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%8C%BA%EF%BC%88Partition%EF%BC%89%EF%BC%9F%E6%A0%B9%E6%8D%AE%E5%88%86%E5%8C%BA%E9%94%AE%EF%BC%88Partition-Key%EF%BC%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%EF%BC%8C%E5%88%86%E5%8C%BA%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">3.1.22.</span> <span class="nav-text">什么是分区（Partition）？根据分区键（Partition Key）的类型分类，分区有哪几种类型？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0SQL%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.23.</span> <span class="nav-text">简述SQL执行的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete%E3%80%81drop%E3%80%81-truncate%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.24.</span> <span class="nav-text">delete、drop、 truncate区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mysql%E4%B8%ADexists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.25.</span> <span class="nav-text">Mysql中exists和in的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%8CMySQL%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">3.1.26.</span> <span class="nav-text">什么是触发器，MySQL都有哪些触发器?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E8%A1%A8%EF%BC%88HOT%EF%BC%89%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%88IOT%EF%BC%89"><span class="nav-number">3.1.27.</span> <span class="nav-text">堆表（HOT）和索引组织表（IOT）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C-%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.28.</span> <span class="nav-text">关系数据库都有哪些操作,特点是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88DDL%EF%BC%8CDML%EF%BC%8CDQL%E3%80%81DCL%EF%BC%89"><span class="nav-number">3.1.29.</span> <span class="nav-text">数据库（DDL，DML，DQL、DCL）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">3.1.30.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B%E6%A0%91-x2F-B-%E6%A0%91"><span class="nav-number">3.1.31.</span> <span class="nav-text">B树&#x2F;B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.1.32.</span> <span class="nav-text">各种连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="nav-number">3.1.33.</span> <span class="nav-text">数据库连接池优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.1.34.</span> <span class="nav-text">MySQL的慢查询优化有了解吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">4.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.1.</span> <span class="nav-text">六种关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">4.1.2.</span> <span class="nav-text">面向对象设计原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.3.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.4.</span> <span class="nav-text">请说说工厂设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.4.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.4.4.</span> <span class="nav-text">⭐️三种工厂模式的区别</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
