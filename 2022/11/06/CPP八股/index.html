<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="C++八股">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股">
<meta property="og:url" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="C++八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230502080518742.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215210345480.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150925539.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150826237.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323152150339.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207131212493.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207143613149.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230327182127099.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131442484.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131536296.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131834043.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131924338.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132509995.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132827930.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161432357.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103852887.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230406225101735.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161511598.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AB3FC1B1325FA341A39644BA061FA439.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230208211405978.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183029287.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181113760.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182404371.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/b0b1814b7ed7990ea54c117fbff29599.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152923685.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152937850.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183418866.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183448058.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/1011415-20170701192633914-1313517581-20230303141645878.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408103355270.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408103757831.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230415124213113.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230415124310204.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408105440294.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408110247633.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408110921178.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408111425752.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408111639335.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408112035495.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408112241808.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218115419272.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230219191007830.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230413593.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230607279.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218122345750.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409231715303.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230220214904180.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182905354.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182934695.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230330220200112.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221143214363.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230412120540372.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227144327617.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120203431492.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221161535855.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221029160442047.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131733787.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131811712.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131913227.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221132718380.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133036044.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133148277.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133313580.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135029847.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135135171.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135313611.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135454172.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145537174.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120441103.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145816015.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145841789.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151210972.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151031497.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151550693.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331141852209.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331142913248.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409165759148.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409165506186.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221130979.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221213065.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221528931.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407222412142.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407223527749.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407224347287.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408212943630.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408213627214.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-9b53bd65fa9e11eeefd5331833d41c78_1440w.webp">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-05b80ce9095004381b5846c6179f932e_r.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-8713b773762e9644c38defa5086afacd_r.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-4abb923772ec1be269843c977b5af3c8_r.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-793f4024bfcb648d9aab2a3dfe6b80de_r.jpg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230222155844859.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200347354.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200602769.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230309193955191.png">
<meta property="article:published_time" content="2022-11-06T14:21:59.000Z">
<meta property="article:modified_time" content="2023-09-06T07:18:36.842Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230502080518742.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++八股 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/11/06/CPP%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++八股
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 22:21:59" itemprop="dateCreated datePublished" datetime="2022-11-06T22:21:59+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-06 15:18:36" itemprop="dateModified" datetime="2023-09-06T15:18:36+08:00">2023-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C++八股</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="0️⃣C-x2F-C-基础"><a href="#0️⃣C-x2F-C-基础" class="headerlink" title="0️⃣C&#x2F;C++基础"></a>0️⃣C&#x2F;C++基础</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><p>向上转型为什么是安全的？</p>
<p>向上转型是安全的，因为它是将子类对象转换为父类对象，不会丢失子类对象的任何信息。这是因为子类继承了父类的属性和方法，所以子类对象包含了父类对象的所有信息</p>
<h5 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++ 中的四种类型转换"></a>C++ 中的四种类型转换</h5><p><code>static_cast&lt;type&gt;(a)</code> </p>
<blockquote>
<p>  和传统的C语言的强制转换一样，不做任何检查，如转型失败会发生未知错误。</p>
<p><code>static_cast&lt;type&gt;(a)</code> 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int 这种转换的安全性也要开发人员来保证</p>
</blockquote>
<p><code>dynamic_cast&lt;type&gt;(a)</code></p>
<blockquote>
<p>   主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全</p>
<p>  转型失败会返回0并抛出bad_cast</p>
</blockquote>
<p><code>const_cast&lt;type&gt;(a)</code> ：用来去除<strong>某指针或者引用的</strong>const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 </p>
<p><code>reinterpret_cast&lt;type&gt;(a) </code>：可进行任意转型，把a中的内存按type的方式来解读，需要程序员保证转换的正确性。</p>
<hr>
<h5 id="说说-C-中-struct-和-class-的区别"><a href="#说说-C-中-struct-和-class-的区别" class="headerlink" title="说说 C++中 struct 和 class 的区别"></a>说说 C++中 struct 和 class 的区别</h5><ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 private </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 默认是公有继承，而 class 是私有继承</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Y&amp; y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说头文件双引号””和尖括号-lt-gt-的区别"><a href="#说说头文件双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说头文件双引号””和尖括号&lt;&gt;的区别"></a>说说头文件双引号””和尖括号&lt;&gt;的区别</h5><ul>
<li>&lt;&gt;的头文件是<strong>系统文件</strong>，””的头文件是<strong>自定义文件</strong></li>
<li>编译器预处理阶段查找头文件的路径不一样<ul>
<li>使用&lt;&gt;的头文件：编译器设置的头文件路径</li>
<li>使用””的头文件：当前目录 or g++指定-I参数查找</li>
</ul>
</li>
</ul>
<hr>
<h5 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h5><ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充, 它们在声明时的区别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制权限</td>
<td align="center">默认public，不能修改</td>
<td align="center">public&#x2F;private&#x2F;protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可继承类或者其他结构体</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;  </span><br><span class="line">  <span class="type">int</span>  iAgeNum;  </span><br><span class="line">  string strName; </span><br><span class="line">&#125; <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Student2; <span class="comment">//C中取别名  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1; <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line">Student stu3;  <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="导入C函数的关键字？C-编译时和C有何不同？"><a href="#导入C函数的关键字？C-编译时和C有何不同？" class="headerlink" title="导入C函数的关键字？C++编译时和C有何不同？"></a>导入C函数的关键字？C++编译时和C有何不同？</h5><ol>
<li><p><strong>关键字：</strong>在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为<strong>extern “C”</strong>。加上extern “C”后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而非C++的</p>
</li>
<li><p><strong>编译区别：</strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时只包括<strong>函数名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="⚠️简述C-从代码到可执行文件过程"><a href="#⚠️简述C-从代码到可执行文件过程" class="headerlink" title="⚠️简述C++从代码到可执行文件过程"></a>⚠️简述C++从代码到可执行文件过程</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230502080518742.png" alt="image-20230502080518742"></p>
<p> C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预处理、编译、汇编、链接</strong>。</p>
<ol>
<li><p>预处理</p>
<p>（1） 展开所有的宏定义#define</p>
<p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p>
<p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p>
<p>（4） 过滤所有的注释, 添加行号, 添加文件名标识</p>
</li>
<li><p>编译 - 处理内联函数，constexpr,static</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树</p>
<p>（3） 语义分析：判断表达式是否有意义</p>
<p>（4） 代码优化</p>
<p>（5） 生成汇编代码</p>
</li>
<li><p>汇编    将汇编代码 -&gt; 机器码</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。分为静态链接和动态链接。</p>
<p><strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；Windows下.lib	Linux下.a</p>
<blockquote>
<p>  <code>ar rcs Calc.a x.o y.o</code></p>
<p>  <code>gcc main.c -o myprogramme -L ./ -l Calc</code>		[第一个myprogramme是生成的可执行文件名]</p>
</blockquote>
<p><strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，生成的可执行文件中没有函数代码, 只包含函数的重定位信息, 在执行的过程中，再去找要链接的函数. 所以当删除动态库时，可执行程序就不能运行. Windows下.dll，Linux下.so</p>
<blockquote>
<p>   <code>gcc -c -fPIC a.c b.c</code>		gcc 得到.o文件，得到和位置无关的代码<br>  <code>gcc -shared a.o b.o -o libcalc.so</code>		gcc 得到动态库</p>
</blockquote>
</li>
</ol>
<p>	</p>
<hr>
<h5 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h5><ol>
<li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li>
<li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。</li>
<li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li>
<li><strong>静态成员函数和静态成员变量</strong>是类的一部分,可以被多个对象所共享,无法访问一个对象中的非静态成员</li>
</ol>
<hr>
<h5 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h5><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化</p>
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造</p>
<hr>
<h5 id="说说静态局部变量-全局变量-局部变量的特点"><a href="#说说静态局部变量-全局变量-局部变量的特点" class="headerlink" title="说说静态局部变量, 全局变量, 局部变量的特点"></a>说说静态局部变量, 全局变量, 局部变量的特点</h5><ol>
<li><p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件</p>
<p>全局变量：全局作用域，可以通过extern作用于其他的源文件</p>
</li>
<li><p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值</p>
</li>
</ol>
<hr>
<h5 id="说说什么是函数指针"><a href="#说说什么是函数指针" class="headerlink" title="说说什么是函数指针"></a>说说什么是函数指针</h5><ol>
<li><strong>概念：</strong>函数指针就是<strong>指向函数入口地址</strong>的指针。</li>
<li><strong>定义</strong>形式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in">int</span> (*f)(<span class="type">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *,<span class="type">const</span> <span class="type">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a , <span class="type">const</span> <span class="type">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in">sizeof</span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="nullptr可以调用成员函数吗？为什么？"><a href="#nullptr可以调用成员函数吗？为什么？" class="headerlink" title="nullptr可以调用成员函数吗？为什么？"></a>nullptr可以调用成员函数吗？为什么？</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn = <span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();  <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以，因为在<strong>编译时指针</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this&#x3D;nullptr，运行出错。</p>
<hr>
<h5 id="内联函数和函数的区别-内联函数的作用"><a href="#内联函数和函数的区别-内联函数的作用" class="headerlink" title="内联函数和函数的区别,内联函数的作用"></a>内联函数和函数的区别,内联函数的作用</h5><ol>
<li>内联函数:调用表达式用内联函数体来替换,避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<hr>
<h5 id="说说内联函数和宏的区别"><a href="#说说内联函数和宏的区别" class="headerlink" title="说说内联函数和宏的区别"></a>说说内联函数和宏的区别</h5><ol>
<li><strong>宏定义不是函数</strong>，相当于直接替换；<strong>而内联函数本质上是一个函数</strong>，内联函数满足函数的性质，比如有返回值、参数列表</li>
<li><strong>宏函数</strong>是在预编译的时候字符串替换；<strong>而内联函数</strong>则是在编译的时候进行代码插入</li>
<li><strong>宏定义</strong>是没有类型检查的；<strong>而内联函数</strong>在编译的时候会进行类型的检查</li>
</ol>
<hr>
<h5 id="说说new和malloc的区别，底层实现原理"><a href="#说说new和malloc的区别，底层实现原理" class="headerlink" title="说说new和malloc的区别，底层实现原理"></a>说说new和malloc的区别，底层实现原理</h5><ol>
<li>new是操作符可以被重载，而malloc是函数</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转</li>
<li>new分配内存更直接和安全</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk () 函数【当进程需要分配更多内存时，可以使用<code>brk()</code>函数将堆的结束位置向上移动一定的距离。相反，当进程释放内存时，可以使用<code>brk()</code>将堆的结束位置向下移动】；当开辟的空间大于 128K 时，调用mmap()</p>
<p>malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<p> (1) 创建一个新的对象</p>
<p> (2) 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
<p> (3) 执行构造函数（为这个新对象添加属性）</p>
<hr>
<h5 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h5><ol>
<li>delete 是操作符，而 free 是函数；</li>
<li>free 不会调用对象的析构函数，而 delete 会调用对象的析构函数；</li>
<li>调用 free 之前需要检查要释放的指针是否为 NULL，使用 delete 释放内存则不需要检查指针是否为 NULL；</li>
</ol>
<hr>
<h5 id="说说const和define的区别。"><a href="#说说const和define的区别。" class="headerlink" title="说说const和define的区别。"></a>说说const和define的区别。</h5><p>const用于定义常量；而define用于定义宏 ：</p>
<ol>
<li>const生效于编译的阶段；define生效于预处理阶段</li>
<li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的</li>
<li>const定义的常量是带类型的；define定义的常量不带类型，不利于类型检查</li>
</ol>
<hr>
<h5 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">const</span> <span class="type">int</span> a;     <span class="comment">// 指的是a是一个常量，不允许修改</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// 同 const int *a;</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="number">5.</span> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> a;   <span class="comment">// 都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️同名全局变量在多个c文件中公用的方法"><a href="#⚠️同名全局变量在多个c文件中公用的方法" class="headerlink" title="⚠️同名全局变量在多个c文件中公用的方法"></a>⚠️同名全局变量在多个c文件中公用的方法</h5><p>项目文件夹下有a.c、b.c和c.h三个文件, 其中a.c和b.c文件中都#include c.h <strong>我们希望声明一个变量key，在a.c和b.c中公用</strong></p>
<p>有人想，既然是想两个文件都用，那就在c.h中声明一个unsigned char key，然后由于包含关系，在a.c和b.c中都是可见的，所以就能共用了,但实际写出来，我们发现编译的时候编译器提示出错，编译器认为我们重复定义了key这个变量。这是因为**#include命令就是原封不动的把头文件中的内容搬到#include的位置**，所以相当于a.c和b.c中都执行了一次unsigned char key，而C语言中全局变量是项目内可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义</p>
<p><strong>正确办法1：</strong>使用extern关键字来声明变量为外部变量。在其中一个c文件中定义一个全局变量key，然后在另一个要使用key的c文件中用extern声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：<strong>定义</strong>和<strong>声明</strong>。例如在a.c文件中定义变量key，在b.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png" alt="image-20230215202524179" style="zoom:50%;">

<p><strong>正确办法2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a.c文件中：*/</span></span><br><span class="line"><span class="type">uint8_t</span> changeflag = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*c.h文件中：*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> changeflag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*b.c文件中：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span> <span class="comment">// 这样就已经可以使用全局变量 changeflag 了。</span></span></span><br></pre></td></tr></table></figure>

<p><strong>正确方法3:</strong> 在不同的C文件中以<strong>static形式来声明同名全局变量</strong></p>
<hr>
<h5 id="c-命名空间"><a href="#c-命名空间" class="headerlink" title="c++命名空间"></a>c++命名空间</h5><p>namespace命名空间语法，定义格式为namespace  A {}，大括号是范围限定，也就是括号内是一个整体空间，可以有任何东西，如变量、函数等，括号内可以直接引用，而括号外的想相互访问必须指定<strong>空间名称+内部名称</strong>，namespace本质上就是改变全局变量或函数的链接属性，即改变作用域。</p>
<p><strong>定义:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test&#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line">test::<span class="built_in">func1</span>();</span><br><span class="line">test::<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">using</span> test::func1; <span class="comment">//单独声明命名空间中的func1函数</span></span><br><span class="line"><span class="built_in">func1</span>();            <span class="comment">//直接使用func1，无须添加其他的前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> test;  <span class="comment">//将整个命名空间全部声明</span></span><br><span class="line">func1（）;            <span class="comment">//访问空间内的函数1</span></span><br><span class="line">func2（）;            <span class="comment">//访问空间内的函数2</span></span><br></pre></td></tr></table></figure>

<p><strong>跨文件使用:</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215210345480.png" alt="image-20230215210345480"></p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h6><p><strong>命名空间只能全局范围内定义（以下错误写法)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> A&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间可嵌套命名空间</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123; <span class="type">int</span> a = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123; <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;	<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-如何在main函数前运行一个函数"><a href="#C-如何在main函数前运行一个函数" class="headerlink" title="C++如何在main函数前运行一个函数"></a>C++如何在main函数前运行一个函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Init function is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitWrapper</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InitWrapper s_initWrapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main function is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这种方法虽然可以在 <code>main()</code> 函数执行之前执行一个函数，但是由于全局变量的构造函数在程序启动时会被自动调用，因此在多个文件中定义全局变量时可能会引起链接错误。为了避免这个问题，可以将全局变量定义在一个独立的文件中，并在其他文件中使用该全局变量</p>
<hr>
<h5 id="Explicit和隐式类型转换"><a href="#Explicit和隐式类型转换" class="headerlink" title="Explicit和隐式类型转换"></a>Explicit和隐式类型转换</h5><p>隐式类型转换指的是一种自动进行的类型转换，将一个数据类型自动转换为另一个数据类型，而不需要显式地调用任何类型转换函数。</p>
<p>隐式类型转换在表达式求值时自动发生，可以将一个值从一种数据类型转换为另一种数据类型。例如，当一个<code>int</code>类型的值被赋值给一个<code>float</code>类型的变量时，就会发生隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> f = n; <span class="comment">// 隐式类型转换，将n从int类型转换为float类型</span></span><br></pre></td></tr></table></figure>

<p>此外，当表达式中出现多种数据类型时，也会发生隐式类型转换，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = n + f; <span class="comment">// 隐式类型转换，将n和f分别转换为double类型，然后执行加法运算</span></span><br></pre></td></tr></table></figure>

<p>虽然隐式类型转换可以方便地进行数据类型的转换，但是在某些情况下可能会引发一些不必要的错误或问题，因此需要谨慎使用。可以通过使用<code>explicit</code>关键字来限制某些类型转换的发生，使代码更加明确和安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        value = n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">//MyClass obj = n; // 错误，不能进行隐式类型转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(n)</span></span>; <span class="comment">// 正确，使用显式构造函数进行对象创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果去掉<code>explicit</code>关键字，则可以进行隐式类型转换，例如<code>MyClass obj = n;</code>就可以编译通过，将一个<code>int</code>类型的变量转换为<code>MyClass</code>类型的对象</p>
<h4 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h4><h5 id="⚠️进程运行时虚拟地址空间"><a href="#⚠️进程运行时虚拟地址空间" class="headerlink" title="⚠️进程运行时虚拟地址空间"></a>⚠️进程运行时虚拟地址空间</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png" alt="img" style="zoom: 67%;">

<ol>
<li><p><strong>data段：</strong>已初始化的全局变量和静态变量</p>
</li>
<li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</p>
</li>
<li><p><strong>bss段</strong>：未初始化的全局变量和静态变量</p>
</li>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>OS创建进程并分配私有进程空间, 然后OS加载器把可执行文件的数据段和代码段映射到进程的虚拟内存空间</li>
<li>加载器读入可执行程序的导入符号表, 根据符号表可以查找出该可执行程序的所有依赖的动态链接库。调用动态链接库的初始化函数</li>
<li>初始化全局变量和全局对象</li>
<li>进入可执行程序入口处开始执行</li>
</ol>
<hr>
<h5 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h5><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放</p>
<p><strong>堆</strong>，就是那些由malloc等分配的内存块</p>
<p><strong>自由存储区</strong>，就是那些由new分配的内存块，和堆是十分相似的</p>
<p><strong>静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改</p>
</li>
<li><p><strong>内存泄露</strong>：</p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数</p>
</li>
</ol>
<hr>
<h5 id="常量存放在内存的哪个位置？"><a href="#常量存放在内存的哪个位置？" class="headerlink" title="常量存放在内存的哪个位置？"></a>常量存放在内存的哪个位置？</h5><p>局部常量，存放在栈区；</p>
<p>全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</p>
<p>字面值常量, 比如字符串，放在常量区。</p>
<hr>
<h5 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h5><p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong>，对齐原则有四个：</p>
<ol>
<li><p>struct或union的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始</p>
</li>
<li><p>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(class a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)</p>
</li>
<li><p>sizeof(struct) &#x3D; 其内部“最宽基本类型成员”的整数倍。(基本类型不包括struct&#x2F;class&#x2F;uinon)</p>
</li>
<li><p>sizeof(union) &#x3D; 结构里面size最大元素的size，因为在某一时刻，union只有一个成员真正存储于该地址</p>
</li>
</ol>
<hr>
<h5 id="说下RAII-与智能指针之间的联系"><a href="#说下RAII-与智能指针之间的联系" class="headerlink" title="说下RAII, 与智能指针之间的联系"></a>说下RAII, 与智能指针之间的联系</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用RAII</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Agouzao&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Axigou&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// delete a; 堆内存忘记释放,多了可能引起内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用RAII改造后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    T *a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n = <span class="number">1</span>) &#123; a = <span class="keyword">new</span> T[n]; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; </span><br><span class="line">        <span class="keyword">delete</span> []a;</span><br><span class="line">        a = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; <span class="comment">// 调用A构造创建a对象.是普通的栈内存对象.</span></span><br><span class="line">    <span class="comment">// 当其作用范围结束后,就会自动调用其析构函数释放a对象的内存</span></span><br><span class="line">    <span class="type">int</span> *ptr = a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    unique_ptr&lt;T[]&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n = <span class="number">1</span>) : <span class="built_in">a</span>(<span class="keyword">new</span> T[n]) &#123;&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a.<span class="built_in">get</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="type">int</span> *ptr = a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是为了理解RAII简单的实现了一下，实际操作中这么写还会出现很多问题. </p>
<p>RAII对象也可以进行复制，但是拷贝的时候必须要一并复制它所管理的资源。一般设置为不可拷贝是为了防止误拷贝时使用了自动生成的拷贝函数，自动生成的函数一般进行的是浅拷贝</p>
<p>简单的处理就是为A类定义一个父类，在父类中将拷贝构造、赋值操作符与new操作符重载声明为私有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAII升级版</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABase</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ABase</span>(<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认拷贝构造</span></span><br><span class="line">        ABase &amp;<span class="keyword">operator</span> = (<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认重载操作符</span></span><br><span class="line">        <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">// 防止子类new</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">        ~<span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>RAII与智能指针</strong></p>
<p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() : <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Resource&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Resource())</span></span>; <span class="comment">// 等价于 Resource* ptr = new Resource(); 	delete ptr; </span></span><br><span class="line">    <span class="comment">// 使用ptr管理Resource对象，无需手动调用delete释放资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// ptr在此处离开作用域，自动释放Resource对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="RAII补充"><a href="#RAII补充" class="headerlink" title="RAII补充"></a>RAII补充</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        m_size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span>[] m_data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++)  m_data[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 <code>testA</code> 函数中没有正确地删除 <code>a</code> 对象，就会导致数组的内存泄漏。例如，如果我们在 <code>testA</code> 函数中添加一个无限循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时程序会陷入无限循环，无法退出 <code>testA</code> 函数。当 <code>main</code> 函数结束时，<code>a</code> 对象并没有被正确地删除，导致数组的内存泄漏。</p>
<p><strong>RAII改写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        m_data = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(size);</span><br><span class="line">        m_size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) m_data[i] = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++) cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>[]&gt; m_data; <span class="comment">// unique_ptr&lt;T[]&gt; a;</span></span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">fillArray</span>();</span><br><span class="line">    a.<span class="built_in">printArray</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><h5 id="简述一下-C-重载和重写"><a href="#简述一下-C-重载和重写" class="headerlink" title="简述一下 C++重载和重写"></a>简述一下 C++重载和重写</h5><ul>
<li><p>重写:是指派生类中存在重新定义的函数。</p>
<p>其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>基类中被重写的函数必须有virtual修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a -&gt; <span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载</p>
<p>在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个<strong>具有不同参数（参数的类型，个数，顺序不同）的同名函数</strong>，根据参数列表确定调用哪个函数，重载的返回值类型可以不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;;     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="说说-C-重载和重写是如何实现的"><a href="#说说-C-重载和重写是如何实现的" class="headerlink" title="说说 C++ 重载和重写是如何实现的"></a>说说 C++ 重载和重写是如何实现的</h5><ul>
<li><p>重写</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数</li>
<li>有虚函数的<strong>类</strong>都有个一维的虚函数表叫做虚表，<strong>类的每个对象有一个指向虚表开始的虚指针</strong>。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚指针指向派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚指针指向的是父类的虚函数地址</li>
<li><strong>多态</strong>性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数</strong></p>
</li>
<li><p>重载</p>
<p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
</li>
</ul>
<hr>
<h5 id="说说C-构造函数有几种"><a href="#说说C-构造函数有几种" class="headerlink" title="说说C++构造函数有几种"></a>说说C++构造函数有几种</h5><p>C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li><p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()&#123; <span class="comment">//默认构造函数  </span></span><br><span class="line">            num=<span class="number">1001</span>;        </span><br><span class="line">            age=<span class="number">18</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">int</span> a):<span class="built_in">num</span>(n),<span class="built_in">age</span>(a)&#123;&#125; <span class="comment">//初始化构造函数  </span></span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="type">int</span> num;  </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Student s1; <span class="comment">//用默认构造函数初始化对象S1  </span></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">18</span>)</span></span>; <span class="comment">//用初始化构造函数初始化对象S2  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li><p>复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;     </span><br><span class="line">    <span class="type">int</span> i;     </span><br><span class="line">    <span class="type">int</span> *p; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> value)&#123;         </span><br><span class="line">            i = ai;         </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">int</span>(value);     </span><br><span class="line">        &#125;     </span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;         </span><br><span class="line">            <span class="keyword">delete</span> p;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t)&#123;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;i = t.i;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*t.p);     </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;     </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;     </span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>：只是对指针的拷贝，拷贝后两个指针指向同一个内存空间。修改其中任意的值,另一个值都会变化</p>
<p><strong>深拷贝</strong>：不但对指针进行拷贝, 且对指针指向的内容拷贝, 经过深拷贝后的指针是指向两个不同地址的指针。修改其中任意的值,另一个值不会变化</p>
</li>
<li><p>移动构造函数</p>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷</p>
<p>拷贝构造函数中，对于指针，我们采用深拷贝，<strong>而移动构造函数中，对于指针，我们采用浅拷贝。浅拷贝之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针 (如a-&gt; value) 置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</strong></p>
<p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)&#123; <span class="comment">// &amp;&amp; 是右值引用 	int num = 10;  int &amp;&amp; a = 10;     </span></span><br><span class="line">		p = a.p;</span><br><span class="line">		a.p = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123; <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ch;</span><br><span class="line">	<span class="function">Test <span class="title">c</span><span class="params">(move(p))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="只定义析构函数-会自动生成哪些构造函数"><a href="#只定义析构函数-会自动生成哪些构造函数" class="headerlink" title="只定义析构函数,会自动生成哪些构造函数"></a>只定义析构函数,会自动生成哪些构造函数</h5><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<blockquote>
<p>  默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作</p>
</blockquote>
<hr>
<h5 id="一个类默认会生成哪些函数"><a href="#一个类默认会生成哪些函数" class="headerlink" title="一个类默认会生成哪些函数"></a>一个类默认会生成哪些函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认会生成以下几个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.默认构造</span></span><br><span class="line"><span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.拷贝构造</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值运算符</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.析构函数（非虚）</span></span><br><span class="line">~<span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="哪些因素会影一个类对象的大小"><a href="#哪些因素会影一个类对象的大小" class="headerlink" title="哪些因素会影一个类对象的大小"></a>哪些因素会影一个类对象的大小</h5><p>对象大小 &#x3D; 虚函数指针 + 所有非静态数据成员大小 + 因对齐而多占的字节</p>
<blockquote>
<p>  静态成员变量是属于类的，而不是属于对象的。它们在内存中只有一份副本(虚表也是)，被所有该类的对象所共享。因此，无论该类有多少个对象，静态成员变量的内存占用量都是固定的</p>
</blockquote>
<hr>
<h5 id="继承一个类的对象的内存结构"><a href="#继承一个类的对象的内存结构" class="headerlink" title="继承一个类的对象的内存结构"></a>继承一个类的对象的内存结构</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br><span class="line"><span class="operator">|</span> vptr   </span><br><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br><span class="line"><span class="operator">|</span> Base class       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> members          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------|</span></span><br><span class="line"><span class="operator">|</span> Derived class    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> members 		   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">----------------- |</span></span><br></pre></td></tr></table></figure>

<p>类的虚表放在程序的数据段（.data）, 类对象的虚指针放在对象内存的开头</p>
<hr>
<h5 id="继承两个类并重写了它们的虚函数的对象的内存结构"><a href="#继承两个类并重写了它们的虚函数的对象的内存结构" class="headerlink" title="继承两个类并重写了它们的虚函数的对象的内存结构"></a>继承两个类并重写了它们的虚函数的对象的内存结构</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">qux</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">baz</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> vptr <span class="keyword">to</span> A<span class="string">&#x27;s vtable      |</span></span><br><span class="line"><span class="string">|------------------------ |</span></span><br><span class="line"><span class="string">| A class members         |</span></span><br><span class="line"><span class="string">|------------------------ |</span></span><br><span class="line"><span class="string">| vptr to B&#x27;</span>s vtable      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> B class members         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br><span class="line"><span class="operator">|</span> C class members         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------ |</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h5><ol>
<li><p>向上转型本身就是安全的</p>
</li>
<li><p>向下转型:</p>
<p>(1) 可以使用强制转换, 这种转换不安全, 会导致数据的丢失, <strong>原因是父类的指针或者引用的内存中可能不包含子类的成员的内存</strong></p>
<p>(2) <code>dynamic_cast&lt;type_id&gt;(expression) </code>主要还是用于执行“安全的向下转型（safe downcasting）”，也即是基类对象的指针或引用转换为同一继承层次的其他指针或引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast&lt;type_id&gt;(expression) 把expression转换成type-id类型的对象</span></span><br><span class="line"><span class="comment">// type_id 必须是类的指针、类的引用或者void*</span></span><br><span class="line"><span class="comment">// 使用场景：我们想使用基类对象的指针或引用来调用某个派生类的操作，并且该操作不是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base *Pb = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	Derived* Pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(Pb);</span><br><span class="line">	Pd-&gt;<span class="built_in">func</span>();  <span class="comment">//将输出hello world!	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述下深拷贝和浅拷贝-如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝-如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝, 如何实现深拷贝"></a>简述下深拷贝和浅拷贝, 如何实现深拷贝</h5><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<p>深拷贝的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">deepCopyString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="type">char</span>* dest = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];  <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, len + <span class="number">1</span>);      <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;xxxxxx&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* aa = a.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">deepCopyString</span>(aa) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法2: 赋值运算符的重载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png" alt="img" style="zoom:50%;">

<hr>
<h5 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h5><ol>
<li><p>多态成员变量: 编译运行看左边</p>
</li>
<li><p>静态方法和变量：编译运行都看左边，同成员变量一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu *f = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f -&gt; num &lt;&lt; endl; <span class="comment">// 取Fu中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态成员方法: 编译看左边,运行看右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu* f1 = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f1-&gt; <span class="built_in">show</span>() &lt;&lt; endl; <span class="comment">// 用基类类型指针绑定派生类实例,调用的是子类重写后的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说为什么要虚析构-为什么不能虚构造"><a href="#说说为什么要虚析构-为什么不能虚构造" class="headerlink" title="说说为什么要虚析构, 为什么不能虚构造"></a>说说为什么要虚析构, 为什么不能虚构造</h5><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，</p>
<ol>
<li>用子类指针绑定子类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用父类指针绑定子类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构父类，不会析构子类对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。</strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li><p>不能虚构造：</p>
<p>虚函数需要一个虚表存储, 这个表的地址是存储在对象的内存空间开始的。如果将构造函数设置为虚函数，就需要到虚表中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</p>
</li>
</ol>
<hr>
<h5 id="构造函数中可以调用虚函数吗？"><a href="#构造函数中可以调用虚函数吗？" class="headerlink" title="构造函数中可以调用虚函数吗？"></a>构造函数中可以调用虚函数吗？</h5><p>可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数</p>
<hr>
<h5 id="说说模板类"><a href="#说说模板类" class="headerlink" title="说说模板类"></a>说说模板类</h5><ol>
<li>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
<li>模板具体化：<strong>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化</strong>。具体化时可以修改原模板的定义 [修改类内函数(不是重写)]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">sizeof</span>(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">int</span>&gt; intStruct; <span class="comment">// 4</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">double</span>&gt; doubleStruct; <span class="comment">// --8--</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">char</span>&gt; llStruct; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++ 类内可以定义引用数据成员吗？"></a>C++ 类内可以定义引用数据成员吗？</h5><p>c++类内可以定义引用成员变量，但要遵循以下规则：</p>
<ol>
<li>必须用初始化列表(构造)来初始化引用成员变量。否则会造成引用未初始化错误</li>
<li>构造函数的形参也必须是引用类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> &amp;target) :<span class="built_in">a</span>(target)&#123;  <span class="comment">//初始化列表</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>; <span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;</span><br><span class="line">	r.<span class="built_in">printA</span>(); <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> &amp;b = a; <span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">	r1.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️简述一下什么是常函数，有什么作用"><a href="#⚠️简述一下什么是常函数，有什么作用" class="headerlink" title="⚠️简述一下什么是常函数，有什么作用"></a>⚠️简述一下什么是常函数，有什么作用</h5><p>类的成员函数后面加 const（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），表明这个函数不会对这个类对象中的<strong>非静态数据成员</strong>作任何改变。</p>
<p><strong>非const类型的数据可以给const类型的变量赋值，反之则不成立</strong></p>
<p><strong>在实例化对象时添加const关键字，就是const对象，const对象只能访问类中的const成员变量和const成员函数</strong></p>
<hr>
<h5 id="说说-C-中什么是菱形继承问题，如何解决"><a href="#说说-C-中什么是菱形继承问题，如何解决" class="headerlink" title="说说 C++ 中什么是菱形继承问题，如何解决"></a>说说 C++ 中什么是菱形继承问题，如何解决</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png" alt="img" style="zoom:25%;">

<p>假设我们有类B和类C，它们都继承了相同的类A。<strong>另外我们还有类D，类D通过多重继承机制继承了类B和类C</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  *Animal类对应于图表的类A* */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;     </span><br><span class="line">    <span class="type">int</span> weight;      </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> weight; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Liger</span> : <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Liger lg;   <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span>   </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>();  <span class="comment">//   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在我们的继承结构中，<strong>我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象”lg”会包含Animal基类的两个子对象。</strong></p>
<p>调用”lg.getWeight()”将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</p>
</li>
<li><p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;  <span class="comment">// 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了”virtual”关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Liger lg;  <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>  </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="虚继承多个父类的子类的内存结构"><a href="#虚继承多个父类的子类的内存结构" class="headerlink" title="虚继承多个父类的子类的内存结构"></a>虚继承多个父类的子类的内存结构</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.a = <span class="number">1</span>;</span><br><span class="line">  d.b = <span class="number">2</span>;</span><br><span class="line">  d.c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Derived</code> 类虚继承了 <code>Base1</code> 和 <code>Base2</code> 两个基类，并拥有一个自己独有的成员 <code>c</code>。由于 <code>Derived</code> 类使用了虚继承，因此在内存中它的布局与普通的继承方式有所不同。</p>
<p>以下是 <code>Derived</code> 对象的内存结构示意图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  虚基类子对象 <span class="number">1</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  虚基类子对象 <span class="number">2</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="type">int</span> c                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>虚基类子对象 1</code> 包含了 <code>Base1</code> 类的成员，而 <code>虚基类子对象 2</code> 包含了 <code>Base2</code> 类的成员。由于 <code>Base1</code> 和 <code>Base2</code> 都是虚基类，因此它们的成员在 <code>Derived</code> 类的对象中只存在一份，被 <code>虚基类子对象</code> 共享。</p>
<hr>
<h5 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h5><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，<strong>含有纯虚函数的类被称为抽象类</strong></li>
<li>虚函数可以被直接使用，也可以被子类重写以后，以多态的形式调用，而纯虚函数必须在子类中重写才可以使用，因为纯虚函数在基类有声明而没有定义。</li>
<li>虚函数的定义形式：virtual(){};纯虚函数的定义形式：virtual() &#x3D; 0;<strong>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时绑定,然而虚函数却是动态绑定，</strong>而且被两者修饰的函数生命周期也不一样</li>
</ol>
<hr>
<h5 id="⚠️C-友元函数和友元类（-friend）详解"><a href="#⚠️C-友元函数和友元类（-friend）详解" class="headerlink" title="⚠️C++友元函数和友元类（ friend）详解"></a>⚠️C++友元函数和友元类（ friend）详解</h5><p>友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> 返回值类型 函数名(参数表); <span class="comment">//将全局函数声明为友元</span></span><br><span class="line"><span class="keyword">friend</span> 返回值类型 其他类的类名::成员函数名(参数表); <span class="comment">//将其他类的成员函数声明为友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能把其他类的私有成员函数声明为友元. </span></span><br><span class="line"><span class="comment">// 友元具有单向性, 不具有传递性和继承性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>;  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️C-中哪些函数不能被声明为虚函数"><a href="#⚠️C-中哪些函数不能被声明为虚函数" class="headerlink" title="⚠️C++ 中哪些函数不能被声明为虚函数"></a>⚠️C++ 中哪些函数不能被声明为虚函数</h5><p>常见的不不能声明为虚函数的有：普通函数（不定义在类里），静态成员函数，内联成员函数，构造函数，友元函数</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>略</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态绑定,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
<p>static函数是在编译时期绑定,而虚函数的特性是运行时才动态联编,两者矛盾</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<hr>
<h5 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h5><p>模板的声明或定义只能在全局，命名空间或类范围内进行。</p>
<p>不能在局部范围，函数内进行，比如不能在<strong>main</strong>函数中声明或定义一个模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替</span></span><br><span class="line">ClassName A = <span class="keyword">new</span> <span class="built_in">ClassName</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h4><h5 id="哈希冲突的解决办法，哈希表适用哪些场景"><a href="#哈希冲突的解决办法，哈希表适用哪些场景" class="headerlink" title="哈希冲突的解决办法，哈希表适用哪些场景"></a>哈希冲突的解决办法，哈希表适用哪些场景</h5><p>哈希冲突是指不同的键值可能会映射到哈希表的同一个位置，造成数据覆盖和查询效率下降的问题。常见的哈希冲突解决办法包括：</p>
<ol>
<li>开放地址法：如果发生哈希冲突，则继续往下探测空闲位置，直到找到为止。探测的方式可以是线性探测、二次探测、双重哈希等。</li>
<li>链地址法：将哈希表中的每个位置都指向一个链表，发生哈希冲突时将新元素插入到对应的链表中即可。</li>
<li>其他方法：如再哈希法、建立公共溢出区等。</li>
</ol>
<p>哈希表适用于需要快速查找和插入元素的场景，特别是当数据集合很大时。常见的应用包括数据库索引、缓存。</p>
<p>哈希表的负载因子是指哈希表中已经存储的元素数量与哈希表大小的比值。通常用字母“α”表示，即 α &#x3D; n &#x2F; m</p>
<p>n是已经存储的元素数量，m是哈希表的大小。负载因子反映了哈希表的使用程度，也可以看作是哈希表的密度。</p>
<blockquote>
<p>  负载因子对哈希表的性能有着重要的影响。当负载因子过高时，哈希冲突的概率会增大，导致哈希表的查询和插入效率下降；而当负载因子过低时，哈希表的空间利用率较低，造成空间浪费。</p>
<p>  一般来说，当负载因子达到一定阈值时，需要进行哈希表的扩容操作。扩容可以增大哈希表的大小，使哈希冲突的概率降低，从而提高哈希表的性能。哈希表的负载因子通常设置在0.7左右，但具体的取值要根据实际情况进行调整。</p>
</blockquote>
<hr>
<h5 id="请说说-STL-的基本组成部分"><a href="#请说说-STL-的基本组成部分" class="headerlink" title="请说说 STL 的基本组成部分"></a>请说说 STL 的基本组成部分</h5><p>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>广义上讲</strong>，STL分为3类：算法、容器、迭代器，容器和算法通过迭代器可以进行无缝地连接。</p>
<p><strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）</p>
<ol>
<li><p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了()的类</p>
</li>
<li><p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3种适配器：Container Adaptor、Iterator Adaptor、Function Adaptor</p>
</li>
<li><p>空间配制器（Allocator）</p>
<p> 为STL提供空间配置的系统。其中主要工作包括两部分</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<hr>
<h5 id="请说说-STL-中常见的容器-并介绍一下实现原理"><a href="#请说说-STL-中常见的容器-并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器, 并介绍一下实现原理"></a>请说说 STL 中常见的容器, 并介绍一下实现原理</h5><ol>
<li><strong>序列式容器</strong></li>
</ol>
<p>所谓序列式容器，其中的元素都是可序的，但是未必都是有序的</p>
<p>（1）vector ：动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
<p>（2）deque ：双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在两端增删元素具有较佳的性能</p>
<p>（3）list ：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取</p>
<ol start="2">
<li><strong>关联式容器</strong></li>
</ol>
<p>关联式容器，每笔数据（每个数据）都有一个键值（key）和一个实值（value）</p>
<blockquote>
<p>  关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()</p>
</blockquote>
<p>关联式容器: set、map、multiset、multimap底层均以RB-tree（红黑树）完成</p>
<p>（1）set&#x2F;multiset ：set 即集合。set中不允许相同元素，multiset中允许存在相同元素</p>
<p>（2）map&#x2F;multimap ：map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素</p>
<ol start="3">
<li><strong>容器适配器</strong></li>
</ol>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个stack。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。stack和queue基于deque实现，priority_queue基于vector实现</p>
<p>（1）stack  </p>
<p>（2）queue ：队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p>
<p>（3）priority_queue：优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p>
<hr>
<h5 id="两种C-类对象实例化方式的异同"><a href="#两种C-类对象实例化方式的异同" class="headerlink" title="两种C++类对象实例化方式的异同"></a>两种C++类对象实例化方式的异同</h5><ol>
<li>在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 <code>Test test;</code>另一种是通过new来实例化一个类对象，如 <code>Test *pTest = new Test();</code>那么，这两种方式有什么异同点呢？</li>
</ol>
<pre><code>我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。



那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间

（2）对于第二种方式来说, new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间
</code></pre>
<hr>
<h5 id="⚠️迭代器用过吗？什么时候会失效？"><a href="#⚠️迭代器用过吗？什么时候会失效？" class="headerlink" title="⚠️迭代器用过吗？什么时候会失效？"></a>⚠️迭代器用过吗？什么时候会失效？</h5><ul>
<li><p>针对数组型数据结构<br>数组型结构有vector、deque等，由于它们的元素是分配在连续的内存中，当进行insert和erase操作，都会使得插入点和删除点之后的元素挪位置，插入点和删除掉之后的迭代器全部失效。</p>
<p>解决方法就是更新迭代器，对于删除，erase（）返回的是下一个有效迭代器的值，可以通过<strong>iter&#x3D;vec.erase(iter)</strong>;来避免迭代器失效。insert同理，insert返回的是插入元素的迭代器的值。<br>注意：在deque首部或尾部删除元素则只会使指向被删除元素的迭代器失效，在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效</p>
</li>
<li><p>针对链表型数据结构<br>如list容器，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<p>解决办法有两种，一种是erase(iter)会返回下一个有效迭代器的值，可以通过<strong>iter&#x3D;vec.erase(iter)</strong>;来避免迭代器失效，另一种方法是通过**erase(iter++)**；来避免迭代器失效，(顺便说一下，erase(iter++)避免迭代器失效的原理，先把iter传值到erase里面，然后iter自增，在失效前已经自增，然后执行erase将自增前的迭代器删除，自增前的迭代器失效），对于插入不会使迭代器失效。</p>
</li>
<li><p>针对树形数据结构<br>如map, set, multimap, multiset， 它们是使用红黑树来存储数据，插入不会使得任何迭代器失效，删除会使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<p><strong>解决方法：由于erase（）返回值为void，所以要采用erase(iter++)；来避免迭代器失效。</strong></p>
</li>
</ul>
<hr>
<h5 id="说说-STL-中-resize-和-reserve-的区别"><a href="#说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="说说 STL 中 resize 和 reserve 的区别"></a>说说 STL 中 resize 和 reserve 的区别</h5><ol>
<li><p>首先必须弄清楚两个概念：</p>
<p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象</p>
<p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</p>
</li>
<li><p>resize和reserve区别主要有以下几点：</p>
<p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert()或push_back()等创建对象</p>
<p>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小</p>
</li>
</ol>
<hr>
<h5 id="char-和string的区别"><a href="#char-和string的区别" class="headerlink" title="char*和string的区别"></a>char*和string的区别</h5><p><code>char*</code> 和 <code>string</code> 都可以用来表示字符串，但它们之间有一些区别：</p>
<ol>
<li>字符串长度</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动计算字符串的长度，并且在操作字符串时需要确保不超过字符串的长度，否则可能会导致内存越界等问题。而 <code>string</code> 则可以自动维护字符串的长度信息，并提供了一些方便的成员函数来操作字符串，比如 <code>size()</code>、<code>append()</code> 等，可以避免手动计算字符串长度的烦恼。</p>
<ol start="2">
<li>内存管理</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动分配和释放字符串内存，并且需要注意内存泄漏和指针悬挂等问题。而 <code>string</code> 则使用了动态内存管理，它会自动分配和释放内存，可以避免这些问题。</p>
<ol start="3">
<li>字符串拷贝</li>
</ol>
<p>使用 <code>char*</code> 表示字符串时，需要手动实现字符串拷贝函数，比如 <code>strcpy()</code>、<code>strncpy()</code> 等。而 <code>string</code> 则提供了重载的赋值运算符和拷贝构造函数，可以方便地进行字符串的拷贝和赋值操作。</p>
<hr>
<h5 id="数组与vector的对比"><a href="#数组与vector的对比" class="headerlink" title="数组与vector的对比"></a>数组与vector的对比</h5><p>1、数组名与vector名</p>
<p>数组名和vector名是有区别的，数组名不仅表示数组的名称，还代表了数组的首地址，数组名有时候可看作指针，并使用一些类似于指针的操作，例如初始化了一个数组 int a[10]；可进行如下操作，a+4、*(a+5)等来访问a中的数据。而vector名的话就仅仅只是vector的名称了，它没有类似于数组名的那些操作</p>
<p>2、大小能否变化</p>
<p>数组的大小在初始化后就固定不变，而vector可以通过push_back或pop等操作进行变化。</p>
<p>3、初始化</p>
<p>数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而vector可以。</p>
<p>4、执行效率</p>
<p>数组 &gt; vector  主要原因是vector的扩容过程要消耗大量的时间。</p>
<hr>
<h5 id="STL容器哪些是线程安全的"><a href="#STL容器哪些是线程安全的" class="headerlink" title="STL容器哪些是线程安全的"></a>STL容器哪些是线程安全的</h5><p><strong>STL容器不是线程安全的。</strong></p>
<blockquote>
<p>  当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。</p>
</blockquote>
<hr>
<h5 id="要将STL库改造为线程安全的"><a href="#要将STL库改造为线程安全的" class="headerlink" title="要将STL库改造为线程安全的"></a>要将STL库改造为线程安全的</h5><p>可以采用以下几种方法：</p>
<ol>
<li>在访问STL容器时使用锁。可以在访问STL容器时使用互斥锁来保证线程安全。例如，可以使用std::mutex和std::lock_guard来实现互斥锁</li>
<li>使用并发容器替换STL容器。一些第三方库或框架提供了线程安全的并发容器，例如Intel TBB和Boost等。这些并发容器可以直接替换STL容器，以实现线程安全</li>
</ol>
<hr>
<h5 id="❤️如何对core-dump-文件debug"><a href="#❤️如何对core-dump-文件debug" class="headerlink" title="❤️如何对core dump 文件debug"></a>❤️如何对core dump 文件debug</h5><p>以下是在Linux环境下如何对core dump文件进行debug的步骤：</p>
<ol>
<li>确认core dump文件是否已启用：执行以下命令：ulimit -c，如果输出的结果为0，表示core dump文件未启用，需要执行命令ulimit -c unlimited启用。</li>
<li>程序必须以调试模式编译，即在编译时需要加上-g选项。</li>
<li>使用gdb工具进行debug：gdb &lt;程序名&gt; &lt;core dump文件名&gt;，进入gdb交互界面。</li>
<li>在gdb交互界面中，使用bt命令查看崩溃时的函数调用栈，可以确定程序崩溃的位置。</li>
<li>使用print命令查看变量的值，可以确定程序崩溃的原因。</li>
<li>使用run命令重新运行程序，可以观察程序在哪个位置崩溃。</li>
<li>修复问题后，重新编译程序并测试。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>在debug过程中，如果程序中有多线程，需要使用thread命令切换线程进行调试。</li>
<li>在debug过程中，如果程序中有动态链接库，需要使用shared命令进行调试。</li>
<li>如果core dump文件过大，可以使用gdb -c &lt;core dump文件名&gt;命令打开core dump文件，然后使用set pagination off命令关闭分页，以加快查看速度。</li>
</ol>
<hr>
<h5 id="❤️多线程-core-dump-文件debug"><a href="#❤️多线程-core-dump-文件debug" class="headerlink" title="❤️多线程 core dump 文件debug"></a>❤️多线程 core dump 文件debug</h5><p>可以使用gdb的thread命令</p>
<p>假设程序中有两个线程，分别是主线程和子线程，其中子线程执行一个函数，主线程等待子线程执行完毕后退出程序。在程序运行过程中，我们想要查看子线程的运行状态，可以使用如下命令：</p>
<ol>
<li>使用gdb调试程序，输入命令“info threads”查看程序中的所有线程及其编号。</li>
<li>输入命令“thread  线程编号”切换到需要调试的线程。</li>
<li>使用gdb常规的调试命令如“bt”、“print”、“step”等对该线程进行调试。</li>
</ol>
<p>例如，在gdb交互界面中，输入“thread 2”切换到子线程进行调试，然后使用“bt”命令查看子线程的函数调用栈，使用“print”命令查看子线程中的变量值，以便定位子线程的问题。调试完成后，再输入“thread 1”切换回主线程进行调试。</p>
<hr>
<h5 id="手写string类"><a href="#手写string类" class="headerlink" title="手写string类"></a>手写string类</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">char</span>* m_data;</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *src = <span class="literal">NULL</span>);<span class="comment">//构造函数 </span></span><br><span class="line">        <span class="built_in">String</span>(<span class="type">const</span> String &amp;other);<span class="comment">//拷贝构造函数</span></span><br><span class="line">        ~<span class="built_in">String</span>(<span class="type">void</span>);<span class="comment">//析构函数</span></span><br><span class="line">        String &amp; <span class="keyword">operator</span> =(<span class="type">const</span> String &amp;other);<span class="comment">//重载赋值运算符 </span></span><br><span class="line">        <span class="comment">//friend String operator+(const String &amp;str1, const String &amp;str2); //重载加号运算符（友元函数） </span></span><br><span class="line">        String <span class="keyword">operator</span>+( <span class="type">const</span> String &amp;str2); <span class="comment">//重载加号运算符（成员函数） </span></span><br><span class="line">        <span class="function">String <span class="title">SubString</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> len)</span></span>; <span class="comment">//求子串,第pos个字符起长度为len的子串 </span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//String 的构造函数 </span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *src) &#123;</span><br><span class="line">    <span class="keyword">if</span>(src == <span class="literal">NULL</span>)&#123; <span class="comment">//当初始化串不存在的时候，为m_data申请一个空间存放&#x27;\0&#x27;；</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//当初始化串存在的时候，为m_data申请同样大小的空间存放该串；</span></span><br><span class="line">        length = <span class="built_in">strlen</span>(src);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,src);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数 </span></span><br><span class="line">String::~<span class="built_in">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;<span class="comment">//析构函数释放地址空间 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️vector-的-部分STL-源码"><a href="#⚠️vector-的-部分STL-源码" class="headerlink" title="⚠️vector 的 部分STL 源码"></a>⚠️vector 的 部分STL 源码</h5><p>  vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li><p>新增元素</p>
<p> Vector通过一个连续的数组存放元素，如果内存已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index &#x3D; iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="type">const</span> T&amp; t )</span> </span>&#123;    </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_)&#123;   </span><br><span class="line">        <span class="keyword">if</span> (size_==capacity_)&#123;    </span><br><span class="line">            <span class="type">int</span> capa=<span class="built_in">calculateCapacity</span>();    </span><br><span class="line">            <span class="built_in">newCapacity</span>(capa);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="built_in">sizeof</span>(T));    </span><br><span class="line">        buf[index]=t;   </span><br><span class="line">        size_++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<p>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index &#x3D; iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素  </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();      </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)&#123;         </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="built_in">sizeof</span>(T));          </span><br><span class="line">        buf[--size_]=<span class="built_in">T</span>();     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h4><h5 id="说说-C-14-新特性"><a href="#说说-C-14-新特性" class="headerlink" title="说说 C++14 新特性"></a>说说 C++14 新特性</h5><ol>
<li>C++14: <ul>
<li>函数返回值类型推导</li>
<li>lambda参数auto</li>
<li>变量模板</li>
<li>别名模板</li>
<li>constexpr的限制</li>
<li>[[<code>deprecated</code>]]标记</li>
<li>二进制字面量与整形字面量分隔符</li>
<li>make_unique</li>
<li>shared_timed_mutex与shared_lock</li>
<li>integer_sequence</li>
<li>exchange</li>
<li>quoted</li>
</ul>
</li>
</ol>
<hr>
<h5 id="说说-C-11-新特性"><a href="#说说-C-11-新特性" class="headerlink" title="说说 C++11 新特性"></a>说说 C++11 新特性</h5><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）初始化方法可以拓展到任意类</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针 &amp; 空指针 nullptr（原来NULL）</p>
<p>（6）基于范围的for循环</p>
<p>（7）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（1）无序容器（哈希表 hashtable）用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（2）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（3）Lambda表达式</p>
</li>
</ol>
<p><strong>详细：</strong></p>
<ol>
<li><p>统一的初始化方法</p>
<p>  C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;     </span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private     </span></span><br><span class="line">    Foo a3 = &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    Foo a4 &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a5 = &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a6 &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<strong>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化</strong></p>
</li>
<li><p>成员变量默认初始化</p>
<p>好处：构建一个类的对象不需要用构造函数初始化成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值  </span></span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    B b;  </span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字  </p>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();   <span class="comment">// auto i = v.begin();  </span></span><br></pre></td></tr></table></figure>

<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>; 	<span class="comment">//x类型被推断为int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x; 	<span class="comment">//cx被推断为 const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;rx = x; 	<span class="comment">//rx被推断为const int &amp;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>auto 原理 : 调用类模板传参</p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// auto pos = container.begin()的推断等价于如下调用模板的推断</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deducePos</span><span class="params">(T pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deducePos</span>(container.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>decltype  求表达式的类型</p>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>(1)为什么要有decltype</p>
<p><strong>auto 要求变量必须初始化，而 decltype 不要求</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<p>(2)代码示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int </span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double </span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针 </p>
<p>见下⬇️</p>
</li>
<li><p>空指针 nullptr（原来NULL）</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> *a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> *a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>nullptr空指针常数可以转换为任意类型的指针类型</p>
<p>在c++中 <code>(void *)</code> 不能转化为任意类型的指针，即 <code>int *p = (void*)</code>是错误的，但<code>int *p = nullptr</code>是正确的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;1&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;2&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);  <span class="comment">//输出1，c++中NULL为整数0</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);  <span class="comment">//输出2，nullptr 为空指针常量。是指针类型</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于范围的for循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;  <span class="comment">//使用基于范围的for循环</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要使用引用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : arr)&#123;</span><br><span class="line">    std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用和move语义 </p>
<p>(1) 右值引用</p>
<p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// 正确, 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值</span></span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p><strong>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>; <span class="comment">// 和常量左值引用不同的是，右值引用还可以对右值进行修改   </span></span><br></pre></td></tr></table></figure>

<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成</p>
<p>(2) move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能<strong>很简单，就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值；但对于使用迭代器遍历容器中存储的元素，执行效率较低</li>
</ul>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table>
<thead>
<tr>
<th align="left">无序容器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unordered_map</td>
<td align="left">存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式  </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
</li>
<li><p>Lambda匿名函数</p>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式</p>
<p>(1) 定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p><code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型  &#123; 函数体; &#125;;</code></p>
<blockquote>
<p>  a.  [ ] 捕获外部变量</p>
<p>  b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略</p>
<p>  c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字</p>
<p>  **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</p>
<p>  d. noexcept&#x2F;throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型</p>
<p>  e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”</p>
<p>  f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式捕获（两种）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数</span></span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mp[a] == mp[b] ? a &lt; b : mp[a] &gt; mp[b];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说-C-中的智能指针"><a href="#说说-C-中的智能指针" class="headerlink" title="说说 C++中的智能指针"></a>说说 C++中的智能指针</h5><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong> 其中auto_ptr被C++11弃用。</p>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间,智能指针本质是类模板。</p>
<ol>
<li>shared_ptr</li>
</ol>
<pre><code> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放)

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//构建 2 个智能指针     </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;     </span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;     </span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="comment">//输出 p2 指向的数据    </span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针     </span></span><br><span class="line">    <span class="keyword">if</span> (p1) cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;     <span class="comment">//以上操作，并不会影响 p2     </span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      程序运行结果：          10  p1 为空  10  1  */</span>    </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p>weak_ptr</p>
<p>它只可以从一个 shared_ptr或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的变化</p>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放</p>
<p>weak_ptr和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了</p>
<p>我们把类A里面的shared_ptr pb_; 改为 weak_ptr pb _ ; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p><strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code> pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();   </code></p>
</li>
<li><p>auto_ptr</p>
<p>C++98的方案，C++11已经弃用. 采用所有权模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题</p>
</li>
<li><p>unique_ptr（替换auto_ptr）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 2 allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中1留下悬挂的unique_ptr(pu1)，这可能导致危害</span></span><br><span class="line"><span class="comment">// 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数, 该函数创建的临时对象在其所有权让给 pu3 后就会被销毁</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="智能指针有内存泄露风险吗"><a href="#智能指针有内存泄露风险吗" class="headerlink" title="智能指针有内存泄露风险吗"></a>智能指针有内存泄露风险吗</h5><p>有,<strong>当两个类对象中各自有一个 shared_ptr 指向对方</strong>时，会造成循环引用，使引用计数失效，从而导致内存泄露。 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr</p>
<p>weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针</p>
<p>weak_ptr不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问</p>
<hr>
<h5 id="⚠️说说三种智能指针原理和使用场景和线程安全"><a href="#⚠️说说三种智能指针原理和使用场景和线程安全" class="headerlink" title="⚠️说说三种智能指针原理和使用场景和线程安全"></a>⚠️说说三种智能指针原理和使用场景和线程安全</h5><ol>
<li><p><strong>实现原理:</strong> 所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的析构函数会删除该对象。然后，让赋值操作转让所有权。这就是用于 auto_ptr 和 unique_ptr 的策略.但 unique_ptr 的策略更严格，unique_ptr 能够在编译期识别错误。 </p>
<p>跟踪引用特定对象的智能指针计数，这称为引用计数（reference counting）。例如，赋值时，计数将加 1，而指针过期时，计数将减 1. 仅当最后一个指针过期时，才调用 delete。这是 shared_ptr 采用的策略</p>
</li>
<li><p><strong>使用场景:</strong> 如果程序要使用多个指向同一个对象的指针，应该选择 shared_ptr； </p>
<p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr; 如果使用 new分配内存，应该选择 unique_ptr; 如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p>
</li>
<li><p><strong>线程安全:</strong> <strong>shared_ptr 加减引用计数是原子操作，只要shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了。所以 shared_ptr 在多线程下引用计数也是安全的.</strong></p>
<p><strong>但是指向对象的指针不是线程安全的，使用 shared_ptr 访问资源不是线程安全的，需要手动加锁解锁。智能指针的拷贝也不是线程安全的</strong></p>
</li>
</ol>
<hr>
<h5 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h5><p>是指在函数调用过程中，将参数以原始形式（左值或右值）转发到另一个函数，而不会改变它们的值类别（左值或右值）。在C++中，可以使用std::forward函数实现完美转发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_print</span><span class="params">(T&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    forward_print(a);       <span class="comment">// 输出：lvalue: 1</span></span><br><span class="line">    forward_print(<span class="number">2</span>);       <span class="comment">// 输出：rvalue: 2</span></span><br><span class="line">    forward_print(<span class="built_in">move</span>(a)); <span class="comment">// 输出：rvalue: 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个示例中，我们定义了两个打印函数，一个接受左值引用，一个接受右值引用。</span></span><br><span class="line"><span class="comment">// 然后我们定义了一个函数模板forward_print，使用完美转发来将参数转发给打印函数。</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h5><p>C++11引入了<code>constexpr</code>（常量表达式）关键字，它表示表达式的值可以在编译期间计算，并且在运行时不会变</p>
<p>使用<code>constexpr</code>修饰的变量或函数可以在编译期间进行求值，这使得它们比运行时计算更加高效，同时还可以帮助我们避免一些运行时错误。在一些场景下，使用<code>constexpr</code>可以提高代码的可读性和可维护性，因为它可以使得一些常量在编译期间计算而不需要在运行时计算。</p>
<p>例如，下面是一个使用<code>constexpr</code>的示例代码，其中计算了斐波那契数列的第n项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">fib</span>(N);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Fibonacci number #&quot;</span> &lt;&lt; N &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器可以在编译期间计算<code>fib(N)</code>的值，并将结果赋值给常量<code>result</code>。在运行时，程序输出斐波那契数列的第10项的值：55。</p>
<p>需要注意的是，<code>constexpr</code>并不是万能的，它有一些限制条件，例如被修饰的函数必须满足编译期间可以进行求值的要求，不能包含运行时的操作，例如I&#x2F;O操作、动态内存分配等。在使用<code>constexpr</code>时，需要仔细考虑这些限制条件，以确保代码的正确性和性能</p>
<h3 id="1️⃣操作系统"><a href="#1️⃣操作系统" class="headerlink" title="1️⃣操作系统"></a>1️⃣操作系统</h3><h4 id="OS的功能"><a href="#OS的功能" class="headerlink" title="OS的功能"></a>OS的功能</h4><ol>
<li>进程管理：操作系统负责管理计算机中运行的所有进程，包括进程的创建、撤销、调度和同步等。</li>
<li>内存管理：操作系统负责管理计算机的存储器，包括内存的分配和回收、虚拟内存的管理等。</li>
<li>设备管理：操作系统负责管理计算机的所有输入输出设备，包括设备的驱动程序、中断处理和设备的分配等。</li>
<li>文件管理：操作系统负责管理计算机中的所有文件和目录，包括文件的创建、删除、复制、移动等操作。</li>
<li>网络管理：操作系统负责管理计算机系统中的网络资源，包括协议栈、网络接口和路由表等。</li>
</ol>
<h4 id="说一说常用的-Linux-命令"><a href="#说一说常用的-Linux-命令" class="headerlink" title="说一说常用的 Linux 命令"></a>说一说常用的 Linux 命令</h4><p>cd：切换当前目录 </p>
<p>ls：查看当前文件与目录 </p>
<p>touch: 创建新文件</p>
<p>grep：通常与管道命令一起使用，用于对一些命令的输出进行筛选加工 </p>
<p>cp：是在同一个linux系统上，在不同的目录之间复制文件</p>
<blockquote>
<p>  scp：是在不同linux系统之间来回复制文件；</p>
</blockquote>
<p>mv：移动文件或文件夹 </p>
<p>rm：删除文件或文件夹 </p>
<blockquote>
<p>  rm -rf test1    可删除非空文件或文件夹  </p>
<p>  rmdir 只能删除空文件夹</p>
</blockquote>
<p>ps：查看进程情况 </p>
<p>tar：对文件进行解压缩</p>
<p>cat：查看文件内容</p>
<p>top：查看操作系统的信息，如进程、CPU占用率、内存信息等（实时） </p>
<blockquote>
<ol>
<li><code>PID</code>：进程的唯一标识符；</li>
<li><code>USER</code>：进程所属的用户名；</li>
<li><code>%CPU</code>：进程使用 CPU 的占比；</li>
<li><code>%MEM</code>：进程使用内存的占比；</li>
<li><code>VSZ</code>：进程的虚拟内存大小（单位为 KB）；</li>
<li><code>RSS</code>：进程正在使用的物理内存大小（单位为 KB）；</li>
<li><code>TTY</code>：进程所属的终端；</li>
<li><code>STAT</code>：进程状态，如 R（运行）、S（睡眠）、D（不可中断的睡眠）等；</li>
<li><code>START</code>：进程启动的时间；</li>
<li><code>TIME</code>：进程使用 CPU 的累计时间；</li>
<li><code>COMMAND</code>：进程启动时的命令。</li>
</ol>
</blockquote>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150925539.png" alt="image-20230323150925539"></p>
<p>free：查看内存使用情况  -m以MB为单位显示</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323150826237.png" alt="image-20230323150826237"></p>
<p>pwd：显示当前工作目录</p>
<p>chmod: 修改用户权限	</p>
<p>chown: 更改或文件的所有权转让给指定的用户名</p>
<p>echo: 将一些数据移到文件中。如果要将文本 “Hello, 我的名字叫 John” 添加到名为 name.txt 的文件中，<code> echo Hello,my name is John &gt;&gt; name.txt</code></p>
<p>ldd:	 <code>ldd [OPTION] FILE</code>  查看libstdc++.so.6依赖的动态库的详细信息</p>
<blockquote>
<p>  ldd -v &#x2F;home&#x2F;libstdc++.so.6</p>
</blockquote>
<blockquote>
<p>  –help 获取指令帮助信息；<br>  –version 打印指令版本号；<br>  -d,–data-relocs 执行重定位和报告任何丢失的对象；<br>  -r, –function-relocs 执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；<br>  -u, –unused 打印未使用的直接依赖；<br>  -v, –verbose 详细信息模式，打印所有相关信息；</p>
</blockquote>
<hr>
<h4 id="查看进程运行状态、查看内存使用情况、tar解压文件"><a href="#查看进程运行状态、查看内存使用情况、tar解压文件" class="headerlink" title="查看进程运行状态、查看内存使用情况、tar解压文件"></a>查看进程运行状态、查看内存使用情况、tar解压文件</h4><ol>
<li><p>查看进程运行状态的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps aux | grep PID </span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323152150339.png" alt="image-20230323152150339"></p>
</li>
<li><p>查看内存使用情况的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">// 查看内存使用情况 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="查看进程运行状态、查看内存使用情况的指令均可使用top指令"><a href="#查看进程运行状态、查看内存使用情况的指令均可使用top指令" class="headerlink" title="查看进程运行状态、查看内存使用情况的指令均可使用top指令"></a><strong>查看进程运行状态、查看内存使用情况的指令均可使用top指令</strong></h4><ol start="3">
<li>tar解压文件的参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>压缩 -cvf</span><br><span class="line">tar -cvf xxx.tar /data : 仅打包</span><br><span class="line">tar -zcvf xxx.tar /data : 打包后，以gzip方式压缩</span><br><span class="line">tar -jcvf xxx.tar /data : 打包后，以bzip2方式压缩</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>解压 -xvf</span><br><span class="line">先进入需要解压缩的文件夹下</span><br><span class="line">cd /tmp/data</span><br><span class="line">tar -xvf xxx.tar : 解包</span><br><span class="line">tar -zxvf xxx.tar : 解压gzip压缩文件</span><br><span class="line">tar -jxvf xxx.tar : 解压bzip2压缩文件</span><br><span class="line">tar -zxvf xxx.tar.gz etc/passwd :只解压部分文件夹</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="查找一个字符串是否在文件中"><a href="#查找一个字符串是否在文件中" class="headerlink" title="查找一个字符串是否在文件中"></a>查找一个字符串是否在文件中</h4><ul>
<li><p>如果在给定的文件中搜索某个字符串， 直接<code>grep “main” ./main.c</code>即可；</p>
</li>
<li><p>如果你要搜索某个特定的字符串，而不确定这个字符串可能会在哪个文件中出现，那只能在某个大的目录下递归搜索：<code>grep -r &quot;main&quot; ./</code></p>
</li>
<li><p>如果只指定-r来搜索，有时候可能会打印出很多无用的错误的信息，这会严重干扰你在搜索结果中查找你想要的信息。所以我们要用<code>grep -rs &quot;main&quot; ./</code>使用-s选项可以帮助我们将这些因为文件不存在或者文件不可读而打印出来的错误信息统统去除掉；</p>
</li>
<li><p>如果你想知道字符串所在的行号，那一定要指定-n选项：<code>grep -nrs &quot;main&quot; ./</code></p>
</li>
<li><p>可是很多时候你按照上面指定的条件进行搜索，在搜索结果中可能仍然有很多不是你想要的。比如你要搜索的字符串是”main”，而要搜索结果中你可能会看到很多诸如”main_function”， “mainly”等等这些包含”main”的更长的字符串。此时我们就需要借助于-w这个命令选项来过滤。<code>grep -nrws &quot;main&quot; ./</code></p>
</li>
</ul>
<hr>
<h4 id="查找本机一个端口号的状态"><a href="#查找本机一个端口号的状态" class="headerlink" title="查找本机一个端口号的状态"></a>查找本机一个端口号的状态</h4><p>netstat 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a：显示所有连接和监听端口，包括 TCP、UDP 和 UNIX 套接字（socket）等</span><br><span class="line">-n：以数值形式显示地址和端口，而不是以名称和服务方式显示</span><br><span class="line">-p：显示与每个连接关联的进程和程序名称</span><br><span class="line">-r：显示路由表信息</span><br><span class="line">-s：显示各种网络统计信息，如传输层协议统计、网络接口统计等</span><br><span class="line">-t：仅显示 TCP 连接信息</span><br><span class="line">-u：仅显示 UDP 连接信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，在命令行中输入 netstat -a 将显示当前计算机上的所有活动连接和监听端口。</span></span><br><span class="line">netstat -rn    <span class="comment"># 显示所有TCP的统计信息</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="如何判断远程服务的端口有没有开启"><a href="#如何判断远程服务的端口有没有开启" class="headerlink" title="如何判断远程服务的端口有没有开启"></a>如何判断远程服务的端口有没有开启</h4><p>telnet 命令可以测试远程主机是否可以访问指定的端口。在命令行中输入 “telnet 远程主机IP 端口号”，如果能够建立连接，说明该端口已经开启。例如，如果要测试远程主机的 80 端口是否开启，可以在命令行中输入 <code>telnet 远程主机IP 80</code>，如果成功建立连接，则说明该端口已经开启。</p>
<hr>
<h4 id="文件权限怎么修改"><a href="#文件权限怎么修改" class="headerlink" title="文件权限怎么修改"></a>文件权限怎么修改</h4><h5 id="文字设定法设置权限-ugoa"><a href="#文字设定法设置权限-ugoa" class="headerlink" title="文字设定法设置权限(ugoa)"></a>文字设定法设置权限(ugoa)</h5><p><code>chmod [操作对象] [操作符号] [权限] [文件|目录] </code></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png" alt="image-20221128220607286"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png" alt="image-20221128220621457"></p>
<p>chmod u+w a	添加所有者对a文件的写入权限</p>
<p>chmod u-r a	取消所有者对a文件的读取权限</p>
<p>chmod g&#x3D;w a	重新分配同组用户对a文件有写入的权限</p>
<p>chmod u+rw,g+r,o+rwx a	添加所有者为读取、写入权限;同组用户为读取权限;其他用户读取、写入和执行的权限</p>
<p>chmod a-rwx a	取消所有用户的读取、写入和执行权限</p>
<h5 id="数字设定法设置权限-ugo"><a href="#数字设定法设置权限-ugo" class="headerlink" title="数字设定法设置权限(ugo)"></a>数字设定法设置权限(ugo)</h5><p><code>chmod [n1n2n3] [文件|目录]</code></p>
<blockquote>
<p>  n1表示用户所有者的权限 ，n2表示组群所有者的权限，n3表示其它用户的权限。</p>
</blockquote>
<ul>
<li><p>文件和目录的权限表中用r、w、x这三个字符来为用户所有者、组群所有者和其它用户设置权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需3个数字。</p>
</li>
<li><p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。</p>
</li>
<li><p>所有数字属性的格式应该是三个0～7的数，其顺序是<strong>u、g、o</strong></p>
</li>
</ul>
<blockquote>
<p>  r：对应数值4	w：对应数值2	x：对应数值1	-：对应数值0</p>
</blockquote>
<blockquote>
<p>  若该文件为目录则第一位用d标志，否则用-标志</p>
</blockquote>
<blockquote>
<p>  -rwx——：用数字表示为700</p>
<p>  -rwxr–r–：用数字表示为744</p>
<p>  -rw-rw-r-x：用数字表示为665</p>
<p>  drwx–x–x：用数字表示为711</p>
<p>  drwx——：用数字表示为700</p>
</blockquote>
<blockquote>
<p>  chmod 777 a	所有用户拥有读取、写入和执行的权限</p>
<p>  chmod (00)7 a	设置a文件权限，其他用户拥有读取、写入和执行的权限</p>
</blockquote>
<h5 id="特殊权限-SUID-SGID-Sticky"><a href="#特殊权限-SUID-SGID-Sticky" class="headerlink" title="特殊权限(SUID SGID Sticky)"></a>特殊权限(SUID SGID Sticky)</h5><p>（1）SUID: 以用户所有者身份来执行一个可执行文件; 对一个目录无影响</p>
<p>（2）SGID: 以组群所有者身份来执行一个可执行文件;</p>
<p>（3）Sticky: 对一个可执行文件无影响, 对目录设置Sticky后，尽管其它用户有写权限，也必须由所有者执行删除和移动等操作</p>
<p><strong>文字设定法设置特殊权限</strong></p>
<p>chmod u+s a	添加a文件的特殊权限为SUID</p>
<p>chmod g+s a	添加a文件的特殊权限为SGID</p>
<p>chmod o+t a	添加a文件的特殊权限为Sticky</p>
<p><strong>数字设定法设置特殊权限</strong></p>
<p>chmod 4000 a	设置文件a具有SUID权限</p>
<p>chmod 2000 a	设置文件a具有SGID权限</p>
<p>chmod 1000 a	设置文件a具有Sticky权限</p>
<p>chmod 7000 a	设置文件a具有SUID，SGID和Sticky权限</p>
<hr>
<h4 id="如何以root权限运行某个程序"><a href="#如何以root权限运行某个程序" class="headerlink" title="如何以root权限运行某个程序"></a>如何以root权限运行某个程序</h4><p>su:  切换成root, 但不改变当前工作目录和环境变量</p>
<p>su-:  切换成root, 改变当前工作目录和环境变量为root的</p>
<p>sudo:  一种权限管理机制，授权给哪个用户可以以管理员的身份执行什么命令</p>
<blockquote>
<p>  sudo [选项] [-u 新使用者账号] 要执行的命令</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chown root 文件</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chmod u+s 文件</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="什么是大端小端-如何判断"><a href="#什么是大端小端-如何判断" class="headerlink" title="什么是大端小端, 如何判断"></a>什么是大端小端, 如何判断</h4><p>小端模式：低的有效字节存储在低的内存地址。小端一般为主机字节序；X86结构和大多数ARM都为小端模式</p>
<p>大端模式：高的有效字节存储在低的内存地址。大端为网络字节序</p>
<p><strong>如何判断：我们可以根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span>&#123;   </span><br><span class="line">        <span class="type">char</span> c;  <span class="comment">// 一个字节，低地址</span></span><br><span class="line">        <span class="type">int</span> i;  <span class="comment">// 四个字节，高地址</span></span><br><span class="line">    &#125;;  </span><br><span class="line">    test t; t.i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> (t.c == <span class="number">1</span>);  <span class="comment">//如果是小端,则t.c为1; 反之是大端  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字节序转换函数-IP转换函数"><a href="#字节序转换函数-IP转换函数" class="headerlink" title="字节序转换函数, IP转换函数"></a>字节序转换函数, IP转换函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从主机字节序到网络字节序的转换函数: </span></span><br><span class="line">htons <span class="comment">// 主机端口 -&gt; 网络端口</span></span><br><span class="line">htonl  <span class="comment">// 转换IP的，IP地址32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络字节序到主机字节序的转换函数</span></span><br><span class="line">ntohs</span><br><span class="line">ntohl</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inet_pton  <span class="comment">// &quot;192.168.12.1&quot; -&gt; 整数</span></span><br><span class="line">inet_ntop  <span class="comment">// 整数 -&gt; IP字符串</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="⚠️简述Linux内核态与用户态"><a href="#⚠️简述Linux内核态与用户态" class="headerlink" title="⚠️简述Linux内核态与用户态"></a>⚠️简述Linux内核态与用户态</h4><p>用户态是指<strong>进程在执行自己的代码时</strong>所处的一种特殊状态，此时进程只能访问自己的地址空间和受限的系统资源，例如打开文件或者建立网络连接。用户态下，进程不能直接访问操作系统核心代码，需要通过系统调用的方式向操作系统发起请求</p>
<p>内核态是指<strong>操作系统内核执行自己的代码</strong>时所处的一种特殊状态，此时操作系统具有对整个系统的控制权，可以访问任何系统资源，包括进程的地址空间和硬件资源。内核态下，操作系统可以直接执行特权指令</p>
<p>进入内核态的步骤如下：</p>
<ol>
<li>进入内核态<strong>：共有三种方式：a、</strong>系统调用<strong>。b、</strong>异常<strong>。c、</strong>设备中断</li>
<li>CPU从用户态切换到内核态，将用户程序的当前状态（如寄存器值）保存到内核栈中。</li>
<li>操作系统根据系统调用号确定需要执行的操作，并检查参数的合法性。</li>
<li>操作系统执行需要的操作，如果需要返回结果，则将结果保存到用户程序指定的内存地址中。</li>
<li>操作系统从内核态切换回用户态，恢复用户程序的状态（如寄存器值），继续执行用户程序。</li>
</ol>
<p>需要注意的是，进入内核态和从内核态返回到用户态的过程涉及到CPU寄存器和堆栈的切换和保存，因此会带来一定的开销。为了提高系统性能，操作系统通常会尽量减少用户态和内核态之间的切换次数，尽可能在用户态完成所有操作</p>
<hr>
<h4 id="虚拟地址到物理地址怎么映射的"><a href="#虚拟地址到物理地址怎么映射的" class="headerlink" title="虚拟地址到物理地址怎么映射的"></a>虚拟地址到物理地址怎么映射的</h4><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207131212493.png" alt="image-20230207131212493" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png" alt="image-20221205224538889" style="zoom:50%;">

<hr>
<h4 id="❤️说说进程-线程-协程是什么-区别？"><a href="#❤️说说进程-线程-协程是什么-区别？" class="headerlink" title="❤️说说进程,线程,协程是什么,区别？"></a>❤️说说进程,线程,协程是什么,区别？</h4><ol>
<li><p><strong>进程</strong>：进程则是程序的运行实例，包括程序计数器、堆栈和变量值</p>
</li>
<li><p><strong>线程</strong>：一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务</p>
</li>
<li><p><strong>协程</strong>：协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行的</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多. 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用</p>
</li>
<li><p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程</p>
<p>（2）一个进程挂掉，对应的线程挂掉；一个进程挂掉，不会影响其他进程</p>
<p>（3）进程是系统资源分配的最小单位；线程CPU调度的最小单位</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少</p>
<p>（5）进程在执行时拥有独立的内存单元; 多个线程共享进程的内存；但每个线程拥有自己的栈和.text段</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</p>
<p>（7）通信方式不一样</p>
</li>
<li><p><strong>线程与协程的区别：</strong></p>
<p>（1）协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小</p>
<p>（2）协程不需要多线程的锁机制，因为协程从属于线程，不存在同时写变量冲突</p>
<p>（3）协程占用内存少。执行协程只需要极少的栈内存（4～5KB），而线程栈的大小为1MB ;</p>
<p>如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</p>
<ol>
<li><strong>在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。</strong></li>
<li><strong>对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。</strong></li>
</ol>
</li>
</ol>
<hr>
<h4 id="❤️多进程和多线程架构"><a href="#❤️多进程和多线程架构" class="headerlink" title="❤️多进程和多线程架构"></a>❤️多进程和多线程架构</h4><p>（1）多进程</p>
<p>1.数据是分开的，共享复杂，同步简单<br>2.占用内存多，切换复杂，CPU利用率低<br>3.创建销毁复杂，切换复杂，速度慢<br>4.编程简单，调试简单<br>5.进程间不会相互影响<br>6.适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</p>
<p>（2）多线程</p>
<p>1.多线程共享进程数据，共享简单，同步复杂<br>2.占用内存少，切换简单，CPU利用率高<br>3.创建销毁简单，切换简单，速度快<br>4.编程复杂，调试复杂<br>5.当一个线程挂掉时，同一个进程下的线程可能会受到影响，取决于是否是共享内存区域遭到破坏，<br>6.适应于多核分布</p>
<p><strong>二.使用场景</strong><br>1)需要频繁创建和销毁的优先用线程。</p>
<p>实例：web 服务器，来一个任务建立一个线程，完了就销毁线程。要是用进程，创建和销毁的代价是很高的。</p>
<p>2）需要进行大量计算的优先使用进程。</p>
<p>3）强相关的处理用线程，弱相关的处理用进程。</p>
<p>4）可能扩展到多机分布的用进程，多核分布的用线程。</p>
<p>5）都满足需求的情况下，用你最熟悉、最拿手的方式。</p>
<hr>
<h4 id="为何CPU密集型适合多进程-I-x2F-O密集适合多线程"><a href="#为何CPU密集型适合多进程-I-x2F-O密集适合多线程" class="headerlink" title="为何CPU密集型适合多进程, I&#x2F;O密集适合多线程"></a>为何CPU密集型适合多进程, I&#x2F;O密集适合多线程</h4><p>CPU密集型任务是指任务的执行主要消耗CPU资源，而不涉及大量的IO操作。这类任务通常需要进行大量的计算、逻辑判断和数据处理，而CPU的计算能力是限制性能的关键因素。</p>
<p>在CPU密集型任务中，多进程的并行处理能力可以充分利用多核处理器的优势。每个进程都可以在独立的CPU核心上执行任务，同时进行计算和处理，提高整体的处理能力和效率。由于多进程之间相互独立，一个进程的计算任务不会影响其他进程的执行，因此可以实现更好的并行化效果。</p>
<p>另一方面，IO密集型任务是指任务的执行主要涉及大量的IO操作，如文件读写、网络通信等。在这种情况下，CPU的计算能力往往不是瓶颈，而是IO操作的速度限制了任务的执行效率。</p>
<p>多线程在IO密集型任务中有一些优势。由于多个线程可以共享同一进程的内存空间，线程之间可以直接访问共享数据，这样可以避免进程间的数据传输和通信开销，提高了数据共享和交互的效率。此外，线程的创建和切换开销较小，适合处理大量的IO操作，可以在等待IO操作完成的同时，切换到其他线程执行，提高系统的并发处理能力和响应速度。</p>
<hr>
<h4 id="❤️nginx为何采用多进程"><a href="#❤️nginx为何采用多进程" class="headerlink" title="❤️nginx为何采用多进程"></a>❤️nginx为何采用多进程</h4><ol>
<li><p>对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多</p>
</li>
<li><p>采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。worker进程的异常退出，只会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险</p>
</li>
</ol>
<p>Nginx多进程模型</p>
<p>master进程主要用来管理worker进程，具体包括如下4个主要功能：</p>
<p>（1）接收来自外界的信号。</p>
<p>（2）向各worker进程发送信号。</p>
<p>（3）监控woker进程的运行状态。</p>
<p>（4）当woker进程退出后（异常情况下），会自动重新启动新的woker进程。</p>
<p>woker进程主要用来处理网络事件，各个woker进程之间是对等且相互独立的，它们同等竞争来自客户端的请求，一个请求只可能在一个woker进程中处理，woker进程个数一般设置为机器CPU核数。</p>
<hr>
<h4 id="❤️当一个子进程挂了后，主进程怎么重启它"><a href="#❤️当一个子进程挂了后，主进程怎么重启它" class="headerlink" title="❤️当一个子进程挂了后，主进程怎么重启它"></a>❤️当一个子进程挂了后，主进程怎么重启它</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="built_in">execl</span>(<span class="string">&quot;/path/to/program&quot;</span>, <span class="string">&quot;program&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            <span class="comment">// 子进程正常退出，根据需要重启它</span></span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="built_in">execl</span>(<span class="string">&quot;/path/to/program&quot;</span>, <span class="string">&quot;program&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">            <span class="comment">// 子进程被信号终止，根据需要重启它</span></span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="built_in">execl</span>(<span class="string">&quot;/path/to/program&quot;</span>, <span class="string">&quot;program&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="❤️当一个子线程挂了后，主线程怎么重启他"><a href="#❤️当一个子线程挂了后，主线程怎么重启他" class="headerlink" title="❤️当一个子线程挂了后，主线程怎么重启他"></a>❤️当一个子线程挂了后，主线程怎么重启他</h4><p>在C++中，主线程无法直接重新启动一个已经终止的子线程，因为一旦一个线程结束，它的资源被操作系统回收，除非重新创建一个新线程。</p>
<p>因此，通常的做法是在主线程中创建一个循环，监视子线程的状态。如果发现子线程已经结束，主线程可以重新启动一个新的线程来替代它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThreadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 线程运行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">myThread</span><span class="params">(myThreadFunc)</span></span>; <span class="comment">// 创建一个子线程</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>() &amp;&amp; myThread.<span class="built_in">join</span>() == thread::<span class="built_in">id</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果子线程已经结束，join() 返回空 thread id</span></span><br><span class="line">      <span class="comment">// 重新启动一个新线程</span></span><br><span class="line">      myThread = <span class="built_in">thread</span>(myThreadFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待一段时间再检查子线程状态, 以避免不必要的 CPU 占用。</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="❤️Linux-和-Windows-多线程编程的区别"><a href="#❤️Linux-和-Windows-多线程编程的区别" class="headerlink" title="❤️Linux 和 Windows 多线程编程的区别"></a>❤️Linux 和 Windows 多线程编程的区别</h4><ol>
<li>线程的实现方式：Linux 线程被实现为一个特殊类型的文件描述符，可以通过系统调用如 <code>clone()</code> 或 <code>pthread_create()</code> 来创建。在这种方式下，线程就像一个文件一样被管理和操作；而 Windows 则是通过创建线程对象实现线程。</li>
<li>线程调度：Linux 使用的是抢占式调度，即线程可以被强制中断；而 Windows 则使用的是协作式调度，即需要线程主动放弃 CPU 时间片才会切换到其他线程。</li>
<li>线程同步：Linux 中使用 pthread 库实现线程同步，如互斥锁、条件变量等，基于POXIS标准实现；而 Windows 中则使用 Win32 API 实现线程同步，如互斥锁、信号量等。</li>
<li>线程的调试：Linux和Windows都提供了线程调试工具。在Linux下，gdb是一种常用的命令行调试工具，可以对多个线程进行调试。在Windows下，Visual Studio提供了可视化的调试工具，可以方便地调试多线程序</li>
</ol>
<hr>
<h4 id="❤️POXIS-和SystemV是什么"><a href="#❤️POXIS-和SystemV是什么" class="headerlink" title="❤️POXIS 和SystemV是什么"></a>❤️POXIS 和SystemV是什么</h4><p>POSIX是一个操作系统接口标准，定义了一套应用程序接口（API）和一组命令行工具，其目的是为了保证不同的操作系统之间的互操作性和可移植性。</p>
<p>System V 是一个 UNIX 操作系统版本。System V 包括一套标准的系统调用、程序库、头文件和一些基本工具。它提供了一些进程间通信（IPC）机制，如消息队列、共享内存和信号量等，这些机制已经成为 UNIX 操作系统的标准特性，并被各种衍生版本所采用。</p>
<p>POSIX 和 System V 在 UNIX 系统中都有广泛的应用。POSIX 旨在提供一个可移植的接口标准，使得 UNIX 操作系统之间的软件移植更加容易，而 System V 则提供了一些标准的系统调用和 IPC 机制，使得 UNIX 操作系统可以在进程间进行通信和数据共享。</p>
<hr>
<h4 id="❤️thread-和-pthread-区别"><a href="#❤️thread-和-pthread-区别" class="headerlink" title="❤️thread 和 pthread 区别"></a>❤️thread 和 pthread 区别</h4><p><code>thread</code> 是 C++11 引入的标准线程库，可以在 C++11 或更高版本的标准中使用。它提供了一种方便、跨平台的方式来创建和管理线程。它使用面向对象的方式，通过创建 <code>std::thread</code> 类对象来表示一个线程，可以使用成员函数 <code>join()</code> 或 <code>detach()</code> 来控制线程的执行和结束。</p>
<p><code>pthread</code> 是 POSIX 线程库，是一种 C 语言线程库，提供了一组用于多线程编程的 API。它在很多 UNIX 系统中都得到了支持，可以用于创建和管理线程、线程同步等操作。与 <code>thread</code> 不同，<code>pthread</code> 不使用面向对象的方式，而是提供了一组 C 函数来创建和管理线程，例如 <code>pthread_create()</code>、<code>pthread_join()</code> 等。</p>
<p>总体来说，<code>thread</code> 更加现代化、易用，而 <code>pthread</code> 更加传统、底层。在使用时，可以根据实际需求和平台限制来选择合适的线程库。如果要编写跨平台的程序，建议使用 <code>thread</code>，而在需要与 POSIX 线程库交互的环境中，可能需要使用 <code>pthread</code>。</p>
<hr>
<h4 id="❤️多线程debug"><a href="#❤️多线程debug" class="headerlink" title="❤️多线程debug"></a>❤️多线程debug</h4><ol>
<li><p>GDB: 包括调用栈、变量值等信息，从而定位崩溃原因。可以通过设置断点、单步执行来观察程序执行过程</p>
</li>
<li><p>打印日志</p>
</li>
<li><p>开源检测工具：如 Linux 的 <code>strace</code> 和 <code>ltrace</code> 命令，Windows 的 Process Monitor </p>
</li>
<li><p>并发测试工具：Valgrind ThreadSanitizer 可以检查多线程程序中的并发问题，包括数据竞争、死锁、死循环等。这些工具可以帮助发现程序中的并发问题，并提供相应的调试信息</p>
</li>
</ol>
<hr>
<h4 id="lock-guard-和-unique-lock-区别，使用案例"><a href="#lock-guard-和-unique-lock-区别，使用案例" class="headerlink" title="lock_guard 和 unique_lock 区别，使用案例"></a>lock_guard 和 unique_lock 区别，使用案例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lock_guard：被设计为在作用域结束时自动释放锁，从而防止忘记解锁的错误。</span></span><br><span class="line"><span class="comment">// 由于其简单性和效率，lock_guard 通常用于保护共享数据的简单操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    A ++; <span class="comment">// 对共享资源进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt --)&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">        t1.<span class="built_in">join</span>();</span><br><span class="line">        t2.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; A; <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unique_lock是一个更为灵活和功能更强大的锁定类。unique_lock 允许你手动地锁定和解锁</span></span><br><span class="line"><span class="comment">// 此外还支持时间限制、递归锁定、条件变量等功能。通常用于需要更复杂的线程同步操作的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line"><span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;     </span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> data_queue.<span class="built_in">size</span>() &lt; <span class="number">10</span>; &#125;); <span class="comment">// 等待队列有空闲位置    </span></span><br><span class="line">        data_queue.<span class="built_in">push</span>(i); <span class="comment">// 生产数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    is_end = <span class="literal">true</span>; <span class="comment">// 生产结束</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>() || is_end; &#125;); <span class="comment">// 等待队列非空或生产者结束</span></span><br><span class="line">        <span class="keyword">if</span> (!data_queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 消费数据</span></span><br><span class="line">            <span class="type">int</span> data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_end &amp;&amp; data_queue.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">// 判断是否结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程"><a href="#什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程" class="headerlink" title="什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程"></a>什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</h4><ol>
<li><p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，子进程残留资源(PCB) 存放于内核中，占用系统资源，这种进程称为僵尸进程。</p>
<p><strong>如何解决僵尸进程:</strong></p>
<p>(1) 一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的</p>
<p>(2) <strong>使用kill命令杀死其父进程(使僵尸进程变成孤儿进程)</strong></p>
<p>打开终端并输入下面命令:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> Z </span><br></pre></td></tr></table></figure>

<p>会列出进程表中所有僵尸进程的详细内容。然后输入命令：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">kill</span> -<span class="variable">s</span> <span class="variable">SIGCHLD</span> <span class="function"><span class="title">pid</span>(父进程<span class="variable">pid</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="说说什么是守护进程-如何实现？"><a href="#说说什么是守护进程-如何实现？" class="headerlink" title="说说什么是守护进程, 如何实现？"></a>说说什么是守护进程, 如何实现？</h4><p><strong>守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务</strong></p>
<ol>
<li>创建子进程，父进程退出</li>
<li>setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </li>
<li>改变当前目录为根目录</li>
<li>重设文件权限掩码</li>
<li>关闭文件描述符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="说说进程通信的方式有哪些"><a href="#说说进程通信的方式有哪些" class="headerlink" title="说说进程通信的方式有哪些"></a>说说进程通信的方式有哪些</h4><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png" alt="image-20221206023051122"></p>
<hr>
<h4 id="进程通信中的管道实现原理是什么"><a href="#进程通信中的管道实现原理是什么" class="headerlink" title="进程通信中的管道实现原理是什么"></a>进程通信中的管道实现原理是什么</h4><p>操作系统在内核中开辟一块<strong>缓冲区</strong>（<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制，半双工。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程）。管道本质是一种文件</p>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。读端由描述字fd[0]表示，称其为管道读端；写端由描述字fd[1]来表示。一般文件的 I&#x2F;O 函数都可以用于管道，如close()、read()、write()等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT  0      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT 1          </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="comment">//创建管道         </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];         </span><br><span class="line">    <span class="built_in">pipe</span>(fd);         </span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">//创建子进程, 父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;             </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);             </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);         </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程           </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端            </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);           </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));           </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);       </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="comment">//执行父进程           </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端             </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);             </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">255</span>];           </span><br><span class="line">        <span class="type">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in">sizeof</span>(buf));           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);       </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h4><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207143613149.png" alt="image-20230207143613149"></p>
<hr>
<h4 id="⚠️共享内存"><a href="#⚠️共享内存" class="headerlink" title="⚠️共享内存"></a>⚠️共享内存</h4><p>共享内存允许多个进程共享物理内存的同一块区域。这种IPC 机制无需内核介入。所有要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管道是一种存在于内核的文件)，这种IPC技术的速度更快</p>
<p><strong>共享内存使用步骤</strong></p>
<ol>
<li>调用<code>shmget()</code>这个调用将返回后续调用中需要用到的共享内存标识符</li>
<li>使用<code>shmat()</code>和当前进程进行关联, 返回已开辟的内存的首地址</li>
<li>调用<code>shmdt() </code>来分离共享内存段。在此之后，进程就无法再引用这块共享内存了。这是可选的，并且在进程终止时会自动完成这一步</li>
<li>调用<code>shmctl()</code>来删除共享内存段。只有当前所有附加内存段的进程都与之分离后,内存段才会销毁。只有一个进程需要执行这一步</li>
</ol>
<hr>
<h4 id="⚠️简述mmap的原理和使用场景-6参数"><a href="#⚠️简述mmap的原理和使用场景-6参数" class="headerlink" title="⚠️简述mmap的原理和使用场景(6参数)"></a>⚠️简述mmap的原理和使用场景(6参数)</h4><p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件映射到进程的虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size; 什么意思</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<p><strong>使用场景</strong>：</p>
<ol>
<li>进程对同一块区域频繁读写操作或者大规模数据传输；</li>
<li>进程间相互通信</li>
</ol>
<p><strong>差别：</strong></p>
<ol>
<li>内存对象的大小限制不同：使用shmem时，共享内存对象的大小通常受到系统限制，而使用mmap则可以映射任意大小的文件到内存中。</li>
<li>内存对象的生命周期不同：使用shmem时，内存对象可以被系统自动清理，也可以在所有进程都释放后由系统清理；而使用mmap则需要手动释放内存，否则会导致内存泄漏。</li>
</ol>
<hr>
<h4 id="说说常见信号"><a href="#说说常见信号" class="headerlink" title="说说常见信号"></a>说说常见信号</h4><table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。包括浮点运算错误，溢出及除0</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody></table>
<hr>
<h4 id="⚠️如何保护一个进程不被杀死，具体的代码实现"><a href="#⚠️如何保护一个进程不被杀死，具体的代码实现" class="headerlink" title="⚠️如何保护一个进程不被杀死，具体的代码实现"></a>⚠️如何保护一个进程不被杀死，具体的代码实现</h4><ol>
<li><p>拦截 SIGTERM &#x2F; SIGHUP 信号来保护进程不被杀死</p>
</li>
<li><p>fork()一个子线程，在子线程里setsid()</p>
</li>
<li><p>setsid  .&#x2F;a</p>
</li>
<li><p>nohup .&#x2F;a</p>
</li>
<li><p>.&#x2F;a &amp; 	切换到后台运行【ls看不到, ctrl + c取消不了，fg切换回前台】</p>
</li>
</ol>
<hr>
<h4 id="进程-线程的中断切换过程是怎样的？"><a href="#进程-线程的中断切换过程是怎样的？" class="headerlink" title="进程, 线程的中断切换过程是怎样的？"></a>进程, 线程的中断切换过程是怎样的？</h4><p>上下文切换指的是内核在CPU上对进程或者线程进行切换</p>
<ol>
<li><p><strong>进程上下文切换</strong></p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的PCB有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的<strong>地址转换</strong>和<strong>存储保护信息</strong></p>
<p>​    <strong>切换页目录以使用新的地址空间</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）</strong></p>
<p>（6）根据被选中进程恢复处理器现场</p>
</li>
<li><p><strong>线程上下文切换</strong></p>
<p>（1）保护被中断线程的处理器现场信息</p>
<p>（2）修改被中断线程的TCB有关信息，如线程状态等</p>
<p>（3）把被中断线程的线程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的线程</p>
<p>（5）根据被选中线程设置操作系统用到的<strong>存储保护信息</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（切换堆栈，以及各寄存器）</strong></p>
<p>（6）根据被选中线程恢复处理器现场</p>
</li>
</ol>
<hr>
<h4 id="❤️死锁产生条件以及如何解决死锁"><a href="#❤️死锁产生条件以及如何解决死锁" class="headerlink" title="❤️死锁产生条件以及如何解决死锁"></a>❤️死锁产生条件以及如何解决死锁</h4><ol>
<li><p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁</p>
</li>
<li><p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>： </p>
<p>（1）<strong>互斥</strong>：一个资源每次只能被一个进程使用</p>
<p>（2）<strong>请求保持</strong>：一个进程因请求资源而阻塞时,对已获得的资源保持不放</p>
<p>（3）<strong>不可剥夺</strong>：进程已获得的资源，在使用完前不可剥夺；</p>
<p>（4）<strong>环路等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li><p><strong>死锁的预防：</strong></p>
<ol>
<li>避免互斥：尽可能减少资源的互斥性，例如使用共享内存代替互斥锁。</li>
<li>破坏循环等待：对资源进行排序，确保线程或进程按照相同的顺序请求资源，从而避免循环等待。</li>
<li>避免请求保持：线程或进程在请求资源时不应该持有其他资源，这可以通过在获取所有资源之前释放已经持有的资源来实现。</li>
<li>避免不可剥夺：确保在任何时候都可以撤销线程或进程所持有的资源</li>
<li>检测和恢复：系统应该能够检测到死锁的发生，并尝试恢复。例如，可以使用超时机制，如果一个线程或进程长时间等待资源，则可以取消其请求，释放已经持有的资源。</li>
</ol>
</li>
</ol>
<hr>
<h4 id="⚠️在Linux中，让程序在系统开启时自启动"><a href="#⚠️在Linux中，让程序在系统开启时自启动" class="headerlink" title="⚠️在Linux中，让程序在系统开启时自启动"></a>⚠️在Linux中，让程序在系统开启时自启动</h4><ol>
<li><strong>使用rc.local文件</strong></li>
</ol>
<p>在Linux系统中，rc.local是一个启动脚本，可以在系统启动时自动运行。</p>
<p>如，如果要在系统启动时启动Apache Web服务器，可以在rc.local文件中添加以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/apachectl start</span><br></pre></td></tr></table></figure>

<p>注意：如果使用了Systemd，则rc.local可能不再适用。</p>
<ol start="2">
<li><strong>使用Systemd服务</strong></li>
</ol>
<p>Systemd是Linux系统中最新的init系统之一。使用systemd服务管理器，可以在系统启动时自动启动指定的程序。可以创建一个新的systemd服务文件，并在其中指定要自启动的程序。例如，如果要在系统启动时启动Nginx Web服务器，可以创建一个名为nginx.service的文件，并将其放置在&#x2F;etc&#x2F;systemd&#x2F;system目录中，然后在文件中添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/kill -s TERM <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>是指计算机在执行指令的过程中，由于硬件设备的需要或者其他原因，被迫中断当前的工作而转而去处理其他的工作。</p>
<p>在操作系统中，中断是一种重要的机制，它允许计算机在运行应用程序时响应外部事件或者硬件设备的请求。当外部事件或者硬件设备需要操作系统的处理时，会向处理器发送一个中断信号，处理器会立即暂停正在执行的程序，转而执行与中断信号相对应的中断处理程序（也称为中断服务程序或者中断处理例程）。</p>
<ol>
<li>硬件中断：由于硬件设备出现故障或需要处理某些事务而引发的中断，例如磁盘操作完成、网络数据传输完成等。</li>
<li>软件中断：由于软件程序需要访问操作系统的某些服务或资源而引发的中断，例如系统调用、异常等。</li>
<li>外部中断：由外部设备发送的信号或事件引发的中断，例如键盘输入、鼠标点击等。</li>
<li>内部中断：由CPU内部的错误或操作引发的中断，例如除零错误、页故障等。</li>
<li>陷阱：由于用户进程在执行时意外触发了操作系统预定义的异常条件而引发的中断，例如系统调用等。</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230327182127099.png" alt="image-20230327182127099"></p>
<hr>
<h4 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h4><p>锁是用来实现多线程同步的一种机制，常见的锁包括以下几种：</p>
<ol>
<li>互斥锁：也称为 Mutex，是一种最基本的锁。它是一种二进制锁，只有两种状态：锁定和非锁定。多个线程同时尝试获取该锁时，只有一个线程能够成功获取，其他线程需要等待该线程释放锁才能尝试获取。</li>
<li>读写锁：也称为 RWLock，是一种特殊的锁。它可以允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁的使用可以提高程序的并发性能。</li>
<li>自旋锁：也称为 SpinLock，是一种非阻塞锁。它是通过忙等待的方式来实现的，当一个线程需要获取该锁时，如果锁已经被其他线程持有，该线程会一直忙等待，直到锁被释放。自旋锁的等待是忙等待，因此适合用于锁被持有时间很短的情况下。</li>
<li>条件变量：是一种基于线程等待和通知机制的锁。当一个线程需要等待某个条件成立时，它会通过条件变量进入阻塞状态，等待其他线程通知条件成立。当条件成立时，其他线程通过条件变量通知等待的线程，使其从阻塞状态中唤醒并继续执行。</li>
<li>信号量：是一种计数器，用来控制多个线程对共享资源的访问。当计数器为 0 时，线程需要等待，否则可以继续执行。</li>
<li>屏障：也称为 Barrier，是一种同步机制。它可以保证多个线程在某个点上同步执行，当所有线程到达该点时，才能继续执行下一步操作。</li>
</ol>
<hr>
<h4 id="自旋锁和条件变量的区别"><a href="#自旋锁和条件变量的区别" class="headerlink" title="自旋锁和条件变量的区别"></a>自旋锁和条件变量的区别</h4><p>自旋锁和条件变量都是用来实现多线程同步的机制，但它们的实现方式和作用有所不同。</p>
<p>自旋锁是一种非阻塞锁，它是通过忙等待的方式来实现的。当一个线程需要获取自旋锁时，如果锁已经被其他线程持有，那么该线程会一直忙等待，直到锁被释放。由于自旋锁的等待是忙等待，所以在锁被持有的时间很短的情况下，自旋锁的效率很高。但是当锁被持有的时间很长时，忙等待会浪费大量的 CPU 资源，因此自旋锁不适合用于长时间的等待。</p>
<p>条件变量是一种阻塞锁，它是基于线程等待和通知机制来实现的。当一个线程需要等待某个条件成立时，它会通过条件变量进入阻塞状态，等待其他线程通知条件成立。当条件成立时，其他线程通过条件变量通知等待的线程，使其从阻塞状态中唤醒并继续执行。因为条件变量是基于线程等待和通知机制实现的，所以它不会浪费 CPU 资源，适合用于长时间的等待。</p>
<hr>
<h4 id="零拷贝-amp-DMA"><a href="#零拷贝-amp-DMA" class="headerlink" title="零拷贝 &amp; DMA"></a>零拷贝 &amp; DMA</h4><p>比如想实现一个下载功能，服务端的任务就是：</p>
<p>将服务器主机磁盘中的文件从已连接的socket中发出去，关键代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = read(diskfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">	write(sockfd, buf, n);</span><br></pre></td></tr></table></figure>

<p>以上过程包括四次内核态切换和2次DMA<br><strong>read</strong>:将数据从磁盘读取到内核缓存区中，在拷贝到用户缓冲区<br><strong>write</strong>:先将数据写入到socket缓冲区中，最后写入网卡设备</p>
<p>DMA本质上是一块主板上独立的芯片，允许外设设备和内存之间直接进行IO数据传输，<strong>其过程不需要CPU的参与</strong></p>
<p>如何实现零拷贝？</p>
<p>零拷贝并不是没有拷贝数据，而是减少用户态&#x2F;内核态的切换次数以及内存拷贝次数；实现零拷贝主要有两种方式分别是</p>
<ol>
<li><p>mmap </p>
</li>
<li><p>sendfile</p>
</li>
</ol>
<hr>
<h4 id="mmap-和sendfile-的区别"><a href="#mmap-和sendfile-的区别" class="headerlink" title="mmap 和sendfile 的区别"></a>mmap 和sendfile 的区别</h4><p><code>sendfile</code>和<code>mmap</code>都是在进行文件传输和IO时使用的函数，但是它们的实现机制不同，各自具有不同的优缺点。</p>
<p><code>sendfile</code>是一个系统调用函数，它将文件从一个文件描述符传输到另一个文件描述符，通常用于网络服务器发送静态文件到客户端。它避免了数据在内核与用户空间之间的复制，直接从文件系统缓存中将数据复制到网络缓存中，因此它是非常快的。但是它的使用场景有限，只能用于网络传输，不能用于内存操作。</p>
<p><code>mmap</code>也是一种高效的IO方式，它将文件映射到进程的虚拟地址空间，使得进程可以直接访问文件中的数据。这种直接的内存访问方式比较快，因为它避免了数据在内核与用户空间之间的复制。此外，<code>mmap</code>允许进程将文件的某一部分映射到内存中，这意味着进程可以仅仅访问文件的一部分而无需将整个文件加载到内存中。</p>
<p>综上所述，<code>sendfile</code>和<code>mmap</code>都是高效的IO方式，但是它们适用于不同的场景。如果你需要在网络上传输文件，那么使用<code>sendfile</code>会更快；如果你需要直接访问文件中的数据，那么使用<code>mmap</code>会更快。</p>
<hr>
<h4 id="future"><a href="#future" class="headerlink" title="future"></a>future</h4><p><code>future</code> 可以理解为金融中的 <code>期货</code>. 我有一个 <code>future</code> 类型的变量, 交给一个异步的线程去处理. 我到期来提货交割就可以了.这个能提供 <code>future</code> 服务的就叫<code>provider</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// future example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::async, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>         <span class="comment">// std::chrono::milliseconds</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a non-optimized way of checking for prime numbers:</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; ++i) <span class="keyword">if</span> (x%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// call function asynchronously:</span></span><br><span class="line">	future&lt;<span class="type">bool</span>&gt; fut = <span class="built_in">async</span>(is_prime, <span class="number">444444443</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do something while waiting for function to set future:</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;checking, please wait&quot;</span>;</span><br><span class="line">	<span class="function">chrono::milliseconds <span class="title">span</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(span) == future_status::timeout)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::flush;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> x = fut.<span class="built_in">get</span>();     <span class="comment">// retrieve return value</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n444444443 &quot;</span> &lt;&lt; (x ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; prime.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">=&gt; checking, please wait........</span><br><span class="line"><span class="number">444444443</span> is prime.</span><br></pre></td></tr></table></figure>





<h3 id="2️⃣计算机网络-5-23"><a href="#2️⃣计算机网络-5-23" class="headerlink" title="2️⃣计算机网络 5.23"></a>2️⃣计算机网络 5.23</h3><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端(被动接受连接的角色)</span></span><br><span class="line"><span class="number">1.</span>创建一个用于监听客户端连接的套接字(文件描述符)【lfd】</span><br><span class="line"><span class="number">2.</span>将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)【【serveraddr要设置IP、端口、协议】lfd与serversaddr绑定】</span><br><span class="line">	-客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span>设置监听，lfd开始工作</span><br><span class="line"><span class="number">4.</span>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字【clientaddr只要定义, cfd【cfd与clientaddr通信】】</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bind() </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET; <span class="comment">// 网络协议</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.12.1&quot;, &amp;serveraddr.sin_addr.s_addr); // IP</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 服务器开发时可写,表示服务器端任何IP都可以被客户端访问</span></span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 8为连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.accept()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd  = <span class="built_in">accept</span>(listenfd, (sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span> *)len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 获取客户端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示客户端断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字【clientfd】</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定连接的服务器的IP和端口【serveraddr要设置IP、端口、协议【clientfd与serveraddr连接，用clientfd通信】】</span><br><span class="line"><span class="number">3.</span>连接成功了，客户端可以直接和服务器通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">4.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clientfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %d\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示服务器断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="listen-里的backlog参数"><a href="#listen-里的backlog参数" class="headerlink" title="listen() 里的backlog参数"></a>listen() 里的backlog参数</h5><p>backlog：等待连接队列的最大长度。当有客户端请求连接时，如果服务器端没有足够的资源去处理这些连接请求，那么这些连接请求就会被放入一个等待队列中，等待服务器处理。</p>
<p><code>backlog</code>参数对于管理服务器性能和连接处理非常重要。如果<code>backlog</code>设置得太低，服务器可能无法处理所有传入的连接请求，导致连接丢失或响应时间缓慢。如果<code>backlog</code>设置得太高，服务器可能会消耗过多的资源来管理大量的挂起连接。</p>
<hr>
<h5 id="accept-在三次握手哪里"><a href="#accept-在三次握手哪里" class="headerlink" title="accept() 在三次握手哪里"></a>accept() 在三次握手哪里</h5><p><strong>accept()需要给此次连接分配资源。</strong>设想一个情景，若有10000个客户端都和该服务端进行连接，发送SYN，服务端收到之后，这些客户端却不再理会服务端的回复，然而此时服务端的资源却都用accept()分配了。这就是所谓的“DDOS攻击”。  <strong>为了解决这个问题，accept() 放在三次握手之后。</strong></p>
<hr>
<h5 id="防范SYN攻击（DDOS的一种）"><a href="#防范SYN攻击（DDOS的一种）" class="headerlink" title="防范SYN攻击（DDOS的一种）"></a>防范SYN攻击（DDOS的一种）</h5><ol>
<li>配置防火墙规则：可以配置防火墙规则，限制每个IP地址对服务器的连接数，以及每个端口的连接数，从而减少SYN攻击对服务器的影响。</li>
<li>启用SYN Cookie：可以在服务器上启用SYN Cookie功能。当服务器收到大量的SYN数据包时，它会在内存中创建一个SYN Cookie，用于保存客户端的状态信息。当客户端返回ACK数据包时，TCP服务器再根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接</li>
<li>加强网络监控：可以使用网络监控工具，实时监控网络流量，及时发现并阻止SYN攻击。</li>
<li>调整服务器性能：可以通过增加服务器性能，如增加CPU、内存、网络带宽等，提高服务器抵御SYN攻击的能力。</li>
</ol>
<h4 id="网络理论"><a href="#网络理论" class="headerlink" title="网络理论"></a>网络理论</h4><h5 id="应用层-gt-传输层-gt-网络层-gt-链路层"><a href="#应用层-gt-传输层-gt-网络层-gt-链路层" class="headerlink" title="(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)"></a>(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)</h5><p>我们就以一个HTTP请求数据包为例子来说明.发送数据的计算机叫做<strong>源主机</strong>，接收数据的计算机叫做<strong>目标主机</strong></p>
<p><strong>应用层</strong><br>首先一个HTTP数据包在应用层中大概包含HTTP协议的版本号、各种字段属性值、最后是包含的要发送的实际数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131442484.png" alt="image-20230227131442484" style="zoom:20%;">

<p><strong>传输层</strong></p>
<p>传输层对应着有UDP和TCP两种协议，HTTP采用的是TCP协议，因为TCP能够提供差错控制。</p>
<blockquote>
<p>  传输层会为将HTTP数据包包装上源端口号和目的端口号等信息。</p>
<p>  <strong>目的端口号</strong>是为了在数据包到达目的计算机的时候让其了解需要将数据包交给什么应用层协议进行处理。</p>
<p>  <strong>源端口号</strong>是为了让目标计算机想要返回数据的时候，知道给源计算机的哪个应用层协议发送数据</p>
</blockquote>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131536296.png" alt="image-20230227131536296" style="zoom:20%;">

<p>如果HTTP报文超过了<strong>数据链路层</strong>规定的最大传输单元MTU,TCP会对HTTP报文进行拆解, 将HTTP报文拆分成多个满足传输要求的报文并包装，这些报文之间是有先后顺序的，TCP对这些报文进行顺序编号，保证数据的正确读</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131834043.png" alt="image-20230227131834043" style="zoom:25%;">

<p><strong>网络层</strong></p>
<p>会为其加入源IP和目标IP等信息。	<strong>源IP</strong> 指的是源计算机的IP	<strong>目标IP</strong> 指的是目标计算机的IP</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131924338.png" alt="image-20230227131924338" style="zoom: 33%;">

<p><strong>数据链路层</strong><br>在数据链路层中会在数据包中，<strong>加入发送方MAC地址和接收方MAC地址。</strong><br><strong>发送方MAC地址</strong> 就是源计算机的MAC地址，不变。<br><strong>接收方MAC地址</strong> 并不是目标计算机的MAC地址， 不变。而是数据包的下一跳的MAC地址，也就是网关的地址，也可以说是第一个转发的路由器的端口mac地址</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132509995.png" alt="image-20230227132509995"></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132827930.png" alt="image-20230227132827930" style="zoom:25%;">

<blockquote>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
<p>  <strong>交换机</strong><br>  数据包首先会发送到交换机中，交换机工作在MAC层，是一个二层网络设备。</p>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
</blockquote>
<h5 id="链路层-gt-网络层-gt-传输层-gt-应用层"><a href="#链路层-gt-网络层-gt-传输层-gt-应用层" class="headerlink" title="(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)"></a>(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)</h5><ol>
<li><strong>路由器——路由转发</strong></li>
</ol>
<blockquote>
<p>  数据包出了交换机就算是出了家门了，开始进入路由器。</p>
<p>  数据包通过端口进入路由器，执行以下步骤：<br>  1、 路由器首先会检查数据包的接收方MAC地址是否等于路由器端口的MAC地址，如果等于就接收，如果不等于就抛弃。<br>  2、 路由器去除头部的MAC包装，暴露出IP地址信息，取出目标IP地址，然后查看路由表。</p>
<p>  <strong>取出路由表中的记录与目标IP地址挨个进行检验，检验过程如下：</strong></p>
<p>  将记录中的子网掩码与目标IP地址进行&amp;运算，如果等于记录中的目标网络，说明存在当前路由器可以到达目标IP地址，就通过记录中对应的端口转发出去, 在转发出去之前需要包装MAC地址</p>
<p>  3、 如果路由表中不存在对应的目标地址，那么就会通过默认路由发出去，默认路由的目标地址和子网掩码都是 <strong>0.0.0.0</strong>，MAC的包装和上述一样。</p>
<p>  4、 如果同时存在多个符合的路由，就按照最长掩码匹配原则，选择掩码中1最多的路由进行转发</p>
</blockquote>
<blockquote>
<p>  从路由转发的过程来看，<strong>源IP地址和目标IP地址一直不变，发送方MAC地址和接收方MAC地址一直在变。</strong></p>
</blockquote>
<ol start="2">
<li><strong>到达目标计算机</strong><br>就这样通过路由器的不断转发，数据包会到达与目标计算机直连的路由器。</li>
</ol>
<blockquote>
<p>  此时，路由器中目标IP地址对应的路由记录中的下一跳IP地址 就是 目标IP地址。</p>
<p>  这个时候，路由表会将目标IP地址的MAC地址当作目的MAC地址，将路由器转发端口对应的MAC地址当作源MAC地址，然后通过端口将MAC帧发送到 路由器端口对应的子网中。</p>
<p>  路由器子网是由多个交换机构成的局域网，交换机只会通过MAC地址缓存将数据包转发给对应的端口，如果没有对应的缓存，就转发给所有的端口。</p>
<p>  这样的话，数据包就会转发到了目标计算机中</p>
</blockquote>
<ol start="3">
<li><strong>目标计算机在收到数据包后会将数据包从下层往上层拆封。</strong></li>
</ol>
<blockquote>
<p>  1、 首先是数据链路层，目标计算机会将MAC包装信息去除，取出接收方MAC地址，查看是否和自己的MAC地址一致，如果不一致，就抛弃。</p>
<p>  2、 接着是网络层，将IP包装信息去除，取出目标IP地址，查看是否与自己的IP地址一致，如果不一致，就抛弃。</p>
<p>  3、 接着是传输层，会取出目标端口号，通过端口号获取对应的进程，将数据包交给对应的进程。比如HTTP数据包的目标端口号是80，就会交给HTTP进程，HTTP会调用其业务逻辑，将返回的数据包装成数据包通过源IP地址发送给源计算机。</p>
</blockquote>
<h5 id="⚠️网络模型"><a href="#⚠️网络模型" class="headerlink" title="⚠️网络模型"></a>⚠️网络模型</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161432357.png" alt="image-20230210161432357"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103852887.png" alt="image-20230227103852887"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230406225101735.png" alt="image-20230406225101735"></p>
<p><strong>广播域就是说，如果站点发出一个广播信号后能接收到这个信号的范围，通常来说一个局域网就是一个广播域。（用路由器连接的除外）。冲突域是一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域</strong></p>
<p><strong>三种模型对比</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161511598.png" alt="image-20230210161511598"></p>
<hr>
<h5 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手 &amp; 四次挥手"></a>TCP三次握手 &amp; 四次挥手</h5><p><strong>三次握手(发生在客户端connect()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AB3FC1B1325FA341A39644BA061FA439.jpeg" alt="img" style="zoom: 33%;">

<p>三次握手完成，成功建立连接，开始传输数据</p>
<blockquote>
<p>  总结：传输层TCP是全双工的，但是其上层应用层可能是半双工的。每一个层次都有自己的双工模式，传输层有传输层的双工模式，应用层有应用层的双工模式。下层的双工模式是支持上层双工模式的上限。比如下层支持半双工，上层顶多支持半双工，不可能支持全双工。tcp是全双工的，但它的上层可能支持半双工，比如http1.1，也有可能支持全双工，比如http2.0</p>
</blockquote>
<p><strong>四次挥手(发生在两端close()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg" alt="img" style="zoom: 33%;">

<hr>
<h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230208211405978.png" alt="image-20230208211405978"></p>
<hr>
<h5 id="TCP流量控制：滑动窗口"><a href="#TCP流量控制：滑动窗口" class="headerlink" title="TCP流量控制：滑动窗口"></a><strong>TCP流量控制：滑动窗口</strong></h5><p>在流量控制中那些已经被客户端发送但是还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口，随着TCP协议的运行、数据的运输，这个窗口在序号空间向前滑动，因此这个窗口被称为滑动窗口。 </p>
<p>可以将整个报文段分为四组 </p>
<ol>
<li>已被确认的分组</li>
<li>已发送但未被确认的分组</li>
<li>接下来可以分发的分组</li>
<li>超出窗口长度之后的待使用的分组</li>
</ol>
<hr>
<h5 id="TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复"><a href="#TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复" class="headerlink" title="TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复"></a>TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复</h5><p><em>发送方的发送窗口大小 &#x3D; Min(接收窗口rwnd</em>,拥塞窗口cwnd) </p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183029287.png" alt="image-20230301183029287" style="zoom: 40%;">

<hr>
<h5 id="说说-TCP-粘包"><a href="#说说-TCP-粘包" class="headerlink" title="说说 TCP 粘包"></a>说说 TCP 粘包</h5><p>TCP基于字节流，无法判断发送方报文段边界 </p>
<p>多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发送边界，若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包</p>
<p>发送端可能堆积了两次数据，每次100字节一共在发送缓存堆积了200字节的数据，而接收方在接收缓存中一次读取120字节的数据，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。 解决粘包的方法： </p>
<ol>
<li>发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界 </li>
<li>数据包末尾加上\r\n标记，模仿FTP协议，但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界 </li>
<li>数据包头部加上数据包的长度，也是目前所采取的方案</li>
</ol>
<hr>
<h5 id="TCP-和-UDP-可以同时绑定相同的端口吗"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗?"></a>TCP 和 UDP 可以同时绑定相同的端口吗?</h5><p>当主机收到数据包后，可以在 IP包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块(TCP &#x2F; UDP)处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 8888号端口，UDP 也可以有一个 8888 号端口</p>
<p>运行这两个程序后，通过 netstat 命令可以看到，TCP 和 UDP 是可以同时绑定同一个端口号的</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181113760.png" alt="image-20230302181113760"></p>
<hr>
<h5 id="多个-TCP-服务进程可以绑定同一个端口吗"><a href="#多个-TCP-服务进程可以绑定同一个端口吗" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗?"></a>多个 TCP 服务进程可以绑定同一个端口吗?</h5><p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是 “Address already in use”</p>
<p>没有设置端口复用的socket在当 TCP 服务进程重启时，客户端处于 TIME_WAIT 状态，在TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误</p>
<p>解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是<strong>：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong></p>
<p>SO_REUSEADDR 的另外一个作用是绑定的 IP地址 + 端口时，只要 IP 地址不是exactly相同，那么允许绑定。</p>
<hr>
<h5 id="同一客户端可以-bind-同一个端口吗？"><a href="#同一客户端可以-bind-同一个端口吗？" class="headerlink" title="同一客户端可以 bind 同一个端口吗？"></a>同一客户端可以 bind 同一个端口吗？</h5><p>客户端在执行 connect() 的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</p>
<p>所以，客户端的端口选择的发生在 connect ()，内核会随机选择一个端口</p>
<p>当客户端与服务端完成 TCP 连接建立后，我们可以通过 netstat 命令查看 TCP 连接<br><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182404371.png" alt="image-20230302182404371"></p>
<blockquote>
<p>  上面客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？</p>
</blockquote>
<p>正确的理解是，TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题</p>
<hr>
<h5 id="⚠️客户端connect函数选择端口号的过程"><a href="#⚠️客户端connect函数选择端口号的过程" class="headerlink" title="⚠️客户端connect函数选择端口号的过程"></a>⚠️客户端connect函数选择端口号的过程</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/b0b1814b7ed7990ea54c117fbff29599.jpeg" alt="img" style="zoom: 50%;">

<hr>
<h5 id="产生大量CLOSE-WAIT原因和解决"><a href="#产生大量CLOSE-WAIT原因和解决" class="headerlink" title="产生大量CLOSE_WAIT原因和解决"></a>产生大量CLOSE_WAIT原因和解决</h5><ol>
<li>服务器迟迟无法进行第三次挥手，从而导致CLOSE_WAIT状态的堆积。(正确关闭套接字连接)</li>
<li>网络问题：在网络故障或不稳定的情况下，连接关闭可能会失败，导致CLOSE_WAIT状态的出现</li>
<li>服务器端使用阻塞式I&#x2F;O：当服务器端使用阻塞式I&#x2F;O时，如果有某个连接上的数据未被及时处理，则可能会导致连接被阻塞，从而导致CLOSE_WAIT状态的堆积</li>
<li>过多的并发连接：如果服务器端同时处理大量的并发连接，可能会导致连接的处理不及时，从而导致CLOSE_WAIT状态的堆积</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法: 在发送数据时，如果发生错误，应该及时关闭套接字，而不是等待数据发送完毕</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(socket_fd, buffer, buffer_size, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="产生大量TIME-WAIT原因和解决"><a href="#产生大量TIME-WAIT原因和解决" class="headerlink" title="产生大量TIME_WAIT原因和解决"></a>产生大量TIME_WAIT原因和解决</h5><ol>
<li>大量短连接：如果一个应用程序频繁地打开和关闭TCP连接，就会产生大量的TIME_WAIT状态。这是因为在TIME_WAIT状态下，操作系统会保留连接信息，直到超时时间到期。如果一个应用程序频繁打开和关闭连接，就会导致大量TIME_WAIT状态堆积。</li>
<li>网络延迟：在网络延迟比较大的情况下，连接关闭时可能需要更长的时间来等待所有的数据包到达。在这种情况下，TIME_WAIT状态会持续更长的时间，从而导致大量TIME_WAIT状态的出现。</li>
<li>大量并发连接：此时，TIME_WAIT状态的数量可能会增加。这是因为每个连接在关闭后都会变成TIME_WAIT状态，如果有大量连接，就会产生大量TIME_WAIT状态。</li>
</ol>
<p>解决办法: 优化内核参数，让服务器能够快速回收和重用那些TIME_WAIT的资源</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%编辑内核文件/etc/sysctl.conf，加入以下内容：</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span>    <span class="comment">%表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span>      <span class="comment">%表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span>    <span class="comment">%表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line">net.ipv4.tcp_fin_timeout      <span class="comment">%修改系默认的 TIMEOUT连接超时 时间</span></span><br><span class="line"></span><br><span class="line">执行 /sbin/sysctl -p 让参数生效</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="HTTP请求报文-amp-响应报文"><a href="#HTTP请求报文-amp-响应报文" class="headerlink" title="HTTP请求报文&amp;响应报文"></a>HTTP请求报文&amp;响应报文</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152923685.png" alt="image-20230209152923685" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span>   </span><br><span class="line">-----------------------↑请求行,↓请求头部---------------------------</span><br><span class="line">Host: https:<span class="comment">//www.baidu.com</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">86.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">86.0</span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,*<span class="comment">/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Cookie: BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; __yjs_duid=1_d05d52b14af4a339210722080a668ec2161****694782; BD\_HOME=1; H_PS_PSSID=33514_33257_33273_31660_33570_26350; BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br><span class="line"><span class="comment">-----------------------------↓请求体-----------------------------</span></span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152937850.png" alt="image-20230209152937850" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">-----------------------↑状态行,↓响应头部---------------------------</span><br><span class="line">Bdpagetype: <span class="number">1</span></span><br><span class="line">Bdqid: <span class="number">0xf3c9743300024ee4</span></span><br><span class="line">Cache-Control: <span class="keyword">private</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf<span class="number">-8</span></span><br><span class="line">Date: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Expires: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line">Set-Cookie: BDSVRTM=<span class="number">13</span>; path=/</span><br><span class="line">Set-Cookie: BD_HOME=<span class="number">1</span>; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=<span class="number">33514</span>_33257_33273_31660_33570_26350; path=/; domain=.baidu.com Strict-Transport-Security: max-age=<span class="number">172800</span></span><br><span class="line">Traceid: <span class="number">161</span>****<span class="number">0751284122890175</span>****<span class="number">9583927635684</span></span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">-----------------------------↓响应体-----------------------------</span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="一次HTTP请求响应的流程"><a href="#一次HTTP请求响应的流程" class="headerlink" title="一次HTTP请求响应的流程"></a>一次HTTP请求响应的流程</h5><p>​		浏览器先查看<strong>浏览器缓存</strong>, 如果缓存中有, 会直接在屏幕中显示页面内容</p>
<ul>
<li>域名解析:浏览器查询 DNS，获取域名对应的IP地址:	浏览器先在本地DNS服务器进行查询, 如果本地域名服务器并未缓存该域名对应IP，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得对应的IP后，向服务器请求建立TCP链接，发起三次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
<hr>
<h5 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h5><p>1.无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。（传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低）</p>
<p>2.无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为。（优点解放服务器，但可能每次请求会传输大量重复的内容信息）</p>
<hr>
<h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置</li>
<li>DELETE：删除文件，与PUT相反，删除对应URI位置文件。</li>
<li>HEAD：获得报文头部，与GET类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>OPTIONS：查询相应URL支持的HTTP方法</li>
</ul>
<hr>
<h5 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h5><ol>
<li><p>get重点在从服务器上获取资源；post重点在向服务器发送数据；</p>
</li>
<li><p>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等 </p>
<p>post传输数据将字段与对应值封存在请求体中发送给服务器，这个过程对用户是不可见的</p>
</li>
<li><p>Get传输的数据量小，因为受URL长度限制，但效率较高</p>
<p>Post可以传输大量数据，所以上传文件时只能用Post方式</p>
</li>
<li><p>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码</p>
<p>post支持标准字符集，可以正确传递中文字符</p>
</li>
</ol>
<hr>
<h5 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h5><ul>
<li>1xx：表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<hr>
<h5 id="Http的keepalive字段"><a href="#Http的keepalive字段" class="headerlink" title="Http的keepalive字段"></a>Http的keepalive字段</h5><p>既然上面提到了HTTP是基于请求与响应的，且最主要的两个特点就是无连接和无状态，但需要说明的是，虽然是无连接的，但其底层也就是传输层大多却是基于 TCP面向连接的通信方式，因此，这里的无连接指的是：当server端和client端进行通讯的时候，client端向server端发起请 求，server端接收请求之后返回给client端一个响应，之后就会断开不再继续保持连接了；这样有一个好处就是对于只有一次访问的连接来说不仅节省 资源还很高效，但很明显，如果client端还想继续多次访问server端就需要重新建立连接也就是会多次进行TCP的“三次握手，四次挥手”的过程， 这样一来并没有节省资源而且还很低效，因此使用keep-alive（又称持久连接、连接重用）可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。减少了建立或者重新建立连接的次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高http服务器的吞吐率</p>
<p>HTTP 1.0 中keep-alive默认是关闭的，需要在HTTP头加入”Connection: Keep-Alive”，才能启用Keep-Alive；</p>
<p>HTTP 1.1中默认启用Keep-Alive，如果加入”Connection: close “则关闭。目前大部分浏览器都是用HTTP 1.1协议</p>
<p>keepalive_timeout时间值意味着：一个http产生的TCP连接在传送完最后一个响应后，还需要保持多久时间后才开始关闭这个连接；如果在这个时间内client端还有请求发过来，那么server端会继续给予响应</p>
<hr>
<h5 id="❤️长连接和短连接"><a href="#❤️长连接和短连接" class="headerlink" title="❤️长连接和短连接"></a>❤️长连接和短连接</h5><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况（会在后台开启http守护进程，一个http守护进程消耗是5MB内存的话）</p>
<p>例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket 创建也是对资源的浪费。</p>
<p>而像 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<hr>
<h5 id="❤️既然有了HTTP为什么还要RPC"><a href="#❤️既然有了HTTP为什么还要RPC" class="headerlink" title="❤️既然有了HTTP为什么还要RPC"></a>❤️既然有了HTTP为什么还要RPC</h5><p>虽然HTTP和RPC都是用于网络通信的协议，但它们的设计目标和使用场景是不同的。</p>
<p>HTTP是一种通用的应用层协议，常用于客户端与服务器之间的请求响应模式的通信，例如浏览器请求网页资源。HTTP协议是无状态的，每次请求需要携带所有必要的信息，如请求头、请求体等。HTTP协议也支持基于文本的协议，易于调试和理解，因此被广泛应用于Web应用程序和API的开发。</p>
<p>RPC支持客户端调用远程服务器上的函数，就像本地函数一样。与HTTP协议相比，RPC协议更加高效、紧凑和灵活，因为它通常使用二进制协议和更紧凑的数据格式来传输数据，避免了HTTP协议中的文本格式和不必要的信息。RPC协议也可以提供更高级的服务发现、负载均衡和故障恢复功能，因此被广泛应用于分布式系统和微服务架构中。</p>
<p>RPC:可以基于thrift实现高效的二进制传输</p>
<p>HTTP:大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</p>
<p>总的来说，HTTP协议适合于简单的请求-响应场景，而RPC协议适合于更复杂的分布式系统场景。当需要在分布式系统中进行服务调用时，RPC协议可以提供更好的性能、可靠性和扩展性。</p>
<hr>
<h5 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h5><p>Http协议运行在TCP之上，明文传输；Https是身披SSL外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>1）Http端口号80, Https是443</p>
<p>2）Https由于加解密处理消耗更多的CPU和内存资源</p>
<p>3）Https通信需要证书，而证书一般需要向认证机构购买 </p>
<p>4）Https的加密机制是一种结合对称加密和非对称加密的混合加密机制</p>
<hr>
<h5 id="❤️HTTPS握手步骤"><a href="#❤️HTTPS握手步骤" class="headerlink" title="❤️HTTPS握手步骤"></a>❤️HTTPS握手步骤</h5><ol>
<li>客户端向服务器发出HTTPS连接请求。</li>
<li>服务器将自己的<strong>数字证书（含公钥）</strong>发送给客户端。</li>
<li>客户端验证证书的有效性。如验证通过，则客户端使用服务器证书中的公钥来生成一个随机密钥</li>
<li>客户端将生成的随机密钥用服务器证书中的公钥进行加密, 然后发送给服务器。</li>
<li>服务器使用自己的私钥解密客户端发送过来的随机密钥。</li>
<li>客户端和服务器使用该随机密钥进行加密和解密,  从而保证HTTPS通信的安全性。</li>
</ol>
<hr>
<h5 id="⚠️对称加密与非对称加密"><a href="#⚠️对称加密与非对称加密" class="headerlink" title="⚠️对称加密与非对称加密"></a>⚠️对称加密与非对称加密</h5><ul>
<li><p>对称加密是指加密和解密使用同一个密钥的方式</p>
</li>
<li><p>非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送方使用对方的公钥进行加密处理，接收方接收到加密信息后，使用自己的私钥进行解密。</p>
</li>
</ul>
<p>由于非对称加密的方式不需要发送用来解密的私钥, 所以可以保证安全性, 但是慢; 所以我们还是要用对称加密来传送消息, 对称加密所使用的密钥我们可以通过非对称加密的方式发送出去</p>
<hr>
<h5 id="⚠️HTTP1-x-和-HTTP2-0-的区别"><a href="#⚠️HTTP1-x-和-HTTP2-0-的区别" class="headerlink" title="⚠️HTTP1.x 和 HTTP2.0 的区别"></a>⚠️HTTP1.x 和 HTTP2.0 的区别</h5><ul>
<li>二进制格式：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</li>
<li>多路复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面</li>
<li>头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小</li>
</ul>
<hr>
<h5 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h5><p><strong>是一种基于 TCP 的协议，在客户端和服务器之间建立双向通信的通道，是长连接，可以在不需要刷新页面或进行轮询的情况下实时传输数据。</strong>客户端和服务器就可以通过该连接进行实时通信。</p>
<p>此外，WebSocket 协议的数据传输是二进制的，传输效率更高，而且支持跨域通信，可以在不同的域名和端口之间建立连接。</p>
<p>WebSocket 协议的使用场景非常广泛，例如在线聊天室、多人游戏、实时数据传输等。可以使用 WebSocket API 在客户端和服务器之间建立 WebSocket 连接，从而实现实时通信的功能。</p>
<hr>
<h6 id="WebSocket-API-有哪些"><a href="#WebSocket-API-有哪些" class="headerlink" title="WebSocket API 有哪些"></a>WebSocket API 有哪些</h6><ol>
<li><p><code>WebSocket</code> 对象：WebSocket API 的核心对象，用于创建 WebSocket 连接、发送和接收数据。</p>
</li>
<li><p><code>onopen</code> 事件：WebSocket 连接成功建立时触发的事件</p>
</li>
<li><p><code>onmessage</code> 事件：接收到 WebSocket 数据时触发的事件</p>
</li>
<li><p><code>onclose</code> 事件：WebSocket 连接关闭时触发的事件</p>
</li>
<li><p><code>onerror</code> 事件：WebSocket 出错时触发的事件</p>
</li>
<li><p><code>send()</code> 方法：用于向 WebSocket 服务器发送数据</p>
</li>
<li><p><code>close()</code> 方法：用于关闭 WebSocket 连接</p>
</li>
</ol>
<hr>
<h6 id="C-中如何实现websocket协议"><a href="#C-中如何实现websocket协议" class="headerlink" title="C++中如何实现websocket协议"></a>C++中如何实现websocket协议</h6><p>在 C++ 中实现 WebSocket 协议，通常需要使用一个第三方库来处理 WebSocket 的底层协议。以下是一些常用的 C++ WebSocket 库</p>
<ol>
<li>libwebsockets：一个小型、轻量级的 C 语言库，用于实现 WebSockets 协议和 HTTP 协议。</li>
<li>WebSocket++：一个基于 Asio 的 I&#x2F;O  C++ WebSocket 库，支持客户端和服务器端的 WebSocket 连接。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是使用 WebSocket++ 库在 C++ 中实现 WebSocket 服务器的示例代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/config/asio_no_tls.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/server.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> websocketpp::server&lt;websocketpp::config::asio&gt; server;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_message</span><span class="params">(server* s, websocketpp::connection_hdl hdl, server::message_ptr msg)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">get_payload</span>() &lt;&lt; std::endl;</span><br><span class="line">  s-&gt;<span class="built_in">send</span>(hdl, msg-&gt;<span class="built_in">get_payload</span>(), msg-&gt;<span class="built_in">get_opcode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  server echo_server;</span><br><span class="line">  echo_server.<span class="built_in">set_message_handler</span>(&amp;on_message);</span><br><span class="line">  echo_server.<span class="built_in">init_asio</span>();</span><br><span class="line">  echo_server.<span class="built_in">listen</span>(<span class="number">9002</span>);</span><br><span class="line">  echo_server.<span class="built_in">start_accept</span>();</span><br><span class="line">  echo_server.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，使用 WebSocket++ 库创建一个 WebSocket 服务器，监听端口号 9002，并在收到消息时打印消息内容。使用 <code>init_asio()</code> 方法初始化 Asio I&#x2F;O 系统，使用 <code>start_accept()</code> 方法开始接收连接请求，使用 <code>run()</code> 方法等待连接和消息。</p>
<hr>
<h6 id="HTTP-协议和-websocket-协议的区别"><a href="#HTTP-协议和-websocket-协议的区别" class="headerlink" title="HTTP 协议和 websocket 协议的区别"></a>HTTP 协议和 websocket 协议的区别</h6><p>HTTP协议和WebSocket协议都是应用层协议，但是它们有一些重要的区别。</p>
<ol>
<li>连接方式： HTTP协议是一种请求-响应协议，客户端发送请求给服务器端，服务器端响应请求，然后断开连接。这种连接方式被称为”短连接”。而WebSocket协议是一种全双工协议，客户端和服务器端之间可以保持长时间的连接，并且可以在任何时间发送数据。这种连接方式被称为”长连接”。</li>
<li>数据格式： <strong>HTTP协议传输的数据格式是纯文本格式，通常使用JSON或XML格式。</strong>而WebSocket协议可以传输任何格式的数据，例如二进制数据、文本数据等。</li>
<li>性能： HTTP协议每次请求都需要重新建立连接，这会带来额外的延迟。而WebSocket协议可以在一次连接中传输多个请求和响应，从而可以提高传输效率和性能。</li>
<li>安全性： HTTP协议的安全性较低，通常需要使用SSL协议来加密数据。而WebSocket协议可以在建立连接时使用SSL协议进行加密，从而保证传输的数据安全。</li>
</ol>
<p>总的来说，WebSocket协议比HTTP协议更适合实时通信和数据传输。但是由于WebSocket协议相对于HTTP协议较新，支持程度和兼容性有时可能存在问题</p>
<hr>
<h5 id="说说ARP协议"><a href="#说说ARP协议" class="headerlink" title="说说ARP协议"></a>说说ARP协议</h5><p>ARP是根据IP地址获取其物理地址的协议</p>
<p>工作原理：</p>
<p>源主机在向目标主机发送IP包前，通过广播ARP请求包， 若源主机不知道目标主机的MAC地址，源主机就会广播一个ARP请求包，请求包中有目标主机的IP，以太网中的所有计算机都会接受到这个请求，而正常情况下只有目标主机会给出ARP应答包，包中就填充上了目标主机的MAC地址，并回复给源主机。源主机得到应答后将目标主机的MAC地址存入本机ARP高速缓存中以便下次使用</p>
<hr>
<h5 id="说说NAT协议"><a href="#说说NAT协议" class="headerlink" title="说说NAT协议"></a>说说NAT协议</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183418866.png" alt="image-20230301183418866" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183448058.png" alt="image-20230301183448058" style="zoom:50%;">

<hr>
<h5 id="Session、Cookie"><a href="#Session、Cookie" class="headerlink" title="Session、Cookie"></a>Session、Cookie</h5><p>同：Cookie和Session都是客户端与服务器之间保持状态的解决方案</p>
<p>不同：</p>
<p>1）cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>2）Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
<p>3）Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全</p>
<hr>
<h5 id="⚠️国内访问不了谷歌的技术原因"><a href="#⚠️国内访问不了谷歌的技术原因" class="headerlink" title="⚠️国内访问不了谷歌的技术原因"></a>⚠️国内访问不了谷歌的技术原因</h5><ol>
<li><p><strong>IP封锁</strong>：IP封锁是一种网络安全措施，用于阻止某个特定的IP地址或一组IP地址访问某个网站或网络资源。封锁可以通过防火墙、路由器或其他网络设备进行实现。</p>
<blockquote>
<p>  IP封锁通常用于以下情况：</p>
<p>  防止恶意攻击或滥用服务：当网络管理员检测到某个IP地址正在进行恶意攻击，可以将该IP地址封锁以防止攻击者继续攻击</p>
</blockquote>
<blockquote>
<p>  要进行IP封锁，可以使用以下方法：</p>
<ol>
<li>防火墙：网络管理员可以使用防火墙来封锁特定的IP地址。防火墙可以根据规则集或白名单&#x2F;黑名单来进行配置，以阻止或允许特定的IP地址或IP地址范围的访问。</li>
<li>路由器：网络管理员可以使用路由器来封锁特定的IP地址。路由器可以使用访问控制列表（ACL）来限制特定的IP地址或IP地址范围的访问。</li>
</ol>
</blockquote>
</li>
<li><p><strong>DNS劫持</strong>：在中国，政府使用DNS劫持来屏蔽谷歌等国外网站。当用户输入被屏蔽的网站的域名时，政府会将其DNS解析请求重定向到另一个地址，通常是一个被政府控制的服务器，而不是实际的DNS服务器。这意味着用户将无法访问被屏蔽的网站，因为他们的计算机将连接到错误的服务器，而不是正确的目标网站。</p>
</li>
</ol>
<hr>
<h5 id="⚠️国内可以通过什么技术手段访问谷歌"><a href="#⚠️国内可以通过什么技术手段访问谷歌" class="headerlink" title="⚠️国内可以通过什么技术手段访问谷歌"></a>⚠️国内可以通过什么技术手段访问谷歌</h5><p>(简单来说 VPN就是更安全的正向代理)</p>
<ol>
<li>虚拟私人网络（VPN）：VPN 的工作原理是建立一个加密通道，在这个加密通道中，数据被加密并封装在一个特定的协议中，这个协议可以保证数据的完整性和机密性。可以避免网络上的拦截、监视、截获和篡改等安全问题</li>
<li>正向代理服务器：代理服务器是一种充当中间人的服务器，它会将用户的互联网请求转发到目标网站，从而帮助用户绕过封锁。用户可以在互联网上找到许多公开的代理服务器，或者使用自己的私人代理服务器，以访问被屏蔽的谷歌网站。</li>
</ol>
<hr>
<h5 id="防火墙的原理"><a href="#防火墙的原理" class="headerlink" title="防火墙的原理"></a>防火墙的原理</h5><p>防火墙是一种网络安全设备，它可以监控和控制网络通信，以保护计算机网络免受恶意攻击和未经授权的访问。防火墙通常作为一个网络边界设备，位于内部网络和外部网络之间。</p>
<p>防火墙的原理基于路由器访问控制列表（ACL），它可以允许或拒绝网络流量通过特定端口和协议。当流量进入防火墙时，它会根据预定义的规则来决定是否允许流量通过。如果流量满足规则，则它会被允许通过防火墙，否则它会被阻止或丢弃。</p>
<p>总的来说，防火墙通过监控和控制网络流量来保护网络免受恶意攻击和未经授权的访问。</p>
<hr>
<h5 id="⚠️运营商给用户限速的类型和原理"><a href="#⚠️运营商给用户限速的类型和原理" class="headerlink" title="⚠️运营商给用户限速的类型和原理"></a>⚠️运营商给用户限速的类型和原理</h5><p>带宽限制(限制用户每秒钟可以传输的数据量)、时间限制、流量限制、服务限制</p>
<p><strong>限速的底层原理</strong></p>
<ol>
<li>在路由器上设置流量控制算法：运营商会在核心路由器或边缘路由器上设置流量控制算法，根据用户的套餐类型、用量等因素进行流量控制。</li>
<li>调度算法：运营商通过调度算法来控制网络资源的分配，以保证整个网络的公平性和平衡性。常见的调度算法包括最小带宽保证、公平队列调度、公平带宽分配</li>
<li>数据包标记：运营商还可以通过给数据包打上不同的标记，实现不同的服务质量级别。例如，将数据包标记为低优先级的，就会被放入低优先级队列中，从而减少其处理优先级，达到限速的效果。</li>
<li>限速设备：运营商在网络中还可以设置专门的限速设备，例如调度器、速率控制器等，通过对数据包进行筛选和处理，实现对用户网速的限制</li>
</ol>
<hr>
<h5 id="⚠️常见的流量控制算法"><a href="#⚠️常见的流量控制算法" class="headerlink" title="⚠️常见的流量控制算法"></a>⚠️常见的流量控制算法</h5><ol>
<li><p><strong>漏桶（水漏的速度是接口的响应速率）：</strong>水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率，（因为漏桶的漏出速率是固定的参数，所以，即使网络中不存在资源冲突(没有发生拥塞)，漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率</p>
</li>
<li><p><strong>令牌桶算法（加令牌的的速度是接口的响应速率）</strong>：和漏桶效果一样但方向相反的算法，更加容易理解。随着时间流逝，系统会按恒定时间间隔往桶里加入Token(想象和漏洞漏水相反，有个水龙头在不断的加水)，如果桶已经满了就不再加了，新请求来临时，会各自拿走一个Token，如果没有Token可拿了就阻塞或者拒绝服务。令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量。</p>
</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/1011415-20170701192633914-1313517581-20230303141645878.jpg" alt="img"></p>
<h3 id="3️⃣数据库-5-21"><a href="#3️⃣数据库-5-21" class="headerlink" title="3️⃣数据库  5.21"></a>3️⃣数据库  5.21</h3><h4 id="存储引擎和存储结构"><a href="#存储引擎和存储结构" class="headerlink" title="存储引擎和存储结构"></a>存储引擎和存储结构</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>存储引擎存储的是数据文件和索引文件</p>
<p>我们把索引文件的组织形式称为存储引擎的存储结构</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408103355270.png" alt="image-20230408103355270" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408103757831.png" alt="image-20230408103757831" style="zoom:50%;">

<p>索引组织表直接把数据记录存储在索引文件内部</p>
<p>堆组织表的数据文件是无序的,但我们可以通过索引文件来快速得到数据文件在堆里的位置</p>
<blockquote>
<p>  堆组织表的写入性能 &gt; 索引组织表, 读取性能 &lt; 索引组织表</p>
<p>  但这种区分较小,远不如索引文件的的组织形式对性能的影响大</p>
</blockquote>
<hr>
<h5 id="⚠️堆表和索引组织表"><a href="#⚠️堆表和索引组织表" class="headerlink" title="⚠️堆表和索引组织表"></a>⚠️堆表和索引组织表</h5><p> ① 堆组织表，其索引中记录了记录所在位置 (文件号：页号：槽号)，查找的时候先找索引，然后再根据索引找到块中的行数据。索引和表数据是分离的</p>
<p> ② 索引组织表，其行数据以索引形式存放，因此找到索引，就等于找到了行数据。索引和数据是在一起的</p>
<p>堆表是一种数据库表的存储方式，它将新插入的行直接插入到表的末尾，而不像传统的B树索引那样插入到合适的位置。这使得插入操作更快，因为不需要寻找正确的位置进行插入，而是直接将数据追加到表的末尾，然后使用一个指针来指向该行。</p>
<p>HOT的优点是：</p>
<ol>
<li>快速的插入操作：由于新数据不需要寻找合适的位置，直接追加到表末尾，因此插入操作速度很快。</li>
<li>避免索引分裂：当表中的数据通过插入或删除操作引起页分裂时，B树索引需要进行数据重组，而HOT则避免了这种情况的发生。</li>
<li>适合高并发：由于插入操作的快速性和避免索引分裂的特点，HOT适合于高并发的应用场景。</li>
</ol>
<p>HOT的缺点是：</p>
<ol>
<li>读取操作效率较低：由于数据是随机存储的，因此读取操作需要扫描整个表，效率较低。</li>
<li>不支持有序查询：HOT不支持有序的查询，因为数据是随机存储的，因此必须扫描整个表才能得到有序的结果。</li>
</ol>
<hr>
<h5 id="⚠️聚集索引和非聚集索引的区别"><a href="#⚠️聚集索引和非聚集索引的区别" class="headerlink" title="⚠️聚集索引和非聚集索引的区别"></a>⚠️聚集索引和非聚集索引的区别</h5><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p>
<ul>
<li><p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</p>
</li>
<li><p>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</p>
</li>
<li><p>聚集索引：物理存储按照索引排序；</p>
<p>非聚集索引：物理存储不按照索引排序；仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序</p>
</li>
<li><p>索引是通过B+树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，指向对应的聚集索引&#x2F; 物理地址（有缓存的情况才有）。</p>
</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230415124213113.png" alt="image-20230415124213113"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230415124310204.png" alt="image-20230415124310204"></p>
<p>需要注意的是，如果查询的列都在非聚集索引中，那么数据库就不需要回表操作，而可以直接从非聚集索引中获取需要的数据。这被称为“覆盖索引”，可以提高查询的性能，减少回表操作的开销。但是，覆盖索引的缺点是需要占用更多的存储空间</p>
<hr>
<h5 id="存储结构分类和发展"><a href="#存储结构分类和发展" class="headerlink" title="存储结构分类和发展"></a>存储结构分类和发展</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408105440294.png" alt="image-20230408105440294"></p>
<p>2014年左右随着SSD固态硬盘的普及,LSM变得更流行,原因有二,一是SSD的随机读省去了在磁盘上的寻道时间,二是SSD由闪存实现,LSM特性保证了不用每次写入时擦除,延长了SSD使用寿命</p>
<h5 id="存储结构的共性特点"><a href="#存储结构的共性特点" class="headerlink" title="存储结构的共性特点"></a>存储结构的共性特点</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408110247633.png" alt="image-20230408110247633"></p>
<h5 id="存储结构的锁与事物的锁有什么不同"><a href="#存储结构的锁与事物的锁有什么不同" class="headerlink" title="存储结构的锁与事物的锁有什么不同"></a>存储结构的锁与事物的锁有什么不同</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408110921178.png" alt="image-20230408110921178"></p>
<p>Latch在B+树中锁一个页,Lock锁一行,但是Lock不能省的原因就是可能对页的修改结束了,但事务还没结束</p>
<h5 id="B树的变种"><a href="#B树的变种" class="headerlink" title="B树的变种"></a>B树的变种</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408111425752.png" alt="image-20230408111425752"></p>
<h5 id="LSM树结构图"><a href="#LSM树结构图" class="headerlink" title="LSM树结构图"></a>LSM树结构图</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408111639335.png" alt="image-20230408111639335" style="zoom:50%;">

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408112035495.png" alt="image-20230408112035495"></p>
<p>目前主流的LSMTree结构图</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408112241808.png" alt="image-20230408112241808"></p>
<h5 id="布隆过滤器-LSM中读取时快速判断key在不在该层中"><a href="#布隆过滤器-LSM中读取时快速判断key在不在该层中" class="headerlink" title="布隆过滤器(LSM中读取时快速判断key在不在该层中)"></a>布隆过滤器(LSM中读取时快速判断key在不在该层中)</h5><p>布隆过滤器的基本思想是使用多个哈希函数对元素进行哈希，并将哈希结果对应到一个位数组中的相应位置，用于表示该元素的存在或不存在。其实现步骤如下：</p>
<ol>
<li>初始化一个位数组，将所有位都设置为0。</li>
<li>对于要加入集合的元素，使用多个不同的哈希函数对其进行哈希，得到多个哈希值。</li>
<li>将每个哈希值对应的位数组位置设置为1，表示该元素存在于集合中。</li>
</ol>
<p>当要查询某个元素是否在集合中时，同样使用多个哈希函数对该元素进行哈希，得到多个哈希值。</p>
<p>判断每个哈希值对应的位数组位置是否都为1，如果存在任意一个位置为0，则表示该元素不在集合中，否则可能存在该元素（注意：可能存在）。可能存在误判，即一个元素可能被判断为存在于集合中，但实际上并不存在。</p>
<h4 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h4><hr>
<h5 id="MySQL体系架构"><a href="#MySQL体系架构" class="headerlink" title="MySQL体系架构"></a>MySQL体系架构</h5><p>网络连接层、服务层、存储引擎层和系统文件层</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218115419272.png" alt="image-20230218115419272" style="zoom: 33%;">

<p><strong>一、网络连接层</strong></p>
<p>客户端连接器：提供与MySQL服务器建立连接的支持。如 Java&#x2F;C通过各自API与MySQL建立连接</p>
<p><strong>二、服务层</strong></p>
<p>服务层是MySQL Server的核心，主要包含六个部分</p>
<ul>
<li><p><strong>系统管理和控制工具：</strong>例如备份恢复、安全管理、集群管理【集群就是指一组相互独立的计算机，利用网络组成的一个较大的计算机服务系统，每个集群节点（即每台计算机）都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序，系统资源和数据，并以单一系统的模式加以管理。当用户请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器】</p>
</li>
<li><p><strong>连接池</strong>：负责存储和管理客户端与数据库服务器的连接，一个线程负责管理一个连接</p>
</li>
<li><p><strong>SQL接口：</strong>用于接收客户端发送的各种SQL命令，并且返回用户需要的查询结果</p>
</li>
<li><p><strong>解析器：</strong>负责检查请求的SQL语句的合法性</p>
</li>
<li><p><strong>查询优化器：</strong>当解析树通过语法检查后，将交由优化器将其转化为执行计划，然后与存储引擎交互</p>
</li>
<li><p><strong>缓存：</strong>缓存机制是由表缓存，记录缓存，权限缓存，引擎缓存组成。如果查询语句有命中的结果，则直接在查询缓冲中取数据</p>
</li>
</ul>
<p><strong>三、存储引擎层</strong></p>
<p><strong>负责MySQL中的数据存储和提取，与底层系统文件交互。</strong>服务器中的查询执行引擎通过接口和存储引擎进项通信，接口屏蔽了不同存储引擎的差异</p>
<p><strong>四、系统文件层</strong></p>
<p>负责将数据库的数据和日志存储在文件系统中，并完成与存储引擎的交互，是文件的物理存储层。主要包括日志文件，数据文件，配置文件，socket文件等</p>
<hr>
<h5 id="SQL语句运行机制"><a href="#SQL语句运行机制" class="headerlink" title="SQL语句运行机制"></a>SQL语句运行机制</h5><p><strong>①建立连接</strong>：通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么</p>
<p><strong>②查询缓存：</strong>如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询缓存或者没有查询到SQL 语句则会由解析器进行语法语义解析</p>
<p><strong>③解析：</strong>将客户端发送的SQL进行语法解析。</p>
<p><strong>④查询优化：</strong>根据解析结果生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）</p>
<p><strong>⑤执行引擎执行 SQL 语句：</strong>此时执行引擎会根据 SQL 语句得到查询结果并返回给客户端。若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存中</p>
<hr>
<h5 id="数据库事物特性-ACID"><a href="#数据库事物特性-ACID" class="headerlink" title="数据库事物特性(ACID)"></a>数据库事物特性(ACID)</h5><ul>
<li>原子性（Atomicity）指一个事务是不可分割的单位，要么全部执行，要么全部回滚；</li>
<li>一致性（Consistency）指一个事务在执行前和执行后都保持系统的一致性状态；</li>
<li>隔离性（Isolation）指一个事务的执行不会影响其他事务的执行；</li>
<li>持久性（Durability）指一个事务提交后，对数据的修改将永久保存在数据库中。</li>
</ul>
<hr>
<h5 id="数据库并发一致性问题：丢读不幻"><a href="#数据库并发一致性问题：丢读不幻" class="headerlink" title="数据库并发一致性问题：丢读不幻"></a>数据库并发一致性问题：丢读不幻</h5><p>​	  丢 (丢失修改) 	读(读脏数据)  	不(不可重复读)【一次事务内的两次读数值不同】	幻(幻影读)</p>
<ul>
<li>丢失修改：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失</li>
<li>读脏数据：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。</li>
<li>幻读与不可重复读类似。它发生在<strong>一个</strong>事务（T1）读取了<strong>几行数据</strong>，接着<strong>另一个</strong>并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<hr>
<h5 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h5><p><strong>快照读：普通的 select 语句</strong></p>
<p>它是基于多版本并发控制即 MVCC机制，快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p>
<p>如下的操作是快照读：不加锁的 select 操作（前提是隔离级别不是串行化，串行化的是当前读）</p>
<p><strong>当前读：能读到所有已经提交的记录的最新值</strong></p>
<p>它读取的记录都是数据库中当前的最新版本，会对当前读取的数据进行加锁，防止其他事务修改数据，是一种悲观锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> … <span class="keyword">for</span> <span class="keyword">update</span> # 当前读</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️两个事务并行提交一定会幻读吗"><a href="#⚠️两个事务并行提交一定会幻读吗" class="headerlink" title="⚠️两个事务并行提交一定会幻读吗"></a>⚠️两个事务并行提交一定会幻读吗</h5><p>在RR(可重复读)隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的</p>
<p><strong>因此，幻读在“当前读”下才会出现。</strong></p>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 引入了新的锁，也就是间隙锁 (Gap Lock)</p>
<p>间隙锁就是，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体</p>
<hr>
<h5 id="说下mysql死锁"><a href="#说下mysql死锁" class="headerlink" title="说下mysql死锁"></a>说下mysql死锁</h5><p>假设有一个名为“accounts”的表，其中包含两个字段“id”和“balance”，并且有两个事务在同时更新“accounts”表中的行</p>
<ul>
<li>事务1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>事务2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，可以在两个事务中按照相同的顺序获取锁定资源，例如，都先锁定id&#x3D;1的行再锁定id&#x3D;2的行。或者可以使用MySQL的死锁检测机制，自动选择其中一个事务回滚，以解除死锁</p>
<hr>
<h5 id="数据库锁类型"><a href="#数据库锁类型" class="headerlink" title="数据库锁类型"></a>数据库锁类型</h5><ol>
<li><strong>表级锁</strong></li>
</ol>
<p>（1）锁定粒度大，锁冲突概率高、并发度低</p>
<p>（2）好处是不会出现死锁、开销小、获取锁和释放锁的速度很快</p>
<p>（3）使用表级锁定的主要是MyISAM等一些非事务性存储引擎，适用于以查询为主，少量更新的应用</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230219191007830.png" alt="image-20230219191007830"></p>
<blockquote>
<p>  意向锁：加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。（防止另一个事务逐行判断是否加锁）是InnoDB自动加的，不需用户干预。意向锁不会与行级的读&#x2F;写锁互斥</p>
</blockquote>
<ol start="2">
<li><strong>行级锁</strong></li>
</ol>
<p>（1）好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；</p>
<p>（2）缺点是开销大、加锁慢，行级锁容易发生死锁；</p>
<p>（3）使用行级锁定的主要是InnoDB存储引擎。适用于对事务完整性要求较高的系统</p>
<blockquote>
<p>  InnoDB行级锁类型：读锁、写锁</p>
</blockquote>
<ol start="3">
<li><strong>页面锁</strong></li>
</ol>
<p>（1）介于行级锁和表级锁之间</p>
<p>（2）会发生死锁</p>
<hr>
<h5 id="关于锁的常见问题"><a href="#关于锁的常见问题" class="headerlink" title="关于锁的常见问题"></a>关于锁的常见问题</h5><ol>
<li>InnoDB存储引擎什么时候会锁住整张表，什么时候或只锁住一行呢？</li>
</ol>
<p><strong>只有通过索引条件查询数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong></p>
<ol start="2">
<li>mysql读锁和写锁</li>
</ol>
<p>用select 命令时触发读锁，当使用update,delete,insert时触发写锁，并且使用rollback或commit后解除本次锁定</p>
<ol start="3">
<li>InnoDB行锁的3种算法：</li>
</ol>
<p>Record Lock： 锁定单个索引记录</p>
<p>Gap Lock ：锁定一个范围，但不包含记录本身</p>
<p>Next-Key Lock：锁定一个范围，并且锁定记录本身</p>
<p><strong>所以 Next-KeyLocks &#x3D; Gap锁+ Recordlock锁</strong></p>
<blockquote>
<p>  Next-Key Locks是 MySQL 的 InnoDB 引擎的一种锁实现。MVCC (多版本的并发控制协议。最大的优点是读不加锁，因此读写不冲突，并发性能好)不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
</blockquote>
<hr>
<h5 id="数据库封锁协议"><a href="#数据库封锁协议" class="headerlink" title="数据库封锁协议"></a>数据库封锁协议</h5><ol>
<li>三级封锁协议(一级:写前加X	 	二级:写前加X读前加S,读完释放 	   三级:写前加X读前加,S锁事务结束释放)	  </li>
<li>两段锁协议(加锁与解锁串行)</li>
</ol>
<hr>
<h5 id="数据库隔离级别：未-提-可-可"><a href="#数据库隔离级别：未-提-可-可" class="headerlink" title="数据库隔离级别：未 提 可 可"></a>数据库隔离级别：未 提 可 可</h5><p>1、读未提交：顾名思义，就是一个事务可以读取另一个未提交事务的数据</p>
<p>2、读已提交：一个事务要等另一个事务提交后才能读取数据</p>
<p>3、可重复读： 在开始读取数据（事务开启）时，不再允许该行的修改操作</p>
<p>4、串行化：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，一般不使用</p>
<p><strong>并行性依次降低，安全性依次提高</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png" alt="image-20230129192103478"></p>
<hr>
<h5 id="1NF-2NF-3NF-BCNF"><a href="#1NF-2NF-3NF-BCNF" class="headerlink" title="1NF	 		2NF		 3NF 		BCNF"></a>1NF	 		2NF		 3NF 		BCNF</h5><p>对于 A-&gt;B(A推出B)，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p>
<p>A-&gt;B: B依赖于A</p>
<p>第一范式（1NF）:确保每个列都具有原子性，即每个列中都只包含单一的、不可分割的数据项</p>
<p>第二范式（2NF）:在满足1NF的基础上，确保每个非主键列都完全依赖于全部主键，而不是仅依赖于主键的一部分</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230413593.png" alt="image-20230323230413593"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230323230607279.png" alt="image-20230323230607279"></p>
<p><strong>BCNF：</strong>设关系模式R是1NF。如果对于R的每个函数依赖X-&gt;Y，X必为候选键，则R是BCNF范式。</p>
<hr>
<h5 id="超键-候选键-主键"><a href="#超键-候选键-主键" class="headerlink" title="超键, 候选键, 主键"></a>超键, 候选键, 主键</h5><p>**超键(super key): **在关系中能唯一标识元组的属性集称为关系模式的超键<br><strong>候选键(candidate key):</strong> 不含有多余属性的超键称为候选键<br>**主键(primary key): **用户选作元组标识的一个候选键 </p>
<hr>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><h6 id="什么是索引？优缺点？"><a href="#什么是索引？优缺点？" class="headerlink" title="什么是索引？优缺点？"></a>什么是索引？优缺点？</h6><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。</p>
<p>它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的 数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。</p>
<p>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小</p>
<hr>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><strong>普通索引：</strong></p>
<p>普通索引是mysql里最基本的索引，没有什么特殊性，在任何一列上都能进行创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure>

<p><strong>主键索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  age <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>复合索引(组合索引)：</strong></p>
<p>指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引</p>
<p>复合索引的使用复合最左原则。举个例子 我们使用 phone和name创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(column1,column2);</span><br></pre></td></tr></table></figure>

<p>我们看下面的查询语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段才能够进行匹配。而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。</p>
<p><strong>全文索引：</strong></p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。</p>
<p>它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。正常情况下我们也不会使用到全文索引，因为这不是mysql的专长。</p>
<p><strong>空间索引：</strong></p>
<p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>创建空间索引的列必须声明为NOT NULL，只能在存储引擎为MYISAM的表中创建。</p>
<hr>
<h6 id="如何创建及保存MySQL的索引？"><a href="#如何创建及保存MySQL的索引？" class="headerlink" title="如何创建及保存MySQL的索引？"></a>如何创建及保存MySQL的索引？</h6><p>在创建表的时候创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX UniqIdx(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在已存在的表上创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在已经存在的表中创建索引，可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句或者<span class="keyword">CREATE</span> INDEX语句。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx (bookId);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx <span class="keyword">ON</span> book (bookId);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="如何判断索引有没有生效？"><a href="#如何判断索引有没有生效？" class="headerlink" title="如何判断索引有没有生效？"></a>如何判断索引有没有生效？</h6><p>使用EXPLAIN语句, 假设已创建了book表, 并已经在其year_publication字段上建立了普通索引, 执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication = 1990; </span><br></pre></td></tr></table></figure>

<p>EXPLAIN语句将为我们输出详细的SQL执行信息, 其中：</p>
<ul>
<li>possible_keys行给出了MySQL在查询时可选用的各个索引。</li>
<li>key行是MySQL实际选用的索引。</li>
</ul>
<p>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</p>
<hr>
<h6 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h6><p>MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN [EXTENDED] SELECT select_options</span><br></pre></td></tr></table></figure>

<p>使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：</p>
<ul>
<li>id：SELECT识别符。这是SELECT的查询序列号。</li>
<li>select_type：表示SELECT语句的类型。</li>
<li>table：表示查询的表。</li>
<li>type：表示表的连接类型。</li>
<li>possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key：是MySQL实际选用的索引。</li>
<li>key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。</li>
<li>ref：给出了关联关系中另一个数据表里的数据列名。</li>
<li>rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>Extra：提供了与关联操作有关的信息。</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h6><ol>
<li><p>优化索引的列宽：索引列的宽度越小，查询效率越高。因此，在创建索引时应该尽可能使用较短的列。</p>
</li>
<li><p>多列索引：要注意索引列的顺序，让选择性最强的索引列放在前面</p>
</li>
<li><p>前缀索引：例如下面 SQL 语句不能使用索引。select * from doc where title like ‘%XX’</p>
</li>
</ol>
<p>​		而非前导模糊查询则可以使用索引，如下面的 SQL 语句。select * from doc where title like ‘XX%’</p>
<ol start="4">
<li>覆盖索引：如果有一个查询包含了所有索引的列，我们称之为覆盖索引</li>
</ol>
<hr>
<h6 id="应该建立索引的条件"><a href="#应该建立索引的条件" class="headerlink" title="应该建立索引的条件"></a>应该建立索引的条件</h6><ol>
<li>在经常使用在 WHERE 子句中的列上面创建索引</li>
<li>在经常用在连接的列上, 这些列主要是一些外键</li>
<li>在经常需要根据范围进行搜索的列上创建索引</li>
<li>在经常需要排序的列上创建索引</li>
</ol>
<hr>
<h6 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h6><p>索引的优点</p>
<ol>
<li>通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度</li>
<li>可以加速表和表之间的连接</li>
<li>加快分组和排序</li>
</ol>
<p>索引的缺点</p>
<ol>
<li>索引有可能降低查询性能，带来磁盘的开销和处理开销等</li>
<li>太多的索引，让设计不稳定</li>
<li>不便维护</li>
<li>数据修改需求&gt;检索需求时，索引会降低性能</li>
</ol>
<hr>
<h6 id="索引的最左前缀问题"><a href="#索引的最左前缀问题" class="headerlink" title="索引的最左前缀问题"></a>索引的最左前缀问题</h6><p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<hr>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。   </li>
<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎放弃使用索引而进行全表扫描。</li>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’   </li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)   </li>
<li>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引2</li>
<li>多使用LIMIT 避免使用SELECT *</li>
</ol>
<hr>
<h5 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h5><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<hr>
<h5 id="⚠️InnoDB体系结构"><a href="#⚠️InnoDB体系结构" class="headerlink" title="⚠️InnoDB体系结构"></a>⚠️InnoDB体系结构</h5><p>innodb的体系架构由多个内存块组成的缓冲池及多个后台线程构成</p>
<p>缓冲池缓存磁盘数据（解决cpu速度和磁盘速度的严重不匹配问题）</p>
<p>后台进程保证缓存池和磁盘数据的一致性（读取、刷新），并保证数据异常宕机时能恢复到正常状态</p>
<p>缓冲池主要分为三个部分：redo <em>log buffer、innodb_buffer_pool、innodb_additional_mem_pool。</em></p>
<ul>
<li>innodb_buffer_pool由包含数据、索引、insert buffer ,adaptive hash index,lock 信息及数据字典。</li>
<li>redo log buffer用来缓存重做日志</li>
<li>additional memory pool:用来缓存LRU链表、等待、锁等数据结构</li>
</ul>
<p>后台进程分为：master thread，IO thread，purge thread，page cleaner thread</p>
<ul>
<li>master thread负责刷新缓存数据到磁盘并协调调度其它后台进程</li>
<li>IO thread 分为 insert buffer、log、read、write进程。分别用来处理insert buffer、重做日志、读写请求的IO回调</li>
<li>purge thread用来回收undo 页</li>
<li>page cleaner thread用来刷新脏页</li>
</ul>
<p>master thread根据服务器的压力分为了每一秒及每十秒的操作。每一秒的操作包括：刷新重做日志、根据过去一秒的磁盘吞吐量来判断是否需要merge insert buffer、根据脏页在缓冲池中占比是否超过最大脏页占比及是否开启自适应刷新来刷新脏页。每十秒的操作包括：根据过去10秒的磁盘吞吐量来刷新脏页，刷新重做日志，回收undo 页，再根据脏页占比是否超过70%刷新定量脏页</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218122345750.png" alt="image-20230218122345750" style="zoom:50%;">

<hr>
<h5 id="⚠️说说-InnoDB-的-MVCC"><a href="#⚠️说说-InnoDB-的-MVCC" class="headerlink" title="⚠️说说 InnoDB 的 MVCC"></a>⚠️说说 InnoDB 的 MVCC</h5><p>InnoDB默认的隔离级别是RR，RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。</p>
<p>MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构： </p>
<ol>
<li>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log（可以实现事务的回滚操作）的指针</li>
<li>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，形成一条版本链</li>
<li>ReadView：用于确定事务能够看到哪些行版本。当一个事务开始时，它会创建一个ReadView，该ReadView会记录事务开始时所有活跃事务的事务ID以及它们创建或删除每行数据的版本号。如果该行某版本的事务ID &lt;&#x3D; ReadView中的最大事务ID，则该版本对于当前事务可见</li>
</ol>
<hr>
<h5 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h5><p>整数类型：TINY&#x2F;SMALL&#x2F;MEDIUM INT、INT、BIGINT</p>
<p>实数类型：FLOAT、DOUBLE、DECIMAL</p>
<p>字符串类型：CHAR、VARCHAR、TEXT、BLOB</p>
<p>枚举类型：ENUM</p>
<p>日期与时间：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<hr>
<h5 id="⚠️主从复制"><a href="#⚠️主从复制" class="headerlink" title="⚠️主从复制"></a>⚠️主从复制</h5><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p>主从复制的优点：</p>
<blockquote>
<p>  <strong>读写分离</strong>: 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>  读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
</blockquote>
<hr>
<h5 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h5><p><strong>关系型</strong></p>
<p>主要是指创建在关系模型上的数据库，借助于集合代数数学概念和方法来处理数据库中的数据。</p>
<p>由关系数据结构、操作集合、完整性约束三部分组成</p>
<p><strong>—优点—</strong></p>
<p>1.事务处理—保持数据的一致性	2.可以进行Join等复杂查询	3.基于严格的数学</p>
<p><strong>—缺点—</strong></p>
<p>1.性能	2.纵向扩展	3.贵</p>
<p><strong>非关系型</strong></p>
<p>—优点—</p>
<ol>
<li><p>简单的扩展（集群）</p>
</li>
<li><p>高性能（它们可以处理超大量的数据）：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作;</p>
</li>
<li><p>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本;</p>
</li>
<li><p>灵活的数据模型。不需要事先对存储数据建立字段。</p>
</li>
</ol>
<p>—缺点—</p>
<ol>
<li>不支持SQL的工业标准，将会对用户产生一定的学习和应用迁移成本;</li>
<li>不支持事务，很难保证数据一致性</li>
<li>不能支持比较复杂的查询</li>
<li>NoSQL 并不完全安全稳定，由于它基于内存，一旦停电或者机器故障数据就很容易丢失数据，其持久化能力也是有限的，而基于磁盘的数据库则不会出现这样的问题</li>
</ol>
<hr>
<h5 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h5><p>实体完整性：指表中行记录的非空、唯一且不重复</p>
<p>域完整性：指表中的列必须满足某种数据类型或约束。CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL都属于域完整性的范畴</p>
<p>参照完整性：修改表，与之相关联的表也随之改变 不一致的处理方法：拒绝执行 、级联操作 、设置为空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">  customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (customer_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">  order_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (order_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个外键约束确保了数据的完整性，因为它防止在orders表中插入一个不存在于customers表中的顾客ID。</p>
<hr>
<h5 id="对表的外键构建索引的好处"><a href="#对表的外键构建索引的好处" class="headerlink" title="对表的外键构建索引的好处"></a>对表的外键构建索引的好处</h5><p>为确保安全，在对主表操作时，需要对参照表进行加锁操作。如果外键没有索引，查找子记录就会很慢，引起全表扫描。且参照表被锁的时间很长，进而可能发生死锁。</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409231715303.png" alt="image-20230409231715303"></p>
<p><strong>注：联合主键：就是用多个字段一起作为一张表的主键。</strong></p>
<hr>
<h5 id="一个好的模式分解具有哪些性质"><a href="#一个好的模式分解具有哪些性质" class="headerlink" title="一个好的模式分解具有哪些性质"></a>一个好的模式分解具有哪些性质</h5><p>无损连接和保持依赖</p>
<p>无损连接指的是对关系分解时，原关系模型中任意列能通过自然联接运算恢复起来。</p>
<p>保持函数依赖指的是对关系分解时，原关系的闭包与分解后关系闭包的并集相等。</p>
<hr>
<h5 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h5><p>视图是从几个表或视图导出的表。是一个虚表。</p>
<p>数据库中只存放视图的定义，而不存放视图对应的数据。</p>
<p>视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化</p>
<hr>
<h5 id="⚠️MySQL分区分表"><a href="#⚠️MySQL分区分表" class="headerlink" title="⚠️MySQL分区分表"></a>⚠️MySQL分区分表</h5><p>MySQL分区是将一个大表分解成更小、更易于管理的部分的过程。分区可以提高查询性能、减少锁定冲突和减轻磁盘I&#x2F;O负载。分区包括水平分区和垂直分区。水平分区将表中的行分成不同的分区，而垂直分区将表中的列分成不同的分区。</p>
<p>MySQL分表是将一个大表拆分成多个小表的过程。这种做法可以解决单表数据量过大、索引效率低下的问题。分表一般按照某个条件（例如日期、区域、用户ID等）将数据分散到不同的表中。</p>
<p>下面是MySQL进行分区分表的步骤：</p>
<ol>
<li>创建分区表：使用CREATE TABLE语句创建分区表。</li>
<li>选择分区键：选择一个或多个用于分区的列。</li>
<li>定义分区：使用PARTITION BY子句指定如何将表分区，例如按照日期或地理位置进行分区。</li>
<li>分配数据：将数据插入分区表中。MySQL会根据分区键的值将数据插入正确的分区。</li>
<li>管理分区：可以使用ALTER TABLE语句管理分区，例如添加或删除分区。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    region <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    country <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="type">date</span> <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id, <span class="type">date</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(<span class="type">date</span>)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2015</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2016</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码创建了一个名为sales的分区表，包含六个列，其中id和<span class="type">date</span>列被指定为主键。分区键使用了<span class="type">date</span>列，按照年份进行分区。一共定义了<span class="number">8</span>个分区，每个分区包含小于指定年份的数据。</span><br><span class="line"></span><br><span class="line"># 将数据插入分区表中，MySQL会根据分区键的值将数据插入正确的分区，例如：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales (region, country, product, <span class="type">date</span>, amount)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2018-01-01&#x27;</span>, <span class="number">1000</span>),</span><br><span class="line">       (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;Japan&#x27;</span>, <span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="number">2000</span>),</span><br><span class="line">       (<span class="string">&#x27;Europe&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;2020-03-01&#x27;</span>, <span class="number">3000</span>),</span><br><span class="line">       (<span class="string">&#x27;North America&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Tablet&#x27;</span>, <span class="string">&#x27;2021-04-01&#x27;</span>, <span class="number">4000</span>),</span><br><span class="line">       (<span class="string">&#x27;South America&#x27;</span>, <span class="string">&#x27;Brazil&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2022-05-01&#x27;</span>, <span class="number">5000</span>);</span><br><span class="line"># 上述代码将五条数据插入到sales表中，MySQL会将它们分别插入到不同的分区中。</span><br><span class="line"></span><br><span class="line"># 可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句管理分区，例如添加或删除分区。以下是添加新分区的示例代码：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码向sales表添加了一个新分区p8，包含小于<span class="number">2023</span>年的数据。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="delete、drop、-truncate区别"><a href="#delete、drop、-truncate区别" class="headerlink" title="delete、drop、 truncate区别"></a>delete、drop、 truncate区别</h5><ul>
<li>truncate和delete只删除数据，不删除表结构;drop删除表结构</li>
<li>删除数据的速度: drop &gt; truncate &gt; delete</li>
<li>delete属于DML语言，需要事务管理，commit之后才能生效; drop 和truncate属于DDL语言，操作立刻生效，不可回滚</li>
<li>使用场合:不再需要表时使用drop语句;保留表删除所有记录用truncate语句;删除部分记录用delete语句</li>
</ul>
<hr>
<h5 id="exists和in的区别"><a href="#exists和in的区别" class="headerlink" title="exists和in的区别"></a>exists和in的区别</h5><p>下面将主查询的表称为外表;子查询的表称为内表。exists与in的主要区别如下:</p>
<ul>
<li><p>使用exists, 会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据;      in,会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据</p>
</li>
<li><p>内表大，用exists 效率较高;内表小，用in效率较高。</p>
</li>
<li><p>not exists的效率一般要高于not in</p>
</li>
</ul>
<hr>
<h5 id="说说触发器"><a href="#说说触发器" class="headerlink" title="说说触发器"></a>说说触发器</h5><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码</p>
<p>MySQL数据库中有六种触发器:</p>
<ul>
<li><p>Before Insert</p>
</li>
<li><p>After Insert</p>
</li>
<li><p>Before Update</p>
</li>
<li><p>After Update</p>
</li>
<li><p>Before Delete</p>
</li>
<li><p>After Delete</p>
</li>
</ul>
<hr>
<h5 id="⚠️数据库（DDL，DML，DQL、DCL）"><a href="#⚠️数据库（DDL，DML，DQL、DCL）" class="headerlink" title="⚠️数据库（DDL，DML，DQL、DCL）"></a>⚠️数据库（DDL，DML，DQL、DCL）</h5><ol>
<li><p>数据查询语言DQL：SELECT…FROM…WHERE</p>
</li>
<li><p>数据管理语言DML [需事务管理]：INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据定义语言DDL [不需事务管理]</p>
<p>创建数据库中的各种对象—–表、视图、索引等 如：CREATE TABLE（表）&#x2F;VIEW（视图）&#x2F;INDEX（索引）</p>
</li>
<li><p>数据控制语言DCL：GRANT &#x2F; ROLLBACK &#x2F; COMMIT</p>
</li>
</ol>
<hr>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p><strong>使用关联多列索引时，跳过左边的右边的全部失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and c &#x3D; 3，索引a是最左边的，c是最右边的，而这里只写了a和c的条件，跳过了b,那b右边的c虽然写了条件c&#x3D;3但是查询的时候也用不上</p>
<p><strong>范围条件右边失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and b &gt; 2 and c &#x3D; 3，b是个范围条件，那么索引智能用到a和b，c是范围条件右边的内容，索引用不到</p>
<p>注意：a &#x3D; 1 and b &gt; 2 and c &#x3D; 3和a &#x3D; 1 and c &#x3D; 3 and b &gt; 2是一样的，a、b、c的顺序不是写sql条件时的顺序，而是建立索引时的顺序</p>
<p><strong>模糊查询like ‘%’在左边时失效</strong></p>
<p>例如:条件where name like ‘%a’,这里name这个索引时用不上的</p>
<p><strong>原理：</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230220214904180.png" alt="image-20230220214904180" style="zoom:50%;">

<hr>
<h5 id="B树-x2F-B-树"><a href="#B树-x2F-B-树" class="headerlink" title="B树&#x2F;B+树"></a>B树&#x2F;B+树</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182905354.png" alt="image-20230217182905354" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182934695.png" alt="image-20230217182934695" style="zoom:50%;">

<p>不同点：</p>
<ol>
<li>b树的叶子节点没有指针，b+树有，有指针可以更加方便范围查询，同一种范围查询，b树可能得多次从头节点开始遍历；</li>
<li>b树非叶子节点也存放数据，但是b+树只有叶子节点存放数据；</li>
<li>存放同样的数据，b树的高度可能比b+树要高。</li>
</ol>
<ul>
<li>B+树在B树中做了一个优化，因为每个磁盘块的大小都是有限的，如果在每个非叶子节点处都存放数据，那么每次获取到的磁盘块上的索引指针信息以及关键字信息将会很少，这样会增加我们的IO次数以及树结构的深度</li>
<li>B+树只在每个非叶子节点处只存放指针以及关键字信息，这样最大化的增加每个磁盘块存放的索引信息，可以更加有效的获取出相对应的地址信息，从而也降低了树结构的深度，而且叶子顶部节点允许互链减少了重新IO的次数</li>
<li>MYSQL引擎InnoDB就是按这种方式存放数据，存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</li>
</ul>
<hr>
<h5 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h5><p>首先，红黑树是一种近似平衡二叉树（不完全平衡），结点非黑即红的树，它的树高最高不会超过 2*log(n)，因此查找的时间复杂度为 O(log(n))，无论是增删改查，它的性能都十分稳定； </p>
<p>但是，红黑树本质还是二叉树，在数据量非常大时，需要访问+判断的节点数还是会比较多，同时数据是存在磁盘上的，访问需要进行磁盘IO，导致效率较低； 而B+树是多叉的，可以有效减少磁盘IO次数；同时B+树增加了叶子结点间的连接，能保证范围查询时找到起点和终点后快速取出需要的数据</p>
<hr>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230330220200112.png" alt="image-20230330220200112" style="zoom: 25%;">

<ol>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从任意一个节点到其子树中每个叶子节点的路径上包含相同数量的黑色节点（称为黑色平衡或黑高度）</li>
</ol>
<p>红黑树插入删除：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/475836398">链接</a></p>
<hr>
<h5 id="各种连接"><a href="#各种连接" class="headerlink" title="各种连接"></a>各种连接</h5><blockquote>
<p>  <strong>内连接：</strong>只连接匹配的行</p>
<p>  <strong>等值连接:</strong></p>
<p>  select A.c1,B.c2 from A join B on A.c3 &#x3D; B.c3;</p>
<p>  <strong>theta连接：</strong>使用等值以外的条件来匹配左、右两个表中的行</p>
<p>  select A.c1,B.c2 from A join B on A.c3 !&#x3D; B.c3;</p>
<p>  <strong>内连接 &#x3D; theta连接 or 等值连接</strong></p>
</blockquote>
<p><strong>自然连接</strong>：是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p>
<p><strong>左外连接：</strong>包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）以及右边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A left join B on A.c3 &#x3D; B.c3;</p>
<p><strong>右外连接：</strong>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）以及左边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A right join B on A.c3 &#x3D; B.c3;</p>
<p><strong>全外连接：</strong>包含左、右两个表的全部行，不管在另一边的表中是否存在与它们匹配的行</p>
<p>select A.c1,B.c2 from A full join B on A.c3 &#x3D; B.c3;</p>
<p><strong>交叉连接：</strong>生成笛卡尔积——它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行一一匹配</p>
<p>select A.c1,B.c2 from A,B;</p>
<hr>
<h5 id="数据库连接池优点"><a href="#数据库连接池优点" class="headerlink" title="数据库连接池优点"></a>数据库连接池优点</h5><p><strong>①资源重用</strong></p>
<p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。</p>
<p><strong>②更快的系统响应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。对于业务请求处理而言，直接利用现有连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p>
<p><strong>③强制收回被占用的连接，避免数据库连接泄露</strong></p>
<hr>
<h5 id="MySQL的慢查询优化有了解吗？"><a href="#MySQL的慢查询优化有了解吗？" class="headerlink" title="MySQL的慢查询优化有了解吗？"></a>MySQL的慢查询优化有了解吗？</h5><p>优化MySQL的慢查询，可以按照如下步骤进行：</p>
<p><strong>开启慢查询日志：</strong>在MySQL服务启动的时候使用<code>--log-slow-queries[=file_name]</code>启动慢查询日志。</p>
<p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p>
<p><strong>分析慢查询日志：</strong></p>
<p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p>
<p><strong>常见慢查询优化：</strong></p>
<ol>
<li><p>索引没起作用的情况</p>
<ul>
<li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</li>
<li>复合索引要注意最左匹配原则</li>
<li>若查询语句的查询条件中只有OR关键字，则当OR前后的两个条件中的列都是索引时，查询中才使用索引</li>
</ul>
</li>
<li><p>优化数据库结构</p>
<ul>
<li>对于列比较多的表，如果有些列的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</li>
</ul>
</li>
<li><p>优化LIMIT分页</p>
<p>当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p>
<p>用 between 优化 SELECT * FROM t_topic WHERE id BETWEEN 10000 AND 10020;</p>
</li>
</ol>
<hr>
<h5 id="⚠️Redo-log-Undo-log和Binlog"><a href="#⚠️Redo-log-Undo-log和Binlog" class="headerlink" title="⚠️Redo log, Undo log和Binlog"></a>⚠️Redo log, Undo log和Binlog</h5><p>都是数据库中常见的日志文件，但是它们在功能和使用方面有一些区别。</p>
<ol>
<li>Redo Log（重做日志）：它用于记录在事务执行过程中所做的更改操作，以便在数据库崩溃或重新启动时能够恢复未完成的事务。Redo Log是在内存中记录的，当事务提交时，将其刷入磁盘</li>
<li>Undo Log（撤销日志）：它记录了在事务执行过程中所做的更改操作的相反操作，以便在回滚事务时可以撤销这些更改操作。Undo Log是在磁盘上记录的</li>
<li>Binlog（二进制日志）：它记录了所有对数据库的更改操作，包括DDL和DML语句。Binlog是在磁盘上记录的，可以用于数据库的备份、复制和恢复等操作</li>
</ol>
<ul>
<li>Redo Log和Undo Log是在数据库的服务器端生成的，而Binlog可以在任何MySQL客户端上生成。</li>
</ul>
<hr>
<h5 id="常见的数据库"><a href="#常见的数据库" class="headerlink" title="常见的数据库"></a>常见的数据库</h5><p>KV：Redis、LevelDB、RocksDB</p>
<p>关系型：SQLite、SQL Server、Oracle</p>
<hr>
<h5 id="❤️什么是消息队列"><a href="#❤️什么是消息队列" class="headerlink" title="❤️什么是消息队列"></a>❤️什么是消息队列</h5><p>消息队列（Message Queue）是一种通信模式，用于在不同组件、系统或服务之间传递消息。它是一种异步通信机制，允许发送者将消息发送到队列中，而不需要显式地等待接收者的响应。接收者可以在适当的时候从队列中获取消息，并进行处理。</p>
<p>消息队列的基本原理是，发送者将消息发送到队列中，然后接收者从队列中获取消息进行处理。消息队列可以在不同的时间和速率下处理消息的发送和接收，因此发送者和接收者可以解耦，彼此不会直接依赖或受制于对方。</p>
<p>消息队列的好处包括：</p>
<ol>
<li>异步通信：发送者和接收者之间的通信是异步的，发送者不需要等待接收者的响应即可继续执行其他任务。</li>
<li>解耦性：通过消息队列，发送者和接收者可以彼此解耦。它们不需要直接知道对方的存在或实现细节，只需关注消息的发送和接收。</li>
<li>缓冲能力：消息队列可以作为缓冲区，即使发送者和接收者之间的处理速度不同，也能确保消息的安全传递和存储。</li>
<li>可靠性：消息队列通常提供可靠的消息传递机制，确保消息不会丢失，并且可以处理故障情况。</li>
<li>扩展性：消息队列可以用于构建分布式系统，并支持水平扩展。多个发送者和接收者可以连接到同一个消息队列，从而实现系统的扩展性。</li>
</ol>
<p>消息队列在软件开发和系统架构中广泛应用，用于处理异步任务、解耦系统组件、平衡负载和构建可靠的分布式系统等方面。常见的消息队列系统包括RabbitMQ、Apache Kafka、ActiveMQ等。</p>
<h5 id="❤️Redis的几种应用场景"><a href="#❤️Redis的几种应用场景" class="headerlink" title="❤️Redis的几种应用场景"></a>❤️Redis的几种应用场景</h5><ol>
<li>缓存 ：Redis的高性能使其成为一个非常有效的缓存解决方案。它可以将热门的数据存储在内存中，以加快数据访问速度。同时，Redis提供了多种数据结构，如哈希表和有序集合等，可以方便地存储和访问不同类型的数据。</li>
<li>会话管理 ：在Web应用程序中，会话管理是一项重要的任务。Redis可以作为分布式会话存储，将会话数据存储在内存中，以提高速度和可扩展性。通过使用Redis，可以轻松地跨多个应用程序实例共享会话数据。</li>
<li>消息队列 ：Redis的发布&#x2F;订阅模式和列表数据结构可以很方便地用作消息队列。发布者将消息发布到一个通道，订阅者可以从该通道接收消息并进行处理。此外，Redis还支持各种高级队列操作，如阻塞队列和优先级队列等。</li>
<li>计数器和排行榜 ：Redis提供了对计数器和排行榜的原生支持，这使得它成为构建实时统计和排名应用程序的理想解决方案。例如，可以使用Redis轻松地实现网站访问量计数器或者实时排行榜功能。</li>
</ol>
<hr>
<h3 id="4️⃣设计模式-5-21"><a href="#4️⃣设计模式-5-21" class="headerlink" title="4️⃣设计模式  5.21"></a>4️⃣设计模式  5.21</h3><h4 id="六种关系"><a href="#六种关系" class="headerlink" title="六种关系"></a>六种关系</h4><p>依赖</p>
<p>依赖关系是在运行过程中起作用的，就是一个类A运行时使用到了另一个类B，而这种使用关系是临时性的、非常弱的</p>
<ul>
<li>A 类是 B 类中的(某种方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个形参；</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom: 67%;">

<p>关联</p>
<p>是一种静态关系，在运行前就可以确定；体现的是两个类、或者类与接口之间一种强依赖关系。一般是长期性的，而且双方的关系一般是平等的</p>
<ul>
<li>类B以类属性的形式出现在关联类A中</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png" alt="在这里插入图片描述"></p>
<p>聚合</p>
<p>但是公司和员工就属于聚合关系了，因为公司没了员工还在</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>组合</p>
<p>组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="img" style="zoom:67%;">



<p>继承（extend）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>实现（implement）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">

<hr>
<h4 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h4><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png" alt="image-20230129223341112"></p>
<hr>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>其主要作用是确保一个类仅有一个实例，并提供一个全局访问点来访问该实例</p>
<p>懒汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mutex mu;<span class="comment">//mutex mlock; 加锁互斥</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            mu.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) instance = <span class="keyword">new</span> <span class="built_in">singleInstance</span>();</span><br><span class="line">            mu.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;; <span class="comment">// 它拥有一个私有构造函数，这确保用户无法通过new直接实例它</span></span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    <span class="type">static</span> singleInstance* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleInstance* singleInstance::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回静态成员变量 </span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">// 饿汉式，直接创建一个对象，不需要加锁</span></span><br><span class="line">        <span class="type">static</span> singleInstance instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回</span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>单例模式多线程是不安全的</p>
<ul>
<li>解决方法加mutex</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221143214363.png" alt="image-20230221143214363"></p>
<hr>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ol>
<li>是一种对象行为模式。它定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有它关联的对象都得到通知并被自动更新</li>
<li>在观察者模式中，Subject是通知的发布者，发出通知时并不需要知道谁是他的观察者，可有任意数目的Observer订阅并接收通知。</li>
<li>观察者模式将观察者和被观察的对象分离开。在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。</li>
</ol>
<blockquote>
<p>  数据库和消息队列系统：在分布式系统中，观察者模式可以用于实现数据的订阅和同步。当数据库中的数据发生变化时，观察者可以更新本地缓存或者发送消息到消息队列。</p>
<p>  日志记录系统：日志作为subject，观察者订阅日志事件。当系统产生新的日志事件时，观察者可以接收到通知并将日志记录到文件或者发送到远程服务器。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer* obs)</span> </span>&#123; observers.<span class="built_in">push_back</span>(obs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* obs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = observers.<span class="built_in">begin</span>(); it != observers.<span class="built_in">end</span>(); ++it) </span><br><span class="line">            <span class="keyword">if</span> (*it == obs) observers.<span class="built_in">erase</span>(it), <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> obs : observers) </span><br><span class="line">            obs -&gt; <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Observer*&gt; observers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteObserver received update.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteSubject is doing something.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteSubject subject;</span><br><span class="line">    ConcreteObserver observer1, observer2;</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">addObserver</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">doSomething</span>(); <span class="comment">// ConcreteObserver received update. ConcreteObserver received update.</span></span><br><span class="line">    subject.<span class="built_in">removeObserver</span>(&amp;observer2);</span><br><span class="line">    subject.<span class="built_in">doSomething</span>(); <span class="comment">// ConcreteObserver received update.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="请说说工厂设计模式"><a href="#请说说工厂设计模式" class="headerlink" title="请说说工厂设计模式"></a>请说说工厂设计模式</h4><p>工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong></p>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png" alt="img" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象</p>
<p><strong>缺点：</strong>就是要增加新的核类型时，就需要修改工厂类。这就违反了开闭原则</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p> 所谓工厂方法模式, 是指定义一个用于创建对象的接口, 让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png" alt="img" style="zoom: 33%;">

<p><strong>举例：</strong>这家生产处理器核的产家决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。  </p>
<p><strong>缺点：</strong>显然，相比简单工厂模式，工厂方法模式需要更多的类定义</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png" alt="image-20221116164855060" style="zoom:50%;">

<p><strong>举例：</strong>这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h5 id="⭐️三种工厂模式的区别"><a href="#⭐️三种工厂模式的区别" class="headerlink" title="⭐️三种工厂模式的区别"></a>⭐️三种工厂模式的区别</h5><p>简单工厂 ：用来生产同一产品族中的任意产品(对于增加新的产品，无能为力)</p>
<p>工厂方法 ：用来生产同一产品族中的任意产品(对于增加新的产品）</p>
<p>抽象工厂 ：产品按产品族（手机，电脑）抽象，工厂就按品牌分【增加品牌就符合开闭原则】；产品按品牌抽象，工厂就按产品族分【增加产品族就符合开闭原则】；</p>
<hr>
<hr>
<hr>
<h3 id="5️⃣项目相关"><a href="#5️⃣项目相关" class="headerlink" title="5️⃣项目相关"></a>5️⃣项目相关</h3><p>面试官您好，我是孔剑刚，就读于南京大学软工专业。目前在荣耀实习，我曾参加过一些项目开发，包括课程设计和个人项目我曾分别用JAVA和Damg写过简单的管理系统，也使用GO语言开发了一个简易的分布式(数据库。最近完成的项目是linux环境下使用C++开发的高并发HTTP服务器。语言方面我对C++的了解最为深人和系统，能够熟练掌握STL库、多线程编程，了解C++内存分配和指针。在项目和学习中遇到问题后，我能够快速定位问题所在，并采取有效的解快方案，并且愿意向他人学习和分享自己的知识和经验。在去年8月份左右，我开始写个人博客，从力扣题解到语言框架和项目bug，我都有完整地记录下来，对我的帮助很大。总之，我对编程充满热情，并希望能够在实践中提高自己的技能，也非常希望能够加人贵公司，贡献自己的力量。</p>
<h4 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h4><h5 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h5><p>此项目是基于Linux的轻量级多线程Web服务器，应用层实现了一个简单的HTTP服务器，利用多路IO复用，可以同时监听多个请求，使用线程池处理请求，使用模拟proactor模式，主线程负责监听，监听有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在请求队列上的工作线程被唤醒进行处理，使用状态机解析HTTP请求报文，将响应报文和资源文件写回通信的socket，并对系统进行了压力测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数   process() = process_read() + process_write()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，需要继续读取客户数据</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="为什么将socket设置为非阻塞"><a href="#为什么将socket设置为非阻塞" class="headerlink" title="为什么将socket设置为非阻塞"></a>为什么将socket设置为非阻塞</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230412120540372.png" alt="image-20230412120540372"></p>
<p>在Web服务器中，为了能够同时处理多个客户端请求，通常会使用多线程或多进程的方式。其中，每个线程或进程会负责处理一个客户端连接。为了高效地处理多个连接，Web服务器通常使用非阻塞IO。</p>
<p>当一个socket被设置为阻塞IO时，当它调用recv()或send()函数时，如果没有数据可读或者写缓冲区已满，该函数会一直阻塞，直到有数据可读或写缓冲区有空闲空间。这意味着，当有多个客户端连接时，每个连接都会阻塞线程或进程的执行，导致服务器的性能受到影响。</p>
<p>相反，当socket被设置为非阻塞IO时，当调用recv()或send()函数时，如果没有数据可读或写缓冲区已满，该函数会立即返回，并且在缓冲区有数据可读或有空闲空间时再继续执行。这意味着线程或进程可以在等待数据的同时处理其他连接，提高了服务器的并发性能。</p>
<p>因此，为了提高Web服务器的并发性能，将socket设置为非阻塞是一个常用的做法。</p>
<hr>
<h6 id="定时器处理非活跃连接"><a href="#定时器处理非活跃连接" class="headerlink" title="定时器处理非活跃连接"></a>定时器处理非活跃连接</h6><p>设置SIGALRM信号处理函数, 设置一个定时器, 到期处理函数就往pipefd[1]里面写, epoll_wait就会由于pipefd[0]可以读而触发, 再设置timeout为true, 调用tick()函数删除非活跃连接, 然后再设置一个定时器. 以此重复. </p>
<hr>
<h6 id="主从状态机"><a href="#主从状态机" class="headerlink" title="主从状态机"></a>主从状态机</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227144327617.png" alt="image-20230227144327617"></p>
<p>主状态机：三种状态，标识解析位置</p>
<p>CHECK_STATE_REQUESTLINE，解析请求行</p>
<p>CHECK_STATE_HEADER，解析请求头</p>
<p>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</p>
<p>从状态机：三种状态，标识解析一行的读取状态</p>
<p>LINE_OK，完整读取一行</p>
<p>LINE_BAD，报文语法有误</p>
<p>LINE_OPEN，读取的行不完整</p>
<p>服务器处理HTTP请求的可能结果，报文解析的结果</p>
<p>NO_REQUEST          :   请求不完整，需要继续读取客户数据</p>
<p>GET_REQUEST         :   表示获得了一个完整的客户请求</p>
<p>BAD_REQUEST         :   表示客户请求语法错误</p>
<p>NO_RESOURCE         :   表示服务器没有资源</p>
<p>FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</p>
<p>FILE_REQUEST        :   文件请求,获取文件成功</p>
<p>INTERNAL_ERROR      :   表示服务器内部错误</p>
<p>CLOSED_CONNECTION   :   表示客户端已经关闭连接了</p>
<hr>
<h6 id="子线程如何提醒主线程"><a href="#子线程如何提醒主线程" class="headerlink" title="子线程如何提醒主线程"></a>子线程如何提醒主线程</h6><p>子线程调用<code>http_conn::process()</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向epoll中添加需要监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot )</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot) event.events |= EPOLLONESHOT; <span class="comment">// 防止同一个通信被不同的线程处理</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd); <span class="comment">// 设置文件描述符非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从epoll中移除监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，修改通信m_sockfd上event.events = EPOLLIN，让主线程继续读取客户数据 	那边wait到了就开始读</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);  <span class="comment">// 响应完，注册写事件，让主线程写入通信socket   那边wait到了就开始写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="服务器是怎么把静态资源传回客户端的"><a href="#服务器是怎么把静态资源传回客户端的" class="headerlink" title="服务器是怎么把静态资源传回客户端的"></a>服务器是怎么把静态资源传回客户端的</h6><p>首先客户端请求里有一个url，服务器端在解析请求首行的时候已经把他存在一个字符串m_url里了。然后我们要把存在服务器相应的资源目录地址拼接上m_url，判断有没有该文件以及该文件的访问权限。如果目标文件存在、对所有用户可读，且不是目录。则使用mmap将其映射到内存地址m_file_address处，并告诉调用者获取文件成功</p>
<p>最后由主线程执行write方法，将其传输给本次连接的socket</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write方法里 分散写，共有两块内存要写出去 m_write_buf 、 m_file_address</span></span><br><span class="line">temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, temp; <span class="comment">// rdset是用户自己维护的, temp是交给内核去修改的</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset); <span class="comment">//初始化，全置0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset); <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = rdset;</span><br><span class="line">        <span class="comment">// 调用select，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;temp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">// 这里我们设置的timeval为NULL，所以是阻塞型，ret不可能返回0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;temp))&#123;</span><br><span class="line">                <span class="comment">// 判断fd对应的标志位是0还是1 , 为1代表有新的客户端连接进来了</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到set中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i ++)&#123; <span class="comment">// lfd最先被监听，肯定在最前面</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;temp))&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h6><ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了默认是1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<hr>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">//需要检测读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>; <span class="comment">// 这里就是最大索引，而不是最大索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用 poll，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123; <span class="comment">// 有新客户端连接进来了，因为revents 返回的是 POLLIN ｜ POLLOUT</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将cfd加入到监听数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i ++)&#123; <span class="comment">// 0是lfd</span></span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)&#123; <span class="comment">// fds[i]可用</span></span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i ++)&#123; <span class="comment">// lfd最先被监听，为0</span></span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h6><ol>
<li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
</li>
<li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
</li>
<li><p><del>select支持的文件描述符数量太小了默认是1024</del></p>
</li>
<li><p><del>fds集合不能重用，每次都需要重置</del></p>
</li>
</ol>
<hr>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><h6 id="说说-epoll-的原理"><a href="#说说-epoll-的原理" class="headerlink" title="说说 epoll 的原理"></a>说说 epoll 的原理</h6><p>wait检测，有EPOLLIN就读，有EPOLLOUT就回</p>
<p>执行epoll_create会在内核中维护一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点</p>
<p>在执行epoll_ctl的add操作时,不仅将文件描述符放到红黑树上,而且也注册了回调函数, 内核在检测到某文件描述符可读&#x2F;可写时会调用回调函数,该回调函数将文件描述符放在就绪链表中</p>
<p><strong>epoll_wait只用观察就绪链表中有无数据即可,最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中,所以只用遍历依次处理即可</strong></p>
<blockquote>
<p>  epoll采用回调机制。造成的结果就是,随着fd的增加,select和poll的效率会线性降低,而epoll不会受到太大影响,除非活跃的socket很多</p>
</blockquote>
<hr>
<h6 id="说说epoll流程"><a href="#说说epoll流程" class="headerlink" title="说说epoll流程"></a>说说epoll流程</h6><ol>
<li>创建一个<code>epoll</code>对象，通过调用<code>epoll_create</code>函数来创建一个<code>epoll</code>实例。它会返回一个文件描述符，用于后续对<code>epoll</code>的操作</li>
<li>将需要监控的文件描述符添加到<code>epoll</code>对象中，通过调用<code>epoll_ctl</code>函数来添加和删除需要监听的文件描述符，可以通过传递参数<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_DEL</code>和<code>EPOLL_CTL_MOD</code>来进行添加、删除和修改操作</li>
<li>等待事件的发生，通过调用<code>epoll_wait</code>函数来等待<code>epoll</code>对象中的事件。该函数将会一直阻塞，直到有一个或多个文件描述符发生了指定的事件或者超时</li>
<li>处理事件，当<code>epoll_wait</code>函数返回后，可以遍历返回的<code>epoll_event</code>数组来处理所有的事件。<code>epoll_event</code>结构体中包含发生事件的文件描述符和事件类型</li>
<li>回到步骤3，等待下一个事件的发生</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//（2）将监听的文件描述符相关的检测信息加入到epoll实例中</span></span><br><span class="line">    epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN; </span><br><span class="line">    epev.data.fd = lfd; </span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line">    </span><br><span class="line">    epoll_event epevs[<span class="number">1024</span>]; <span class="comment">// 内核检测后会将已就绪的文件描述符放在这里面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>); <span class="comment">//（3）-1设置阻塞。只有设置了阻塞时，会返回0，代表超时了都没有检测到变化的文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(epevs[i].data.fd == lfd) &#123; <span class="comment">// 监听到了客户端的连接</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); <span class="comment">// 添加到epoll实例中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// epevs[i].data.fd == cfd  有数据到达，通信</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(epevs[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// （4）将此fd从红黑树中删除</span></span><br><span class="line">                    <span class="built_in">close</span>(epevs[i].data.fd); <span class="comment">// close(cfd)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">write</span>(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);<span class="comment">// （5）关闭epoll实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="epoll事件类型"><a href="#epoll事件类型" class="headerlink" title="epoll事件类型"></a>epoll事件类型</h6><p>epoll是一种高效的I&#x2F;O多路复用机制，在Linux系统上被广泛应用。它可以同时处理大量的socket连接，并且可以有效地减少系统开销。在epoll中，有四种不同的事件类型：</p>
<ol>
<li>EPOLLIN：读事件就绪。当socket接收到数据，就会触发这种事件。</li>
<li>EPOLLOUT：写事件就绪。当socket可以发送数据，就会触发这种事件。</li>
<li>EPOLLERR：错误事件。当socket出现错误，就会触发这种事件。</li>
<li>EPOLLHUP：挂起事件。当socket被挂起，就会触发这种事件。</li>
</ol>
<p>在epoll中，有两种就绪状态：读就绪和写就绪。当一个socket可以读取数据时，就会触发读就绪事件。而当一个socket可以发送数据时，就会触发写就绪事件</p>
<p>在epoll中，写完成事件指的是数据已经被完全写入socket缓冲区的事件，而写就绪事件指的是socket缓冲区中有足够的空间可以继续写入数据的事件。类似地，读完成事件指的是数据已经被完全读取的事件，而读就绪事件指的是socket缓冲区中有足够的数据可以读取的事件</p>
<hr>
<h6 id="epoll写就绪事件和写完成事件"><a href="#epoll写就绪事件和写完成事件" class="headerlink" title="epoll写就绪事件和写完成事件"></a>epoll写就绪事件和写完成事件</h6><p><code>epoll</code>中的写就绪事件是指一个文件描述符上的输出缓冲区可用空间已经超过一定阈值，<strong>此时可以向该文件描述符进行写操作（就是用该fd写出去）</strong>。在默认的水平触发模式下，只要输出缓冲区还有空闲空间，就会一直触发写就绪事件。而在边缘触发模式下，只有在输出缓冲区从空变为非空时才会触发写就绪事件。</p>
<p>在<code>epoll</code>中，写就绪事件可以通过监听<code>EPOLLOUT</code>事件来实现。当一个文件描述符的输出缓冲区可用空间大于一定阈值时，<code>epoll</code>会将该文件描述符上的<code>EPOLLOUT</code>事件加入到事件集合中，通知应用程序该文件描述符可以进行写操作了</p>
<p>在<code>epoll</code>中，写完成事件指的是一个文件描述符上的所有数据已经写入完毕，此时可以关闭该文件描述符或者等待更多的写操作。在默认的LT模式下，只要输出缓冲区还有空闲空间，就会一直触发写就绪事件，不管数据是否已经全部写入完毕。而在边缘触发模式下，只有当输出缓冲区从非空变为空时才会触发写完成事件。</p>
<p><code>epoll</code>中的写完成事件无法直接注册，需要通过一些技巧来实现。一种常用的方法是在注册<code>EPOLLOUT</code>事件时，将文件描述符关联一个状态标志，当输出缓冲区变为空时，将该状态标志设置为“写完成”，在处理<code>EPOLLOUT</code>事件时，检查该状态标志，如果为“写完成”，则认为所有数据已经写入完毕，可以进行相应的处理</p>
<hr>
<h6 id="epoll水平触发与边缘触发的区别"><a href="#epoll水平触发与边缘触发的区别" class="headerlink" title="epoll水平触发与边缘触发的区别"></a>epoll水平触发与边缘触发的区别</h6><p>LT模式（水平触发）: 同时支持 Block (读写操作完才返回)和 Nonblock Socket (读写不等待完毕就返回); 只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。LT模式通常需要使用阻塞I&#x2F;O，以确保程序能够正确处理事件。</p>
<p>而在ET（边缘触发）: 支持 Nonblock socket, 它只会提示一次,  直到下次再有数据流入之前都不会再提示了, 无论fd中是否还有数据可读。如果程序没有及时处理事件，事件会被丢失。ET模式通常需要使用非阻塞I&#x2F;O，以确保程序能够及时响应事件。</p>
<p><strong>场景上来说</strong>：</p>
<p>ET模式适用于需要高并发、高吞吐量的场景，例如网络编程中的服务器端。服务器需要及时响应大量的客户端请求，并发地处理多个请求。ET模式可以确保服务器能够及时响应客户端请求，并发地处理多个请求。</p>
<p>LT模式适用于需要保证数据的完整性和可靠性的场景，例如数据库、事务处理等。LT模式可以确保程序能够正确处理所有的事件，并保证数据的完整性和可靠性。</p>
<hr>
<h6 id="epoll是同步的还是异步的"><a href="#epoll是同步的还是异步的" class="headerlink" title="epoll是同步的还是异步的"></a>epoll是同步的还是异步的</h6><blockquote>
<ol>
<li>一个同步的IO操作使得请求进程一直被阻塞，直到IO操作完成；</li>
<li>一个异步的IO操作不会导致请求进程被阻塞.</li>
</ol>
</blockquote>
<p>epoll既可以是同步的，也可以是异步的，这取决于它的使用方式。</p>
<p>在epoll的LT（Level Triggered）模式下，<strong>epoll_wait函数</strong>是同步的。这意味着当调用epoll_wait函数时，程序会一直等待，直到有事件发生，然后返回就绪的事件集合。</p>
<p>而在epoll的ET（Edge Triggered）模式下，<strong>epoll_wait函数</strong>是异步的。这意味着当调用epoll_wait函数时，如果有事件已经就绪，它会立即返回就绪的事件集合，如果没有就绪的事件，它会立即返回空集合，而不会阻塞等待事件的发生。</p>
<hr>
<h6 id="EPOLLONESHOT事件-保证线程安全"><a href="#EPOLLONESHOT事件-保证线程安全" class="headerlink" title="EPOLLONESHOT事件(保证线程安全)"></a>EPOLLONESHOT事件(保证线程安全)</h6><p>即使<strong>可以使用 ET 模式</strong>，一个socket 上的某个事件还是可能被触发多次。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，对此我们可以使用 epoll 的 EPOLLONESHOT 事件实现</p>
<p>对于注册了 EPOLLONESHOT 事件的文件描述符，<strong>操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次</strong>，<strong>除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件</strong>。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， <strong>该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发</strong>，进而让其他工作线程有机会继续处理这个 socket</p>
<hr>
<p>在使用同步方式模拟 Proactor 模式时，每个 HTTP 连接的处理流程通常如下：</p>
<ol>
<li>主线程从 epoll 中取出一个 <code>EPOLLONESHOT</code> 类型的 fd。</li>
<li>主线程处理该 fd，并将处理结果传递给工作线程池。</li>
<li>工作线程池异步地处理请求，并将响应结果返回给主线程。</li>
<li>主线程将响应结果发送给客户端。</li>
</ol>
<p>由于在步骤2和步骤3中都需要处理 fd，为了保证同一时刻只有一个线程处理一个 fd，需要将每个 HTTP 连接</p>
<p>的 fd 设置为 <code>EPOLLONESHOT</code> 模式。这样可以保证同一时刻只有一个线程处理同一个 fd，从而避免线程安全问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span>(users[sockfd].<span class="built_in">read</span>()) &#123;</span><br><span class="line">     pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 如果不注册 EPOLLONESHOT，那 sockfd 有新数据时，主线程被唤醒来读取这些新的数据。 </span></span><br><span class="line"><span class="comment">// 于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，对此我们可以使用 epoll 的 EPOLLONESHOT 事件实现</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h5><p>IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
<p>无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png" alt="image-20221120132728012"></p>
<hr>
<h5 id="说说Reactor、Proactor模式"><a href="#说说Reactor、Proactor模式" class="headerlink" title="说说Reactor、Proactor模式"></a>说说Reactor、Proactor模式</h5><h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列(线程池)</strong></li>
<li>线程池中的某个线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入线程池</li>
<li>线程池上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png" alt="image-20221120194303146"></p>
<h6 id="同步IO的模拟Proactor"><a href="#同步IO的模拟Proactor" class="headerlink" title="同步IO的模拟Proactor"></a>同步IO的模拟Proactor</h6><p>使用同步I&#x2F;O方式模拟出Proactor模式。原理是:主线程执行数据读写操作,读写**(就是将socket上的数据(客户端传的http报文)读取至http类对象维护的读写缓冲区)**完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理</p>
<p>使用同步I&#x2F;O模型(以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait 等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理完客户请求，然后往epoll内核事件表中注册socket上的写完成事件</li>
<li>因为主线程调用epoll_wait 等待socket可写, 所以当socket可写时, epoll_wait 通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120203431492.png" alt="image-20221120203431492" style="zoom:50%;">



<hr>
<h5 id="将文件描述符设置为非阻塞有什么用"><a href="#将文件描述符设置为非阻塞有什么用" class="headerlink" title="将文件描述符设置为非阻塞有什么用"></a>将文件描述符设置为非阻塞有什么用</h5><p>将文件描述符设置为非阻塞可以使文件 I&#x2F;O 操作变得更加灵活和高效。</p>
<p>当文件描述符被设置为阻塞时，当进行 I&#x2F;O 操作时，程序会一直等待直到操作完成，如果操作需要花费很长时间（如从网络中读取大量数据），程序就会在等待操作完成时阻塞。这样可能会导致程序在等待 I&#x2F;O 操作完成时无法执行其他任务，从而影响整个程序的性能和响应能力。</p>
<p>相比之下，当文件描述符被设置为非阻塞时，I&#x2F;O 操作不会阻塞程序的执行。如果 I&#x2F;O 操作需要花费很长时间，程序可以继续执行其他任务。此外，当进行非阻塞 I&#x2F;O 操作时，如果数据还没有准备好或者无法立即写入，I&#x2F;O 操作将会立即返回并返回一个错误码（如 EAGAIN 或 EWOULDBLOCK），程序可以在稍后再次尝试 I&#x2F;O 操作，从而避免了长时间的等待阻塞。这种方法可以使程序更加高效和响应快速。</p>
<hr>
<h5 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h5><h6 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h6><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h6 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h6><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h6><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h6 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h6><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h6 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h6><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h6 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<hr>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>该项目使用线程池（同步模拟Proactor）并发处理用户请求，<strong>主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number; <span class="comment">// 线程的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> * m_threads; <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_max_requests; <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    </span><br><span class="line">    std::list&lt; T* &gt; m_workqueue; <span class="comment">// 请求队列 按理说应当叫 m_requestqueue</span></span><br><span class="line"></span><br><span class="line">    locker m_queuelocker; <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line"></span><br><span class="line">    sem m_queuestat; <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">bool</span> m_stop; <span class="comment">// 是否结束线程                     </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : </span><br><span class="line">        <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), </span><br><span class="line">        <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_detach</span>( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt; T &gt;::<span class="built_in">append</span>( T* request )&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt; T &gt;::<span class="built_in">worker</span>( <span class="type">void</span>* arg )&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt; T &gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) <span class="keyword">continue</span>;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h6 id="如何确定线程数量"><a href="#如何确定线程数量" class="headerlink" title="如何确定线程数量"></a>如何确定线程数量</h6><p>线程数量的确定需要考虑多种因素，如处理器核心数、内存大小、任务类型、线程间的依赖关系等。</p>
<ol>
<li>处理器核心数：线程数不宜超过处理器核心数，因为超过这个数量后，线程之间可能会竞争处理器资源，导致性能下降。</li>
<li>内存大小：每个线程需要占用一定的内存，因此线程数不能过多，否则会导致内存不足。</li>
<li>任务类型：如果任务是I&#x2F;O密集型的，例如网络通信或者文件读写等，线程数可以比较多，因为线程会在I&#x2F;O操作中阻塞，不会占用过多的处理器资源。而如果是CPU密集型的任务，例如图像处理或者计算密集型算法等，则线程数需要适当减少，避免CPU资源竞争。</li>
<li>线程间的依赖关系：如果任务中的线程之间存在依赖关系，需要根据依赖关系来确定线程数，避免出现死锁等问题。</li>
</ol>
<h6 id="线程数量与CPU核心数的关系"><a href="#线程数量与CPU核心数的关系" class="headerlink" title="线程数量与CPU核心数的关系"></a>线程数量与CPU核心数的关系</h6><p>如果任务是CPU密集型的，那么线程数不应该超过CPU核心数，因为过多的线程会导致线程之间的上下文切换，从而浪费CPU时间。此时，线程数可以根据CPU核心数进行适当调整，以充分利用CPU资源。</p>
<p>如果任务是I&#x2F;O密集型的，那么线程数可以适当增加，以充分利用CPU资源。此时，线程数可以根据CPU核心数和系统负载情况进行适当调整，以提高并发处理能力</p>
<h6 id="线程池中的工作线程是一直等待吗？"><a href="#线程池中的工作线程是一直等待吗？" class="headerlink" title="线程池中的工作线程是一直等待吗？"></a>线程池中的工作线程是一直等待吗？</h6><p>在run函数中，我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的 </p>
<h6 id="线程池工作线程处理完一个任务后的状态是什么？"><a href="#线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="线程池工作线程处理完一个任务后的状态是什么？"></a>线程池工作线程处理完一个任务后的状态是什么？</h6><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p>
<p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格</p>
<h6 id="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h6><p>本项目是通过对子线程循环调用来解决高并发的问题的</p>
<hr>
<h5 id="Nginx的负载均衡"><a href="#Nginx的负载均衡" class="headerlink" title="Nginx的负载均衡"></a>Nginx的负载均衡</h5><p>模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方的调度方法。</p>
<ul>
<li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响；</li>
<li>Weight：指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下；</li>
<li>ip_hash：每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题</li>
<li>fair：比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>
<li>url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包</li>
</ul>
<p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p>
<ul>
<li>down：表示当前的server暂时不参与负载均衡；</li>
<li>backup：预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻；</li>
<li>max_fails：允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误；</li>
<li>fail_timeout：在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<hr>
<h5 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h5><p><code>upstream</code> 说白了就是做负载均衡，它可以帮助我们定义一组相同服务的别名，如<code>backend</code>，当请求到来的时候可以通过相关策略帮我们选一组服务提供响应。</p>
<p>目前只能被 <code>proxy_pass</code>，<code>fastcgi_pass</code>，<code>uwsgi_pass</code>，<code>scgi_pass</code>，<code>memcached_pass</code>，<code>grpc_pass</code> 使用。</p>
<hr>
<h5 id="读多写少的优化"><a href="#读多写少的优化" class="headerlink" title="读多写少的优化"></a>读多写少的优化</h5><ul>
<li><p>加读写锁</p>
<p>但是，只要加了锁，就会带来竞争，即使加的是读写锁，虽然读之间不互斥，但写一样会影响读，而且读写同时争夺锁的时候，锁优先分配给写。</p>
<p>例如，写的时候，要求所有的读请求阻塞住，等到写线程或协程释放锁之后才能读。如果写的临界区耗时比较大，则所有的读请求都会受影响，所有的读请求都在队列中等待处理，如果在下个更新周期来之前，服务能处理完这些读请求，可能情况没那么糟糕。但极端情况下，如果下个更新周期来了，读请求还没处理完，就会形成一个恶性循环，不断的有读请求在队列中等待，最终导致队列被挤满，服务出现假死，情况再恶劣一点的话，上游服务发现某个节点假死后，由于负载均衡策略，一般会重试请求其他节点，这时候其他节点的压力跟着增加了，最终导致整个系统出现雪崩。<br>因此，加锁在高并发场景下要尽量避免，如果避免不了，需要让锁的粒度尽量小，接近无锁（lock-free）更好，简单的对一大片临界区加锁，在高并发场景下不是一种合适的解决方案</p>
</li>
<li><p>双缓冲</p>
</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221161535855.png" alt="image-20230221161535855"></p>
<hr>
<h5 id="GDB-常见的调试命令"><a href="#GDB-常见的调试命令" class="headerlink" title="GDB 常见的调试命令"></a>GDB 常见的调试命令</h5><h6 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h6><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h6 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h6><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h6 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h6><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	每次调试时如果a, b值发生变化的话, 自动打印</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<hr>
<h5 id="提高WebServer的性能"><a href="#提高WebServer的性能" class="headerlink" title="提高WebServer的性能"></a>提高WebServer的性能</h5><ol>
<li>加机器</li>
<li>提升机器性能(内存, CPU)</li>
<li>拓展线程池的大小</li>
</ol>
<hr>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>假如我们刚刚上线一个网站，最多只有 10 个人同时访问，那么只需要把网站放到一台服务器上就够了，又叫 <strong>单机部署</strong> </p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131733787.png" alt="image-20230221131733787" style="zoom:33%;">

<p>随着我们网站的不断宣传，可能出现上万用户同时访问的情况。由于一台服务器的 CPU、内存、带宽等资源都是有限的，无法同时支撑那么多用户。因此可能需要多台服务器一起来扛，分摊用户的请求，又叫 <strong>集群部署</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131811712.png" alt="image-20230221131811712" style="zoom: 33%;">

<p>但这样有个问题，每个服务器都有一个不同的 IP 地址，想把用户的请求分摊到不同的服务器上，不能让用户自己去输入不同的 IP 访问。</p>
<p>因此，我们还需要一台 <strong>代理服务器</strong> ，对外提供 <strong>唯一</strong> 的入口，<strong>统一</strong> 接受用户的请求。再根据请求（或流量）的 <strong>特征</strong> ，依据一定的 <strong>算法</strong> ，将请求转发到内部的服务器集群中</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131913227.png" alt="image-20230221131913227" style="zoom:33%;">

<p>这样对于用户来说，始终通过一个域名访问网站即可，他完全感知不到你的网站到底部署到多少台服务器上、也不关心它是如何部署的。这便是 <strong>负载均衡</strong>（Load Balancing 简称 LB），是企业中最重要的高并发解决方案</p>
<p><strong>优点：</strong></p>
<p>提高整个系统的可用性，假如集群中有一台服务器挂了，代理服务器只要不再把请求转发给它就行了，集群中的其他服务器仍然能够正常地接受和处理请求</p>
<p>此外，负载均衡还能够减少用户等待响应的时间、通过并行提高整个系统的处理能力等</p>
<hr>
<h6 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h6><p>虽然通过代理服务器转发请求能够提升整个系统的并发访问数，但不要忘了，代理服务器本身的资源也是有限的啊！像比较常用的 Nginx 代理，能有个几万并发就撑死了。如果同时访问的用户量再大一点，不就忍不下了么？</p>
<p>而且代理服务器也存在挂掉的可能性，一旦它挂了，后果不堪设想。因此，我们可以将负载均衡进行分类，针对不同的场景来选择相对合适的实现方式。比较常见的分类方法是：根据 <strong>计算机网络七层模型</strong> ，按照负载均衡所属的网络层次去区分</p>
<ol>
<li><p><strong>二层负载均衡</strong>：二层指数据链路层，数据以数据帧的形式通过交换机进行传输。</p>
<p>这一层是没有 IP 地址概念的，只能用 MAC 地址对机器进行区分。因此负载均衡服务器会通过一个虚拟 MAC 地址接受请求，并通过改写报文目标 MAC 地址的方式将请求转发到具有不同 MAC 地址的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221132718380.png" alt="image-20230221132718380" style="zoom:33%;">
</li>
<li><p><strong>三层负载均衡</strong>：三层即网络层，这一层开始有了 IP 地址的概念，可以根据 IP 地址路由网络。</p>
<p>这一层的负载均衡设备会对外提供一个虚拟的 IP 地址（VIP）以接收请求，然后根据算法将请求转发到 IP 地址不同的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133036044.png" alt="image-20230221133036044" style="zoom:33%;">
</li>
<li><p><strong>四层即传输层</strong>：除了包含三层的 IP 地址信息之外，还多了源目端口号的概念，可以区分同一机器上不同的应用。</p>
<p>由于得到了更多的信息，这一层的负载均衡会更加灵活，对外提供一个虚拟的 IP 地址 + 端口号来接收请求，然后根据算法将请求转发到不同目标机器的不同端口上</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133148277.png" alt="image-20230221133148277" style="zoom:33%;">
</li>
<li><p><strong>七层指应用层</strong>：是计算机网络模型的最上层，因此能得到请求最为详细的信息，比如 HTTP 请求头等。</p>
<p>可以根据域名或主机 IP + 端口接收请求，并通过应用层信息（请求头、Cookie 等）灵活地转发请求，比如将手机端用户转发到服务器 A、桌面端用户转发到服务器 B 等</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133313580.png" alt="image-20230221133313580" style="zoom:33%;"></li>
</ol>
<hr>
<h6 id="负载均衡算法：一致性哈希"><a href="#负载均衡算法：一致性哈希" class="headerlink" title="负载均衡算法：一致性哈希"></a>负载均衡算法：一致性哈希</h6><ul>
<li><p><strong>哈希算法</strong></p>
<p>以分布式缓存为例，假设现在有3台缓存服务器(S0，S1，S2)，要将一些图片尽可能平均地分配到不同的服务器上，hash算法的做法是：</p>
<p>(1) 以图片的名称作为key，然后对其做hash运算。</p>
<p>(2) 将hash值对服务器数量进行求余，得到服务器编号，最后存入即可。</p>
<p>如：a.jpg 需要存入， 我们就得到hash(a.jpg) &#x3D; 5 ——-&gt; 5%3 &#x3D; 2 得到数据存入S2   思考:</p>
<p>上述HASH算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法</p>
</li>
<li><p><strong>一致性哈希算法</strong></p>
<p>也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：</p>
<ol>
<li>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</li>
<li>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</li>
<li>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135029847.png" alt="image-20230221135029847" style="zoom:40%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135135171.png" alt="image-20230221135135171" style="zoom:40%;"></li>
</ul>
<p>优点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135313611.png" alt="image-20230221135313611" style="zoom:50%;">

<p>哈希环的倾斜与虚拟节点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135454172.png" alt="image-20230221135454172" style="zoom:50%;">

<hr>
<h5 id="性能测试-Webbench"><a href="#性能测试-Webbench" class="headerlink" title="性能测试 Webbench"></a>性能测试 Webbench</h5><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出(4gb,单核)</p>
<p><code>webbench -c 1000 -t 60 http://172.16.208.129:8000/index.html</code> </p>
<p>每秒500个并发测试60秒</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145537174.png" alt="image-20230409145537174"></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331120441103.png" alt="image-20230331120441103">

<p>每秒1000个并发测试60秒</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145816015.png" alt="image-20230409145816015"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409145841789.png" alt="image-20230409145841789"></p>
<p>每秒2000个并发测试60秒</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151210972.png" alt="image-20230409151210972"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151031497.png" alt="image-20230409151031497"></p>
<p>每秒3000个并发测试60秒</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409151550693.png" alt="image-20230409151550693"></p>
<p>每秒3000+ 出现CPU资源不足</p>
<p>如果在使用 Webbench 进行测试时，发现 CPU 占用率非常高，但内存消耗很低，可以考虑进行优化，比如使用缓存技术</p>
<p>nginx配置后(设置event数量为63335后全部成功)</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331141852209.png" alt="image-20230331141852209" style="zoom: 33%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230331142913248.png" alt="image-20230331142913248" style="zoom:50%;">

<p>对于服务器我们需要测试两个指标</p>
<ul>
<li>同时连接服务器的数量</li>
<li>每秒的接入量</li>
</ul>
<hr>
<h5 id="什么是QPS和TPS-如何计算"><a href="#什么是QPS和TPS-如何计算" class="headerlink" title="什么是QPS和TPS, 如何计算"></a>什么是QPS和TPS, 如何计算</h5><p>QPS和TPS都是衡量系统性能的指标，它们分别代表<strong>每秒钟处理的请求数量</strong>和<strong>事务处理数量</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">QPS <span class="operator">=</span> 请求数 <span class="operator">/</span> 时间 # 在<span class="number">1</span>秒钟内处理了<span class="number">100</span>个请求，则QPS为<span class="number">100</span></span><br><span class="line">TPS <span class="operator">=</span> 事务数 <span class="operator">/</span> 时间 # 通常用于衡量事务性系统的处理能力，例如交易处理系统</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="访问服务端延迟高的原因"><a href="#访问服务端延迟高的原因" class="headerlink" title="访问服务端延迟高的原因"></a>访问服务端延迟高的原因</h5><ol>
<li>服务端应用压力太大，确实处理不过来了</li>
<li>请求的资源太大</li>
<li>线程池配置的不合理，线程数配置的太少导致的请求积压</li>
<li>客户端网络原因，丢包、带宽限制、重传等</li>
<li>节点距离：需要跳转的网络节点越多，呈现在现实就是网络访问速度会越慢</li>
</ol>
<hr>
<h5 id="如何定位服务器性能瓶颈"><a href="#如何定位服务器性能瓶颈" class="headerlink" title="如何定位服务器性能瓶颈"></a>如何定位服务器性能瓶颈</h5><p>观察机器的磁盘IO：dstat -d</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409165759148.png" alt="image-20230409165759148"></p>
<p>观察网卡的流量情况： dstat -n</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230409165506186.png" alt="image-20230409165506186"></p>
<p><strong>查看内存(top) + jstack</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">top <span class="comment">// 使用top指令找到CPU使用最高的进程</span></span><br><span class="line">top -Hp <span class="number">6962</span> <span class="comment">// 使用 top -Hp 进程Id ，找到使用率最高的线程</span></span><br><span class="line">printf <span class="string">&quot;%x\n&quot;</span> <span class="number">2846</span> <span class="comment">// 将这些线程id转换为16进制的，printf “%x\n” 线程Id</span></span><br><span class="line">jstack <span class="number">6962</span> | grep a33 -A <span class="number">100</span> <span class="comment">// 打印进程堆栈信息 （6962是进程id，a33是线程id的对应的16进制）</span></span><br><span class="line"><span class="comment">// 这样就能找到导致CPU使用率飙高的具体的代码了</span></span><br></pre></td></tr></table></figure>



<p><strong>查看端口状态(netstat)</strong></p>
<p><strong>抓包(tcpdump)</strong></p>
<blockquote>
<p>  host 192.168.130.1表示一台主机.    没有指明数据类型，那么默认就是host</p>
<p>  net 192.168.130.0表示一个网络网段</p>
<p>  port 80 指明端口号为80</p>
</blockquote>
<p><code>tcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host ! www.baidu.com  </code></p>
<p><code>tcpdump udp port 53</code> 监听本机udp的53端口的数据包</p>
<p><code>tcpdump tcp port 22 and host 192.168.56.210</code> 捕获主机192.168.56.210接收和发出的tcp协议的数据包</p>
<hr>
<h5 id="防止恶意请求，服务器端可以采取措施"><a href="#防止恶意请求，服务器端可以采取措施" class="headerlink" title="防止恶意请求，服务器端可以采取措施"></a><strong>防止恶意请求，服务器端可以采取措施</strong></h5><ol>
<li>在服务器端对所有输入进行验证, 确保只有有效的请求才会被处理. 可以使用正则表达式或其他验证库来验证输入</li>
<li>可以限制单个IP地址或用户在特定时间内访问服务器的次数。这可以防止暴力攻击和DDoS攻击等。</li>
<li>可以在敏感操作前要求用户输入验证码，这可以防止自动化脚本或机器人攻击。</li>
<li>可以使用HTTPS协议进行通信，这可以防止网络窃听和中间人攻击等。</li>
<li>可以在服务器上安装防火墙，来过滤不受欢迎的网络流量，包括恶意请求。</li>
<li>可以实时监控服务器端的请求日志，这可以帮助发现潜在的恶意请求和攻击。</li>
</ol>
<hr>
<h5 id="如何限制单个IP地址在特定时间内访问服务器的次数"><a href="#如何限制单个IP地址在特定时间内访问服务器的次数" class="headerlink" title="如何限制单个IP地址在特定时间内访问服务器的次数"></a>如何限制单个IP地址在特定时间内访问服务器的次数</h5><ol>
<li>配置防火墙规则：大多数防火墙都允许您设置规则以限制特定IP地址或用户在特定时间内的访问次数。您可以配置规则，使它们在指定时间内仅允许有限数量的请求通过。这是一个基于网络层面的解决方案，可以防止任何类型的请求访问服务器。</li>
<li>使用限流器：限流器是一个应用层面的解决方案，可以限制单个IP地址或用户在特定时间内访问服务器的次数。您可以配置限流器以允许每个IP地址或用户在指定的时间段内仅能发送有限数量的请求。这可以确保您的服务器不会被恶意请求攻击。</li>
<li>使用反向代理服务器：如果您使用反向代理服务器，您可以在代理服务器上设置规则以限制特定IP地址或用户在特定时间内访问服务器的次数。反向代理服务器可以充当服务器和客户端之间的中介，允许您在代理服务器上执行任意数量的控制和限制。</li>
</ol>
<hr>
<h5 id="服务器端限流"><a href="#服务器端限流" class="headerlink" title="服务器端限流"></a>服务器端限流</h5><p>一种防止服务器过载的措施。通过限制每个客户端在一定时间内可以发送到服务器的请求数量，可以避免某些恶意用户或脚本通过高速请求导致服务器宕机或运行缓慢</p>
<p>以下是实施服务器端限流的一些方法：</p>
<ol>
<li>客户端IP地址限制：限制来自单个IP地址的请求数量，这可以防止单个客户端对服务器进行过度请求。</li>
<li>并发连接数限制：限制服务器能够同时处理的连接数量，这可以防止服务器过载。</li>
<li>请求速率限制：限制客户端在一定时间内可以发送的请求数量，这可以防止DDoS攻击和暴力破解等。</li>
<li>Token Bucket算法：Token Bucket算法是一种常见的限流算法。服务器为每个客户端分配一个令牌桶，每个令牌代表一个请求。客户端在发送请求之前必须从令牌桶中获取令牌。如果令牌桶为空，则请求被拒绝。</li>
<li>漏桶算法：漏桶算法是另一种常见的限流算法。服务器维护一个固定大小的漏桶，每个请求被视为一个水滴。当一个请求到达时，服务器将水滴放入漏桶中。如果漏桶已经满了，则请求被拒绝。</li>
</ol>
<hr>
<h4 id="基于-Go-开发的分布式-KV-数据库"><a href="#基于-Go-开发的分布式-KV-数据库" class="headerlink" title="基于 Go 开发的分布式 KV 数据库"></a>基于 Go 开发的分布式 KV 数据库</h4><h5 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h5><h6 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h6><p>不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：</p>
<p>Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。</p>
<p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<ul>
<li><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li><strong>Candidate</strong>：Leader选举过程中的临时角色。</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221130979.png" alt="image-20230407221130979" style="zoom:50%;">

<p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。Raft算法角色状态转换如下：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221213065.png" alt="image-20230407221213065" style="zoom:50%;">

<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407221528931.png" alt="image-20230407221528931" style="zoom:50%;">

<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h6 id="二、Leader选举"><a href="#二、Leader选举" class="headerlink" title="二、Leader选举"></a>二、Leader选举</h6><p>Raft 使用心跳来维持 leader 身份。任何节点都以 follower 的身份启动。 leader 会定期的发送心跳给所有的 follower 以确保自己的身份。 每当 follower 收到心跳后，就刷新自己的 electionElapsed（当前经过的选举耗时），重新计时。</p>
<p>一旦一个 follower 在指定的时间内没有收到任何 RPC（称为 electionTimeout），则会发起一次选举。 当 follower 试图发起选举后，其身份转变为 candidate，在增加自己的 term 后， 会向所有节点发起 RequestVoteRPC 请求，candidate 的状态会一直持续直到：</p>
<ul>
<li>赢得选举</li>
<li>其他节点赢得选举</li>
<li>一轮选举结束，无人胜出</li>
</ul>
<p>选举的方式非常简单，谁能获取到多数选票 <code>(N/2 + 1)</code>，谁就成为 leader。 在一个 candidate 节点等待投票响应的时候，它有可能会收到其他节点心跳， 此时有两种情况：</p>
<ul>
<li>该请求的 term 和自己一样或更大：说明对方已经成为 leader，自己立刻退为 follower。</li>
<li>该请求的 term 小于自己：拒绝请求并返回当前 term 以让请求节点更新 term。</li>
</ul>
<p>安全性要求：</p>
<ul>
<li>日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大）拒绝投票给日志完整性低的候选人。比如节点B的任期编号为3，节点C的任期编号为4，节点B的最后一条日志项对应的任期编号为3，而节点C为2，那么当节点C请求节点B投票给自己时，节点B将拒绝投票</li>
</ul>
<p>为了防止在同一时间有太多的 follower 转变为 candidate 导致无法选出绝对多数， Raft 采用了随机选举超时（<code>randomized election timeouts</code>）的机制， 每一个 candidate 在发起选举后，都会随机化一个新的选举超时时间， 一旦超时后仍然没有完成选举，则增加自己的 term，然后发起新一轮选举。 在这种情况下，应该能在较短的时间内确认出 leader。 （因为 term 较大的有更大的概率压倒其他节点）</p>
<p>通过一个节点在一个 term 只能给一个节点投票，Raft 保证了对于给定的一个 term 最多只有一个 leader，从而避免了选举导致的 <code>split brain</code> 以确保 safety；通过不同节点每次随机化选举超时时间以确保 liveness。</p>
<blockquote>
<p>  “liveness” 问题指的是如何确保当网络分裂或节点故障时，系统仍然能够继续运行，并最终达成一致性.</p>
<p>  禁止节点对外提供服务：在 Raft 中，当节点开始发起领导者选举时，它会暂停对外提供服务，直到选举结束并成为领导者后才重新开始对外提供服务。通过这个机制，Raft 算法可以确保在选举期间系统不会出现不一致的情况。</p>
</blockquote>
<h6 id="三、日志同步-复制"><a href="#三、日志同步-复制" class="headerlink" title="三、日志同步 (复制)"></a>三、日志同步 (复制)</h6><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果</p>
<p>因为领导者的日志复制RPC消息或心跳消息，包含了当前最大的、将会被提交的日志项索引值。所以通过日志复制RPC消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407222412142.png" alt="image-20230407222412142" style="zoom:50%;">

<ol>
<li>接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中</li>
<li>领导者通过日志复制RPC，将新的日志复制到其他的服务器</li>
<li>当领导者将日志项成功复制到大多数的服务器上的时候，领导者会将这条日志项应用到它的状态机中</li>
<li>领导者将执行的结果返回给客户端</li>
<li>当跟随者接收到心跳消息，或者新的日志复制RPC消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没应用，那么跟随者就将这条日志项应用到本地的状态机上</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407223527749.png" alt="image-20230407223527749" style="zoom:50%;">

<p>Raft日志同步保证如下两点：</p>
<ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li>
</ul>
<p>第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。</p>
<p>一般情况下，Leader和Followers的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，Leader崩溃可能会导致日志不一致：旧的Leader可能没有完全复制完日志中的所有条目。</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230407224347287.png" alt="image-20230407224347287" style="zoom:50%;">

<p>上图阐述了一些Followers可能和新的Leader日志不同的情况。一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p>
<p>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。</p>
<p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</p>
<p>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目。</p>
<h6 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h6><p><strong>选举限制</strong>:</p>
<p>因为 leader 的强势地位，所以 Raft 在投票阶段就确保选举出的 leader 一定包含了整个集群中目前已 committed 的所有日志。</p>
<p>当 candidate 发送 RequestVoteRPC 时，会带上最后一个 entry 的信息。 所有的节点收到该请求后，都会比对自己的日志，如果发现自己的日志更新一些，则会拒绝投票给该 candidate。 </p>
<p>判断日志新旧的方式：获取请求的 entry 后，比对自己日志中的最后一个 entry。 首先比对 term，如果自己的 term 更大，则拒绝请求。 如果 term 一样，则比对 index，如果自己的 index 更大（说明自己的日志更长），则拒绝请求。</p>
<p><strong>提交限制：</strong></p>
<p>为什么需要 no-op 日志?</p>
<p>leader 永远只提交当前 term 的 entry， 过去的 entry 只会随着当前的 entry 被一并提交。 见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jzx05Q781ytMXrZ2wrm2Vg">博客</a></p>
<p><strong>节点崩溃：</strong></p>
<p>如果 leader 崩溃，集群中的所有节点在 electionTimeout 时间内没有收到 leader 的心跳信息就会触发新一轮的选主。总而言之，最终集群总会选出唯一的 leader 。按论文中的说法，计算一次 RPC 耗时高达 <code>30～40ms</code> 时，<code>99.9%</code> 的选举依然可以在 <code>3s</code> 内完成，但一般一个机房内一次 RPC 只需 1ms。当然，选主期间整个集群对外是不可用的。</p>
<p>如果 follower 和 candidate 奔溃相对而言就简单很多， 因为 Raft 所有的 RPC 都是幂等的，所以 Raft 中所有的请求，只要超时，就会无限的重试。follower 和 candidate 崩溃恢复后，可以收到新的请求，然后按照上面谈论过的追加或拒绝 entry 的方式处理请求。</p>
<p><strong>时间与可用性：</strong></p>
<p>Raft 原则上可以在绝大部分延迟情况下保证一致性， 不过为了保证选择和 leader 的正常工作，最好能满足下列时间条件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</span><br></pre></td></tr></table></figure>

<ul>
<li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li>
<li><code>electionTimeout</code>：follower 判定 leader 已经故障的时间（heartbeat 的最长容忍间隔）；</li>
<li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li>
</ul>
<p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>
<h6 id="五、日志压缩"><a href="#五、日志压缩" class="headerlink" title="五、日志压缩"></a>五、日志压缩</h6><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p>
<p>Snapshot中包含以下内容：</p>
<ul>
<li>日志元数据。最后一条已提交的 log entry的 index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</li>
<li>系统当前状态。</li>
</ul>
<p>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC。</p>
<p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p>
<p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p>
<h6 id="六、成员变更"><a href="#六、成员变更" class="headerlink" title="六、成员变更"></a>六、成员变更</h6><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408212943630.png" alt="image-20230408212943630" style="zoom:50%;">

<p>由于在分布式的系统中，每一个节点收到并执行配置变更指令的时间都是不完全一致的，因此系统可能出现上图所述的双leader的情况：</p>
<ul>
<li>对于server2来说，它此时还在Cold配置中，可以通过获得1、2的选票成为leader</li>
<li>对于server3来说，它已经处在Cnew配置中，可以获得3、4、5的选票成为leader</li>
</ul>
<p>这种情况下，5个节点出现了两个leader，直接违反了核心的Safety原则。</p>
<p>在这种情况下，一次变更一个节点能够保证不会出现两个leader的split。因为新的group和majority和旧的group的majority一定是overlap的。具体解释可以看论文中的图：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230408213627214.png" alt="image-20230408213627214" style="zoom:50%;">





<h6 id="七、Raft与Multi-Paxos的异同"><a href="#七、Raft与Multi-Paxos的异同" class="headerlink" title="七、Raft与Multi-Paxos的异同"></a>七、Raft与Multi-Paxos的异同</h6><h6 id="八、Raft算法总结"><a href="#八、Raft算法总结" class="headerlink" title="八、Raft算法总结"></a>八、Raft算法总结</h6><p>Raft算法各节点维护的状态：</p>
<p>对于一个Raft节点服务器来说，当宕机重新启动的时候，它必须恢复到宕机以前的状态。论文中提到了需要持久化的状态：currentTerm、voteFor、logs(全部)</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-9b53bd65fa9e11eeefd5331833d41c78_1440w.webp" alt="img" style="zoom:67%;">

<p>Leader选举：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-05b80ce9095004381b5846c6179f932e_r.jpg" alt="img" style="zoom:67%;">

<p>日志同步：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-8713b773762e9644c38defa5086afacd_r.jpg" alt="img" style="zoom:67%;">

<p>Raft状态机：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-4abb923772ec1be269843c977b5af3c8_r.jpg" alt="img" style="zoom:67%;">

<p>安装snapshot：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/v2-793f4024bfcb648d9aab2a3dfe6b80de_r.jpg" alt="img" style="zoom:67%;">





<hr>
<h5 id="分布式架构中handler和sender"><a href="#分布式架构中handler和sender" class="headerlink" title="分布式架构中handler和sender"></a>分布式架构中handler和sender</h5><p>具体来说，如果一个节点需要向其他节点发送消息，那么它就扮演 sender 角色。需要负责将消息打包成特定格式，然后将消息发送到目标节点。sender 节点需要考虑到网络状况、消息是否发送成功等问题，以确保消息能够被可靠地发送到目标节点。</p>
<p>如果一个节点需要接收并处理其他节点发送过来的消息，那么它就扮演 handler 角色。这个节点需要负责解析消息并根据消息的内容进行相应的处理。消息的处理可能包括更新本地数据、调用本地服务、向其他节点发送消息等操作。在处理消息的过程中，handler 节点需要考虑到系统的可用性、容错性等问题，以确保系统能够正常工作并避免数据丢失或错误。</p>
<hr>
<h5 id="在实现Raft的什么情况下不要持锁"><a href="#在实现Raft的什么情况下不要持锁" class="headerlink" title="在实现Raft的什么情况下不要持锁"></a>在实现Raft的什么情况下不要持锁</h5><ol>
<li>发送RPC或push channel时持有锁：如果发送方在发送RPC或push channel之前持有锁，则在接收方没有准备好接收时，它将无法释放锁并阻塞，这可能导致死锁。</li>
<li>接收RPC或pop channel时持有锁：如果接收方在接收RPC或pop channel之前持有锁，则发送方无法在接收方已准备好接收之前释放锁，这也可能导致死锁。</li>
</ol>
<p>因此，为避免死锁，应该尽量避免在发送RPC、push channel、接收RPC、pop channel时持有锁。相反，应该使用异步或非阻塞的方法来发送和接收信息。如果必须使用锁，则应确保在发送和接收信息之前释放锁，以便其他进程可以访问共享资源。</p>
<hr>
<h5 id="Raft-哪些-state-需要持久化，为什么"><a href="#Raft-哪些-state-需要持久化，为什么" class="headerlink" title="Raft 哪些 state 需要持久化，为什么"></a>Raft 哪些 state 需要持久化，为什么</h5><ol>
<li>currentTerm：当前节点所处的任期号；</li>
<li>votedFor：当前节点在当前任期内投票给了哪个节点；</li>
<li>logs：当前节点保存的日志。</li>
<li>已知的最大的已经被提交的日志条目的索引值（commitIndex）：Raft 确保所有节点都应用了相同的日志条目</li>
<li>每个节点的最后一条日志条目的索引值（lastApplied）：Raft 通过复制日志来实现一致性</li>
</ol>
<p>这些状态信息对于Raft算法的正常运行非常关键，需要在所有节点之间保持一致。如果这些状态信息在不同节点之间不一致，就可能导致Raft算法的执行出现问题。</p>
<p>而其他节点信息，如节点的ID、地址等信息通常不会发生变化，因此可以不用进行序列化和反序列化。这些信息可以在节点启动时从配置文件或其他来源中读取，并在整个运行期间保持不变。因此，这些信息不会影响节点之间的一致性。</p>
<hr>
<h5 id="commit和apply的区别"><a href="#commit和apply的区别" class="headerlink" title="commit和apply的区别"></a>commit和apply的区别</h5><p>Commit（提交）是指Leader将一个日志条目成功复制到了大多数的Follower节点的日志中，并将该条目标记为已提交。在Raft中，只有被提交的日志条目才能被应用到状态机中</p>
<p>Apply（应用）是指将已提交的日志条目应用到状态机中，以便状态机的状态能够更新到与Leader节点相同的状态。Apply的过程是在每个节点上独立进行的，而Commit的过程是在整个Raft集群中协同进行的。</p>
<h6 id="commitIndex-与-applyIndex"><a href="#commitIndex-与-applyIndex" class="headerlink" title="commitIndex 与 applyIndex"></a>commitIndex 与 applyIndex</h6><p>它们的关系是 commitIndex &lt;&#x3D; applyIndex。因为只有被commit 的指令才能被应用到状态机中</p>
<p>在 Raft 算法中，只有被大多数节点确认的指令才能被认为是已提交的。这意味着在 commitIndex 确定之前，即使 Leader 已经确认了某些指令，它们也不会被认为是已提交的。只有当 commitIndex 更新到这些指令的索引时，它们才会被认为是已提交的。</p>
<p>需要注意的是，applyIndex 和 commitIndex 都是需要持久化的，以确保系统在节点宕机或网络故障等情况下能够恢复状态。</p>
<hr>
<h5 id="raftstate和snapshot的区别"><a href="#raftstate和snapshot的区别" class="headerlink" title="raftstate和snapshot的区别"></a>raftstate和snapshot的区别</h5><p><code>raftstate</code> 是用来记录当前节点的状态机信息的，包括节点已经提交但未被应用的日志项、已知的最新领导人、节点当前的角色等。每个节点都需要定期将自己的 <code>raftstate</code> 发送给其他节点，以便其他节点了解该节点的状态，并在需要的时候进行状态同步。因此，<code>raftstate</code> 是用于节点之间的状态同步的。</p>
<p><code>snapshot</code> 则是用来记录节点状态机的快照的，以便节点在某些情况下可以通过快照来恢复其状态机。当节点的状态机变得太大，无法通过网络传输，或者由于节点加入或离开导致节点的状态机需要重新同步时，就会使用快照来进行状态机的同步。快照通常包含状态机中的部分信息，以及最后一个已知的日志项的索引，以便节点在接收快照后恢复到正确的状态。</p>
<p>因此，<code>raftstate</code> 和 <code>snapshot</code> 都是用于记录节点状态机信息的数据，但是它们的作用和用途不同。<code>raftstate</code> 用于节点之间的状态同步，而 <code>snapshot</code> 用于恢复节点的状态机。</p>
<hr>
<h5 id="如何确保-applier-的-exactly-once"><a href="#如何确保-applier-的-exactly-once" class="headerlink" title="如何确保 applier 的 exactly once"></a>如何确保 applier 的 exactly once</h5><p>对于异步 apply，其触发方式无非两种，1. leader 提交了新的日志 2.follower 通过 leader 发来的 leaderCommit 来更新 commitIndex。很多人实现的时候可能顺手就在这两处分别异步开启一个goroutine把 [lastApplied + 1, commitIndex] 的 entry push 到 applyCh 中，但其实这样子是可能重复发送 entry 的，原因是 push applyCh 的过程不能够持锁，那么这个 lastApplied 在没有 push 完之前就无法得到更新，从而可能被多次调用。</p>
<p>虽然只要上层服务可以保证不重复 apply 相同 index 的日志到状态机就不会有问题，但这样的做法是不优雅的。考虑到异步 apply 时最耗时的步骤是 push channel 和 apply 日志到状态机，其他的都不怎么耗费时间。因此我们完全可以只用一个 applier 协程，让其不断的把 [lastApplied + 1, commitIndex] 区间的日志 push 到 applyCh 中去。这样既可保证每一条日志只会被 exactly once 地 push 到 applyCh 中，也可以使得日志 apply 到状态机和 raft 提交新日志可以真正的并行。</p>
<hr>
<h5 id="为什么-Leader-不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志-为什么需要-no-op-日志"><a href="#为什么-Leader-不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志-为什么需要-no-op-日志" class="headerlink" title="为什么 Leader 不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志?  为什么需要 no-op 日志?"></a>为什么 Leader <strong>不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志</strong>?  为什么需要 no-op 日志?</h5><ol>
<li><p>如果Leader能提交之前任期的日志, 则同一index 的日志可能会被提交了多次,每次的term不一样</p>
</li>
<li><p>no-op 日志即只有 index 和 term 信息，command 信息为空。也是要写到磁盘存储的。为了解决如果一直没新的请求进来最新的日志不能被提交的问题</p>
<p>具体流程是在 Leader 刚选举成功的时候，立即追加一条 no-op 日志，并立即复制到其它节点，no-op 日志一经提交，Leader 前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了 no-op 日志之后，Leader 就能快速响应客户端查询了。本质上，no-op 日志使 Leader 隐式地快速提交之前任期未提交的日志，确认当前 <code>commitIndex</code>，这样系统才会快速对外正常工作。</p>
</li>
</ol>
<hr>
<h5 id="说一说raft算法的快照机制"><a href="#说一说raft算法的快照机制" class="headerlink" title="说一说raft算法的快照机制"></a>说一说raft算法的快照机制</h5><p>Raft算法的快照机制是用来减少存储在日志中的数据量和提高性能的一种机制。当系统中的状态机状态更新时，Raft算法会将状态机状态持久化到日志中。但是，如果不对日志进行限制，日志会不断增长，导致系统性能下降。</p>
<p>为了解决这个问题，Raft算法使用了快照机制。快照机制是通过将状态机的快照存储到磁盘上，从而缩减了日志的长度。当系统中的日志长度达到一定值时，Raft算法会自动触发快照机制，生成一个快照并将其存储到磁盘上。</p>
<p>在Raft算法中，每个节点都有自己的快照，并且在成为leader之前，follower节点的快照必须和leader节点的快照一致。为了保证节点间的一致性，leader节点会周期性地向follower节点发送快照信息。follower节点会根据接收到的快照信息来更新自己的状态机状态，从而保证节点间的状态一致。</p>
<hr>
<h5 id="raft在什么时候安装快照"><a href="#raft在什么时候安装快照" class="headerlink" title="raft在什么时候安装快照"></a>raft在什么时候安装快照</h5><ol>
<li>日志长度过长</li>
</ol>
<p>当系统中的日志长度达到一定值时，Raft算法会触发快照机制，生成一个快照并将其存储到磁盘上。这是因为随着系统运行时间的增加，日志的长度会不断增长，导致系统性能下降，因此需要通过安装快照来减少日志的长度。</p>
<ol start="2">
<li>崩溃恢复</li>
</ol>
<p>当系统发生故障或崩溃后，Raft算法会使用快照来进行恢复。在这种情况下，Raft算法会先从磁盘上读取最近的快照，然后通过读取该快照之后的日志来恢复系统状态。这是因为在发生故障或崩溃时，系统的状态可能已经落后于最新的快照，因此需要通过读取最近的快照来恢复系统状态。</p>
<p>需要注意的是，在安装快照时，Raft算法会将快照应用到状态机上，并更新节点的状态，以保证节点间的一致性。同时，Raft算法还会向其他节点发送更新信息，以通知它们快照已经被安装。</p>
<hr>
<h5 id="Raft-的优化"><a href="#Raft-的优化" class="headerlink" title="Raft 的优化"></a>Raft 的优化</h5><blockquote>
<p>  如果集群有一个节点网络延迟很大，可能每隔一段时间它就收不到leader的心跳，然后发起投票。而它的currTerm又高于leader，导致leader变成follower，最终导致整个集群的可用性很低？</p>
</blockquote>
<p>使用分布式缓存可以解决该问题，因为分布式缓存可以将数据缓存在节点之间，这样在节点之间的数据读写时就可以减少网络传输的数据量，从而减少网络延迟。</p>
<p>当一个节点的网络延迟很大时，可能会导致该节点无法及时响应leader节点的心跳信号，并导致发起选举。在这种情况下，如果使用分布式缓存系统如Redis等，可以将数据缓存在节点之间，这样就可以在多个节点之间共享数据。当需要访问该数据时，可以直接从缓存中读取，而不是每次都从远程节点读取。这样可以减少节点之间的数据传输量，从而减少网络延迟，降低选举的发生率。</p>
<p>当一个节点的网络延迟很大时，可能会导致该节点无法及时响应心跳信号，并导致发起选举。如果使用分布式缓存，节点之间可以缓存一些数据，当需要访问该数据时，可以直接从缓存中读取，而不是每次都从远程节点读取。这样可以减少节点之间的数据传输量，从而减少网络延迟，降低选举的发生率。</p>
<p>此外，使用分布式缓存还可以提高系统的读写性能。当多个节点都需要访问同一份数据时，可以将数据缓存在多个节点中，这样可以避免单个节点的瓶颈，提高整个系统的读写性能。</p>
<hr>
<h5 id="KV存储的客户端和服务器端模型"><a href="#KV存储的客户端和服务器端模型" class="headerlink" title="KV存储的客户端和服务器端模型"></a>KV存储的客户端和服务器端模型</h5><p>对于 raft 的日志序列，状态机需要按序 apply 才能保证不同节点上数据的一致性，因此，在实现中服务器端一定得有一个单独的 apply 协程去顺序的 apply 日志到状态机中去。</p>
<p>对于客户端的Command请求，在服务器端 rpc 框架也会生成一个线程Command去处理逻辑。</p>
<p>为此，我的实现是：</p>
<ol>
<li>服务器 将日志传递raft 层，调用Raft的Start(),  用于在 Leader 节点接收到新的客户端请求时，将客户端请求转化为日志条目, 并将这些条目复制到所有节点的日志中，从而实现状态的一致性.</li>
<li>服务器 随即注册一个 channel 去阻塞等待，我们在启动服务器的时候开启一个applier 线程监控 applyCh，在得到 raft 层已经 commit 的日志后，applier 协程首先将其 apply 到状态机中，接着根据 index 得到对应的 channel ，最后将状态机执行的结果 push 到 channel 中</li>
<li>这使得客户端能够解除阻塞并得到结果。对于这种只需通知一次的场景，这里使用 channel 而不是 cond 的原因是理论上一条日志被路由到 raft 层同步后，客户端call Command协程拿锁注册 notifyChan 和 applier 协程拿锁执行该日志再进行 notify 之间的拿锁顺序无法绝对保证，虽然直观上感觉应该一定是前者先执行，但如果是后者先执行了，那前者对于 cond 变量的 wait 就永远不会被唤醒了，那情况就有点糟糕了。</li>
</ol>
<p>在目前的实现中，读请求也会生成一条 raft 日志去同步，这样可以以最简单的方式保证线性一致性。</p>
<hr>
<h5 id="如果一个-Raft-Group-中存在多个-Learner，如何防止多个-Learner-同时同步数据给-Leader-造成压力"><a href="#如果一个-Raft-Group-中存在多个-Learner，如何防止多个-Learner-同时同步数据给-Leader-造成压力" class="headerlink" title="如果一个 Raft Group 中存在多个 Learner，如何防止多个 Learner 同时同步数据给 Leader 造成压力"></a>如果一个 Raft Group 中存在多个 Learner，如何防止多个 Learner 同时同步数据给 Leader 造成压力</h5><hr>
<h5 id="raft算法中，follower收到一个日志后发现有冲突怎么办"><a href="#raft算法中，follower收到一个日志后发现有冲突怎么办" class="headerlink" title="raft算法中，follower收到一个日志后发现有冲突怎么办"></a>raft算法中，follower收到一个日志后发现有冲突怎么办</h5><p>Follower 会采取以下步骤来解决冲突：</p>
<ol>
<li>拒绝接受 Leader 发送的冲突日志。Follower 会向 Leader 发送拒绝响应（AppendEntries RPC 响应）并包含自己的日志中下一个条目的索引（即与 Leader 发送的日志冲突的第一个条目的索引加 1）。</li>
<li>Leader 收到拒绝响应后会尝试减少它的日志匹配的索引。Leader 会将自己的 nextIndex 减少到收到拒绝响应的 Follower 日志索引的位置。</li>
<li>Leader 重试向 Follower 发送日志。在减小 nextIndex 后，Leader 将重试发送上次被拒绝的日志条目。如果仍然发生冲突，Leader 将继续减小 nextIndex 并重试，直到成功地将日志复制到 Follower 中为止。</li>
<li>一旦 Leader 成功地将日志条目复制到 Follower 中，它会更新 Follower 的匹配索引。Leader 会将 Follower 的 matchIndex 更新为最新复制的日志条目的索引，然后继续发送后续的日志条目。</li>
</ol>
<p>总之，当 Follower 收到冲突的日志时，它会拒绝该日志并返回自己的下一个条目的索引，Leader 将根据此更新自己的 nextIndex 并重试发送日志，直到成功为止。这样可以确保 Raft 群集中所有的节点最终保持一致的日志。</p>
<hr>
<h5 id="说说-ACID和CAP"><a href="#说说-ACID和CAP" class="headerlink" title="说说 ACID和CAP"></a>说说 ACID和CAP</h5><p>ACID 是一种<strong>数据管理的事务处理模型</strong>，而 CAP 是分布式计算中的一个理论</p>
<p>C 和 CAP 中的 C： 在 CAP 理论中，C 指的是一致性（Consistency），而在 ACID 中，C 指的是另一个特性，即一致性（Consistency）。虽然它们都叫做一致性，但是它们的含义和应用场景却不同。在 ACID 中，一致性指的是数据在事务执行前后保持一致的状态；而在 CAP 中，一致性指的是在分布式系统中，当多个节点同时对同一数据进行操作时，最终结果必须保证一致。</p>
<p>CAP： CAP 理论指的是在分布式计算中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三个特性无法同时满足的问题。其中：</p>
<ul>
<li>一致性（Consistency）指的是所有节点有效的数据是一致的；</li>
<li>可用性（Availability）指的是系统必须保证每个请求都能收到响应；</li>
<li>分区容错性（Partition tolerance）指的是系统在遇到网络故障等分区情况时仍能正常运行。</li>
</ul>
<p>CAP 理论认为，在分布式系统中，由于网络通信的不可靠性和不确定性，无法同时满足这三个特性，因此需要根据具体的应用场景进行选择。例如，对于金融领域这样需要强一致性的场景，可以牺牲可用性来保证一致性；而对于社交网络这样需要高可用性的场景，可以在一定程度上放弃一致性来换取可用性和分区容错性。</p>
<p>CAP 理论的实现主要依赖于分布式数据存储技术和分布式一致性算法。常见的分布式存储技术包括关系型数据库的分布式部署、NoSQL 数据库、分布式文件系统等。而分布式一致性算法则包括 Paxos、Raft、Zab 等。这些算法的主要目标是保证数据在多个节点之间的一致性，实现 CAP 中的一致性特性。</p>
<hr>
<h5 id="说说读优化"><a href="#说说读优化" class="headerlink" title="说说读优化"></a>说说读优化</h5><p>在目前的实现中，读请求也会生成一条 raft 日志去同步，这样可以以最简单的方式保证线性一致性。当然，这样子实现的读性能会相当的差，实际生产级别的 raft 读请求实现一般都采用了 Read Index</p>
<p>由于只读请求并没有需要写入的数据，因此并不需要将其写入Raft日志，而只需要关注收到请求时leader的commit index。只要在该commit index被应用到状态机后执行读操作，就能保证其线性一致性。因此使用了ReadIndex的leader在收到只读请求时，会按如下方式处理：</p>
<p>记录当前的commit index，作为read index;<br>向集群中的所有节点广播一次心跳，如果收到了数量达到quorum的心跳响应，leader可以得知当收到该只读请求时，其一定是集群的合法leader;<br>继续执行，直到leader本地的apply index大于等于之前记录的read index。此时可以保证只读操作的线性一致性;<br>让状态机执行只读操作，并将结果返回给客户端。</p>
<hr>
<h5 id="Raft如何实现线性语义"><a href="#Raft如何实现线性语义" class="headerlink" title="Raft如何实现线性语义"></a>Raft如何实现线性语义</h5><p>Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，Raft 是可以执行同一条命令多次的：例如，如果leader在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的leader重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p>
<hr>
<h4 id="工程问题"><a href="#工程问题" class="headerlink" title="工程问题"></a>工程问题</h4><h5 id="❤️检测内存泄漏-用top发现虚拟内存在涨"><a href="#❤️检测内存泄漏-用top发现虚拟内存在涨" class="headerlink" title="❤️检测内存泄漏(用top发现虚拟内存在涨)"></a>❤️检测内存泄漏(用top发现虚拟内存在涨)</h5><p>线上系统要做好热更新，方便随时打开内存调试。 <code>#if  mem = 1  #endif</code></p>
<h6 id="法一-malloc-stats-和-malloc-info-0-stdout"><a href="#法一-malloc-stats-和-malloc-info-0-stdout" class="headerlink" title="法一:  malloc_stats() 和 malloc_info(0, stdout)"></a><strong>法一:</strong>  malloc_stats() 和 malloc_info(0, stdout)</h6><p>检测具体函数的内存泄漏: gdb中打断点配合调用malloc_stats()函数 <code>call malloc_stats()</code></p>
<p>函数执行前后调用<code>call malloc_info(0, stdout)</code>输出内存,比较</p>
<h6 id="法二：宏定义"><a href="#法二：宏定义" class="headerlink" title="法二：宏定义"></a>法二：宏定义</h6><p>创建一个文件夹。每次malloc的时候在其中创建一个文件，文件名是本次malloc申请的内存地址。free的时候去该文件夹中查找与没有 那个名为那个地址的文件，有的话就删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _malloc(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%s:%d]_malloc:%ld,ptr:%p\n&quot;</span>, filename, line, size, p);</span><br><span class="line">    <span class="built_in">fflush</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _free(<span class="type">void</span> *p, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>)&#123; <span class="comment">// 删除失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;[-%s:%d]_free:%p\n&quot;, filename, line, p);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) _malloc(size, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) _free(ptr, __FILE__, __LINE__)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230222155844859.png" alt="image-20230222155844859"></p>
<h6 id="法三：-hook截获malloc和free-dlsym改成自定义的"><a href="#法三：-hook截获malloc和free-dlsym改成自定义的" class="headerlink" title="法三： hook截获malloc和free, dlsym改成自定义的"></a>法三： hook截获malloc和free, dlsym改成自定义的</h6> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">malloc_t</span> malloc_f; <span class="comment">// malloc_f 是 malloc_t 类型的函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="type">free_t</span> free_f;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> enable_malloc_hook = <span class="number">1</span>, enable_free_hook = <span class="number">1</span>; <span class="comment">// 防止malloc中循环调用malloc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_malloc_hook)&#123;</span><br><span class="line">        enable_malloc_hook = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *p = <span class="built_in">malloc_f</span>(size);</span><br><span class="line">        <span class="type">void</span> *caller = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%p]malloc --&gt; addr:%p size:%lu\n&quot;</span>, caller, p, size);</span><br><span class="line">        <span class="built_in">fflush</span>(fp);</span><br><span class="line"></span><br><span class="line">        enable_malloc_hook = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">malloc_f</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_free_hook)&#123;</span><br><span class="line">        enable_free_hook = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="built_in">free_f</span>(p);</span><br><span class="line">        </span><br><span class="line">        enable_free_hook = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">free_f</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有malloc和free包括第三方库中的，走我们自定义的那一段</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init_hook</span><span class="params">()</span></span>&#123;</span><br><span class="line">    malloc_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">// 获取 malloc 地址为 malloc_f, 因此调用malloc_f等价于调用malloc</span></span><br><span class="line">    free_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -o memleak_0 memleak_0.c -ldl -g </span></span><br><span class="line"><span class="comment">// addr2line -f -e  memleak_0 -a 0x4006d8   （-f表示file -e表示execute -a表示代码段地址）可以查看 内存泄漏的行数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init_hook</span>();</span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="法四：-mtrace"><a href="#法四：-mtrace" class="headerlink" title="法四： mtrace"></a>法四： mtrace</h6><p>mtrace() 函数中会为那些和动态内存分配有关的函数（譬如 malloc()、realloc()、memalign() 以及 free()）安装 “钩子（hook）” 函数，这些 hook 函数会为我们记录所有有关内存分配和释放的跟踪信息，而 muntrace() 则会卸载相应的 hook 函数。基于这些 hook 函数生成的调试跟踪信息，我们就可以分析是否存在 “内存泄露” 这类问题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">mtrace</span>();  <span class="comment">// 开始跟踪</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">muntrace</span>();   <span class="comment">// 结束跟踪，并生成日志信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test  <span class="comment">// 一定加上 -g 能够帮我们定位代码中的具体位置，否则看到的只是执行文件中的地址信息</span></span><br></pre></td></tr></table></figure>

<p>mtrace 机制需要我们实际运行一下程序，然后才能生成跟踪的日志，但在实际运行程序之前还有一件要做的事情是需要告诉 mtrace生成日志文件的路径。具体的方法是通过定义并导出一个环境变量 “MALLOC_TRACE”，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> MALLOC_TRACE=./test.log  <span class="comment">// 当前目录下</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200347354.png" alt="image-20230226200347354"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200602769.png" alt="image-20230226200602769"></p>
<hr>
<h5 id="查看链接了哪些动态库和第三方库有无内存泄漏"><a href="#查看链接了哪些动态库和第三方库有无内存泄漏" class="headerlink" title="查看链接了哪些动态库和第三方库有无内存泄漏"></a>查看链接了哪些动态库和第三方库有无内存泄漏</h5><ul>
<li>查看链接了哪些动态库</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ldd a.so	<span class="comment">//查看SO文件的动态链接库</span></span><br><span class="line">nm -D a.so	<span class="comment">//查看so文件的函数列表</span></span><br><span class="line">objdump -tT a.so	<span class="comment">//查看so文件的导出函数及源文件等信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Linux&#x2F;unix 提供了使用 dlopen 和 dlsym 方法动态加载库和调用函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开指定的动态库，返回的是该动态库的handle，在dlsym，dlclose中将继续使用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// RTLD_LAZY 暂缓决定，等有需要时再解出符号 </span></span><br><span class="line"><span class="comment">// RTLD_NOW 立即决定，返回前解除所有未决定的符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看错误信息</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">dlerror</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获得对应的函数或变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="comment">//关闭打开的动态库</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="c-程序崩溃定位方法"><a href="#c-程序崩溃定位方法" class="headerlink" title="c++程序崩溃定位方法"></a>c++程序崩溃定位方法</h5><ol>
<li><p>使用调试器</p>
<p>使用调试器是定位程序崩溃的最常用方法之一。你可以使用诸如GDB或Visual Studio等调试器。调试器能够提供有关程序崩溃的详细信息，如程序的状态、变量值、函数调用堆栈等。</p>
</li>
<li><p>输出调试信息</p>
<p>在程序中插入调试信息，可以帮助你了解程序崩溃的位置和原因。你可以在关键位置打印变量的值或者调用函数，以确定程序执行到哪里就崩溃了。</p>
</li>
<li><p>内存检测工具</p>
<p>使用内存检测工具可以帮助你检测内存泄漏、野指针等问题。例如，使用mtrace, Valgrind可以在Linux环境下检测内存问题。</p>
</li>
<li><p>静态代码分析工具</p>
<p>使用静态代码分析工具可以帮助你找到潜在的代码缺陷，例如未初始化的变量、函数调用不匹配等。例如，Cppcheck是一款常用的静态代码分析工具。</p>
</li>
<li><p>测试用例</p>
<p>编写测试用例可以帮助你定位程序崩溃的原因。测试用例应该包含各种输入和边界条件，以确保程序能够处理各种情况。如果测试用例能够触发程序崩溃，就可以进一步分析和修复问题。</p>
</li>
</ol>
<hr>
<h5 id="git-如何查看远程服务器分支"><a href="#git-如何查看远程服务器分支" class="headerlink" title="git 如何查看远程服务器分支"></a>git 如何查看远程服务器分支</h5><p>要查看远程服务器上的分支，可以使用 <code>git branch -r</code> 该命令会显示所有已知的远程分支列表。</p>
<p>如果你想查看特定远程分支的详细信息，可以使用 <code>git show &lt;remote-name&gt;/&lt;branch-name&gt;</code> 命令，其中 <code>remote-name</code> 是远程服务器的名称，<code>branch-name</code> 是要查看的分支名称。例如，要查看名为 <code>master</code> 的远程分支的详细信息，可以运行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git show origin/master</span><br></pre></td></tr></table></figure>

<p>请注意，在使用此命令之前，你需要先确保已经将远程分支拉取到本地仓库中，否则该命令将无法正常工作。可以使用 <code>git fetch</code> 命令将远程分支更新到本地仓库</p>
<h3 id="6️⃣其他"><a href="#6️⃣其他" class="headerlink" title="6️⃣其他"></a>6️⃣其他</h3><h4 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h4><h5 id="沙漏计时问题"><a href="#沙漏计时问题" class="headerlink" title="沙漏计时问题"></a>沙漏计时问题</h5><p>有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>两个沙漏同时倒置开始计时，等小沙漏漏完，大沙漏还剩<span class="number">2</span>分钟，这时倒置小沙漏继续计时；</span><br><span class="line"><span class="number">2.</span>大沙漏漏完小沙漏还剩<span class="number">4</span>分钟，再把大沙漏倒置继续计时；</span><br><span class="line"><span class="number">3.</span>小沙漏漏完大沙漏还剩<span class="number">4</span>分钟，这时准备工作已经完毕；</span><br><span class="line"><span class="number">4.</span>等待大沙漏漏完（<span class="number">4</span>分钟）+小沙漏（<span class="number">6</span>分钟）=<span class="number">10</span>分钟。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="吃药片问题"><a href="#吃药片问题" class="headerlink" title="吃药片问题"></a>吃药片问题</h5><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 把手上的三片药各自切成两半，分成两堆摆放；</span><br><span class="line"><span class="number">2.</span> 再取出一粒药片 A，也把它切成两半，然后在每一堆里加上半片的 A；</span><br><span class="line"><span class="number">3.</span> 现在，每一堆药片恰好包含两个半片的 A 和两个半片的 B；</span><br><span class="line"><span class="number">4.</span> 一天服用其中一堆即可。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="老鼠毒药问题"><a href="#老鼠毒药问题" class="headerlink" title="老鼠毒药问题"></a>老鼠毒药问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤一： 给所有瓶子转化为二进制</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0000000001</span></span><br><span class="line"><span class="number">2</span>：<span class="number">0000000010</span></span><br><span class="line"><span class="number">3</span>：<span class="number">0000000011</span></span><br><span class="line"><span class="number">4</span>：<span class="number">0000000100</span></span><br><span class="line">.....<span class="number">.1000</span>：<span class="number">1111101000</span> </span><br><span class="line"><span class="comment">// 步骤二： 让第i只老鼠喝二进制表示第i位为一的所有瓶子</span></span><br><span class="line"><span class="comment">// 一星期后看第几只老鼠死了, 比如第1,3,5只死了, 则毒药编号就是 1010100000</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="箱子开锁问题"><a href="#箱子开锁问题" class="headerlink" title="箱子开锁问题"></a>箱子开锁问题</h5><p>A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> A 把药放进箱子，用自己的锁把箱子锁上；</span><br><span class="line"><span class="number">2.</span> B 拿到箱子后，再在箱子上加一把自己的锁；</span><br><span class="line"><span class="number">3.</span> 箱子运回 A 后，A 取下自己的锁；</span><br><span class="line"><span class="number">4.</span> 箱子再运到 B 手中时，B 取下自己的锁，获得药物。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="人鬼过桥问题"><a href="#人鬼过桥问题" class="headerlink" title="人鬼过桥问题"></a>人鬼过桥问题</h5><p>有三个人跟三个鬼要过河，河上没桥只有条小船，然后船一次只能渡一个人和一个鬼，或者两个鬼和两个人，无论在哪边岸上，只有是人比鬼少的情况下（如两鬼一人，三鬼两人，三鬼一人），人会被鬼吃掉，然而船有一定需要人或鬼操作才能航行（要有人或鬼划船），问，如何安全的把三人三鬼渡过河对岸？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 先两鬼过去，再一鬼回来。此时，对面有一鬼，这边有三人两鬼；</span><br><span class="line"><span class="number">2.</span> 再两鬼过去，再一鬼回来。此时对面有两鬼，这边有三人一鬼；</span><br><span class="line"><span class="number">3.</span> 再两人过去，一人一鬼回来。此时，对面一人一鬼。这边两人两鬼；</span><br><span class="line"><span class="number">4.</span> 最后两人过去，一鬼回来。此时，对面三人，这边三鬼；</span><br><span class="line"><span class="number">5.</span> 剩下的就三个鬼，两个过去，一个回来再接另外一个鬼就结束了。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="赛马找最快的马匹"><a href="#赛马找最快的马匹" class="headerlink" title="赛马找最快的马匹"></a>赛马找最快的马匹</h5><p>25匹马5条跑道找最快的3匹马，需要跑几次？参考回答：7</p>
<p>64匹马8条跑道找最快的4匹马，需要跑几次？参考回答：11</p>
<p>25匹马5条跑道找最快的5匹马，需要跑几次？参考回答：最少8次最多9次</p>
<h6 id="25匹马5条跑道找最快的3匹马"><a href="#25匹马5条跑道找最快的3匹马" class="headerlink" title="25匹马5条跑道找最快的3匹马"></a>25匹马5条跑道找最快的3匹马</h6><p>将25匹马分成ABCDE5组，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5，这里比赛5次</p>
<p>第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1</p>
<p>D1，E1肯定进不了前3，直接排除掉。 第7次，B1 C1 A2 B2 A3比赛，可以找出第二，第三名</p>
<h6 id="64匹马8条跑道找最快的4匹马"><a href="#64匹马8条跑道找最快的4匹马" class="headerlink" title="64匹马8条跑道找最快的4匹马"></a><strong>64匹马8条跑道找最快的4匹马</strong></h6><p>第一步：全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名</p>
<p>第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马。这个时候总冠军已经诞生，它就是这场比赛第一名</p>
<p>第三步：可能是前四名的只能是下面淡黄色的9只，随机选出8匹马进行一次比赛</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230309193955191.png" alt="image-20230309193955191" style="zoom:50%;">

<p>第四步：上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，就和前三名比一比，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了</p>
<h4 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h4><h4 id="—"><a href="#—" class="headerlink" title="—"></a>—</h4><h4 id="如何将敏捷开发应用到项目中"><a href="#如何将敏捷开发应用到项目中" class="headerlink" title="如何将敏捷开发应用到项目中"></a>如何将敏捷开发应用到项目中</h4><p>敏捷开发是一种以人为本、迭代、快速响应变化的软件开发方法。</p>
<p>1.明确需求：与利益相关者合作，以确定项目需求，以及确定优先级和业务价值。</p>
<p>2.规划Sprint：根据需求，规划一系列Sprint，每个Sprint都是一个短期的开发周期，通常为1到4周。</p>
<p>3.制定任务：将每个Sprint拆分为可管理的任务，每个任务都应该很小且具体，以便在Sprint期间完成。</p>
<p>4.持续开发和集成：在Sprint期间，团队成员应该持续进行开发，并将代码集成到主干分支中，以便进行测试和审查。</p>
<p>5.持续交付：在每个Sprint结束时，将交付可用的软件功能，以便利益相关者进行测试和反馈。</p>
<p>6.迭代和反馈：利用利益相关者的反馈，对需求进行迭代，并对Sprint计划进行调整。</p>
<p>7.持续集成和交付：在整个开发过程中，应该持续集成和交付可用的软件功能。</p>
<p>8.团队合作：敏捷开发强调团队合作和通信，团队成员应该经常交流和协作，以确保项目的顺利开展。</p>
<p>9.自我评估：在每个Sprint结束时，团队应该进行自我评估，以确定在下一个Sprint中需要改进的方面。</p>
<h4 id="介绍下鸿蒙系统"><a href="#介绍下鸿蒙系统" class="headerlink" title="介绍下鸿蒙系统"></a>介绍下鸿蒙系统</h4><p>鸿蒙（HarmonyOS）是一款分布式操作系统，由华为公司开发。它可以运行在各种智能终端设备上，包括手机、电视、智能手表、汽车信息娱乐系统等。鸿蒙系统采用了微内核架构和分层设计，具有高效稳定、安全可靠、灵活多样的特点。其最大特点是分布式能力，可以实现设备之间的协同工作和资源共享。</p>
<p>鸿蒙系统的分布式能力是其最大的优势之一，通过分布式协同能力，多个鸿蒙系统的设备可以组成一个虚拟超级设备，共同提供服务，实现信息的流动和资源的共享。例如，在鸿蒙系统上，用户可以将手机、电视和智能手表连接在一起，实现无缝切换和协同工作，让用户体验更加流畅和便捷。</p>
<p>另一个优势是鸿蒙系统的安全性能。鸿蒙系统采用了分层设计，将不同的硬件和应用服务分为核心系统层、驱动层和应用层，实现了更好的应用隔离和安全保障。此外，鸿蒙系统采用了多种安全技术和机制，包括安全芯片、安全通信、安全启动等，确保用户的数据和隐私得到充分的保护。</p>
<p>不过，鸿蒙系统也存在一些不足之处。首先，目前鸿蒙生态还不够完善，相比于市场上主流的操作系统，鸿蒙应用数量和种类还相对较少。其次，由于鸿蒙系统的推广时间较短，一些第三方应用和设备还未完全适配鸿蒙系统，可能存在一些兼容性问题。此外，鸿蒙系统也需要面对来自竞争对手的激烈竞争，以及应对安全漏洞和网络攻击等挑战。</p>
<h4 id="微内核架构有什么特点"><a href="#微内核架构有什么特点" class="headerlink" title="微内核架构有什么特点"></a>微内核架构有什么特点</h4><p>微内核架构是一种操作系统设计模式，其核心思想是将操作系统内核中的大部分功能剥离出来，构建成一个小巧的内核，只保留最基本的功能，如进程管理、内存管理和线程调度等。其他的操作系统功能则通过进程间通信（IPC）的方式在用户空间实现，这样可以提高系统的稳定性、安全性和可维护性。微内核架构有以下几个主要特点：</p>
<ol>
<li>简洁、可靠：微内核架构将操作系统内核中的大部分功能剥离出来，只保留最基本的功能，简化了内核的设计和实现，可以提高内核的可靠性。</li>
<li>灵活、可扩展：由于微内核架构将大部分操作系统功能移到用户空间实现，因此可以方便地对系统进行功能扩展和修改，具有很强的灵活性。</li>
<li>安全、可维护：微内核架构将操作系统功能拆分成多个独立的进程，通过进程间通信实现功能交互，使得系统中的每个功能模块都可以独立运行和维护，从而提高系统的安全性和可维护性。</li>
<li>性能：尽管微内核架构会引入额外的进程间通信开销，但由于内核只保留了最基本的功能，相比于传统的宏内核架构，微内核架构具有更好的性能表现。</li>
</ol>
<h4 id="谈谈对加班的看法"><a href="#谈谈对加班的看法" class="headerlink" title="谈谈对加班的看法"></a>谈谈对加班的看法</h4><p>第一种：上级不知道如何提高公司的效率，也没有清晰的规划，只能依靠强行制度化的加班，让员工背锅，缓解自身的焦虑感。</p>
<p>第二种：有规划，有方法，有希望 地加班，我可以接受</p>
<h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><p>中短期内我希望把重心仍然放在能否高质量的按时的完成公司的任务上，无论是什么技术栈，</p>
<h4 id="了解荣耀吗"><a href="#了解荣耀吗" class="headerlink" title="了解荣耀吗"></a>了解荣耀吗</h4><p>荣耀（Honor）是一家中国智能手机品牌，成立于2013年。最初是华为的子品牌，但在2020年底从华为剥离，成为独立的品牌。</p>
<p>我查了下一季度手机国内市场份额排名数据，荣耀排第四</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/" rel="prev" title="链表逆置合集">
      <i class="fa fa-chevron-left"></i> 链表逆置合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/06/CPP%E5%85%AB%E8%82%A1-%E4%BA%8C/" rel="next" title="CPP八股(二)">
      CPP八股(二) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0%EF%B8%8F%E2%83%A3C-x2F-C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">0️⃣C&#x2F;C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.</span> <span class="nav-text">C++ 中的四种类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">说说 C++中 struct 和 class 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">说说头文件双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8CC%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.4.</span> <span class="nav-text">说说C++结构体和C结构体的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9FC-%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8CC%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">导入C函数的关键字？C++编译时和C有何不同？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.6.</span> <span class="nav-text">⚠️简述C++从代码到可执行文件过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.7.</span> <span class="nav-text">说说 static关键字的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.8.</span> <span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.9.</span> <span class="nav-text">说说静态局部变量, 全局变量, 局部变量的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.10.</span> <span class="nav-text">说说什么是函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.11.</span> <span class="nav-text">nullptr可以调用成员函数吗？为什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.12.</span> <span class="nav-text">内联函数和函数的区别,内联函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.13.</span> <span class="nav-text">说说内联函数和宏的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.14.</span> <span class="nav-text">说说new和malloc的区别，底层实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete-%E5%92%8C-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.15.</span> <span class="nav-text">delete 和 free 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.16.</span> <span class="nav-text">说说const和define的区别。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.17.</span> <span class="nav-text">常量指针和指针常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%90%8C%E5%90%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%9C%A8%E5%A4%9A%E4%B8%AAc%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%AC%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.18.</span> <span class="nav-text">⚠️同名全局变量在多个c文件中公用的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.19.</span> <span class="nav-text">c++命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.1.19.1.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E5%9C%A8main%E5%87%BD%E6%95%B0%E5%89%8D%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.20.</span> <span class="nav-text">C++如何在main函数前运行一个函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Explicit%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.21.</span> <span class="nav-text">Explicit和隐式类型转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">⚠️进程运行时虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">简述C++的内存管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">简述C++中内存对齐的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8BRAII-%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">说下RAII, 与智能指针之间的联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII%E8%A1%A5%E5%85%85"><span class="nav-number">1.2.6.</span> <span class="nav-text">RAII补充</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.3.1.</span> <span class="nav-text">简述一下 C++重载和重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">说说 C++ 重载和重写是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.3.3.</span> <span class="nav-text">说说C++构造函数有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">只定义析构函数,会自动生成哪些构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">一个类默认会生成哪些函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E5%BD%B1%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">哪些因素会影一个类对象的大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.7.</span> <span class="nav-text">继承一个类的对象的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%B9%B6%E9%87%8D%E5%86%99%E4%BA%86%E5%AE%83%E4%BB%AC%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.8.</span> <span class="nav-text">继承两个类并重写了它们的虚函数的对象的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.3.9.</span> <span class="nav-text">简述下向上转型和向下转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.10.</span> <span class="nav-text">简述下深拷贝和浅拷贝, 如何实现深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.11.</span> <span class="nav-text">简述一下 C++ 中的多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">1.3.12.</span> <span class="nav-text">说说为什么要虚析构, 为什么不能虚构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.13.</span> <span class="nav-text">构造函数中可以调用虚函数吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.14.</span> <span class="nav-text">说说模板类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.15.</span> <span class="nav-text">C++ 类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.16.</span> <span class="nav-text">⚠️简述一下什么是常函数，有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.3.17.</span> <span class="nav-text">说说 C++ 中什么是菱形继承问题，如何解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%88%B6%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.18.</span> <span class="nav-text">虚继承多个父类的子类的内存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.19.</span> <span class="nav-text">说说C++中虚函数与纯虚函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FC-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%EF%BC%88-friend%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.20.</span> <span class="nav-text">⚠️C++友元函数和友元类（ friend）详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FC-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.21.</span> <span class="nav-text">⚠️C++ 中哪些函数不能被声明为虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.3.22.</span> <span class="nav-text">类模板和模板类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-STL"><span class="nav-number">1.4.</span> <span class="nav-text">C++STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E9%80%82%E7%94%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">哈希冲突的解决办法，哈希表适用哪些场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">请说说 STL 的基本组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">请说说 STL 中常见的容器, 并介绍一下实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8DC-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.4.4.</span> <span class="nav-text">两种C++类对象实例化方式的异同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">⚠️迭代器用过吗？什么时候会失效？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-STL-%E4%B8%AD-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.6.</span> <span class="nav-text">说说 STL 中 resize 和 reserve 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#char-%E5%92%8Cstring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.7.</span> <span class="nav-text">char*和string的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8Evector%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.8.</span> <span class="nav-text">数组与vector的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#STL%E5%AE%B9%E5%99%A8%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">1.4.9.</span> <span class="nav-text">STL容器哪些是线程安全的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%81%E5%B0%86STL%E5%BA%93%E6%94%B9%E9%80%A0%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">1.4.10.</span> <span class="nav-text">要将STL库改造为线程安全的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%A6%82%E4%BD%95%E5%AF%B9core-dump-%E6%96%87%E4%BB%B6debug"><span class="nav-number">1.4.11.</span> <span class="nav-text">❤️如何对core dump 文件debug</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B-core-dump-%E6%96%87%E4%BB%B6debug"><span class="nav-number">1.4.12.</span> <span class="nav-text">❤️多线程 core dump 文件debug</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%86%99string%E7%B1%BB"><span class="nav-number">1.4.13.</span> <span class="nav-text">手写string类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8Fvector-%E7%9A%84-%E9%83%A8%E5%88%86STL-%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.14.</span> <span class="nav-text">⚠️vector 的 部分STL 源码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">C++新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">说说 C++14 新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">说说 C++11 新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.5.3.</span> <span class="nav-text">说说 C++中的智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E5%90%97"><span class="nav-number">1.5.4.</span> <span class="nav-text">智能指针有内存泄露风险吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4%E4%B8%89%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">⚠️说说三种智能指针原理和使用场景和线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">1.5.6.</span> <span class="nav-text">完美转发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#constexpr"><span class="nav-number">1.5.7.</span> <span class="nav-text">constexpr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">1️⃣操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OS%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.1.</span> <span class="nav-text">OS的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">说一说常用的 Linux 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%81%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E3%80%81tar%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">查看进程运行状态、查看内存使用情况、tar解压文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%81%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%9A%84%E6%8C%87%E4%BB%A4%E5%9D%87%E5%8F%AF%E4%BD%BF%E7%94%A8top%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">查看进程运行状态、查看内存使用情况的指令均可使用top指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">2.5.</span> <span class="nav-text">查找一个字符串是否在文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%AC%E6%9C%BA%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.6.</span> <span class="nav-text">查找本机一个端口号的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BC%80%E5%90%AF"><span class="nav-number">2.7.</span> <span class="nav-text">如何判断远程服务的端口有没有开启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9"><span class="nav-number">2.8.</span> <span class="nav-text">文件权限怎么修改</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90-ugoa"><span class="nav-number">2.8.1.</span> <span class="nav-text">文字设定法设置权限(ugoa)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90-ugo"><span class="nav-number">2.8.2.</span> <span class="nav-text">数字设定法设置权限(ugo)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90-SUID-SGID-Sticky"><span class="nav-number">2.8.3.</span> <span class="nav-text">特殊权限(SUID SGID Sticky)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%A5root%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.9.</span> <span class="nav-text">如何以root权限运行某个程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD"><span class="nav-number">2.10.</span> <span class="nav-text">什么是大端小端, 如何判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-IP%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">字节序转换函数, IP转换函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0Linux%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">2.12.</span> <span class="nav-text">⚠️简述Linux内核态与用户态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E6%98%A0%E5%B0%84%E7%9A%84"><span class="nav-number">2.13.</span> <span class="nav-text">虚拟地址到物理地址怎么映射的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.14.</span> <span class="nav-text">❤️说说进程,线程,协程是什么,区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="nav-number">2.15.</span> <span class="nav-text">❤️多进程和多线程架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E9%80%82%E5%90%88%E5%A4%9A%E8%BF%9B%E7%A8%8B-I-x2F-O%E5%AF%86%E9%9B%86%E9%80%82%E5%90%88%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.16.</span> <span class="nav-text">为何CPU密集型适合多进程, I&#x2F;O密集适合多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8Fnginx%E4%B8%BA%E4%BD%95%E9%87%87%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.17.</span> <span class="nav-text">❤️nginx为何采用多进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%8C%82%E4%BA%86%E5%90%8E%EF%BC%8C%E4%B8%BB%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E9%87%8D%E5%90%AF%E5%AE%83"><span class="nav-number">2.18.</span> <span class="nav-text">❤️当一个子进程挂了后，主进程怎么重启它</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%8C%82%E4%BA%86%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E9%87%8D%E5%90%AF%E4%BB%96"><span class="nav-number">2.19.</span> <span class="nav-text">❤️当一个子线程挂了后，主线程怎么重启他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8FLinux-%E5%92%8C-Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.20.</span> <span class="nav-text">❤️Linux 和 Windows 多线程编程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8FPOXIS-%E5%92%8CSystemV%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.21.</span> <span class="nav-text">❤️POXIS 和SystemV是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8Fthread-%E5%92%8C-pthread-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.22.</span> <span class="nav-text">❤️thread 和 pthread 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug"><span class="nav-number">2.23.</span> <span class="nav-text">❤️多线程debug</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-guard-%E5%92%8C-unique-lock-%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">2.24.</span> <span class="nav-text">lock_guard 和 unique_lock 区别，使用案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.25.</span> <span class="nav-text">什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">2.26.</span> <span class="nav-text">说说什么是守护进程, 如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.27.</span> <span class="nav-text">说说进程通信的方式有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.28.</span> <span class="nav-text">进程通信中的管道实现原理是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.29.</span> <span class="nav-text">使用管道的四种特殊情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.30.</span> <span class="nav-text">⚠️共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%AE%80%E8%BF%B0mmap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-6%E5%8F%82%E6%95%B0"><span class="nav-number">2.31.</span> <span class="nav-text">⚠️简述mmap的原理和使用场景(6参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.32.</span> <span class="nav-text">说说常见信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.33.</span> <span class="nav-text">⚠️如何保护一个进程不被杀死，具体的代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">2.34.</span> <span class="nav-text">进程, 线程的中断切换过程是怎样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">2.35.</span> <span class="nav-text">❤️死锁产生条件以及如何解决死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9C%A8Linux%E4%B8%AD%EF%BC%8C%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%90%AF%E6%97%B6%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="nav-number">2.36.</span> <span class="nav-text">⚠️在Linux中，让程序在系统开启时自启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">2.37.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.38.</span> <span class="nav-text">锁的种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.39.</span> <span class="nav-text">自旋锁和条件变量的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D-amp-DMA"><span class="nav-number">2.40.</span> <span class="nav-text">零拷贝 &amp; DMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap-%E5%92%8Csendfile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.41.</span> <span class="nav-text">mmap 和sendfile 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future"><span class="nav-number">2.42.</span> <span class="nav-text">future</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5-23"><span class="nav-number">3.</span> <span class="nav-text">2️⃣计算机网络 5.23</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">TCP通信流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#listen-%E9%87%8C%E7%9A%84backlog%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">listen() 里的backlog参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#accept-%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%93%AA%E9%87%8C"><span class="nav-number">3.1.3.</span> <span class="nav-text">accept() 在三次握手哪里</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E8%8C%83SYN%E6%94%BB%E5%87%BB%EF%BC%88DDOS%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%89"><span class="nav-number">3.1.4.</span> <span class="nav-text">防范SYN攻击（DDOS的一种）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA"><span class="nav-number">3.2.</span> <span class="nav-text">网络理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-gt-%E4%BC%A0%E8%BE%93%E5%B1%82-gt-%E7%BD%91%E7%BB%9C%E5%B1%82-gt-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">3.2.1.</span> <span class="nav-text">(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82-gt-%E7%BD%91%E7%BB%9C%E5%B1%82-gt-%E4%BC%A0%E8%BE%93%E5%B1%82-gt-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.2.2.</span> <span class="nav-text">(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.3.</span> <span class="nav-text">⚠️网络模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-amp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">TCP三次握手 &amp; 四次挥手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.5.</span> <span class="nav-text">TCP与UDP区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.2.6.</span> <span class="nav-text">TCP流量控制：滑动窗口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%85%A2%E5%BC%80%E5%A7%8B-amp-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0-amp-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">3.2.7.</span> <span class="nav-text">TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-TCP-%E7%B2%98%E5%8C%85"><span class="nav-number">3.2.8.</span> <span class="nav-text">说说 TCP 粘包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="nav-number">3.2.9.</span> <span class="nav-text">TCP 和 UDP 可以同时绑定相同的端口吗?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-TCP-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="nav-number">3.2.10.</span> <span class="nav-text">多个 TCP 服务进程可以绑定同一个端口吗?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5-bind-%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.2.11.</span> <span class="nav-text">同一客户端可以 bind 同一个端口吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%AE%A2%E6%88%B7%E7%AB%AFconnect%E5%87%BD%E6%95%B0%E9%80%89%E6%8B%A9%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.12.</span> <span class="nav-text">⚠️客户端connect函数选择端口号的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8FCLOSE-WAIT%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="nav-number">3.2.13.</span> <span class="nav-text">产生大量CLOSE_WAIT原因和解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8FTIME-WAIT%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="nav-number">3.2.14.</span> <span class="nav-text">产生大量TIME_WAIT原因和解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-amp-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">3.2.15.</span> <span class="nav-text">HTTP请求报文&amp;响应报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.16.</span> <span class="nav-text">一次HTTP请求响应的流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="nav-number">3.2.17.</span> <span class="nav-text">HTTP协议特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.18.</span> <span class="nav-text">HTTP方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GET%E3%80%81POST%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.19.</span> <span class="nav-text">GET、POST区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.2.20.</span> <span class="nav-text">Http状态码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E7%9A%84keepalive%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.21.</span> <span class="nav-text">Http的keepalive字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.22.</span> <span class="nav-text">❤️长连接和短连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86HTTP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81RPC"><span class="nav-number">3.2.23.</span> <span class="nav-text">❤️既然有了HTTP为什么还要RPC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Http%E5%92%8CHttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.24.</span> <span class="nav-text">Http和Https的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8FHTTPS%E6%8F%A1%E6%89%8B%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.25.</span> <span class="nav-text">❤️HTTPS握手步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">3.2.26.</span> <span class="nav-text">⚠️对称加密与非对称加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FHTTP1-x-%E5%92%8C-HTTP2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.27.</span> <span class="nav-text">⚠️HTTP1.x 和 HTTP2.0 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebSocket-%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.28.</span> <span class="nav-text">WebSocket 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#WebSocket-API-%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.2.28.1.</span> <span class="nav-text">WebSocket API 有哪些</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0websocket%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.28.2.</span> <span class="nav-text">C++中如何实现websocket协议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E5%92%8C-websocket-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.28.3.</span> <span class="nav-text">HTTP 协议和 websocket 协议的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.29.</span> <span class="nav-text">说说ARP协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4NAT%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.30.</span> <span class="nav-text">说说NAT协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session%E3%80%81Cookie"><span class="nav-number">3.2.31.</span> <span class="nav-text">Session、Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.2.32.</span> <span class="nav-text">⚠️国内访问不了谷歌的技术原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%9B%BD%E5%86%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C"><span class="nav-number">3.2.33.</span> <span class="nav-text">⚠️国内可以通过什么技术手段访问谷歌</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.34.</span> <span class="nav-text">防火墙的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%BF%90%E8%90%A5%E5%95%86%E7%BB%99%E7%94%A8%E6%88%B7%E9%99%90%E9%80%9F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.35.</span> <span class="nav-text">⚠️运营商给用户限速的类型和原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.36.</span> <span class="nav-text">⚠️常见的流量控制算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%B8%8F%E2%83%A3%E6%95%B0%E6%8D%AE%E5%BA%93-5-21"><span class="nav-number">4.</span> <span class="nav-text">3️⃣数据库  5.21</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">存储引擎和存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E5%A0%86%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text">⚠️堆表和索引组织表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.3.</span> <span class="nav-text">⚠️聚集索引和非聚集索引的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%8F%91%E5%B1%95"><span class="nav-number">4.1.4.</span> <span class="nav-text">存储结构分类和发展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B1%E6%80%A7%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.5.</span> <span class="nav-text">存储结构的共性特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%94%81%E4%B8%8E%E4%BA%8B%E7%89%A9%E7%9A%84%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">4.1.6.</span> <span class="nav-text">存储结构的锁与事物的锁有什么不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">4.1.7.</span> <span class="nav-text">B树的变种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LSM%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">4.1.8.</span> <span class="nav-text">LSM树结构图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-LSM%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%97%B6%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%ADkey%E5%9C%A8%E4%B8%8D%E5%9C%A8%E8%AF%A5%E5%B1%82%E4%B8%AD"><span class="nav-number">4.1.9.</span> <span class="nav-text">布隆过滤器(LSM中读取时快速判断key在不在该层中)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA"><span class="nav-number">4.2.</span> <span class="nav-text">数据库理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">4.2.1.</span> <span class="nav-text">MySQL体系架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">SQL语句运行机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9%E7%89%B9%E6%80%A7-ACID"><span class="nav-number">4.2.3.</span> <span class="nav-text">数据库事物特性(ACID)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A2%E8%AF%BB%E4%B8%8D%E5%B9%BB"><span class="nav-number">4.2.4.</span> <span class="nav-text">数据库并发一致性问题：丢读不幻</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">4.2.5.</span> <span class="nav-text">当前读和快照读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%B9%BB%E8%AF%BB%E5%90%97"><span class="nav-number">4.2.6.</span> <span class="nav-text">⚠️两个事务并行提交一定会幻读吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8Bmysql%E6%AD%BB%E9%94%81"><span class="nav-number">4.2.7.</span> <span class="nav-text">说下mysql死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.8.</span> <span class="nav-text">数据库锁类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.9.</span> <span class="nav-text">关于锁的常见问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.2.10.</span> <span class="nav-text">数据库封锁协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A%E6%9C%AA-%E6%8F%90-%E5%8F%AF-%E5%8F%AF"><span class="nav-number">4.2.11.</span> <span class="nav-text">数据库隔离级别：未 提 可 可</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1NF-2NF-3NF-BCNF"><span class="nav-number">4.2.12.</span> <span class="nav-text">1NF	 		2NF		 3NF 		BCNF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E4%B8%BB%E9%94%AE"><span class="nav-number">4.2.13.</span> <span class="nav-text">超键, 候选键, 主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95"><span class="nav-number">4.2.14.</span> <span class="nav-text">数据库索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">4.2.14.1.</span> <span class="nav-text">什么是索引？优缺点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.14.2.</span> <span class="nav-text">索引的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BF%9D%E5%AD%98MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">4.2.14.3.</span> <span class="nav-text">如何创建及保存MySQL的索引？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88%EF%BC%9F"><span class="nav-number">4.2.14.4.</span> <span class="nav-text">如何判断索引有没有生效？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EXPLAIN"><span class="nav-number">4.2.14.5.</span> <span class="nav-text">EXPLAIN</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.14.6.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.14.7.</span> <span class="nav-text">应该建立索引的条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.14.8.</span> <span class="nav-text">索引的优缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.14.9.</span> <span class="nav-text">索引的最左前缀问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.15.</span> <span class="nav-text">sql优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM"><span class="nav-number">4.2.16.</span> <span class="nav-text">InnoDB和MyISAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FInnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.17.</span> <span class="nav-text">⚠️InnoDB体系结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E8%AF%B4%E8%AF%B4-InnoDB-%E7%9A%84-MVCC"><span class="nav-number">4.2.18.</span> <span class="nav-text">⚠️说说 InnoDB 的 MVCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.19.</span> <span class="nav-text">Mysql数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">4.2.20.</span> <span class="nav-text">⚠️主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.2.21.</span> <span class="nav-text">关系型数据库和非关系型数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.2.22.</span> <span class="nav-text">数据库完整性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%A1%A8%E7%9A%84%E5%A4%96%E9%94%AE%E6%9E%84%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">4.2.23.</span> <span class="nav-text">对表的外键构建索引的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%B4%A8"><span class="nav-number">4.2.24.</span> <span class="nav-text">一个好的模式分解具有哪些性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.2.25.</span> <span class="nav-text">视图的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FMySQL%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8"><span class="nav-number">4.2.26.</span> <span class="nav-text">⚠️MySQL分区分表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete%E3%80%81drop%E3%80%81-truncate%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.27.</span> <span class="nav-text">delete、drop、 truncate区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.28.</span> <span class="nav-text">exists和in的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">4.2.29.</span> <span class="nav-text">说说触发器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88DDL%EF%BC%8CDML%EF%BC%8CDQL%E3%80%81DCL%EF%BC%89"><span class="nav-number">4.2.30.</span> <span class="nav-text">⚠️数据库（DDL，DML，DQL、DCL）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">4.2.31.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B%E6%A0%91-x2F-B-%E6%A0%91"><span class="nav-number">4.2.32.</span> <span class="nav-text">B树&#x2F;B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E7%94%A8-B-%E6%A0%91"><span class="nav-number">4.2.33.</span> <span class="nav-text">数据库为什么不用红黑树而用 B+ 树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.2.34.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.2.35.</span> <span class="nav-text">各种连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="nav-number">4.2.36.</span> <span class="nav-text">数据库连接池优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.37.</span> <span class="nav-text">MySQL的慢查询优化有了解吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8FRedo-log-Undo-log%E5%92%8CBinlog"><span class="nav-number">4.2.38.</span> <span class="nav-text">⚠️Redo log, Undo log和Binlog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.2.39.</span> <span class="nav-text">常见的数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.2.40.</span> <span class="nav-text">❤️什么是消息队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8FRedis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.41.</span> <span class="nav-text">❤️Redis的几种应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%B8%8F%E2%83%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-21"><span class="nav-number">5.</span> <span class="nav-text">4️⃣设计模式  5.21</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.</span> <span class="nav-text">六种关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">5.2.</span> <span class="nav-text">面向对象设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.</span> <span class="nav-text">请说说工厂设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.4.</span> <span class="nav-text">⭐️三种工厂模式的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%B8%8F%E2%83%A3%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">5️⃣项目相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#webserver"><span class="nav-number">6.1.</span> <span class="nav-text">webserver</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.1.1.</span> <span class="nav-text">介绍一下项目</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86socket%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">为什么将socket设置为非阻塞</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E8%B7%83%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">定时器处理非活跃连接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">主从状态机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8F%90%E9%86%92%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">子线程如何提醒主线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%A0%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84"><span class="nav-number">6.1.1.5.</span> <span class="nav-text">服务器是怎么把静态资源传回客户端的</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">6.1.2.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E7%BC%BA%E7%82%B9"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">select缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">6.1.3.</span> <span class="nav-text">poll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#poll%E7%BC%BA%E7%82%B9"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">poll缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">6.1.4.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-epoll-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">说说 epoll 的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4epoll%E6%B5%81%E7%A8%8B"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">说说epoll流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.4.3.</span> <span class="nav-text">epoll事件类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E5%86%99%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%86%99%E5%AE%8C%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.1.4.4.</span> <span class="nav-text">epoll写就绪事件和写完成事件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.4.5.</span> <span class="nav-text">epoll水平触发与边缘触发的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="nav-number">6.1.4.6.</span> <span class="nav-text">epoll是同步的还是异步的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EPOLLONESHOT%E4%BA%8B%E4%BB%B6-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.1.4.7.</span> <span class="nav-text">EPOLLONESHOT事件(保证线程安全)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">6.1.5.</span> <span class="nav-text">阻塞和非阻塞、同步和异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4Reactor%E3%80%81Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.</span> <span class="nav-text">说说Reactor、Proactor模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">Proactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5IO%E7%9A%84%E6%A8%A1%E6%8B%9FProactor"><span class="nav-number">6.1.6.3.</span> <span class="nav-text">同步IO的模拟Proactor</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">6.1.7.</span> <span class="nav-text">将文件描述符设置为非阻塞有什么用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unix%E3%80%81Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.</span> <span class="nav-text">Unix、Linux上的五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.1.</span> <span class="nav-text">阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.2.</span> <span class="nav-text">非阻塞IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">6.1.8.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="nav-number">6.1.8.4.</span> <span class="nav-text">信号驱动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.8.5.</span> <span class="nav-text">异步IO模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.8.6.</span> <span class="nav-text">⭐️5种IO模型的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.1.9.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">6.1.9.1.</span> <span class="nav-text">如何确定线程数量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E4%B8%8ECPU%E6%A0%B8%E5%BF%83%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.9.2.</span> <span class="nav-text">线程数量与CPU核心数的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="nav-number">6.1.9.3.</span> <span class="nav-text">线程池中的工作线程是一直等待吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.1.9.4.</span> <span class="nav-text">线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="nav-number">6.1.9.5.</span> <span class="nav-text">如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.1.10.</span> <span class="nav-text">Nginx的负载均衡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nginx%E9%85%8D%E7%BD%AE"><span class="nav-number">6.1.11.</span> <span class="nav-text">nginx配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.1.12.</span> <span class="nav-text">读多写少的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">6.1.13.</span> <span class="nav-text">GDB 常见的调试命令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8-x2F-%E9%80%80%E5%87%BA-x2F-%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">6.1.13.1.</span> <span class="nav-text">GDB命令-启动&#x2F;退出&#x2F;查看代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.13.2.</span> <span class="nav-text">GDB命令-断点操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">6.1.13.3.</span> <span class="nav-text">GDB命令-调试命令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E9%AB%98WebServer%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">6.1.14.</span> <span class="nav-text">提高WebServer的性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.1.15.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.15.1.</span> <span class="nav-text">负载均衡分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">6.1.15.2.</span> <span class="nav-text">负载均衡算法：一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Webbench"><span class="nav-number">6.1.16.</span> <span class="nav-text">性能测试 Webbench</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFQPS%E5%92%8CTPS-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="nav-number">6.1.17.</span> <span class="nav-text">什么是QPS和TPS, 如何计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BB%B6%E8%BF%9F%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.1.18.</span> <span class="nav-text">访问服务端延迟高的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">6.1.19.</span> <span class="nav-text">如何定位服务器性能瓶颈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E6%8E%AA%E6%96%BD"><span class="nav-number">6.1.20.</span> <span class="nav-text">防止恶意请求，服务器端可以采取措施</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E5%8D%95%E4%B8%AAIP%E5%9C%B0%E5%9D%80%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">6.1.21.</span> <span class="nav-text">如何限制单个IP地址在特定时间内访问服务器的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%99%90%E6%B5%81"><span class="nav-number">6.1.22.</span> <span class="nav-text">服务器端限流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Go-%E5%BC%80%E5%8F%91%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-KV-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.2.</span> <span class="nav-text">基于 Go 开发的分布式 KV 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Raft%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.1.</span> <span class="nav-text">Raft算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Leader%E9%80%89%E4%B8%BE"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">二、Leader选举</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5-%E5%A4%8D%E5%88%B6"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">三、日志同步 (复制)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">6.2.1.4.</span> <span class="nav-text">四、安全性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">6.2.1.5.</span> <span class="nav-text">五、日志压缩</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4"><span class="nav-number">6.2.1.6.</span> <span class="nav-text">六、成员变更</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%83%E3%80%81Raft%E4%B8%8EMulti-Paxos%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">6.2.1.7.</span> <span class="nav-text">七、Raft与Multi-Paxos的异同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AB%E3%80%81Raft%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">6.2.1.8.</span> <span class="nav-text">八、Raft算法总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%ADhandler%E5%92%8Csender"><span class="nav-number">6.2.2.</span> <span class="nav-text">分布式架构中handler和sender</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E7%8E%B0Raft%E7%9A%84%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%A6%81%E6%8C%81%E9%94%81"><span class="nav-number">6.2.3.</span> <span class="nav-text">在实现Raft的什么情况下不要持锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Raft-%E5%93%AA%E4%BA%9B-state-%E9%9C%80%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">6.2.4.</span> <span class="nav-text">Raft 哪些 state 需要持久化，为什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#commit%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.5.</span> <span class="nav-text">commit和apply的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#commitIndex-%E4%B8%8E-applyIndex"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">commitIndex 与 applyIndex</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raftstate%E5%92%8Csnapshot%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.6.</span> <span class="nav-text">raftstate和snapshot的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D-applier-%E7%9A%84-exactly-once"><span class="nav-number">6.2.7.</span> <span class="nav-text">如何确保 applier 的 exactly once</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Leader-%E4%B8%8D%E8%83%BD%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%97%B4%E6%8E%A5%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-no-op-%E6%97%A5%E5%BF%97"><span class="nav-number">6.2.8.</span> <span class="nav-text">为什么 Leader 不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志?  为什么需要 no-op 日志?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4raft%E7%AE%97%E6%B3%95%E7%9A%84%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.9.</span> <span class="nav-text">说一说raft算法的快照机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raft%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AE%89%E8%A3%85%E5%BF%AB%E7%85%A7"><span class="nav-number">6.2.10.</span> <span class="nav-text">raft在什么时候安装快照</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Raft-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.11.</span> <span class="nav-text">Raft 的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#KV%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.2.12.</span> <span class="nav-text">KV存储的客户端和服务器端模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA-Raft-Group-%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA-Learner%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%A4%9A%E4%B8%AA-Learner-%E5%90%8C%E6%97%B6%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%99-Leader-%E9%80%A0%E6%88%90%E5%8E%8B%E5%8A%9B"><span class="nav-number">6.2.13.</span> <span class="nav-text">如果一个 Raft Group 中存在多个 Learner，如何防止多个 Learner 同时同步数据给 Leader 造成压力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#raft%E7%AE%97%E6%B3%95%E4%B8%AD%EF%BC%8Cfollower%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AA%E6%97%A5%E5%BF%97%E5%90%8E%E5%8F%91%E7%8E%B0%E6%9C%89%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">6.2.14.</span> <span class="nav-text">raft算法中，follower收到一个日志后发现有冲突怎么办</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-ACID%E5%92%8CCAP"><span class="nav-number">6.2.15.</span> <span class="nav-text">说说 ACID和CAP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%AF%BB%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.16.</span> <span class="nav-text">说说读优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Raft%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%AF%AD%E4%B9%89"><span class="nav-number">6.2.17.</span> <span class="nav-text">Raft如何实现线性语义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">工程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%9D%A4%EF%B8%8F%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E7%94%A8top%E5%8F%91%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%A8%E6%B6%A8"><span class="nav-number">6.3.1.</span> <span class="nav-text">❤️检测内存泄漏(用top发现虚拟内存在涨)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%B8%80-malloc-stats-%E5%92%8C-malloc-info-0-stdout"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">法一:  malloc_stats() 和 malloc_info(0, stdout)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">法二：宏定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E4%B8%89%EF%BC%9A-hook%E6%88%AA%E8%8E%B7malloc%E5%92%8Cfree-dlsym%E6%94%B9%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84"><span class="nav-number">6.3.1.3.</span> <span class="nav-text">法三： hook截获malloc和free, dlsym改成自定义的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%95%E5%9B%9B%EF%BC%9A-mtrace"><span class="nav-number">6.3.1.4.</span> <span class="nav-text">法四： mtrace</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%93%BE%E6%8E%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%9C%89%E6%97%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">6.3.2.</span> <span class="nav-text">查看链接了哪些动态库和第三方库有无内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">c++程序崩溃定位方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#git-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%94%AF"><span class="nav-number">6.3.4.</span> <span class="nav-text">git 如何查看远程服务器分支</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%B8%8F%E2%83%A3%E5%85%B6%E4%BB%96"><span class="nav-number">7.</span> <span class="nav-text">6️⃣其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">智力题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B2%99%E6%BC%8F%E8%AE%A1%E6%97%B6%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.1.</span> <span class="nav-text">沙漏计时问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%83%E8%8D%AF%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.2.</span> <span class="nav-text">吃药片问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.3.</span> <span class="nav-text">老鼠毒药问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%B1%E5%AD%90%E5%BC%80%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.4.</span> <span class="nav-text">箱子开锁问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%BA%E9%AC%BC%E8%BF%87%E6%A1%A5%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.5.</span> <span class="nav-text">人鬼过桥问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%9B%E9%A9%AC%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%84%E9%A9%AC%E5%8C%B9"><span class="nav-number">7.1.6.</span> <span class="nav-text">赛马找最快的马匹</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#25%E5%8C%B9%E9%A9%AC5%E6%9D%A1%E8%B7%91%E9%81%93%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%843%E5%8C%B9%E9%A9%AC"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">25匹马5条跑道找最快的3匹马</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#64%E5%8C%B9%E9%A9%AC8%E6%9D%A1%E8%B7%91%E9%81%93%E6%89%BE%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC"><span class="nav-number">7.1.6.2.</span> <span class="nav-text">64匹马8条跑道找最快的4匹马</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">7.2.</span> <span class="nav-text">场景题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%94"><span class="nav-number">7.3.</span> <span class="nav-text">—</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD"><span class="nav-number">7.4.</span> <span class="nav-text">如何将敏捷开发应用到项目中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.5.</span> <span class="nav-text">介绍下鸿蒙系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">7.6.</span> <span class="nav-text">微内核架构有什么特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E5%8A%A0%E7%8F%AD%E7%9A%84%E7%9C%8B%E6%B3%95"><span class="nav-number">7.7.</span> <span class="nav-text">谈谈对加班的看法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="nav-number">7.8.</span> <span class="nav-text">职业规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E8%8D%A3%E8%80%80%E5%90%97"><span class="nav-number">7.9.</span> <span class="nav-text">了解荣耀吗</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
