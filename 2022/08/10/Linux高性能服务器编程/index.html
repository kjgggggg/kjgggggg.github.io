<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="Linux高性能服务器编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="Linux高性能服务器编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028142406885.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028143032281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028154045633.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160925281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160951754.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028163708993.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028172215221.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174622965.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174905118.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175247985.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175559945.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028180448158.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029160442047.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029165648092.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029171653493.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029172431281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030145918168.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030193146766.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VwZXJzbWFydEA=,size_11,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Center.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221031215037224.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101013945568.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143024126.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143922053.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102133524824.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102140508146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102143252014.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144326483.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144456528.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102174749178.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102194024601.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103120849314.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103164530935.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165336300.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165127529.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165504053.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221104170616515.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105134241461.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105165609594.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105181155408.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106215842522.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106220232940.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221108162830690.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221109231419437.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-9fdab4ff37d12e944d2a9025b583d0ac_1440w.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110150321181.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/da60a6fcfe684b679c3ca13c116f3004.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110155956089.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110160740252.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140220057.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140701837.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140730605.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162651180.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162731372.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162838743.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162859467.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162942609.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163111692.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163326444.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163211127.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI1ODk3OQ==,size_16,color_FFFFFF,t_70.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112140046029.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112154950130.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/AB3FC1B1325FA341A39644BA061FA439.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-eff93036b85f660537ac9c8036cb896b_1440w.webp">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-b4e28461732b87b1d96da64456868ec4_1440w.webp">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221116151457850.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7786.PNG">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7787.PNG">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7788.PNG">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7790.PNG">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7791.PNG">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117131507683.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117145127724.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117172543560.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118183329846.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118231053331.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119030142283.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjc1MDYyMw==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119135550407.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132531092.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132728012.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/694be39c2749f98700567080f2b56154.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/7848d265b695b27b3175be6ffe1ff381.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120135606806.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120140459752.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/787ff6e538868898f53a27e55bc30c62.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120175048248.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120192657906.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120194303146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120203431492.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120212110980.png">
<meta property="article:published_time" content="2022-08-10T07:54:39.000Z">
<meta property="article:modified_time" content="2022-12-06T07:36:57.740Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux高性能服务器编程 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux高性能服务器编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-10 15:54:39" itemprop="dateCreated datePublished" datetime="2022-08-10T15:54:39+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:36:57" itemprop="dateModified" datetime="2022-12-06T15:36:57+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">linux && 服务器</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">Linux高性能服务器编程</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装了远程连接服务器的工具,操作它就不要打开再操作了	<code>sudo yum install openssh-server</code></p>
<p>查看虚拟机ip地址	<code>ifconfig</code> </p>
<p>登录该虚拟机	<code>ssh kjg@172.16.208.128</code></p>
<p>利用Vscode远程连接该虚拟机</p>
<h4 id="Gcc编译"><a href="#Gcc编译" class="headerlink" title="Gcc编译"></a>Gcc编译</h4><h5 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h5><p>GCC 原名为 GNU C语言编译器（GNU C Compiler）</p>
<p>可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个C 标准。如，当使用 <code>-std = c99</code>启动 GCC时，编译器支持 C99 标准</p>
<h5 id="GCC命令"><a href="#GCC命令" class="headerlink" title="GCC命令"></a>GCC命令</h5><p>安装命令 <code>sudo yum install gcc g++ </code>（版本＞4.8.5）</p>
<p>查看版本 <code>gcc / g++ -v / --version</code></p>
<p>预处理指定的源文件,不进行编译[ .c -&gt; .i ]	<code>gcc test.c -E -o test.i</code></p>
<p>编译指定的源文件,但是不进行汇编[ .i -&gt; .s ]	<code>gcc test.i -S -o test.s</code></p>
<p>编译,汇编指定的源文件,但不进行链接[ .s -&gt; .o ]	<code>gcc test.s -c -o test.o</code></p>
<p>编译生成可执行文件[ .c -&gt; .out ]	<code>gcc test.c -o app</code>	如果<code>gcc test.c</code>则生成一个默认的<code>a.out</code>文件</p>
<p>运行	<code>./app</code> 或 <code>./a.out</code></p>
<h5 id="GCC工作流程"><a href="#GCC工作流程" class="headerlink" title="GCC工作流程"></a>GCC工作流程</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png" alt="image-20221026150832523" style="zoom:50%;">



<h5 id="gcc与g-区别"><a href="#gcc与g-区别" class="headerlink" title="gcc与g++区别"></a>gcc与g++区别</h5><p>gcc编译c文件，g++编译c++文件</p>
<p>编译可以用<code>gcc / g++</code> 链接可用 <code>g++</code> 或者 <code>gcc -lstdc++</code></p>
<h4 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h4><h5 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h5><ul>
<li><p>库是特殊的一种程序，提供给使用者一些可以直接拿来用的变量、函数或类,编写库的程序和编写一般的程序区别不大，只是库不能单独运待。</p>
</li>
<li><p>库文件有两种，静态库和动态库(共享库)区别是:</p>
<p>静态库在程序的链接阶段被复制到了程序中;</p>
<p>动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
</li>
<li><p>库的好处: 1.代码保密  2.方便部署和分发</p>
</li>
</ul>
<h5 id="静态库的命名规则"><a href="#静态库的命名规则" class="headerlink" title="静态库的命名规则"></a>静态库的命名规则</h5><p>Linux:	<code>libxxx.a</code>	(lib是固定前缀	a是固定后缀	中间的xxx是库名)</p>
<p>Windows:	<code>libxxx.lib</code></p>
<h5 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h5><ol>
<li><p><code>gcc - c</code>获得.o文件</p>
</li>
<li><p>将.o文件打包,使用ar工具(archive)    </p>
<p><code>ar rcs libxxx.a xxx.o xxx.o</code>		r是将文件插入备存文件(在这里是库文件)中 c是建立备存文件 s是索引</p>
</li>
</ol>
<h5 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56673429/article/details/124168013">静态库的使用</a></h5><p>得到了一个可用的静态库之后，将其与相应的头文件放到一个目录中(就相当于发布了)，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。</p>
<p>这里我把生成的静态库和相应的头文件放到temp文件夹中进行测试。<br>这里我们会用到gcc的两个参数</p>
<p>-l 	在程序编译的时候，指定使用的库。（静态库的名字一定要掐头去尾。如：libCalc.a变为Calc）<br>-L 	在程序编译的时候，指定使用的库的路径。</p>
<p>如:	<code>gcc main.c -o Calc -L ./ -l Calc</code> [第一个Calc是生成的可执行文件名]</p>
<p>运行:	<code>./Calc</code></p>
<h5 id="动态库的命名规则"><a href="#动态库的命名规则" class="headerlink" title="动态库的命名规则"></a>动态库的命名规则</h5><p>Linux:	<code>libxxx.so</code> 	lib:前缀(固定)	xxx ：库的名字，自己起 	so:后缀（固定）	在Linux下是一个可执行文件 </p>
<p>Windows:	<code>libxxx.dll</code></p>
<h5 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h5><p>gcc 得到.o文件，得到和位置无关的代码	 <code>gcc -c -fpic/-fPIC a.c b.c</code><br>gcc 得到动态库	<code>gcc －shared a.o b.o -o libcalc.so</code></p>
<h5 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h5><p>库文件是src里源文件的定义，头文件是src里源文件的声明；使用时需要将库文件和头文件都分发给src里的文件们</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028142406885.png" alt="image-20221028142406885" style="zoom:50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要将使用的库文件拷贝到当前lib目录下</span></span><br><span class="line">gcc main.c -o main -I include/ -L /lib -l calc   </span><br><span class="line"><span class="comment"># -I include/ 是为了找到head.h  	-L /lib是为了找到库文件的目录		-l calc是为了指定库文件名</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028143032281.png" alt="image-20221028143032281" style="zoom:50%;"> 



<h5 id="动态库加载失败的原因"><a href="#动态库加载失败的原因" class="headerlink" title="动态库加载失败的原因"></a>动态库加载失败的原因</h5><ul>
<li><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中</p>
</li>
<li><p>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中</p>
</li>
<li><p>程序启动之后，动态库会被动态加载到内存中，通过 <code>ldd </code> 命令检查动态库依赖关系 在上例中就是 <code>ldd main</code></p>
</li>
<li><p>如何定位共享库文件呢？</p>
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于<code>elf</code>格式的可执行程序，是由<code>ld-linux.so</code>来完成的，它先后搜索<code>elf</code>文件的 <code>DT_RPATH段</code>→<code>环境变量 LD_LIBRARY_PATH</code>→<code>/etc/1d.so.cache文件列表</code>→<code>/lib/</code>或<code>／usr/lib</code>目录找到库文件后将其载入内存。</p>
</li>
<li><p>解决动态库加载失败方式</p>
<ol>
<li>配置环境变量[一次性的,临时的]</li>
</ol>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028154045633.png" alt="image-20221028154045633"></p>
<ol start="2">
<li>在 <code>.bashrc</code>里配置 同图上同样内容	后输入<code>source .bashrc</code></li>
<li>在<code>/etc/profile</code>里配置 同图上同样内容    后输入<code>source /etc/profile</code></li>
</ol>
</li>
</ul>
<h5 id="动静态库优缺点"><a href="#动静态库优缺点" class="headerlink" title="动静态库优缺点"></a>动静态库优缺点</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160925281.png" alt="image-20221028160925281" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160951754.png" alt="image-20221028160951754" style="zoom: 33%;">





<h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><h5 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h5><ul>
<li><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shel1 脚本一样,也可以执行操作系统的命令</p>
</li>
<li><p>Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令[是Makefile的启动器]，整个工程完全自动编译，极大提高了软件开发效率。</p>
</li>
<li><p>make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi的make，Visual C++的 nmake，Linux下 GNU的make</p>
</li>
</ul>
<h5 id="Makefile文件命名和规则"><a href="#Makefile文件命名和规则" class="headerlink" title="Makefile文件命名和规则"></a>Makefile文件命名和规则</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028163708993.png" alt="image-20221028163708993" style="zoom: 50%;">

<p>例1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Makefile <span class="comment"># 不管当前目录有没有Makefile , 只要有你想编译的.c文件就行</span></span><br><span class="line"></span><br><span class="line">================================================</span><br><span class="line">app : add.c	sub.c	multi.c	div.c	main.c</span><br><span class="line">	gcc add.c	sub.c	multi.c	div.c	main.c -o app</span><br><span class="line">================================================</span><br><span class="line"></span><br><span class="line">make <span class="comment"># sudo yum install make</span></span><br></pre></td></tr></table></figure>

<p>例2:</p>
<p>如果第一个规则的依赖在当前目录暂时找不到, 那就往后查找看后面的规则的目标是否有满足的</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028172215221.png" alt="image-20221028172215221" style="zoom:50%;">

<p>但这样写太繁琐,	 如何简化呢?	下面引入变量和模式匹配和函数</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><h6 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h6><p>变量名＝ 变量值 	<code>var = hello</code></p>
<h6 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h6><p>AR 	归档维护程序的名称，默认值为 <code>ar</code></p>
<p>CC	C编译器的名称，默认值为 <code>cc</code></p>
<p>CXX	C＋＋编译器的名称，默认值为 <code>g++</code></p>
<p>$@	目标的完整名称</p>
<p>$&lt;	第一个依赖文件的名称</p>
<p>$^	所有的依赖文件</p>
<h6 id="获取变量的值"><a href="#获取变量的值" class="headerlink" title="获取变量的值"></a>获取变量的值</h6><p>＄（变量名）	如<code>$(var)</code></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174622965.png" alt="image-20221028174622965"></p>
<h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174905118.png" alt="image-20221028174905118" style="zoom:50%;">



<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h6><p>获取指定目录下指定类型的文件列表</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175247985.png" alt="image-20221028175247985"></p>
<h6 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175559945.png" alt="image-20221028175559945" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028180448158.png" alt="image-20221028180448158" style="zoom:50%;">



<h4 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h4><h5 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h5><p>GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，是Linux和许多类Unix系统中的标准开发环境。</p>
<p>一般来说，GDB主要帮助你完成下面四个方面的功能:</p>
<ol>
<li><p>启动程序，可以按照自定义的要求随心所欲的运行程序</p>
</li>
<li><p>可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)</p>
</li>
<li><p>当程序被停住时，可以检查此时程序中所发生的事</p>
</li>
<li><p>可以改变程序，将一个BUG产生的影响修正从而测试其他BUG</p>
</li>
</ol>
<h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><ul>
<li><p>通常，在为调试而编译时，我们会关掉编译器的优化选项(-o)，并打开调试选项(-g)</p>
<p>  另外，<code>-Wall</code>可以在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p>
</li>
<li><p><code>gcc -g -Wall program.c -o program</code></p>
</li>
<li><p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文</p>
<p>  件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p>
</li>
</ul>
<h5 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h5><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h5 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h5><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h5 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h5><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	(每次调试时(输入n, s), 如果a, b值发生变化的话, 自动打印指定变量(在这里是a, b)的值)</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<h4 id="Linux文件IO"><a href="#Linux文件IO" class="headerlink" title="Linux文件IO"></a>Linux文件IO</h4><ul>
<li><p>文件角度:	输入: 内存 -&gt; 文件	输出: 文件 -&gt; 内存	</p>
</li>
<li><p>内存角度:	输入: 文件 -&gt; 内存	输出: 内存 -&gt; 文件	【我们通常站在内存角度】</p>
</li>
</ul>
<h5 id="标准C库文件函数"><a href="#标准C库文件函数" class="headerlink" title="标准C库文件函数"></a>标准C库文件函数</h5><p>标准C库函数是带缓冲区的， <strong>Linux文件操作时可选用C库函数，效率更好。 网络通信时使用Linux自己的库函数，效率更好</strong></p>
<p>C语言写出的程序可以跨平台运行的原因是C库函数继续调用各系统的库函数</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029165648092.png" alt="image-20221029165648092" style="zoom:50%;">



<h5 id="标准C库IO和LinuxIO的区别"><a href="#标准C库IO和LinuxIO的区别" class="headerlink" title="标准C库IO和LinuxIO的区别"></a>标准C库IO和LinuxIO的区别</h5><p>即 C库IO <strong>调用</strong> LinuxIO</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029171653493.png" alt="image-20221029171653493" style="zoom:50%;">



<h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><ul>
<li><p>它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）</p>
</li>
<li><p>一个进程一个虚拟地址空间，该空间会被MMU映射到真实的内存中（以32位机器举例）</p>
</li>
<li><p>大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等</p>
</li>
<li><p>内核区可以通过调用Linux的API访问</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029172431281.png" alt="image-20221029172431281" style="zoom:50%;">



<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>负责 索引到对应的磁盘文件</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030145918168.png" alt="image-20221030145918168" style="zoom:50%;">







<h4 id="LInux系统函数"><a href="#LInux系统函数" class="headerlink" title="LInux系统函数"></a>LInux系统函数</h4><blockquote>
<p>   帮助文档 ：</p>
<p>  <code>man 2 关键词</code></p>
<p>  <code>关键词 --help</code></p>
</blockquote>
<h5 id="errno-amp-perror"><a href="#errno-amp-perror" class="headerlink" title="errno &amp; perror"></a>errno &amp; perror</h5><p><code>errno</code>	 记录错误号</p>
<p><code>void perror(const string *s)</code>	打印错误描述</p>
<h5 id="open-amp-close"><a href="#open-amp-close" class="headerlink" title="open &amp; close"></a>open &amp; close</h5><p><code>int open (const char *pathname, int flags);</code>	打开一个已经存在的文件， 返回一个新的文件描述符 FILE *</p>
<blockquote>
<p>  pathname 要打开的文件路径</p>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code> <code>O_WRONLY``O_RDWR</code></p>
<p>  使用:	 <code>int fd = open(&quot;a.txt&quot;, O_RDONLY);</code></p>
</blockquote>
<p><code>int open (const char *pathname, int flags, mode_t mode);</code>	创建一个新的文件</p>
<blockquote>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code> <code>O_WRONLY</code> <code>_RDWR</code>  这里多一个可选项 <code>O_CREAT</code>: 文件不存在， 创建新文件</p>
<p>  mode:	八进制权限码，一定是在flags中使用了O_CREAT标志，mode记录待创建的文件的访问权限</p>
<p>  如<code>fd = open(&quot;./file1&quot;, O_RDWR|O_CREAT, 0600);</code></p>
</blockquote>
<p><code>int close (int fd);</code></p>
<h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<blockquote>
<p>  fd	为文件描述符；buf	表示读出数据缓冲区地址；count	表示要读出的字节数。</p>
<p>  返回值：若读取成功，则返回读到的字节数；若失败，返回-1；若已达到文件尾，则返回0。因此读到的字节数可能小于count的值</p>
</blockquote>
<h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p><code>ssize_t write (int fd, const void *buf, size_t count);</code></p>
<h5 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h5><p>在程序中，在调用read函数之前，先调用了close函数和open函数，这是为了让光标移到文件的头，否则将读取失败。因此，就还需要用到lseek函数来移动文件中光标的位置。通过调用lseek函数可以改变光标的位置，其函数原型为</p>
<p><code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<blockquote>
<p>  其中，fd为文件描述符；offset指的是每一次读写操作所需移动距离，以字节为单位 ，可正可负，正值表示想文件尾部移动，负值表示向文件头部移动。whence表示当前位置的基点，主要有以下三个基点符号常量。</p>
<p>  SEEK_SEK	将光标移到距离文件头前后offset个字节；</p>
<p>  SEEK_CUR	将光标移到当前位置前后offset个字节；</p>
<p>  SEEK_END	将光标移到文件末尾前后offset个字节。</p>
<ul>
<li>除此之外,lseek函数还可以用来计算文件大小，因为他的返回值是以字节为单位，从文件的起始点开始计算到当前位置的字节数</li>
<li><code>int size_of_file = lseek(fd, 0, SEEK_END);</code></li>
</ul>
</blockquote>
<h5 id="stat-amp-lstat"><a href="#stat-amp-lstat" class="headerlink" title="stat &amp; lstat"></a>stat &amp; lstat</h5><p>stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carefree2005/article/details/122454333">stat</a>	<code>int stat(const char *pathname, struct stat *buf);</code>	(使用时要先<code>struct stat st;</code> 传入<code>&amp;st</code>)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/W1024201/article/details/125118032">lstat</a>	<code>int lstat(const char *pathname, struct stat buf);</code></p>
<blockquote>
<p>  stat	获取链接文件的信息时，具有穿透能力，直接穿越链接文件，获取所被链接文件的信息。</p>
<p>  lstat	获取链接文件的信息，无穿透能力</p>
<p>  st.st_mode	获取到的部分文件信息用st.st_mode 与下面这13个码分别相与得到，第一个&amp;得出4位，后面的每个&amp;得出1位</p>
<p>  st.st_xxx	其他的所有属性也在这里面，到时查手册即可</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030193146766.png" alt="image-20221030193146766" style="zoom:50%;">



<h4 id="Linux文件属性操作函数"><a href="#Linux文件属性操作函数" class="headerlink" title="Linux文件属性操作函数"></a>Linux文件属性操作函数</h4><h5 id="access"><a href="#access" class="headerlink" title="access"></a>access</h5><p><code>int access(const char* pathname, int mode);</code></p>
<blockquote>
<p>  返回值：成功0，失败-1</p>
<p>  mode：指定access的作用，取值如下</p>
<ol>
<li>F_OK 值为0，判断文件是否存在</li>
<li>X_OK 值为1，判断对文件是可执行权限</li>
<li>W_OK 值为2，判断对文件是否有写权限</li>
<li>R_OK 值为4，判断对文件是否有读权限</li>
</ol>
<p>   注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</p>
</blockquote>
<h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p><code>int chmod(const char* filename ,int mode);</code></p>
<p><code>chmod [-cfvR] [--help] [--version] mode file</code>	其中<code>mode</code>格式 : <code>[ugoa] [+ - =] [rwxX] [ ,... ]</code></p>
<blockquote>
<p>  <code>u</code> 表示该档案的拥有者，<code>g</code>表示与该档案的拥有者属于同一个群体(group)者，<code>o </code>表示其他以外的人，<code>a</code> 表示这三者皆是。</p>
<p>  <code>+</code>表示增加权限、<code>-</code> 表示取消权限、<code>=</code> 表示唯一设定权限。</p>
<p>  <code>r </code>表示可读取，<code>w</code> 表示可写入，<code>x</code> 表示可执行，<code>X</code> 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</p>
<p>  -c 	若该档案权限确实已经更改，才显示其更改动作</p>
<p>  -f 	若该档案权限无法被更改也不要显示错误讯息</p>
<p>  -v 	显示权限变更的详细资料</p>
<p>  -R 	对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</p>
<p>  –help	显示辅助说明</p>
<p>  –version	显示版本</p>
</blockquote>
<blockquote>
<p>  <code>chmod ugo+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod a+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod ug+w,o-w file1.txt file2.txt </code>	将档案 file1.txt 与 file2.txt 设为该档案拥有者与其同组可写入，其他人不可写入 </p>
<p>  <code>chmod u+x ex1.py </code>	将 ex1.py 设定为只有该档案拥有者可以执行 </p>
<p>  <code>chmod -R a+r * </code>	将目前目录下的所有档案与子目录皆设为任何人可读取 </p>
<p>  <code>chmod ug=rwx,o=x file </code>	设置该档案拥有者与其同组可读写执行，其他人只能执行</p>
</blockquote>
<h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p><code>int chown(const char *path, uid_t owner, gid_t group);</code></p>
<p><code>chown [参数] user[:group] [文件]</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>新的文件拥有者的使用者 ID</td>
</tr>
<tr>
<td>group</td>
<td>新的文件拥有者的使用者组(group)</td>
</tr>
<tr>
<td>-c</td>
<td>显示更改的部分的信息</td>
</tr>
<tr>
<td>-f</td>
<td>忽略错误信息</td>
</tr>
<tr>
<td>-h</td>
<td>-h 改变的是链接文件属主， 不加-h改变的是链接源文件属主</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>-R</td>
<td>处理指定目录以及其子目录下的所有文件</td>
</tr>
<tr>
<td>–help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<p>以下选项修改了在还指定了-R选项时遍历层次结构的方式。如果指定了多个，则只有最后一个生效。</p>
<blockquote>
<p>  -H 如果命令行参数是指向目录的符号链接，则遍历它</p>
<p>  -L 遍历遇到的每个指向目录的符号链接</p>
<p>  -P 不遍历任何符号链接（默认）</p>
</blockquote>
<h5 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h5><p><code>int truncate(const char *path, off_t length);</code></p>
<p><code>truncate OPTION... FILE...</code>	命令可以将一个文件缩小或者扩展到某个给定的大小.可以用-s选项来指定文件的大小</p>
<blockquote>
<p>  -c	do not create any files</p>
<p>  -o	treat SIZE as number of IO blocks instead of bytes</p>
<p>  -r	base size on RFILE</p>
<p>  -s	set or adjust the file size by SIZE bytes</p>
<p>  –help </p>
<p>  –version</p>
</blockquote>
<h4 id="Linux目录操作函数"><a href="#Linux目录操作函数" class="headerlink" title="Linux目录操作函数"></a>Linux目录操作函数</h4><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p><code>int mkdir (const char *pathname, mode_t mode) ;</code></p>
<h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h5><p><code>int rmdir (const char *pathname) ;</code></p>
<h5 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h5><p><code>int rename (const char *oldname, const char* newname) ;</code></p>
<h5 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h5><p><code>char *getcwd (char *buf,size_t size) ;</code></p>
<blockquote>
<p>  getcwd	会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</p>
</blockquote>
<h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h5><p><code>DIR* opendir (const char* name) ;</code></p>
<blockquote>
<p>  打开一个目录并建立一个目录流</p>
<p>  如果打开成功的话返回一个DIR结构的指针,该指针用于读取目录数据项。</p>
<p>  如果失败的话返回一个空指针如果文件中的文件过多也可能打开失败</p>
</blockquote>
<h5 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h5><p><code>int chdir (const char* path) ;</code></p>
<blockquote>
<p>  改变当前工作目录</p>
</blockquote>
<h5 id="readir"><a href="#readir" class="headerlink" title="readir"></a>readir</h5><p><code>struct dirent* readdir (DIR* dirp) ;</code></p>
<blockquote>
<p>  返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h5><p><code>int closedir (DIR* dirp) ;</code></p>
<h4 id="dup-amp-dup2"><a href="#dup-amp-dup2" class="headerlink" title="dup &amp; dup2"></a>dup &amp; dup2</h4><p><code>int dup(int oldfd) ;</code></p>
<blockquote>
<p>  在 Linux 系统中， open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具 有读写权限；在 Linux 系统下，可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制。我们来学习下两个函数的用法以及它们之间的区别。</p>
<p>  复制得到的文件描述符与旧的文件描述符都指向了同一个文件表，假设 fd1 为原文件描述符， fd2 为复制得到的文件描述符，如下图所示：</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VwZXJzbWFydEA=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>  因为复制得到的文件描述符与旧的文件描述符指向的是同一个文件表，所以可知，这两个文件描述符的 属性是一样，譬如对文件的读写权限、文件状态标志、文件偏移量等，所以从这里也可知道“复制”的含义实则是复制文件表。同样，在使用完毕之后也需要使用 close 来关闭文件描述符。</p>
<p>  例子：若fd 等于 3 ，复制得到的新的文件描述符为可能为 5</p>
</blockquote>
<p><code>int dup2(int oldfd, int newfd);</code></p>
<blockquote>
<p>  oldfd ： 需要被复制的文件描述符。<br>  newfd ： 指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>  返回值： 成功时将返回一个新的文件描述符，即手动指定的文件描述符 newfd ；如复制失败将返回-1 ，并且会设置 errno 值。</p>
</blockquote>
<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><p><code>int fcntl(int fd, int cmd);</code></p>
<p><code>int fcntl(int fd, int cmd, long arg);</code></p>
<p><code>int fcntl(int fd, int cmd ,struct flock* lock);</code></p>
<blockquote>
<p>  fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</p>
<p>  cmd参数对应功能如下:</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Center.png" alt="img"></p>
<p>  记录锁：实现只锁文件的某个部分，并且可以灵活的选择是阻塞方式还是立刻返回方式</p>
<p>  当fcntl用于管理文件记录锁的操作时，第三个参数指向一个struct flock *lock的结构体</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">flock</span> &#123;</span><br><span class="line">   short_l_type;    <span class="comment">/*锁的类型*/</span></span><br><span class="line">    short_l_whence;  <span class="comment">/*偏移量的起始位置：SEEK_SET,SEEK_CUR,SEEK_END*/</span></span><br><span class="line">    off_t_l_start;   <span class="comment">/*加锁的起始偏移*/</span></span><br><span class="line">    off_t_l_len;    <span class="comment">/*上锁字节*/</span></span><br><span class="line">    pid_t_l_pid;   <span class="comment">/*锁的属主进程ID */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Linux-多进程开发"><a href="#Linux-多进程开发" class="headerlink" title="Linux 多进程开发"></a>Linux 多进程开发</h3><h4 id="程序和进程概述"><a href="#程序和进程概述" class="headerlink" title="程序和进程概述"></a>程序和进程概述</h4><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB (Processing Control Block) 进程控制块，维护进程相关的信息。</p>
<p>Linux内核的进程控制块是<code>task_struct</code> 结构体。在<code>/usr/src/linux-headers-xxx/include/linux/sched.h</code>文件中可以查看其定义</p>
<p>其内部成员有很多，我们只需要掌握以下部分即可:</p>
<blockquote>
<p>  进程id:系统中每个进程有唯一的id, 用pid_t类型表示, 其实就是一个非负整数</p>
<p>  进程的状态:有就绪、运行、挂起、停止等状态</p>
<p>  进程切换时需要保存和恢复的一些CPU寄存器</p>
<p>  描述虚拟地址空间的信息</p>
<p>  描述控制终端的信息</p>
<p>  当前工作目录(Current Working Directory)</p>
<p>  umask掩杩</p>
<p>  文件描述符表, 包含很多指向file结构体的指针**(一个进程一个虚拟地址空间,该虚拟空间内核区有个PCB, PCB里有文件描述符表)**</p>
<p>  和信号相关的信息</p>
<p>  用户id和组id</p>
<p>  会话 (Session) 和 进程组</p>
<p>  进程可以使用的资源上限(Resource Limit)</p>
</blockquote>
<h5 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221031215037224.png" alt="image-20221031215037224" style="zoom: 67%;">



<h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h5><p><code>tty</code>	显示当前终端</p>
<h5 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h5><p><code>ulimit -a</code>	查看系统中所有资源使用情况</p>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p><code>ps -aux /ajx</code>	查看进程</p>
<blockquote>
<p>  a: 显示终端上的所有进程，包括其他用户的进程<br>  u: 显示进程的详细信息<br>  x: 显示没有控制终端的进程<br>  j: 列出与作业控制相关的信息</p>
</blockquote>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p><code>top</code>	实时显示进程动态</p>
<p>可以在使用top命令时加上-d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示的结果进行排序:</p>
<blockquote>
<p>  M	根据内存使用量排序<br>  P	根据CPU占有率排序<br>  T	根据进程运行时间长短排序<br>  U	根据用户名来筛选进程.<br>  K	输入指定的PID杀死进程</p>
</blockquote>
<h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p><code>kill [-选项] pid</code>	杀死进程</p>
<blockquote>
<p>  kill -l	列出所有可选选项</p>
<p>  -9	强制杀死进程</p>
</blockquote>
<h5 id="获取pid函数"><a href="#获取pid函数" class="headerlink" title="获取pid函数"></a>获取pid函数</h5><p><code>pid_t getpid (void);</code>	获取当前进程号</p>
<p><code>pid_t getppid (void);</code>	获取父进程号</p>
<p><code>pid_t getpgid(pid_t pid);</code>	获取组进程号</p>
<blockquote>
<p>  进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID) 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</blockquote>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p><code>pid_t fork(void);</code>	系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<blockquote>
<p>  成功:子进程中返回 0，父进程中返回子进程 ID	失败:返回 -1</p>
<p>  失败的两个主要原因:</p>
<p>  1.当前系统的进程数已经达到了系统规定的上限，这时 <code>errno</code> 的值被设置为 <code>EAGAIN</code></p>
<p>  2.系统内存不足，这时 <code>errno</code> 的值被设置为 <code>ENOMEM</code></p>
</blockquote>
<h4 id="父子进程虚拟地址空间"><a href="#父子进程虚拟地址空间" class="headerlink" title="父子进程虚拟地址空间"></a>父子进程虚拟地址空间</h4><ol>
<li>内核区的pid(自己的)不同</li>
<li>使用<code>pid_t a = fork()</code>后,栈内的返回值不同,父进程栈里a为子进程号, 子进程栈里a为0</li>
<li>修改栈空间的变量互不干扰</li>
<li>父子进程有相同的文件描述符,指向相同的文件表,引用计数增加,共享文件偏移指针</li>
</ol>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101013945568.png" alt="image-20221101013945568" style="zoom: 67%;">



<h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><p>使用GDB调试的时候，GDB 默认只能跟踪一个进程， 可以在fork 函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<p><code>set follow-fork-mode [parent (默认) | child]</code>	</p>
<blockquote>
<p>  设置调试父进程或者子进程[被调试的进程停在断点处, 另一个进程顺利执行]</p>
</blockquote>
<p><code>set detach-on-fork [on| off]</code>	</p>
<blockquote>
<p>  设置调试模式默认为on，表示调试当前进程的时候，其它的进程继续运行，如果为off, 调试当前进程的时候，其它进程被GDB挂起。</p>
</blockquote>
<p><code>info inferiors</code>	查看调试的进程</p>
<p><code> inferior id</code>	切换当前调试的进程</p>
<p><code>detach inferiors id </code>	使进程脱离GDB调试</p>
<h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样,颇有些神似“三十六计”中的“金蝉脱壳”。只有调用失败了，它们才会返回-1， 从原程序的调用点接着往下执行。</p>
<p>exec函数族共有6种不同形式的函数。这6个函数可以划分为两组：</p>
<p>(1)execl、execle和execlp。</p>
<blockquote>
<p>  这里的l是list(列表)的意思，表示execl系列函数需要将每个命令行参数作为函数的参数进行传递；</p>
</blockquote>
<p>(2)execv、execve和execvp。</p>
<blockquote>
<p>  而v是vector(矢量)的意思，表示execv系列函数将所有函数包装到一个矢量数组中传递即可</p>
</blockquote>
<p><code>int execl(const char * path，const char * arg，…)；</code></p>
<p><code>int execle(const char * path，const char * arg，char * const envp[])；</code></p>
<p><code>int execlp(const char * file，const char * arg，…)；</code></p>
<p><code>int execv(const char * path，char * const argv[])；</code></p>
<p><code>int execve(const char * path，char * const argv[]，char * const envp[])；</code></p>
<p><code>int execvp(const char * file，char * const argv[])；</code></p>
<blockquote>
<p>path	要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execve、execl和execle这4个函数中，使用带路径名的文件名作为参数。</p>
<p>file	要执行的程序名称。如果该参数中包含“&#x2F;”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。</p>
<p>argv	命令行参数的矢量数组。</p>
<p>envp	带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用进程的环境变量。</p>
<p>arg	程序的第0个参数，即程序名自身。相当于argv[0]。</p>
<p>…	命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。</p>
</blockquote>
<h4 id="结束进程、孤儿进程、僵尸进程"><a href="#结束进程、孤儿进程、僵尸进程" class="headerlink" title="结束进程、孤儿进程、僵尸进程"></a>结束进程、孤儿进程、僵尸进程</h4><h5 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h5><p>exit是标准C库函数</p>
<p>_exit是标准Linux库函数</p>
<blockquote>
<p>  status是进程退出是的一个状态信息,父进程回收子进程资源时可以获取到</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143024126.png" alt="image-20221101143024126" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143922053.png" alt="image-20221101143922053" style="zoom: 67%;">



<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><ul>
<li><p>**父进程运行结束，但子进程还在运行(未运行结束)**，这样的子进程就称为孤儿进程(Orphan Process) 。</p>
</li>
<li><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init ,而init进程会循环地wait() 它的已经退出的子进程。当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
</li>
</ul>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><ul>
<li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。</p>
</li>
<li><p><strong>进程终止时，父进程尚未回收它，子进程残留资源(PCB) 存放于内核中，变成僵尸(Zombie)进程</strong>。</p>
</li>
<li><p>僵尸进程不能被kill -9杀死。</p>
</li>
<li><p>这样就会导致一个问题，如果父进程不调用wait() 或waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
</li>
</ul>
<blockquote>
<p>  kill -9 僵尸进程号 杀不了僵尸进程, 只有把他父进程杀了&#x2F;在父进程中按<code>ctrl + c</code>&#x2F;调用<code>wait()</code>或<code>waitpid()</code>函数后, 他才会被杀死</p>
</blockquote>
<h4 id="wait、waitpid函数"><a href="#wait、waitpid函数" class="headerlink" title="wait、waitpid函数"></a>wait、waitpid函数</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主</p>
<p>要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。wait()和waitpid() 函数的功能一样</p>
<p>区别在于，wait()函数会阻塞  waitpid()可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</p>
<blockquote>
<p>  注意: 一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
</blockquote>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p><code> pid_t wait(int *stat_loc);</code></p>
<blockquote>
<p>  返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno 中</p>
</blockquote>
<blockquote>
<p>  stat_loc 可以是a, b, c 然后调用<code>WIFEXITED(a)</code> <code>WEXITSTATUS(b)</code> <code>WIFSIGNALED(stat_val)</code> <code>WTERMSIG(stat_val)</code> <code>WIFSTOPPED(stat_val)</code> <code>WSTOPSIG(stat_val)</code> <code>WIFCONTINUED(stat_val)</code>能获取各种返回状态</p>
</blockquote>
<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><p><code>pid_t waitpid(pid_t pid, int *stat_loc, int options);</code></p>
<blockquote>
<p>  pid &#x3D;&#x3D; -1	 等待任一子进程。与wait等效</p>
<p>  pid &gt; 0	等待其进程ID 与 pid 相等的子进程</p>
<p>  pid &#x3D;&#x3D; 0	 等待进程组ID 与 目前进程相同的任何子进程。（少用&#x2F;基本不用）</p>
<p>  pid &lt; -1	等待其组ID 等于 pid的绝对值的任一子进程。（少用&#x2F;基本不用)   </p>
</blockquote>
<blockquote>
<p>  options  &#x3D;&#x3D; 0，表示waitpid函数为阻塞的。（该函数会阻塞卡在这儿，若有子进程，就回收；若没有子进程，一直卡着）</p>
<p>  options &#x3D;&#x3D; WNOHANG，表示waitpid函数为非阻塞的（也即不管有没有子进程了，该函数都不会阻塞卡在这儿）</p>
</blockquote>
<h4 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h4><p>进程是一个独立的资源分配单元，不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC: Inter Processes Communication )。</p>
<p>进程通信的目的:</p>
<blockquote>
<p>  数据传输    一个进程需要将它的数据发送给另一个进程。</p>
<p>  通知事件    一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)</p>
<p>  资源共享    多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</p>
<p>  进程控制    有些进程希望完全控制另一个进程的执行(如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</blockquote>
<h5 id="Linux进程通信方式"><a href="#Linux进程通信方式" class="headerlink" title="* Linux进程通信方式"></a>* Linux进程通信方式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102133524824.png" alt="image-20221102133524824"></p>
<h4 id="匿名管道-管道"><a href="#匿名管道-管道" class="headerlink" title="匿名管道[管道]"></a>匿名管道[管道]</h4><blockquote>
<p>   用在父子或兄弟进程中</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102140508146.png" alt="image-20221102140508146"></p>
<h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><ul>
<li><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</p>
</li>
<li><p>管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体，有名管道有文件实体,但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102143252014.png" alt="image-20221102143252014" style="zoom:50%;">



<h5 id="匿名管道进程间通信原理"><a href="#匿名管道进程间通信原理" class="headerlink" title="匿名管道进程间通信原理"></a>匿名管道进程间通信原理</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144326483.png" alt="image-20221102144326483" style="zoom:50%;">



<h5 id="匿名管道的数据结构"><a href="#匿名管道的数据结构" class="headerlink" title="匿名管道的数据结构"></a>匿名管道的数据结构</h5><ul>
<li>逻辑环形队列</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144456528.png" alt="image-20221102144456528" style="zoom:50%;">



<h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><p> 使用	<code>xxx | xxx</code></p>
<h6 id="创建一个匿名管道"><a href="#创建一个匿名管道" class="headerlink" title="创建一个匿名管道"></a>创建一个匿名管道</h6><p><code>int pipe(int pipefd[2]);</code></p>
<blockquote>
<p>  pipefd 数组是一个传出参数	pipefd[0] 对应管道的读端 pipefd[1] 对应管道的写端</p>
<p>  返回值: 成功返回0, 失败返回-1</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在fork之前创建管道</span></span><br><span class="line">	<span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot; pipe&quot;</span> );</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//父进程, 读</span></span><br><span class="line">            <span class="comment">// 从管道的读取端读取数据, 返回读取到的字节数 若管道内没有数据自动阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>); <span class="comment">// 将buf置为全0</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//父进程, 写</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am a parent&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程, 写</span></span><br><span class="line">           <span class="type">char</span>* str = <span class="string">&quot;hello,i am a child&quot;</span>;</span><br><span class="line">           <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>	(<span class="number">1</span>); <span class="comment">// 若没有sleep 则下面读模块会读取自己刚写的</span></span><br><span class="line">      </span><br><span class="line">            <span class="comment">// 子进程, 读	一定要在子进程写后 不然父子进程都阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="查看管道缓冲大小"><a href="#查看管道缓冲大小" class="headerlink" title="查看管道缓冲大小"></a>查看管道缓冲大小</h6><p><code>ulimit -a</code>	命令</p>
<p><code>long fpathconf (int fd, int name);</code>	函数</p>
<blockquote>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102174749178.png" alt="image-20221102174749178">
</blockquote>
<h6 id="设置管道非阻塞"><a href="#设置管道非阻塞" class="headerlink" title="设置管道非阻塞"></a>设置管道非阻塞</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_GETFL);		<span class="comment">//获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;		<span class="comment">//修改flag的值</span></span><br><span class="line"><span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_SETFL, flags);		<span class="comment">//设置新的flag</span></span><br></pre></td></tr></table></figure>



<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><blockquote>
<p>  用在没有关系的进程中</p>
</blockquote>
<ul>
<li>匿名管道，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO) ，也叫命名管道、FIF0文件。</li>
<li>有名管道(FIFO) 不同于匿名管道在于它提供了一个路径名与之关联，以FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。</li>
<li>一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了(如read()、 write ()和close())。与管道一样，FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。</li>
<li>有名管道(FIFO)和匿名管道(pipe) 有一些特点是相同的，不一样的地方在于:<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但FIFO 中的内容却存放在内存中。</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO有名字，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
</li>
</ul>
<h5 id="创建有名管道"><a href="#创建有名管道" class="headerlink" title="创建有名管道"></a>创建有名管道</h5><p><code>mkfifo 名字</code>		通过函数创建有名管道</p>
<p><code>int mkfifo(const char *pathname, mode_t mode);</code>		通过函数创建有名管道</p>
<blockquote>
<p>  mode 和 open 函数的mode是一样的</p>
</blockquote>
<blockquote>
<p>   一旦使用mkfifo 创建了一个FIFO， 就可以使用open打开，常见的文件I&#x2F;0函数都可用于fifo,如 close、read、 write、unlink</p>
<p>  FIFO严格遵循先进先出(First in First out)，对管道及FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
</blockquote>
<h5 id="使用有名管道"><a href="#使用有名管道" class="headerlink" title="使用有名管道"></a>使用有名管道</h5><ul>
<li>创建两个文件(两个进程)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向管道中写数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.一个为只读打开管道进程会阻塞，直到写端打开</span></span><br><span class="line"><span class="comment">2.一个为只写打开管道进程会阻塞，直到读端打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、先判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建管道文件</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        	<span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、打开管道，以只写的方式</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123; </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n &quot;</span>, i); 	<span class="comment">// sprintf函数调用的主要用途就是把一个字符串放在一个已知的字符数组里去</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从管道中读数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 ： 需要两个进程（这里是两个文件）同时执行</span></span><br></pre></td></tr></table></figure>



<h5 id="有名管道实现聊天功能"><a href="#有名管道实现聊天功能" class="headerlink" title="有名管道实现聊天功能"></a>有名管道实现聊天功能</h5><ul>
<li>这样的文件 (进程) 有两份 A文件中为以下代码，B文件与A中只读和只写的有名管道相反</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">//创建管道</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断管道2是否存在</span></span><br><span class="line">    ret=<span class="built_in">access</span>(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret ==- <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只写的方式打开fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道1fifo1成功, 等待写入数据\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以只读的方式打开fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功, 等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//4、循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">//读取标准输入的数据(test用户输入的东西)</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf,<span class="number">128</span>,stdin);</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        ret = <span class="built_in">write</span>(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、读管道数据</span></span><br><span class="line">        <span class="built_in">mset</span>(buf,<span class="number">0</span>,<span class="number">128</span>);<span class="comment">//清空数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf:%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6、关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端1</span></span><br><span class="line">gcc chatA.c -o a</span><br><span class="line">gcc chatB.c -o b</span><br><span class="line">./a</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 终端2</span></span><br><span class="line">./b</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br></pre></td></tr></table></figure>



<h4 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h4><blockquote>
<p>  关闭读描述符 <code>close(piped[0]);</code>		 写类似</p>
</blockquote>
<ul>
<li><strong>没有进程写，只有进程读</strong>	如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道的读端读数据，那么文件内的所有内容被读完后再次read就会返回0，就像读到文件结尾。</li>
<li><strong>写描述符没关，但也没写</strong>    如果有指向管道写端的文件描述符没有关闭（管道写段的引用计数大于0），而持有管道写端的进程没有向管道内写入数据，假如这时有进程从管道读端读数据，那么读完管道内剩余的数据后就会阻塞等待，直到有数据可读才读取数据并返回。</li>
<li><strong>没有进程读，只有进程写</strong>    如果所有指向管道读端的文件描述符都关闭，此时有进程通过写端文件描述符向管道内写数据时，则该进程就会收到SIGPIPE信号，并异常终止。</li>
<li><strong>读描述符没关，但也没读</strong>    如果有指向管道读端的文件描述符没有关闭（管道读端的引用计数大于0），而持有管道读端的进程没有从管道内读数据，假如此时有进程通过管道写段写数据，那么管道被写满后就会被阻塞，直到管道内有空位置后才写入数据并返回。</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102194024601.png" alt="image-20221102194024601" style="zoom: 67%;">



<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><ul>
<li><p>内存映射区通信，是非阻塞。</p>
</li>
<li><p>进程间有无关系都可以</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103120849314.png" alt="image-20221103120849314" style="zoom:50%;">

<h5 id="内存映射的相关系统调用"><a href="#内存映射的相关系统调用" class="headerlink" title="内存映射的相关系统调用"></a>内存映射的相关系统调用</h5><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size;</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<h5 id="使用内存映射实现进程间通信"><a href="#使用内存映射实现进程间通信" class="headerlink" title="使用内存映射实现进程间通信"></a>使用内存映射实现进程间通信</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>有关系的进程（父子进程）</span><br><span class="line">	- 还没有子进程的时候</span><br><span class="line">		- 通过唯一的父进程，先创建内存映射区</span><br><span class="line">	- 有了内存映射区以后，创建子进程</span><br><span class="line">	- 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>没有关系的进程间通信</span><br><span class="line">	- 准备一个大小不是<span class="number">0</span>的磁盘文件</span><br><span class="line">	- 进程<span class="number">1</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 进程<span class="number">2</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 使用内存映射区通信</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 test.txt 在里面写一点数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父子进程间通讯(两个独立的进程通信：将下面的代码拆成两个文件 需要各打开同一个文件，都得创建内存映射区)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);	<span class="comment">// 子进程往文件中写数据，写完了后父进程就将它回收，再读</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr); <span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;nihao a, son!!!&quot;</span>);	<span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="内存映射TIPS"><a href="#内存映射TIPS" class="headerlink" title="内存映射TIPS"></a>内存映射TIPS</h5><p>如果对mmap的返回值(ptr)做++操作(ptr++)，munmap是否能够成功?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * ptr = <span class="built_in">mmap</span>(...);</span><br><span class="line">ptr++;  <span class="comment">//可以对其进行++操作，但是不建议这样做，会导致无法正确释放映射</span></span><br><span class="line"><span class="built_in">munmap</span>(ptr, len);   <span class="comment">// 错误，要保存地址</span></span><br></pre></td></tr></table></figure>

<p>如果open时O_RDONLY, mmap 时 prot 参数指定PROT_READ | PROT_WRITE会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">错误，返回 <span class="function">MAP_FAILED</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">()</span>函数中的权限建议和 prot 参数的权限保持一致。</span></span><br></pre></td></tr></table></figure>

<p>如果文件偏移量为1000会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">偏移量必须是 <span class="number">4</span>K 的整数倍，返回 MAP_FAILED。</span><br></pre></td></tr></table></figure>

<p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- 可以的，但是创建的文件的大小如果为<span class="number">0</span>的话，肯定不行</span><br><span class="line">- 可以对新的文件进行扩展</span><br><span class="line">	- <span class="built_in">lseek</span>()</span><br><span class="line">  - <span class="built_in">truncate</span>()</span><br></pre></td></tr></table></figure>

<p>mmap后关闭文件描述符，对mmap映射有没有影响？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="built_in">mmap</span>(,,,,fd,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">close</span>(fd); <span class="comment">// 映射区还存在，创建映射区的fd被关闭，没有任何影响。</span></span><br></pre></td></tr></table></figure>



<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h5 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h5><ul>
<li><p>信号是Linux进程间通信的最古老的方式之一，<strong>是事件发生时对进程的通知机制，有时也称之为软件中断</strong>，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下:</p>
<ol>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用kill 函数。</li>
</ol>
</li>
<li><p>使用信号的两个主要目的是:</p>
<ol>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ol>
</li>
<li><p>信号的特点:</p>
<ol>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ol>
</li>
<li><p>查看系统定义的信号列表    <code>kill -l</code>     (前31个信号为常规信号，其余为实时信号)</p>
</li>
</ul>
<h5 id="部分信号一览表"><a href="#部分信号一览表" class="headerlink" title="部分信号一览表"></a>部分信号一览表</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103164530935.png" alt="image-20221103164530935" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165336300.png" alt="image-20221103165336300" style="zoom: 50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165127529.png" alt="image-20221103165127529" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165504053.png" alt="image-20221103165504053" style="zoom:50%;">



<h6 id="举例：SIGCHILD"><a href="#举例：SIGCHILD" class="headerlink" title="举例：SIGCHILD"></a>举例：SIGCHILD</h6><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221104170616515.png" alt="image-20221104170616515"></p>
<h5 id="信号的五种默认处理动作"><a href="#信号的五种默认处理动作" class="headerlink" title="信号的五种默认处理动作"></a>信号的五种默认处理动作</h5><p>查看信号的详细信息	<code>man 7 signal</code></p>
<p>信号的5种默认处理动作：</p>
<ol>
<li>Term	终止进程</li>
<li>Ign    当前进程忽略掉这个信号</li>
<li>Core    终止进程，并生成一个Core文件</li>
<li>Stop    暂停当前进程</li>
<li>Cont    继续执行当前被暂停的进程</li>
</ol>
<p>信号的几种状态：	产生、未决（没到达进程）、递达（到达进程）</p>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p>
<h5 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h6 id="kill-1"><a href="#kill-1" class="headerlink" title="kill"></a>kill</h6><p><code>int kill (pid_t pid, int sig);</code>		给任何进程或者进程组pid发送任何信号sig</p>
<blockquote>
<p>  pid:</p>
<p>  若 &gt; 0	将信号发送给指定的进程；</p>
<p>  &#x3D; 0	将信号发送给当前的进程组；</p>
<p>  &#x3D; -1	将信号发送给每一个有权限接收这个信号的进程</p>
<p>  &lt;-1：这个pid&#x3D;某个进程组的ID取反（-12345）</p>
<p>  sig	需要发送的信号的编号或者是宏值，0表示不发送任何信号</p>
</blockquote>
<h6 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h6><p><code>int raise(int sig);</code>		给当前进程发送信号</p>
<blockquote>
<p>  sig	要发送的信号</p>
<p>  返回值 	成功：0	失败：非0</p>
<p>  相当于  <code>kill(getpid(), sig);</code></p>
</blockquote>
<h6 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h6><p><code>void abort(void) ;</code>		发送SIGABRT信号给当前的进程，杀死当前进程</p>
<blockquote>
<p>  相当于 <code>kill(getpid(),SIGABRT);</code></p>
</blockquote>
<h6 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h6><p><code>unsigned int alarm(unsigned int seconds);</code>		</p>
<blockquote>
<p>  设置定时器(闹钟)。函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号 SIGALARM</p>
</blockquote>
<blockquote>
<p>  seconds	倒计时的时长，单位:秒。如果参数为0，定时器无效(不进行倒计时，不发送信号)</p>
<p>  取消一个定时器，通过alarm(0)</p>
<p>  返回值	之前没有定时器返回0;  之前有定时器,则返回之前定时剩余的倒计时剩余的时间</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> seconds = <span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    seconds = <span class="built_in">alarm</span>(<span class="number">2</span>);<span class="comment">//不阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h6><p><code>int setitimer (int which, const struct itimerval *new_val, struct itimerval *old_value) ;</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能:设置定时器(闹钟)，可以替代alarm函数。精度us，可以实现周期性的定时</span></span><br><span class="line"><span class="comment">          参数:</span></span><br><span class="line"><span class="comment">              which:定时器以什么时间计时</span></span><br><span class="line"><span class="comment">                  ITIMER_REAL:真实时间，时间到达，发送SIGALRM 	常用</span></span><br><span class="line"><span class="comment">                  ITIMER_VIRTUAL:用户时间，时间到达，发送SIGVTALRM</span></span><br><span class="line"><span class="comment">                  ITIMER_PROF:以该进程在用户态和内核态下所消耗的时间来计时，时间到达，发送SIGPROF</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">              new_value:设置定时器的属性</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              struct itimerval &#123;//定时器的结构体</span></span><br><span class="line"><span class="comment">                 struct timeval it_interval; //每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="comment">                 struct timeval it_value;    //延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              struct timeval &#123;//时间的结构体</span></span><br><span class="line"><span class="comment">                 time_t      tv_sec;  //秒数</span></span><br><span class="line"><span class="comment">                 suseconds_t tv_usec; //微秒</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              过10s后每隔2s定时一次</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              old_value:记录上一次的定时的时间参数可以在这里获取到，用不到的话传递一个NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          	返回值:</span></span><br><span class="line"><span class="comment">              成功 0</span></span><br><span class="line"><span class="comment">              失败 -1 指定错误号</span></span><br><span class="line"><span class="comment">*/</span>            </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//过3s后每隔2s定时一次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置值</span></span><br><span class="line">    new_value.it_interval.tv_sec=<span class="number">2</span>;<span class="comment">//设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置延迟的时间,3s后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec=<span class="number">3</span>;<span class="comment">//s</span></span><br><span class="line">    new_value.it_value.tv_usec=<span class="number">0</span>;<span class="comment">//us</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">setitimer</span>(ITIMER_REAL,&amp;new_value,<span class="literal">NULL</span>); <span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>); <span class="comment">// 这里过了3s接收到sigALARM信号直接就终止了，如果想不终止，需要捕捉到信号后自定义处理</span></span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><p><code>sighandler_t signal (int signum, sighandle_ t handler);</code></p>
<blockquote>
<p>  signum	要捕捉的信号，也可以是宏</p>
<p>  handler		捕捉到信号要如何处理</p>
<ul>
<li>SIG_IGN	忽略信号</li>
<li>SIG_DFL	使用信号默认的行为</li>
<li>回调函数	自定义函数（返回值一定要是 void 参数一定要是 int类型（或者信号宏名））</li>
</ul>
<p>  返回值</p>
<ul>
<li>成功，返回上一次注册的信号处理函数的地址。第次调用返回NULL</li>
<li>失败，返回SIG_ ERR， 设置错误号</li>
</ul>
<p>  <strong>SIGKILL SIGSTOP不能被捕捉或忽略</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalhandler</span><span class="params">(<span class="type">int</span> signo)</span></span>&#123;    <span class="comment">//signal函数会传递信号序号给这个函数</span></span><br><span class="line">    <span class="comment">//信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">14</span>, signalhandler);    <span class="comment">//收到14号信号「SIGALARM」时，就会执行对应的信号处理函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h6><p><code>int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);</code></p>
<blockquote>
<p>  sig 指出要捕获的信号类型，act 指定新的信号处理方式，oact 输出先前信号的处理方式（如果不为NULL的话）。</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__sigaction_u</span> __sigaction_u;  <span class="comment">/* signal handler */</span></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask;               <span class="comment">/* signal mask to apply */</span></span><br><span class="line">  <span class="type">int</span> sa_flags;               <span class="comment">/* see signal options below */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">__sigaction_u</span> &#123;</span><br><span class="line">  <span class="built_in">void</span> (*__sa_handler)(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">void</span> (*__sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler      __sigaction_u.__sa_handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction    __sigaction_u.__sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>  sa_handler	此参数和signal()的参数handler相同，代表新的信号处理函数</p>
<p>  sa_mask	用来设置在处理该信号时暂时将sa_mask 指定的信号集搁置</p>
<p>  sa_flags	用来设置信号处理的其他相关操作，下列的数值可用</p>
<ul>
<li><p>SA_RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</p>
</li>
<li><p>SA_RESTART：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</p>
</li>
<li><p>SA_NODEFER ：一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了 SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p>其他查阅 <code>man sigaction</code></p>
</li>
</ul>
</blockquote>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因</p>
<p>此这种IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进</p>
<p>程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管</p>
<p>道是一种存在于内核的文件)，这种IPC技术的速度更快。</p>
<h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol>
<li><p>调用<code>shmget()</code>创建一个新共享内存段或取一个既有共享内存段的标识符( 即由其他进程创建的共享内存段 )。这个调用将返回后续调用中需要用到的共享内存标识符。</p>
</li>
<li><p>使用<code>shmat()</code>和当前进程进行关联, 返回已开辟的内存的首地址</p>
</li>
<li><p>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由<code>shmat() </code>返回的addr 值，它是一个指向进程的虛拟地址空间中该共享内存段的起点的指针。</p>
</li>
<li><p>调用<code>shmdt() </code>来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</p>
</li>
<li><p>调用<code>shmctl()</code>来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</p>
</li>
</ol>
<h5 id="共享内存使用函数"><a href="#共享内存使用函数" class="headerlink" title="共享内存使用函数"></a>共享内存使用函数</h5><h6 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h6><p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>
<blockquote>
<p>  成功完成后，将共享内存段标识符为返回。否则，返回-1并设置全局变量errno表示错误</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">key</span><br><span class="line"><span class="number">0</span>(IPC_PRIVATE)：会建立新共享内存对象</span><br><span class="line"></span><br><span class="line">大于<span class="number">0</span>的<span class="number">32</span>位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">大于<span class="number">0</span>的整数：新建的共享内存大小，以字节为单位</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：只获取共享内存时指定为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">shmflg</span><br><span class="line"><span class="number">0</span>：取共享内存标识符，若不存在则函数会报错</span><br><span class="line"></span><br><span class="line">IPC_CREAT：当shmflg&amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符</span><br><span class="line"></span><br><span class="line">IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h6><p><code>void* shmat(int shmid, const void * shmaddr, int shmflg);</code></p>
<blockquote>
<p>  成功：附加好的共享内存地址  出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid	共享内存标识符</p>
<p>  shmaddr	指定共享内存出现在进程内存地址的什么位置，直接指定为NULL让内核自己决定一个合适的地址位置</p>
<p>  shmflg	SHM_RDONLY：为只读模式， 0：为读写模式</p>
</blockquote>
<h6 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h6><p><code>int shmdt (const void *shmaddr) ;</code></p>
<blockquote>
<p>  成功返回0	出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmaddr	连接的共享内存的起始地址</p>
</blockquote>
<h6 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h6><p><code>int shmctl (int shmid, int cmd, struct shmid_ds *buf) ;</code></p>
<blockquote>
<p>  成功：0	出错：-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid：共享内存标识符</p>
<p>  cmd</p>
<blockquote>
<p>  IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</p>
<p>  IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内</p>
<p>  IPC_RMID：删除这片共享内存</p>
</blockquote>
<p>  buf	需要设置或者获取的共享内存的属性信息, 一般写NULL</p>
<blockquote>
<p>  IPC_ STAT 	buf存储数据<br>  IPC_ SET 	buf中需要初始化数据，设置到内核中<br>  IPC_ RMID 	没有用，NULL</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /home/kjg/Linux/sharememory/write_shm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一块共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联, 返回已开辟的内存的首地址</span></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按任意键继续</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.释放共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h6><p><code>key_t ftok (const char *pathname, int proj_id);</code></p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105134241461.png" alt="image-20221105134241461">



<h5 id="操作系统如何知道一块共享内存被多少个进程关联"><a href="#操作系统如何知道一块共享内存被多少个进程关联" class="headerlink" title="操作系统如何知道一块共享内存被多少个进程关联"></a>操作系统如何知道一块共享内存被多少个进程关联</h5><ul>
<li>共享内存维护了一个结构体<code>struct shmid_ds</code> 这个结构体中有一个成员<code>shm_nattach </code>记录了关联的进程个数</li>
<li>ipcs用法</li>
</ul>
<blockquote>
<p>  ipcs -a	&#x2F;&#x2F;打印当前系统中所有的进程间通信方式的信息</p>
<p>  ipcs -m	&#x2F;&#x2F;打印出使用共享内存进行进程间通信的信息</p>
<p>  ipcs -q	&#x2F;&#x2F;打印出使用消息队列进行进程间通信的信息</p>
<p>  ipcs -s	&#x2F;&#x2F;打印出使用信号进行进程间通信的信息</p>
</blockquote>
<ul>
<li>ipcrm用法</li>
</ul>
<blockquote>
<p>  ipcrm -M shmkey	&#x2F;&#x2F;移除用shmkey创建的共享内存段</p>
<p>  ipcrm -m shmid	&#x2F;&#x2F; 移除用 shmid标识的共享内存段</p>
<p>  ipcrm -Q msgkey	&#x2F;&#x2F;移除用msqkey创建的消息队列</p>
<p>  ipcrm -q msqid	&#x2F;&#x2F;移除用msqid标识的消息队列</p>
<p>  ipcrm -S semkey	&#x2F;&#x2F;移除用semkey创建的信号</p>
<p>  ipcrm -s semid	&#x2F;&#x2F; 移除用semid标识的信号</p>
</blockquote>
<h4 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h4><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><ul>
<li><p>查看当前终端的pid	<code>echo $$</code></p>
</li>
<li><p>在UNIX系统中，用户通过终端登录系统后得到一个shell 进程，这个终端成为shell 进程的控制终端(Controlling Terminal) ，进程中，控制终端是保存在PCB 中的信息，而fork() 会复制PCB中的信息，因此由shell 进程启动的其它进程的控制终端也是这个终端。</p>
</li>
<li><p>默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
</li>
<li><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生SIGINT 信号，Ctrl + \会产生SIGQUIT 信号。</p>
</li>
</ul>
<h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><ul>
<li><p>进程组和会话在进程之间形成了一种两级层次关系:<strong>进程组是一组相关进程的集合,会话是一组相关进程组的集合</strong>。进程组和会话是为支持shell 作业控制而定义的抽象概念，用户通过shell 能够交互式地在前台或后台运行命令。</p>
</li>
<li><p>进程组由一个或多个共享同一进程组标识符(PGID) 的进程组成。<strong>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID,  新进程会继承其父进程所属的进程组ID</strong></p>
</li>
<li><p>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员</p>
</li>
</ul>
<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><ul>
<li><p>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</p>
</li>
<li><p><strong>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端</strong></p>
</li>
<li><p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p>
</li>
<li><p><strong>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程</strong></p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105165609594.png" alt="image-20221105165609594">



<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p><code>pid_t getpgrp(void);</code>	用来取得进程所属的组识别码。此函数相当于调用 <code>getpgid(0); </code></p>
<p><code>pid_t getpgid(pid_t pid);</code></p>
<p><code>int setpgid(pid_t pid, pid_t pgid);</code></p>
<p><code>pid_t getsid(pid_t pid);</code></p>
<p><code>pid_t setsid(void);</code></p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><ul>
<li>守护进程 (Daemon Process) ，也就是通常说的精灵进程，<strong>是Linux中的后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</li>
<li>守护进程具备下列特诊:<ul>
<li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如SIGINT、 SIGQUIT)。</li>
</ul>
</li>
<li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器inetd, web服务器httpd 等。</li>
</ul>
<h5 id="守护进程的创建步骤"><a href="#守护进程的创建步骤" class="headerlink" title="守护进程的创建步骤"></a>守护进程的创建步骤</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105181155408.png" alt="image-20221105181155408"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现一个守护进程的实例（每隔 10s 在／tmp/dameon.log 写入一句话）*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Linux多线程开发"><a href="#Linux多线程开发" class="headerlink" title="Linux多线程开发"></a>Linux多线程开发</h3><h4 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h4><ul>
<li>与进程(process) 类似，线程(thread)是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的UNIX进程只是多线程程序的一个特例，该进程只包含一个线程)</li>
<li>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程 (LWP: Light Weight Process) ，在Linux环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号: <code>ps -Lf pid</code></li>
</ul>
<h5 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h5><ul>
<li><p>进程间的信息难以共享。 由于除去只读代码段外，父子进程并未共享内存，因此必须采一些进程间通信方式，在进程间进行信息交换</p>
</li>
<li><p>调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍热需要复制诸如内存页表和文件描述符表之类的多种进程属性,这意味着fork() 调用很慢</p>
</li>
<li><p>线程之间能够方便、快速地共享信息。只需将数据复制到共享(全局或堆)变量中即可</p>
</li>
<li><p>创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</p>
</li>
</ul>
<h5 id="线程和进程虚拟地址空间"><a href="#线程和进程虚拟地址空间" class="headerlink" title="线程和进程虚拟地址空间"></a>线程和进程虚拟地址空间</h5><p>子进程复制父进程的虚拟地址空间，而线程间共享进程的虚拟地址空间，只不过各线程在 <code>栈空间</code> <code>  .text段</code>占据了各一部分</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106215842522.png" alt="image-20221106215842522" style="zoom:50%;">



<h5 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106220232940.png" alt="image-20221106220232940" style="zoom:50%;">



<h4 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h4><p><code>pthread_t pthread_self(void);</code></p>
<p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
<p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start routine) (void *), void *arg);</code></p>
<p><code>void pthread_exit(void *retval);</code></p>
<p><code>int pthread_join(pthread_t thread, void **retval);</code></p>
<p><code>int pthread_detach(pthread_t thread);</code></p>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
<h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start routine)(void *) , void* arg);</code></p>
<p>创建一个子线程</p>
<blockquote>
<p>  thread	传出参数，线程创建成功后，子线程的线程ID被写到该变量</p>
<p>  attr	设置线程的属性，一般使用默认值，NULL</p>
<p>  start_ routine 	函数指针，这个函数是子线程需要处理的逻辑代码</p>
<p>  arg	给第三个参数使用，传参</p>
</blockquote>
<blockquote>
<p>  返回值:	成功: 0	失败:返回错误号。这个错误号和之前errno不太一样。</p>
<p>  获取错误号的信息:	<code>char * strerror(int errnum);</code></p>
</blockquote>
<h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p><code>pthread_t pthread_self(void);</code></p>
<blockquote>
<p>  获取当前线程id</p>
</blockquote>
<h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
<blockquote>
<p>  判断两个线程号是否相等</p>
</blockquote>
<h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p><code>void pthread_exit(void *retval);</code></p>
<blockquote>
<p>  主线程退出时，不影响其他线程的运行</p>
<p>  子线程中 return NULL 相当于 pthread_exit(NULL)</p>
</blockquote>
<h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_ join"></a>pthread_ join</h5><p><code>int pthread_join(pthread_t thread, void **retval);</code></p>
<blockquote>
<p>  pthread_t thread	被连接线程的线程号</p>
<p>  void **retval 	指向 一个指向被连接线程的返回码的指针 的指针</p>
<p>  返回值	线程连接的状态，0是成功，非0是失败</p>
</blockquote>
<blockquote>
<p>  在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果。也就是主线程需要等待子线程执行完成之后再结束，就要用pthread_join()</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;pthreadVC2.lib&quot;</span>) </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_run</span><span class="params">(<span class="type">void</span>* parm)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123; </span><br><span class="line">        count++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The thread_run method count is = %d\n&quot;</span>,count); </span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">pthread_t</span> tid; </span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_run,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 加入pthread_join后，主线程&quot;main&quot;会一直等待直到tid这个线程执行完毕自己才结束 </span></span><br><span class="line">    <span class="comment">// 一般项目中需要子线程计算后的值就需要加join方法 </span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid,<span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果没有join方法可以看看打印的顺序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The count is = %d\n&quot;</span>,count); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当A线程调用线程B并 pthread_join() 时，A线程会处于阻塞状态，直到B线程结束后，A线程才会继续执行下去</p>
<p>  当 pthread_join() 函数返回后，被调用线程才算真正意义上的结束，它的内存空间也会被释放（如果被调用线程是非分离的）</p>
<ol>
<li>被释放的内存空间仅仅是系统空间，你必须手动清除程序分配的空间，比如 malloc() 分配的空间。</li>
<li>一个线程只能被一个线程所连接。</li>
<li>被连接的线程必须是非分离的，否则连接会出错。</li>
</ol>
<p>  所以可以看出pthread_join()有两种作用：</p>
<p>  (1) 用于等待其他线程结束：调用 pthread_join() 后, 当前线程会处于阻塞状态, 直到被调用的线程结束后当前线程才会重新开始执行</p>
<p>  (2) 对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”</p>
</blockquote>
<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p><code>int pthread_detach (pthread_t thread);</code></p>
<blockquote>
<p>  在任何一个时间点上，线程是可结合的，或者是分离的。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的</p>
<p>  <strong>一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">pthread_t</span> tid;</span><br><span class="line">  <span class="type">int</span> status = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">perror</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">pthread_detach</span>(tid);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p><code>int pthread_cancel (pthread_t thread);</code></p>
<blockquote>
<p>  功能：取消线程（终止）	如果成功，返回0;如果发生错误，则返回非零值错误的数字</p>
<p>   pthread_cancel并不立刻让线程终止，它只提出请求。线程在取消请求(pthread_cancel)发出后会继续运行，直到到达某个取消点(CancellationPoint)。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>
<p>  pthread标准指定了几个取消点，其中包括：</p>
<ol>
<li>通过pthread_testcancel调用以编程方式建立线程取消点。</li>
<li>线程等待pthread_cond_wait或pthread_cond_timewait()中的特定条件。</li>
<li>被sigwait(2)阻塞的函数</li>
<li>一些标准的库调用。通常，这些调用包括线程可基于阻塞的函数。</li>
</ol>
</blockquote>
<h4 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h4><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start routine) (void *) , void *arg);</code></p>
<p>中第二个参数就是线程属性</p>
<h5 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h5><p><code>int pthread_attr_init (pthread_attr_t *attr);</code></p>
<p><code>int pthread_attr_destroy (pthread_attr_t *attr);</code></p>
<p><code>int pthread_attr_getdetachstate (const pthread_attr_t *attr, int *detachstate);</code></p>
<p><code>int pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate);</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程分离状态属性</span></span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, THREAD_FUNCTION, arg);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的:必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
<li>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li>
<li>线程同步:即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标,结果: 三个窗口，每个窗口都卖一百张票</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">        tickets --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标: 三个窗口，共卖一百张票, 但结果通常办不到</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>); <span class="comment">// tid1 进入循环休眠时, tid2,tid3都可能进入循环并执行过程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">        tickets --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// 548136161792正在卖第87 张票</span></span><br><span class="line"><span class="comment">// 548119376384正在卖第87 张票</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 547602481664正在卖第1 张票</span></span><br><span class="line"><span class="comment">// 547594088960正在卖第0 张票</span></span><br><span class="line"><span class="comment">// 547585696256正在卖第-1 张票</span></span><br></pre></td></tr></table></figure>



<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><ul>
<li>为避免线程更新共享变量时出现问题，可以使用互斥量(mutex )来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源(可能由多个相关变量组成)会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:<ul>
<li>针对共享资源锁定互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
</ul>
<h6 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h6><p>互斥量的类型	<code>pthread_mutex_t</code></p>
<p><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p>
<blockquote>
<p>  mutex 	需要初始化的互斥量变量</p>
<p>  attr 	互斥量相关的属性，NULL</p>
<p>  restrict 	C语言的修饰符，被修饰的指针的内容不能由另外的一个指针进行操作</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pthread_ <span class="type">mutex_t</span> *restrict mutex = XXX;</span><br><span class="line"><span class="type">pthread_mutex_t</span> * mutex1 = mutex;</span><br><span class="line">* mutex1 = ZZZ; <span class="comment">// 错误,因为 restrict mutex</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p>  释放互斥量的资源</p>
</blockquote>
<p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p>  上锁,阻塞</p>
</blockquote>
<p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex) ;</code></p>
<blockquote>
<p>上锁,非阻塞,如果加锁失败,直接返回</p>
</blockquote>
<p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex) ;</code></p>
<blockquote>
<p>  解锁</p>
</blockquote>
<p><code>lock_guard(mutex&amp; m);</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_count = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_count1</span><span class="params">(std::mutex* mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;fun_count1:&quot;</span>&lt;&lt;--g_count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>*<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_count2</span><span class="params">(std::mutex* mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fun = [&amp;]&#123;</span><br><span class="line">        <span class="comment">//构造时自动加锁</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(*mutex);</span><br><span class="line">        <span class="keyword">if</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;fun_count2:&quot;</span>&lt;&lt;--g_count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//析构自动解锁</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>*<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="案例改进版"><a href="#案例改进版" class="headerlink" title="案例改进版"></a>案例改进版</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三个窗口，卖一百张票</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">            tickets --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221108162830690.png" alt="image-20221108162830690"></p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul>
<li>当有一个线程已经持有互斥锁时，互斥销将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是<strong>实际上多个线程同时读访问共享资源并不会导致问题</strong></li>
<li>在对数据的读写操作中， 更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</li>
<li>读写锁的特点:<ul>
<li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li>
<li>如果有其它线程写数据，则其它线程都不允许读、写。 写的优先级高</li>
</ul>
</li>
</ul>
<h6 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h6><p>读写锁的类型	<code>pthread_rwlock_t</code></p>
<p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock; <span class="comment">// 声明失败是因为与C99冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">writeNum</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        num ++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write===pid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">readNum</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read===pid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个写进程,五个读进程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(wtids[i]); <span class="comment">// 设置线程分离, 线程结束后由系统释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);\</span><br><span class="line">        <span class="built_in">pthread_detach</span>(rtids[i]); <span class="comment">// 设置线程分离, 线程结束后由系统释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>); <span class="comment">// 不写这段话,直接进程退出,所有线程都没了.</span></span><br><span class="line">    <span class="comment">//若写了则主线程退出,子线程都设置了分离,运行完系统回收</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="条件变量-不是锁-不好用"><a href="#条件变量-不是锁-不好用" class="headerlink" title="条件变量(不是锁,不好用)"></a>条件变量(不是锁,不好用)</h5><p>条件变量的类型	<code>pthread_cond_t </code></p>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></p>
<p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p>
<p><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t * restrict mutex);</code></p>
<blockquote>
<p>  阻塞函数,调用了该函数,线程会阻塞等待</p>
</blockquote>
<p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p>
<blockquote>
<p>  阻塞函数,调用了该函数,线程会阻塞等待,直到指定的时间结束</p>
</blockquote>
<p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p>
<blockquote>
<p>  唤醒一个或者多个</p>
</blockquote>
<p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p>
<blockquote>
<p>  唤醒所有</p>
</blockquote>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的类型	<code>sem_t</code></p>
<p><code>int sem_init(sem_t *sem, int pshared, unsigned int value) ;</code></p>
<blockquote>
<p>  sem	信号量变量的地址</p>
<p>  pshared 	0用在线程间，非0用在进程间</p>
<p>  value 	信号量中的值</p>
</blockquote>
<p><code>int sem_destroy(sem_t *sem);</code></p>
<p><code>int sem_wait(sem_t *sem);</code>	P操作</p>
<blockquote>
<p>①S减1</p>
<p>②若S减1后仍大于或等于0，则进程继续执行</p>
<p>③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度</p>
</blockquote>
<p><code>int sem_trywait(sem_t *sem);</code></p>
<p><code>int sem_timedwait(sem_t * sem, const struct timespec *abs_timeout);</code></p>
<p><code>int sem_post(sem_t *sem);</code>		V操作</p>
<blockquote>
<p>  ①S加1</p>
<p>  ②若相加后结果大于0，则进程继续执行</p>
<p>  ③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度</p>
</blockquote>
<p><code>int sem_getvalue(sem_t *sem, int *sval);</code></p>
<blockquote>
<p>  要配合mutex一起用</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221109231419437.png" alt="image-20221109231419437"></p>
<h3 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h3><h4 id="BS和CS架构"><a href="#BS和CS架构" class="headerlink" title="BS和CS架构"></a>BS和CS架构</h4><h5 id="C-x2F-S"><a href="#C-x2F-S" class="headerlink" title="C&#x2F;S"></a>C&#x2F;S</h5><p>C&#x2F;S架构是第一种比较早的软件架构，主要用于局域网内。也叫客户机&#x2F;服务器模式</p>
<p><strong>它可以分为客户机和服务器两层：</strong></p>
<ul>
<li>第一层: 在客户机系统上结合了界面显示与业务逻辑</li>
<li>第二层: 通过网络结合了数据库服务器</li>
</ul>
<blockquote>
<p>  客户端不仅仅是一些简单的操作，它也是会处理一些运算，业务逻辑的处理等。也就是说，客户端也做着一些本该由服务器来做的一些事情，如图所示：</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-9fdab4ff37d12e944d2a9025b583d0ac_1440w.jpeg" alt="img"></p>
<p>C&#x2F;S架构软件有一个特点，就是如果用户要使用的话，需要下载一个客户端，安装后就可以使用。比如QQ,OFFICE软件等</p>
<p><strong>C&#x2F;S架构的优点：</strong></p>
<ol>
<li>C&#x2F;S架构的界面和操作可以很丰富。（客户端操作界面可以随意排列，满足客户的需要）</li>
<li>安全性能可以很容易保证。（因为只有两层的传输，而不是中间有很多层）</li>
<li>由于只有一层交互，因此响应速度较快。（直接相连，中间没有什么阻隔或岔路，比如QQ，每天那么多人在线，也不觉得慢）</li>
</ol>
<p><strong>C&#x2F;S架构的缺点：</strong></p>
<ol>
<li>适用面窄，通常用于局域网中</li>
<li>用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户</li>
<li>维护成本高，发生一次升级，则所有客户端的程序都需要改变</li>
</ol>
<h5 id="B-x2F-S"><a href="#B-x2F-S" class="headerlink" title="B&#x2F;S"></a>B&#x2F;S</h5><p>B&#x2F;S架构的全称为Browser&#x2F;Server，即浏览器&#x2F;服务器结构。</p>
<p>Browser指的是Web浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现</p>
<p>其实就是我们前端现在做的一些事情，大部分的逻辑交给后台来实现，我们前端大部分是做一些数据渲染，请求等比较少的逻辑。</p>
<p><strong>B&#x2F;S架构的优点：</strong></p>
<ol>
<li>成本低,方便维护,分布性强,开发简单</li>
<li>BS架构无需升级多个客户端，升级服务器即可。可以随时更新版本，而无需用户重新下载啊什么的。</li>
</ol>
<p><strong>B&#x2F;S架构的缺点：</strong></p>
<ol>
<li>在跨浏览器上，BS架构不尽如人意。</li>
<li>协议一般是固定的 http&#x2F;https ,所以无法操作大数据量的文件</li>
<li>无法实现个性化</li>
<li>在速度和安全性上无法保证</li>
</ol>
<h4 id="MAC地址-IP地址和端口"><a href="#MAC地址-IP地址和端口" class="headerlink" title="MAC地址,IP地址和端口"></a>MAC地址,IP地址和端口</h4><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><blockquote>
<p>  又称以太网地址,物理地址		</p>
</blockquote>
<blockquote>
<p>  网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有MAC地址，属于OSI模型的第2层，它使得用户可以通过电缆或无线相互连接。<strong>每一个网卡都有一个被称为MAC地址的独一无二的48位串行号</strong></p>
<p>  网卡的主要功能: 1 .数据的封装与解封装 2.链路管理 3.数据编码与译码      一台设备可以有多个网卡</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110150321181.png" alt="image-20221110150321181">
</blockquote>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><blockquote>
<p>  IP协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网.上进行通信时应当遵守的规则。</p>
<p>  任何厂家生产的计算机系统，只I守IP协议就可以与因特网互连互通。各个厂家生产的网络系统和设备,如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元(技术上称之为“帧”)的格式不同。</p>
<p>  IP 协议实际上是一套由软件程序组成的协议软件,它把各种不同”帧”统-转换成”IP 数据报”格式,这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有”开放性”的特点。正是因为有了IP协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，<strong>IP 协议也可以叫做”因特网协议</strong>”</p>
<p>  IP地址(Internet Protocol Address)是指互联网协议地址，又译为网际协议地址。IP 地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一 台主机分配一个逻辑地址, 以此来屏蔽物理地址的差异。</p>
<p>  IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”(也就是4个字节)。IP 地址通常用”点分十进制”表示成(a.b.c.d) 的形式，其中，a,b,c,d都是 0~255之间的十进制整数</p>
<p>  IP分类:</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/da60a6fcfe684b679c3ca13c116f3004.png" alt="img">

<p>  <strong>A类地址</strong><br>  为大型网络而设计的，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0）。可用的A类网络有127个，每个网络能容纳16777214个主机。其中127.0.0.1是一个特殊的IP地址，表示主机本身，用于本地机器的测试</p>
<p>  注：A: 0-127，其中<strong>0代表本网络的主机</strong>，<strong>127为回环测试地址</strong>，因此，A类ip地址的实际范围是1-126. 默认子网掩码为<strong>255.0.0.0</strong></p>
<p>  <strong>B类地址</strong><br>  一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p>
<p>  注：	B:128-191，其中128.0.0.0和191.255.0.0为保留ip，实际范围是128.1.0.0–191.254.0.0</p>
<p>  <strong>C类地址</strong><br>  一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。</p>
<p>  注：C:192-223，其中192.0.0.0和223.255.255.0为保留ip，实际范围是192.0.1.0–223.255.254.0</p>
<p>  <strong>D类地址</strong><br>  用于多点广播（Multicast）。 D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。224.0.0.0到239.255.255.255用于多点广播 </p>
<p>  <strong>E类IP地址</strong>	以“1111”开始，为将来使用保留。240.0.0.0到255.255.255.254，<strong>255.255.255.255用于广播地址</strong></p>
</blockquote>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><blockquote>
<p>  用来找到某个网络中的特定应用,一个应用可以同时有多个端口</p>
<p>  “端口”是英文port的意译,可以认为是设备与外界通讯交流的出口。<strong>端口可分为虚拟端口和物理端口</strong>,其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端口,是逻辑意义上的端口。例如计算机中的80端口、21 端口、23端口等</p>
<p>  物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等R]45端口。电话使用R]11插口也属于物理端口的范畴</p>
<p>  如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536 (即: 2^16) 个之多!<strong>端口是通过端口号</strong>来标记的，端口号只有整数，范围是从0到65535 (2^16-1)</p>
</blockquote>
<blockquote>
<p>  <strong>端口分类</strong></p>
<p>  1.周知端口<br>  周知端口是众所周知的端口号，也叫知名端口、公认端口或者官用端口，<strong>范围从0到1023</strong>,它们紧密绑定于一些特定的服务。例如80端口分配给WWW服务, 21端口分配给FTP服务, 23端口分配给Telnet服务等等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是在地址后面加上冒号”:” (半角)，再加上端口号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如139端口专门用于NetBIOS与TCP&#x2F;IP之间的通信，不能手动改变。</p>
<p>  2.注册端口<br>  端口号从<strong>1024到49151</strong>,它们松散的绑定于一些服务，也就是说有许多服务绑定于这些端口，这些端口同样用于其他许多目的，如：许多系统处理端口从1024开始</p>
<p>  3.动态端口&#x2F;私有端口<br>  动态端口的范围是从49152到65535。之所以称为动态端口，是因为它一般不固定分配某种服务,而是动态分配</p>
</blockquote>
<h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110155956089.png" alt="image-20221110155956089"></p>
<h5 id="三种模型对比"><a href="#三种模型对比" class="headerlink" title="三种模型对比"></a>三种模型对比</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110160740252.png" alt="image-20221110160740252"></p>
<h5 id="封装（TCP-x2F-IP结构）"><a href="#封装（TCP-x2F-IP结构）" class="headerlink" title="封装（TCP&#x2F;IP结构）"></a>封装（TCP&#x2F;IP结构）</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140220057.png" alt="image-20221111140220057"></p>
<h5 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140701837.png" alt="image-20221111140701837"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140730605.png" alt="image-20221111140730605"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>应用层常见的协议有: <strong>FTP</strong>协议(File Transfer Protocol文件传输协议)、HTTP协议 (Hyper Text Transfer Protocol超文本传输协议)、<strong>NFS</strong> (Network File System网络文件系统)。</p>
<p>传输层常见协议有: <strong>TCP</strong>协议(Transmission Control Protocol传输控制协议)、UDP协议(User Datagram Protocol用户数据报协议)。</p>
<p>网络层常见协议有: <strong>IP</strong>协议(Internet Protocol因特网互联协议)、<strong>ICMP</strong>协议(Internet Control Message Protocol因特网控制报文协议)、IGMP协议(Internet Group Management Protocol因特网组管理协议)。</p>
<p>网络接口层常见协议有: <strong>ARP</strong>协议(Address Resolution Protocol地址解析协议)、<strong>RARP</strong>协议 (Reverse Address Resolution Protocol反向地址解析协议)。</p>
<h5 id="UDP头部格式"><a href="#UDP头部格式" class="headerlink" title="UDP头部格式"></a>UDP头部格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162651180.png" alt="image-20221110162651180"></p>
<h5 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162731372.png" alt="image-20221110162731372"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162838743.png" alt="image-20221110162838743"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162859467.png" alt="image-20221110162859467"></p>
<h5 id="IPv4头部结构"><a href="#IPv4头部结构" class="headerlink" title="IPv4头部结构"></a>IPv4头部结构</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162942609.png" alt="image-20221110162942609"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163111692.png" alt="image-20221110163111692"></p>
<h5 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163326444.png" alt="image-20221110163326444"></p>
<h5 id="ARP报文格式"><a href="#ARP报文格式" class="headerlink" title="ARP报文格式"></a>ARP报文格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163211127.png" alt="image-20221110163211127"></p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>socket是一个接口，在用户进程与TCP&#x2F;IP协议之间充当中间人，完成TCP&#x2F;IP协议的书写，用户只需理解接口即可</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI1ODk3OQ==,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p>
<p>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议</p>
<p>socket本身有”插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的,我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将T封装成文件的目的是为了统-接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p>
<h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>字节序分为大端字节序(Big-Endian) 和小端字节序(ittle-Endian) </p>
<p>大端字节序是指一个整数的最高位字节(23<del>31 It)存储在内存的低地址处,低位字节(0</del> 7 bit)存储在内存的高地址处;</p>
<p>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</p>
<h6 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h6><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是:发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序,所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换(小端机转换,大端机不转换)。<strong>网络字节顺序是TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式</strong></p>
<p>BSD Socket提供了封装好的转换接口，方更程序员使用。包括</p>
<blockquote>
<p>  从主机字节序到网络字节序的转换函数: htons、htonl;</p>
<p>  从网络字节序到主机字节序的转换函数: ntohs、 ntohl。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">h- host主机，主机字节序</span><br><span class="line">to- 转换成什么</span><br><span class="line">n- network 网络字节序</span><br><span class="line">s- <span class="type">short</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口的 端口16位</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>; <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换IP的，IP地址32位</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">hton1</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntoh1</span><span class="params">(<span class="type">uint32_t</span> net1ong)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// htons 主机端口 -&gt; 网络端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = <span class="built_in">htons</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl 主机IP -&gt; 网络IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> * )buf;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">htonl</span>(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="IP转换函数（有字节序转换的功能）"><a href="#IP转换函数（有字节序转换的功能）" class="headerlink" title="IP转换函数（有字节序转换的功能）"></a>IP转换函数（有字节序转换的功能）</h5><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。</p>
<p><strong>但编程中我们需要先把它们转化为整数(二进制数)方能使用。</strong></p>
<p><strong>而记录日志时则相反,我们要把整数表示的IP地址转化为可读的字符串。</strong></p>
<p>下面 3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">in_addr_t inet_addr (const char *cp);</span></span><br><span class="line"><span class="comment">int inet_aton(const char *cp, struct in_addr *inp);</span></span><br><span class="line"><span class="comment">char *inet_ntoa(struct in_addr in);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面这对更新的函数也能完成前面3个函数同样的功能，并且它们同时适用IPv4地址和IPv6地址:</p>
<h6 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton"></a>inet_pton</h6><p><code>int inet_pton(int af, const char *src, void *dst); </code>	将点分十进制的ip地址转化为用于网络传输的数值格式</p>
<blockquote>
<p>  af 		选择ipv4还是ipv6   AF_INET 或者 AF_INET6</p>
<p>  src		需要转换的点分十进制IP字符串</p>
<p>  dst		传出参数，数据转换后保存在dst中</p>
<p>  返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1</p>
</blockquote>
<h6 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop"></a>inet_ntop</h6><p><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 	将数值格式转化为点分十进制的ip地址格式</p>
<blockquote>
<p>  af 		选择ipv4还是ipv6   AF_INET 或者 AF_INET6</p>
<p>  src		需要转换的整数的地址</p>
<p>  dst		传出参数，数据转换后保存在dst中（IP字符串）</p>
<p>  size		指定dst的大小（数组的容量）</p>
<p>  返回值：若成功则为转换后的字符串的指针（与dst为同一个值），若出错则为NULL</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.12.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 转成了整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个IP字符串</span></span><br><span class="line">    <span class="type">char</span> dst[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str = <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, dst, <span class="built_in">sizeof</span>(dst)); <span class="comment">// dst为数组首地址</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; <span class="comment">// 转成了IP字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h5><h6 id="通用socket地址-只为IPv4设计"><a href="#通用socket地址-只为IPv4设计" class="headerlink" title="通用socket地址(只为IPv4设计)"></a>通用socket地址(只为IPv4设计)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;<span class="comment">/*地址族类型，本教程使用AF_INET,代表TCP/IPv4协议族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];     <span class="comment">/*14字节，存放socket地址值，ip地址和端口号*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sa_family成员是地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应。常见的协议族和对应的地址族如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">协议族(domain)	地址族			描述</span></span><br><span class="line"><span class="comment">PF_UNIX		AF_UNIX		UNIX本地域协议族</span></span><br><span class="line"><span class="comment">PF_INET		AF_INET		TCP/IPv4协议族</span></span><br><span class="line"><span class="comment">PF_INET6	AF_INET6	TCP/IPv6协议族</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h6 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h6><p>作为参数使用时要强转成sockaddr类型</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112140046029.png" alt="image-20221112140046029"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;<span class="comment">//地址族：AF_INET</span></span><br><span class="line">	<span class="type">u_int16_t</span> sin_port;<span class="comment">//端口号，要用网络字节序表示</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">//IPV4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">	<span class="type">u_int32_t</span> s_addr;<span class="comment">//ipv4地址，要用网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h4><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>socket通信分两部分：服务器端与客户端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端(被动接受连接的角色)</span></span><br><span class="line"><span class="number">1.</span>创建一个用于监听的套接字【lfd】</span><br><span class="line">	-监听:监听有客户端的连接</span><br><span class="line">	-套接字:这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span>将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)【【saddr要设置IP、端口、协议】lfd与saddr绑定】</span><br><span class="line">	-客户端连接 服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span>设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字【clientaddr只要定义, cfd【cfd与clientaddr通信】】</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字【clientfd】</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定连接的服务器的IP和端口【serveraddr要设置IP、端口、协议【clientfd与serveraddr连接，用clientfd通信】】</span><br><span class="line"><span class="number">3.</span>连接成功了，客户端可以直接和服务器通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">4.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112154950130.png" alt="image-20221112154950130" style="zoom:50%;">



<h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><h5 id="要包含的头文件"><a href="#要包含的头文件" class="headerlink" title="要包含的头文件"></a>要包含的头文件</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 若包含了这个，上面两个可以省略</span></span></span><br></pre></td></tr></table></figure>



<h5 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h5><p><code>int socket(int domain, int type, int protocol);</code> 	创建一个套接字</p>
<blockquote>
<p>  domain:	协议族</p>
<p>  ​	AF_INET : ipv4<br>  ​	AF_INET6 : ipv6<br>  ​	AF_UNIX，AF_ LOCAL :本地套接字通信(进程间通信)</p>
<p>  type	通信过程中使用的协议类型</p>
<p>  ​	SOCK_STREAM : 流式协议<br>  ​	SOCK_DGRAM : 报式协议</p>
<p>  protocol 	具体的一个协议。一般写0</p>
<p>  ​	SOCK_ STREAM : 流式协议默认使用TCP<br>  ​	SOCK_ DGRAM : 报式协议默认使用UDP</p>
<p>  返回值	成功:返回文件描述符，操作的就是内核缓冲区	失败: -1</p>
</blockquote>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 	绑定，将fd和本地的IP +端口进行绑定</p>
<blockquote>
<p>  sockfd 	通过socket函数得到的文件描述符</p>
<p>  addr 	需要绑定的socket地址， 这个地址封装了ip和端口号的信息</p>
<p>  addrlen 	第二个参数结构体占的内存大小</p>
</blockquote>
<h5 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h5><p><code>int listen(int sockfd, int backlog);</code>		监听这个socket上的连接</p>
<blockquote>
<p>  sockfd 	通过socket ()函数得到的文件描述符</p>
<p>  backlog 	未连接的和已经连接的和的最大值，给5就行  不能超过&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值</p>
</blockquote>
<h5 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h5><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>	阻塞的函数，阻塞等待客户端连接</p>
<blockquote>
<p>  sockfd 	用于监听的文件描述符</p>
<p>  addr 	传出参数，记录了连接成功后客户端的地址信息(ip, port)</p>
<p>  addrlen 	指定第二个参数的对应的内存大小</p>
<p>  返回值	成功返回用于通信的文件描述符，失败返回-1</p>
</blockquote>
<h5 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h5><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>	客户端连接服务器</p>
<blockquote>
<p>  sockfd 	用于通信的文件描述符</p>
<p>  addr 	客户端要连接的服务器的地址信息</p>
<p>  addrlen 	第二个参数的内存大小</p>
</blockquote>
<h5 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h5><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<h5 id="send"><a href="#send" class="headerlink" title="(send)"></a>(send)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">send</span>( cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h5 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h5><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<h5 id="recv"><a href="#recv" class="headerlink" title="(recv)"></a>(recv)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">recv</span>(cfd, recvBuf, <span class="built_in">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\);</span></span><br><span class="line"><span class="string">	break ;</span></span><br><span class="line"><span class="string">&#125;else if(len &gt; 0)&#123;</span></span><br><span class="line"><span class="string">	printf(&quot;</span>read buf = %s\n<span class="string">&quot;, recvBuf);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="fgets"><a href="#fgets" class="headerlink" title="* fgets"></a>* fgets</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">fgets</span>(sendBuf, <span class="built_in">sizeof</span>(sendBuf), stdin); <span class="comment">// 阻塞，接收用户输入，再写入sendBuf</span></span><br><span class="line"><span class="built_in">write</span>(fd, sendBuf, <span class="built_in">strlen</span>( sendBuf) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h4 id="代码实现服务器-x2F-客户端通信"><a href="#代码实现服务器-x2F-客户端通信" class="headerlink" title="代码实现服务器&#x2F;客户端通信"></a>代码实现服务器&#x2F;客户端通信</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCP通信的服务器端</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个用于监听的套接字(lfd)</span></span><br><span class="line"><span class="comment">	-监听:监听有客户端的连接</span></span><br><span class="line"><span class="comment">	-套接字:这个套接字其实就是一个文件描述符</span></span><br><span class="line"><span class="comment">2.将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)</span></span><br><span class="line"><span class="comment">	-客户端连接 服务器的时候使用的就是这个IP和端口</span></span><br><span class="line"><span class="comment">3.设置监听，监听的fd开始工作</span></span><br><span class="line"><span class="comment">4.阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字(cfd)</span></span><br><span class="line"><span class="comment">5.通信</span></span><br><span class="line"><span class="comment">	-接收数据</span></span><br><span class="line"><span class="comment">	-发送数据</span></span><br><span class="line"><span class="comment">6.通信结束，断开连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bind() </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">// 网络协议</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.12.1&quot;, &amp;saddr.sin_addr.s_addr); // IP</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 服务器开发时可写,表示服务器端任何IP都可以被客户端访问</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 8为连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.accept()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd  = <span class="built_in">accept</span>(listenfd, (sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span> *)len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 获取客户端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示客户端断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCP通信的客户端</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个用于通信的套接字(clientfd)</span></span><br><span class="line"><span class="comment">2.连接服务器，需要指定连接的服务器的IP和端口</span></span><br><span class="line"><span class="comment">3.连接成功了，客户端可以直接和服务器通信</span></span><br><span class="line"><span class="comment">	-接收数据</span></span><br><span class="line"><span class="comment">	-发送数据</span></span><br><span class="line"><span class="comment">4.通信结束，断开连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clientfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %d\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示服务器断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手 &amp; 四次挥手"></a>TCP三次握手 &amp; 四次挥手</h4><h5 id="三次握手-发生在客户端connect-中"><a href="#三次握手-发生在客户端connect-中" class="headerlink" title="三次握手(发生在客户端connect()中)"></a>三次握手(发生在客户端connect()中)</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/AB3FC1B1325FA341A39644BA061FA439.jpeg" alt="img" style="zoom:50%;">

<p>1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq&#x3D;x），请求建立连接，等待确认</p>
<p>2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK&#x3D;x+1）确认收到，同时发送一个SYN包（seq&#x3D;y）给客户端</p>
<p>3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK&#x3D;y+1）告诉服务端已经收到</p>
<p>4）三次握手完成，成功建立连接，开始传输数据</p>
<h5 id="四次握手-发生在两端close-中"><a href="#四次握手-发生在两端close-中" class="headerlink" title="四次握手(发生在两端close()中)"></a>四次握手(发生在两端close()中)</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg" alt="img" style="zoom:50%;">

<p>1）客户端发送FIN包（FIN&#x3D;1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据</p>
<p>2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕</p>
<p>3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接</p>
<p>4）客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><ol>
<li><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的</p>
<p>TCP的滑动窗口解决了<strong>端到端的流量控制</strong>、ACK确认、拥塞控制 问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据</p>
</li>
<li><p>TCP协议要求维护以下两个端口：</p>
<ol>
<li>接收窗口rwnd，<strong>接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量</strong>( 由接收方根据其放在TCP报文的首部的窗口字段通知发送方)</li>
<li>拥塞窗口cwnd，<strong>发送方根据自己估算的网络拥塞程度而设置的窗口值</strong>，反映网络的当前容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。</li>
</ol>
<ul>
<li>发送窗口的上限值应取接收窗口rwnd和拥塞窗口cwnd中较小的一个 <strong>发送窗口的上限值&#x3D;min{rwnd，cwnd}</strong></li>
</ul>
</li>
</ol>
<h5 id="发送方如何维护拥塞窗口"><a href="#发送方如何维护拥塞窗口" class="headerlink" title="发送方如何维护拥塞窗口"></a>发送方如何维护拥塞窗口</h5><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-eff93036b85f660537ac9c8036cb896b_1440w.webp" alt="img" style="zoom:67%;">

<h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-b4e28461732b87b1d96da64456868ec4_1440w.webp" alt="img" style="zoom:67%;">

<h5 id="补充-TCP两种重传方式"><a href="#补充-TCP两种重传方式" class="headerlink" title="(补充)TCP两种重传方式"></a>(补充)TCP两种重传方式</h5><p>TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为<strong>超时重传</strong> </p>
<p>另一种方式的重传称为<strong>快速重传</strong>，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传</p>
<h4 id="TCP通信并发"><a href="#TCP通信并发" class="headerlink" title="TCP通信并发"></a>TCP通信并发</h4><h5 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h5><h6 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:</span></span><br><span class="line"><span class="comment">1.一个父进程,多个子进程</span></span><br><span class="line"><span class="comment">2.父进程: 负责等待并接受客户端的连接</span></span><br><span class="line"><span class="comment">3.子进程: 完成通信，接受一个客户端连接，就创建一个子进程用于通信</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，就创建一个子进程和客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// pid == 0 为子进程</span></span><br><span class="line">            <span class="comment">// 输出客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 通信</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//表示客户端断开连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">                <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="comment">// exit(0);  可写可不写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i ++);</span><br><span class="line">        <span class="built_in">write</span>(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示服务器断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="第二版-回收子进程资源"><a href="#第二版-回收子进程资源" class="headerlink" title="第二版(回收子进程资源)"></a>第二版(回收子进程资源)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recycleChild</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); <span class="comment">// -1代表回收所有子进程， WNOHANG代表非阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//被回收了  </span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;被回收了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 注册信号捕捉, 目的是回收资源</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recycleChild; <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，就创建一个子进程和客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// pid == 0 为子进程</span></span><br><span class="line">            <span class="comment">// 输出客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 通信</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//表示客户端断开连接</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 不break的话会继续发送一份数据</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                <span class="built_in">write</span>(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="comment">// exit(0);  可写可不写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i ++);</span><br><span class="line">        <span class="built_in">write</span>(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示服务器断开连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;server closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 只是为了教学方便</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockInfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// cfd</span></span><br><span class="line">    <span class="type">pthread_t</span> tid; <span class="comment">// 自己tid</span></span><br><span class="line">    sockaddr_in addr; <span class="comment">// 客户端信息</span></span><br><span class="line">&#125;;</span><br><span class="line">sockInfo sockInfos[<span class="number">128</span>]; <span class="comment">// 最多有128个子线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">working</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    sockInfo* pinfo = (sockInfo* )arg;</span><br><span class="line">    <span class="comment">// 5.子线程和客户端通信</span></span><br><span class="line">    <span class="comment">// 输出客户端信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(pinfo-&gt;fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示客户端断开连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 不break的话会继续发送一份数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(pinfo-&gt;fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">sizeof</span>(sockInfos) / <span class="built_in">sizeof</span>(sockInfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i ++)&#123;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;sockInfos[i], <span class="built_in">sizeof</span>(sockInfos[i]));</span><br><span class="line">        sockInfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockInfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockInfo</span> * pinfo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i ++)&#123;</span><br><span class="line">            <span class="comment">//从这个数组I找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockInfos[i].fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                pinfo = &amp;sockInfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo -&gt; fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo -&gt; addr, &amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pinfo -&gt; tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// pthread_join() 不能用，因为它是阻塞的。如果子线程不死亡，主线程则会一直卡在此处，不会执行 while 循环</span></span><br><span class="line">        <span class="built_in">pthread_detach</span>(pinfo -&gt; tid); <span class="comment">// 设置线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP半关闭、端口复用"><a href="#TCP半关闭、端口复用" class="headerlink" title="TCP半关闭、端口复用"></a>TCP半关闭、端口复用</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p><code>int shutdown(int sockfd, int how);</code></p>
<blockquote>
<p>  当TCP链接中A向B发送FIN请求关闭，另一端B回应ACK之后(A端进入FIN_WAIT2状态)，并没有立即发送FIN给A, A处于半连接状态(半开关)，此时A可以接收B发送的数据，但是A已经不能再向B发送数据。从程序的角度，可以使用API来控制实现半连接状态:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line">sockfd:		需要关闭的socket的描述符</span><br><span class="line">how:	允许为shutdown操作选择以下几种方式:</span><br><span class="line"><span class="built_in">SHUT_RD</span>(<span class="number">0</span>):		关闭sdckfd上的读功能，此选项将不允许sockfd进行读操作</span><br><span class="line">				该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉</span><br><span class="line"><span class="built_in">SHUT_WR</span>(<span class="number">1</span>):		关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作</span><br><span class="line"><span class="built_in">SHUT_RDWR</span>(<span class="number">2</span>):	关闭sockfd的读写功能。相当于调用shut down两次:首先是以SHUT_RD ,然后以SHUT_WR</span><br></pre></td></tr></table></figure>

<p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写</p>
<p>注意:</p>
<ol>
<li><p>如果有多个进程共享一个套接字, close 每被调用一次,计数减1，直到计数为0时，也就是所用进程都调用了close,套接字将被释放</p>
</li>
<li><p><strong>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后,其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响到其它进程</strong></p>
</li>
</ol>
<h5 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h5><blockquote>
<p>  设置端口复用（也可以设置socket的其他属性）：</p>
<ol>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>防止程序突然退出而系统没有释放端口</li>
</ol>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221116151457850.png" alt="image-20221116151457850" style="zoom:50%;">
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- sockfd: 要操作的文件描述符</span><br><span class="line">- level: 级别</span><br><span class="line">    <span class="built_in">SOL_SOCKET</span> (端口复用的级别)</span><br><span class="line">- optname: 选项的名称</span><br><span class="line">    SO_REUSEADDR</span><br><span class="line">    SO_REUSEPORT</span><br><span class="line">-optval: 端口复用的值(端口复用中为整型)</span><br><span class="line">    <span class="number">1</span>:	可以复用</span><br><span class="line">    <span class="number">0</span>:	不可以复用</span><br><span class="line">-optlen: optva1参数的大小</span><br><span class="line">    </span><br><span class="line">端口复用，设置的时机是在服务器绑定端口之前。</span><br><span class="line"><span class="built_in">setsockopt</span>();</span><br><span class="line"><span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure>



<h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><blockquote>
<p>  查看网络相关信息的命令</p>
<p>  参数:<br>  -a	所有的socket<br>  -p	显示正在使用socket的程序的名称<br>  -n	直接使用IP地址,而不通过域名服务器</p>
</blockquote>
<h4 id="IO多路复用-转接"><a href="#IO多路复用-转接" class="headerlink" title="IO多路复用(转接)"></a>IO多路复用(转接)</h4><p>I:	输入 指数据由	程序(文件) -&gt; 内存</p>
<p>O:	输出 指数据由	内存 -&gt; 程序(文件） </p>
<p>I&#x2F;O多路复用使得程序能同时监听多个文件描述符(在此之前，若有多个客户端同时请求，我们只能在while循环中依次监听),能够提高程序的性能, Linux 下实现I&#x2F;O多路复用的系统调用主要有select, poll 和epoll</p>
<h5 id="几种常见的I-x2F-O模型"><a href="#几种常见的I-x2F-O模型" class="headerlink" title="几种常见的I&#x2F;O模型"></a>几种常见的I&#x2F;O模型</h5><h6 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7786.PNG" alt="IMG_7786" style="zoom: 33%;">

<h6 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7787.PNG" alt="IMG_7787" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7788.PNG" alt="IMG_7788" style="zoom: 33%;">

<p>解决NIO的方法:IO多路复用</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7790.PNG" alt="IMG_7790" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7791.PNG" alt="IMG_7791" style="zoom: 33%;">



<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ol>
<li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回。<ul>
<li>函数对文件描述符的检测的操作是由内核完成的</li>
<li>在返回时，它会告诉进程有多少(哪工)描述符要进行I&#x2F;O操作</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds , fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">    - nfds	委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">    - readfds	要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">    - writefds	要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        - 委托内核检测写缓冲区是不是还可以写数据(不满的就可以写)</span><br><span class="line">    - exceptfds :检测发生异常的文件描述符的集合</span><br><span class="line">	- timeout	设置的超时时间</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeva1</span> &#123;</span><br><span class="line">        	<span class="number">1</span>ong tv_ sec; <span class="comment">/* seconds */</span></span><br><span class="line">        	<span class="number">1</span>ong tv_ _usec; <span class="comment">/* microseconds */</span></span><br><span class="line">        &#125;;</span><br><span class="line">	- <span class="literal">NULL</span>	永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">		- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>，不阻塞</span><br><span class="line">		- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>，阻塞对应的时间</span><br><span class="line">-返回值:</span><br><span class="line">	- <span class="number">-1</span>		失败</span><br><span class="line">    - &gt;<span class="number">0</span> (n)	检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *set); <span class="comment">//将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">//判断fd对应的标志位是0还是1，返回值 : fd对应的标志位的值， 0, 返回0，1, 返回1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>; <span class="comment">// fd_set共有1024 bit,全部初始化为0</span></span><br></pre></td></tr></table></figure>

<h6 id="select工作流程"><a href="#select工作流程" class="headerlink" title="select工作流程"></a>select工作流程</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117131507683.png" alt="image-20221117131507683" style="zoom: 67%;">

<h6 id="select代码实现"><a href="#select代码实现" class="headerlink" title="select代码实现"></a>select代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, temp; <span class="comment">// rdset是用户自己维护的, temp是交给内核去修改的</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset); <span class="comment">//初始化，全置0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset); <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = rdset;</span><br><span class="line">        <span class="comment">// 调用select，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;temp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">// 这里我们设置的timeval为NULL，所以是阻塞型，ret不可能返回0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;temp))&#123;</span><br><span class="line">                <span class="comment">// 判断fd对应的标志位是0还是1 , 为1代表有新的客户端连接进来了</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到set中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i ++)&#123; <span class="comment">// lfd最先被监听，肯定在最前面</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;temp))&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h6><ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了默认是1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;po11.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">po11fd</span>&#123;</span><br><span class="line">	<span class="type">int</span>	fd;	<span class="comment">/*委托内核检测的文件描述符*/</span></span><br><span class="line">	<span class="type">short</span> events;	<span class="comment">/*委托内核检测文件描述符的什么事件*/</span></span><br><span class="line">	<span class="type">short</span> revents;	<span class="comment">/*内核返回文件描述符实际发生的事件*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">po11</span><span class="params">(<span class="keyword">struct</span> po11fd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	-fds	是一个<span class="keyword">struct</span> <span class="title class_">pol1fd</span>结构体数组，这是一个需要检测的文件描述符的集合</span><br><span class="line">	-nfds	这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">	-timeout	阻塞时长</span><br><span class="line">        <span class="number">0</span>	不阻塞</span><br><span class="line">        <span class="number">-1</span> 	阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">        &gt;<span class="number">0</span> 	阻塞的时长</span><br><span class="line">-返回值: </span><br><span class="line">    <span class="number">-1</span>	失败</span><br><span class="line">    &gt;<span class="number">0</span> (n) 	成功，n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117145127724.png" alt="image-20221117145127724"></p>
<h6 id="poll代码实现"><a href="#poll代码实现" class="headerlink" title="poll代码实现"></a>poll代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">//需要检测读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>; <span class="comment">// 这里就是最大索引，而不是最大索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用 poll，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123; <span class="comment">// 有新客户端连接进来了，因为revents 返回的是 POLLIN ｜ POLLOUT</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将cfd加入到监听数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i ++)&#123; <span class="comment">// 0是lfd</span></span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)&#123; <span class="comment">// fds[i]可用</span></span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i ++)&#123; <span class="comment">// lfd最先被监听，为0</span></span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h6><ol>
<li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
</li>
<li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
</li>
<li><p><del>select支持的文件描述符数量太小了默认是1024</del></p>
</li>
<li><p><del>fds集合不能重用，每次都需要重置</del></p>
</li>
</ol>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epo11.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个新的epo11实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息(红黑树)，还有一个是就绪列表，存放检测到数据发生改变的文件描述符信息(双向链表)。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	size :目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">-返回值:</span><br><span class="line">	<span class="number">-1</span>	失败</span><br><span class="line">	&gt;<span class="number">0</span>	文件描述符，操作epo11实例的</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epo11_data</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epo11_event</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epo11 events */</span></span><br><span class="line">	<span class="type">epo11_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对epoll实例进行管理:添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_ct1</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epo11_event *event)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	epfd	epo11实例对应的文件描述符</span><br><span class="line">	op		要进行什么操作</span><br><span class="line">            EPOLL_CTL_ADD:添加</span><br><span class="line">            EPOLL_CTL_MOD:修改</span><br><span class="line">            EPOLL_CTL_DEL :删除</span><br><span class="line">	fd		要检测的文件描述符</span><br><span class="line">    event	检测文件描述符什么事情</span><br><span class="line">        EPOLLIN</span><br><span class="line">        EPOLLOUT</span><br><span class="line">        EPOLLERR</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epo11_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">	epfd	epo11实例对应的文件描述符</span><br><span class="line">	events	传出参数,数组,保存了发生了变化的文件描述符的信息,</span><br><span class="line">	maxevents	第二个参数结构体数组的大小</span><br><span class="line">	timeout	阻塞时间</span><br><span class="line">		<span class="number">0</span>:不阻塞</span><br><span class="line">		<span class="number">-1</span> :阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">		&gt;<span class="number">0</span>:阻塞的时长(毫秒)</span><br><span class="line">返回值:</span><br><span class="line">	成功	返回发送变化的文件描述符的个数</span><br><span class="line">	失败	<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117172543560.png" alt="image-20221117172543560"></p>
<h6 id="epoll代码实现"><a href="#epoll代码实现" class="headerlink" title="epoll代码实现"></a>epoll代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将监听的文件描述符相关的检测信息加入到epoll实例中</span></span><br><span class="line">    epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN; <span class="comment">// 要检测他的读事件</span></span><br><span class="line">    epev.data.fd = lfd; <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line">    </span><br><span class="line">    epoll_event epevs[<span class="number">1024</span>]; <span class="comment">// 内核检测后会将已就绪的文件描述符放在这里面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>); <span class="comment">// -1设置阻塞。只有设置了阻塞时，会返回0，代表超时了都没有检测到变化的文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(epevs[i].data.fd == lfd) &#123; <span class="comment">// 监听到了客户端的连接</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); <span class="comment">// 添加到epoll实例中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// epevs[i].data.fd == cfd  有数据到达，通信</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(epevs[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// 将此fd从红黑树中删除</span></span><br><span class="line">                    <span class="built_in">close</span>(epevs[i].data.fd); <span class="comment">// close(cfd)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">write</span>(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="epoll两种工作模式"><a href="#epoll两种工作模式" class="headerlink" title="epoll两种工作模式"></a>epoll两种工作模式</h6><ul>
<li><p>LT模式(水平触发)</p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区-&gt;读缓冲区有数据 -&gt; epoll检测到了会给用户通知</p>
<ol>
<li>用户不读数据，数据一直在缓冲区，epoll 会一直通知</li>
</ol>
</li>
</ul>
<ol start="2">
<li>用户只读了一部分数据， epoll会通知<br>3.   缓冲区的数据读完了，不通知</li>
</ol>
<pre><code>&gt;   LT (level - triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行操作。如果你不作任何操作，内核还是会继续通知你的
</code></pre>
<ul>
<li><p>ET模式(边沿触发) </p>
<p>假设委托内核检测读事件-&gt;检测fd的读缓冲区-&gt;读缓冲区有数据-&gt; epoll检测到了会给用户通知</p>
<ol>
<li>用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</li>
<li>用户只读了一部分数据，epoll不通知</li>
<li>缓冲区的数据读完了，不通知</li>
</ol>
<blockquote>
<p>  ET (edge - triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epolI告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是, 如果一直不对这个fd做操作, 内核不会发送更多的通知</p>
</blockquote>
<p>EPOLLONESHOT（相当于一个socket的锁）</p>
<blockquote>
<p>  即使可以使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。 比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读. (EPOLIN再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。一个socket连接在任一时刻都只被一个线程处理， 可以使用epoll的 EPOLLONESHOT 事件实现</p>
<p>  对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件,且只触发一次，除非我们使用epoll_ ctl 函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。<strong>但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket</strong></p>
</blockquote>
</li>
</ul>
<h4 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h4><h5 id="UDP通信流程"><a href="#UDP通信流程" class="headerlink" title="UDP通信流程"></a>UDP通信流程</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118183329846.png" alt="image-20221118183329846" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> f1ags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	sockfd	通信的fd</span><br><span class="line">	buf	要发送的数据</span><br><span class="line">	<span class="number">1</span>en	发送数据的长度</span><br><span class="line">	flags	写<span class="number">0</span>就好</span><br><span class="line">	dest_addr :通信的另外一端的地址信息</span><br><span class="line">	addrlen	地址的内存大小</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	sockfd	通信的fd</span><br><span class="line">	buf	接收数据的数组</span><br><span class="line">	len	数组的大小</span><br><span class="line">	flags	<span class="number">0</span></span><br><span class="line">	src_addr	用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">	addrlen	地址的内存大小</span><br></pre></td></tr></table></figure>



<h5 id="UDP通信代码实现"><a href="#UDP通信代码实现" class="headerlink" title="UDP通信代码实现"></a>UDP通信代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UDP服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>, (sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client IP :&quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, ipbuf, <span class="built_in">sizeof</span>(ipbuf)) &lt;&lt; <span class="string">&quot; Port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(clientaddr.sin_port) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say :&quot;</span> &lt;&lt; recvbuf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;clientaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UDP通信客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// saddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf, <span class="string">&quot;hello, i am client: %d\n&quot;</span>, num ++);</span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, sendbuf, <span class="built_in">strlen</span>(sendbuf) + <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收 </span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, sendbuf, <span class="built_in">sizeof</span>(sendbuf), <span class="number">0</span>, (sockaddr*)&amp;saddr, (<span class="type">socklen_t</span>*)<span class="built_in">sizeof</span>(saddr));</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;server say :&quot;</span> &lt;&lt; sendbuf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>子网号：主机号（主机号全0表示该子网，全1代表在该子网中广播）</p>
<blockquote>
<p>  向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。</p>
<ol>
<li>只能在局域网中使用</li>
<li>客户端(ABCD)需要绑定服务器(下图左)广播使用的端口，才可以接收到广播消息</li>
</ol>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118231053331.png" alt="image-20221118231053331" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置广播属性的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line">	sockfd : 文件描述符</span><br><span class="line">	level : SOL_SOCKET</span><br><span class="line">	optname : SO_BROADCAST</span><br><span class="line">	optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">	optlen : optval的大小</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- 【fd】</span><br><span class="line">(<span class="number">2</span>) 设置为允许发送广播权限 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">3</span>) 填充广播信息结构体 -- 【clientaddr设置IP（X.X.X<span class="number">.255</span>）、端口 用来通信】</span><br><span class="line">(<span class="number">4</span>) 发送数据 -- <span class="built_in">sendto</span>()</span><br><span class="line"></span><br><span class="line">接受者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 --  【fd】</span><br><span class="line">(<span class="number">2</span>) 填充广播信息结构体 -- 【addr设置<span class="built_in">IP</span>(<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>)、端口 用来通信】</span><br><span class="line">(<span class="number">3</span>) 将套接字与广播信息结构体绑定 -- 【addr和fd】</span><br><span class="line">(<span class="number">4</span>) 接收数据 -- <span class="built_in">recvfrom</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BROADCAST_IP <span class="string">&quot;192.168.99.255&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为允许发送广播权限</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(fd , SOL_SOCKET , SO_BROADCAST , &amp;op , <span class="built_in">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造client地址  IP+端口号 </span></span><br><span class="line">    sockaddr_in clientaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, BROADCAST_IP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址--IP地址本地，端口号9000</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span> , &amp;addr.sin_addr.s_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><blockquote>
<p>  单播地址标识单个IP接口,广播地址标识某个子网的所有IP接口，多播地址标识一组IP接口。</p>
<p>  单播和广播是寻址方案的两个极端(要么单个要么全部)，多播则意在两者之间提供一种折中方案。 多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外,广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119030142283.png" alt="image-20221119030142283" style="zoom:50%;">

<p>组播地址</p>
<blockquote>
<p>  IP多播通信必须依赖于IP多播地址，在IPv4中它的范围从224.0.0.0 到239.255.255.255.并被划分为<br>  局部链接多播地址、预留多播地址、管理权限多播地址</p>
<table>
<thead>
<tr>
<th align="left">IP地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">244.0.0.0~244.0.0.255</td>
<td>局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="left">244.0.1.0~244.0.1.255</td>
<td>预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="left">244.0.2.0~238.255.255.255</td>
<td>预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效</td>
</tr>
<tr>
<td align="left">239.0.0.0~239.255.255.255</td>
<td>本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level,<span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器设置多播的信息，外出接口</span></span><br><span class="line">    - leve1 : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端加入到多播组:</span></span><br><span class="line">	- leve1 : IPPROTO_IP</span><br><span class="line">	- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">	- optva1 : <span class="keyword">struct</span> <span class="title class_">ip_mreq</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ip_mreq</span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_multiaddr; <span class="comment">//组播的IP地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_address; <span class="comment">//本地的IP地址</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">            <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjc1MDYyMw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- <span class="built_in">socket</span>()</span><br><span class="line">(<span class="number">2</span>) 填充组播信息结构体 -- <span class="built_in">sockaddr_in</span></span><br><span class="line">(<span class="number">3</span>) 设置为组播属性 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">4</span>) 发送数据 -- <span class="built_in">sendto</span>()</span><br><span class="line"></span><br><span class="line">接收者： </span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- <span class="built_in">socket</span>()</span><br><span class="line">(<span class="number">2</span>) 填充组播信息结构体 -- <span class="built_in">sockaddr_in</span></span><br><span class="line">(<span class="number">3</span>) 将套接字与组播信息结构体绑定 -- <span class="built_in">bind</span>()</span><br><span class="line">(<span class="number">4</span>) 设置为加入多播组 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">5</span>) 接收数据 -- <span class="built_in">recvfrom</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIIP <span class="string">&quot;239.0.0.10&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多播属性，设置外出接口</span></span><br><span class="line">    in_addr imr_multiaddr; </span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;imr_multiaddr.s_addr); <span class="comment">//初始化多播地址</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="built_in">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端地址信息</span></span><br><span class="line">    sockaddr_in clientaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIIP <span class="string">&quot;239.0.0.10&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址  IP地址本地，端口号9000</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ip_mreq  op;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="built_in">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h4><blockquote>
<p>  本地套接字：同一主机的进程间通信，有没有关系的进程间通信都可以实现</p>
<p>  采用TCP通信流程</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119135550407.png" alt="image-20221119135550407" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>&#123;</span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sun_family; <span class="comment">// 地址族协议， AF_LOCAL</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径，这是一个伪文件，大小永远为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地套接字通信的流程- tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="number">1.</span>创建监听的套接字</span><br><span class="line">	<span class="type">int</span> <span class="number">1f</span>d = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span>监听的套接字绑定本地的套接字文件-&gt; server端 </span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr;</span><br><span class="line">	<span class="comment">//绑定成功之后，指定的sun_ path中的套接字文件会自动生成。</span></span><br><span class="line">	<span class="built_in">bind</span>(<span class="number">1f</span>d, addr, len);</span><br><span class="line"><span class="number">3.</span>监听</span><br><span class="line">	<span class="built_in">listen</span>(<span class="number">1f</span>d,<span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span>等待并接受连接请求</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> cliaddr ;</span><br><span class="line">	<span class="type">int</span> cfd = <span class="built_in">accept</span>(<span class="number">1f</span>d, &amp;cliaddr, <span class="number">1</span>en);</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">    接收数据: read/recv</span><br><span class="line">    发送数据: write/send</span><br><span class="line"><span class="number">6.</span>关闭连接</span><br><span class="line">	<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建通信的套接字</span><br><span class="line">	<span class="type">int</span> fd = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span>监听的套接字绑定本地的IP端口</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr ;</span><br><span class="line">    <span class="comment">//绑定成功之后，指定的sun_ path中的套接字文件会自动生成。</span></span><br><span class="line">    <span class="built_in">bind</span>(fd, addr, <span class="number">1</span>en);</span><br><span class="line"><span class="number">3.</span>连接服务器</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> serveraddr ;</span><br><span class="line">    <span class="built_in">connect</span>(fd，&amp;serveraddr ，<span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span>通信</span><br><span class="line">    接收数据: read/recv</span><br><span class="line">    发送数据: write/send</span><br><span class="line"><span class="number">5.</span>关闭连接</span><br><span class="line">	<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>





<h3 id="项目实战与总结"><a href="#项目实战与总结" class="headerlink" title="项目实战与总结"></a>项目实战与总结</h3><h4 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h4><blockquote>
<p>  IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132531092.png" alt="image-20221120132531092"></p>
<blockquote>
<p>  无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132728012.png" alt="image-20221120132728012"></p>
<h4 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h4><h5 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h5><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h5 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h5 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h5><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当10事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h5 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h5><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h5 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h4 id="Web服务器简介及HTTP协议"><a href="#Web服务器简介及HTTP协议" class="headerlink" title="Web服务器简介及HTTP协议"></a>Web服务器简介及HTTP协议</h4><h4 id="服务器编程基本框架和两种高效的事件处理模式"><a href="#服务器编程基本框架和两种高效的事件处理模式" class="headerlink" title="服务器编程基本框架和两种高效的事件处理模式"></a>服务器编程基本框架和两种高效的事件处理模式</h4><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120175048248.png" alt="image-20221120175048248" style="zoom:80%;">

<p><strong>模块</strong>						<strong>功能</strong><br>I&#x2F;O处理单元		   处理客户连接，读写网络数据</p>
<p>逻辑单元				业务进程或线程</p>
<p>网络存储单元		数据库、文件或缓存</p>
<p>请求队列				各单元之间的通信方式（请求队列通常被实现为池的一部分）</p>
<h5 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h5><p>服务器程序通常需要处理三类事件: I&#x2F;O 事件、信号及定时事件。</p>
<p>有两种高效的事件处理模式: Reactor 和Proactor,同步I&#x2F;O模型通常用于实现Reactor模式，异步I&#x2F;O模型通常用于实现Proactor模式。</p>
<h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列。(线程池)</strong></li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</p>
<p> <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120194303146.png" alt="image-20221120194303146"></p>
<h6 id="⭐️使用同步IO的方式模拟Proactor"><a href="#⭐️使用同步IO的方式模拟Proactor" class="headerlink" title="⭐️使用同步IO的方式模拟Proactor"></a>⭐️使用同步IO的方式模拟Proactor</h6><p>使用同步I&#x2F;O方式模拟出Proactor模式。原理是:主线程执行数据读写操作,读写完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<p>使用同步I&#x2F;O模型(以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait 等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket_上的写就绪事件。_</li>
<li>主线程调用epoll_wait 等待socket可写。</li>
<li>当socket可写时，epoll_wait 通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120203431492.png" alt="image-20221120203431492" style="zoom:50%;">





<h4 id="线程同步机制类封装及线程池实现"><a href="#线程同步机制类封装及线程池实现" class="headerlink" title="线程同步机制类封装及线程池实现"></a>线程同步机制类封装及线程池实现</h4><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和CPU数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之 服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式:</p>
<p>●主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和Round Robin (轮流选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</p>
<p>●主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时,主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权”，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</p>
<p>线程池的一般模型为:</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120212110980.png" alt="image-20221120212110980"></p>
<p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N:如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4 (或者+1防止其他因素造成的线程阻塞) ;对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO, IO的处理一般较慢, 多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>●空间换时间，浪费服务器的硬件资源，换取运行效率。</p>
<p>●池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</p>
<p>●当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取,无需动态分配。</p>
<p>●当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。</p>
<h4 id="项目整体流程代码实现"><a href="#项目整体流程代码实现" class="headerlink" title="项目整体流程代码实现"></a>项目整体流程代码实现</h4><h5 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>(Package _pack)&#123;</span><br><span class="line">    PackageType _type = _pack.<span class="built_in">GetType</span>();</span><br><span class="line">    <span class="keyword">switch</span>(_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            <span class="built_in">process_package_A</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            <span class="built_in">process_package_B</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>带状态转换的有限状态机</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>( )&#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span>(cur_State != type_C)&#123;</span><br><span class="line">        Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">        <span class="keyword">switch</span>(cur_State)&#123;</span><br><span class="line">            <span class="keyword">case</span> type_ A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>(_pack);</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>(_pack);</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="定时检测非活跃连接"><a href="#定时检测非活跃连接" class="headerlink" title="定时检测非活跃连接"></a>定时检测非活跃连接</h4><p>见<code>/home/kjg/webserver/noactive</code></p>
<h4 id="服务器压力测试"><a href="#服务器压力测试" class="headerlink" title="服务器压力测试"></a>服务器压力测试</h4><p>Webbench是Linux上一款知名的、优秀的web性能压力测试工具。它是由Lionbridge公司开发。</p>
<ul>
<li>测试处在相同硬件上,不同服务的性能以及不同硬件上同一个服务的运行状况。</li>
<li>展示服务器的两项内容:每秒钟响应请求数和每秒钟传输数据量。</li>
</ul>
<p>基本原理: Webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p>
<p>测试示例.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd webbench<span class="number">-1.5</span>/</span><br><span class="line">./webbench -c <span class="number">1000</span> -t <span class="number">30</span> http:<span class="comment">//192.168.110.129:10000/index.htm1</span></span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">    -c 表示客户端数</span><br><span class="line">    -t 表示时间</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/" rel="prev" title="DP之简单题合集">
      <i class="fa fa-chevron-left"></i> DP之简单题合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" rel="next" title="17.电话号码的字母组合">
      17.电话号码的字母组合 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">Linux入门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gcc%E7%BC%96%E8%AF%91"><span class="nav-number">1.2.</span> <span class="nav-text">Gcc编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGCC"><span class="nav-number">1.2.1.</span> <span class="nav-text">什么是GCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCC%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">GCC命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">GCC工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gcc%E4%B8%8Eg-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.</span> <span class="nav-text">gcc与g++区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">1.3.</span> <span class="nav-text">静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%93"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.3.2.</span> <span class="nav-text">静态库的命名规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">1.3.3.</span> <span class="nav-text">静态库的制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">静态库的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.3.5.</span> <span class="nav-text">动态库的命名规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">1.3.6.</span> <span class="nav-text">动态库的制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.7.</span> <span class="nav-text">动态库的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.3.8.</span> <span class="nav-text">动态库加载失败的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.9.</span> <span class="nav-text">动静态库优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Makefile"><span class="nav-number">1.4.</span> <span class="nav-text">Makefile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMakefile"><span class="nav-number">1.4.1.</span> <span class="nav-text">什么是Makefile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Makefile%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E5%92%8C%E8%A7%84%E5%88%99"><span class="nav-number">1.4.2.</span> <span class="nav-text">Makefile文件命名和规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">自定义变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">预定义变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">获取变量的值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.4.4.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wildcard"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">wildcard</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#patsubst"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">patsubst</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="nav-number">1.5.</span> <span class="nav-text">GDB调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGDB"><span class="nav-number">1.5.1.</span> <span class="nav-text">什么是GDB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-1"><span class="nav-number">1.5.2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8-x2F-%E9%80%80%E5%87%BA-x2F-%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.3.</span> <span class="nav-text">GDB命令-启动&#x2F;退出&#x2F;查看代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.4.</span> <span class="nav-text">GDB命令-断点操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.5.</span> <span class="nav-text">GDB命令-调试命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6IO"><span class="nav-number">1.6.</span> <span class="nav-text">Linux文件IO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86C%E5%BA%93%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">标准C库文件函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86C%E5%BA%93IO%E5%92%8CLinuxIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.</span> <span class="nav-text">标准C库IO和LinuxIO的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.</span> <span class="nav-text">虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.8.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LInux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">LInux系统函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#errno-amp-perror"><span class="nav-number">1.9.1.</span> <span class="nav-text">errno &amp; perror</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#open-amp-close"><span class="nav-number">1.9.2.</span> <span class="nav-text">open &amp; close</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read"><span class="nav-number">1.9.3.</span> <span class="nav-text">read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#write"><span class="nav-number">1.9.4.</span> <span class="nav-text">write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lseek"><span class="nav-number">1.9.5.</span> <span class="nav-text">lseek</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stat-amp-lstat"><span class="nav-number">1.9.6.</span> <span class="nav-text">stat &amp; lstat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">Linux文件属性操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#access"><span class="nav-number">1.10.1.</span> <span class="nav-text">access</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chmod"><span class="nav-number">1.10.2.</span> <span class="nav-text">chmod</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chown"><span class="nav-number">1.10.3.</span> <span class="nav-text">chown</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#truncate"><span class="nav-number">1.10.4.</span> <span class="nav-text">truncate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.</span> <span class="nav-text">Linux目录操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mkdir"><span class="nav-number">1.11.1.</span> <span class="nav-text">mkdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rmdir"><span class="nav-number">1.11.2.</span> <span class="nav-text">rmdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rename"><span class="nav-number">1.11.3.</span> <span class="nav-text">rename</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getcwd"><span class="nav-number">1.11.4.</span> <span class="nav-text">getcwd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#opendir"><span class="nav-number">1.11.5.</span> <span class="nav-text">opendir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chdir"><span class="nav-number">1.11.6.</span> <span class="nav-text">chdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#readir"><span class="nav-number">1.11.7.</span> <span class="nav-text">readir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#closedir"><span class="nav-number">1.11.8.</span> <span class="nav-text">closedir</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dup-amp-dup2"><span class="nav-number">1.12.</span> <span class="nav-text">dup &amp; dup2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fcntl"><span class="nav-number">1.13.</span> <span class="nav-text">fcntl</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">Linux 多进程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">程序和进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PCB"><span class="nav-number">2.1.1.</span> <span class="nav-text">PCB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">五状态模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">进程相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tty"><span class="nav-number">2.2.1.</span> <span class="nav-text">tty</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ulimit"><span class="nav-number">2.2.2.</span> <span class="nav-text">ulimit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps"><span class="nav-number">2.2.3.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#top"><span class="nav-number">2.2.4.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kill"><span class="nav-number">2.2.5.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96pid%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.6.</span> <span class="nav-text">获取pid函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.4.</span> <span class="nav-text">父子进程虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GDB%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-number">2.5.</span> <span class="nav-text">GDB多进程调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">2.6.</span> <span class="nav-text">exec函数族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">结束进程、孤儿进程、僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.1.</span> <span class="nav-text">结束进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.3.</span> <span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E3%80%81waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.</span> <span class="nav-text">wait、waitpid函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wait"><span class="nav-number">2.8.1.</span> <span class="nav-text">wait</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#waitpid"><span class="nav-number">2.8.2.</span> <span class="nav-text">waitpid</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B"><span class="nav-number">2.9.</span> <span class="nav-text">进程间通信简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.1.</span> <span class="nav-text">* Linux进程通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-%E7%AE%A1%E9%81%93"><span class="nav-number">2.10.</span> <span class="nav-text">匿名管道[管道]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.10.1.</span> <span class="nav-text">管道的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">2.10.2.</span> <span class="nav-text">匿名管道进程间通信原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.10.3.</span> <span class="nav-text">匿名管道的数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.10.4.</span> <span class="nav-text">匿名管道的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.10.4.1.</span> <span class="nav-text">创建一个匿名管道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.10.4.2.</span> <span class="nav-text">查看管道缓冲大小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">2.10.4.3.</span> <span class="nav-text">设置管道非阻塞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.11.</span> <span class="nav-text">有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.11.1.</span> <span class="nav-text">创建有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.11.2.</span> <span class="nav-text">使用有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD"><span class="nav-number">2.11.3.</span> <span class="nav-text">有名管道实现聊天功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.12.</span> <span class="nav-text">使用管道的四种特殊情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">2.13.</span> <span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.13.1.</span> <span class="nav-text">内存映射的相关系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.13.2.</span> <span class="nav-text">使用内存映射实现进程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84TIPS"><span class="nav-number">2.13.3.</span> <span class="nav-text">内存映射TIPS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.14.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.14.1.</span> <span class="nav-text">信号的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E4%BF%A1%E5%8F%B7%E4%B8%80%E8%A7%88%E8%A1%A8"><span class="nav-number">2.14.2.</span> <span class="nav-text">部分信号一览表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9ASIGCHILD"><span class="nav-number">2.14.2.1.</span> <span class="nav-text">举例：SIGCHILD</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%94%E7%A7%8D%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.14.3.</span> <span class="nav-text">信号的五种默认处理动作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">2.14.4.</span> <span class="nav-text">信号相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#kill-1"><span class="nav-number">2.14.4.1.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#raise"><span class="nav-number">2.14.4.2.</span> <span class="nav-text">raise</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#abort"><span class="nav-number">2.14.4.3.</span> <span class="nav-text">abort</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#alarm"><span class="nav-number">2.14.4.4.</span> <span class="nav-text">alarm</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#setitimer"><span class="nav-number">2.14.4.5.</span> <span class="nav-text">setitimer</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-number">2.14.5.</span> <span class="nav-text">信号捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#signal"><span class="nav-number">2.14.5.1.</span> <span class="nav-text">signal</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sigaction"><span class="nav-number">2.14.5.2.</span> <span class="nav-text">sigaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.15.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.15.1.</span> <span class="nav-text">共享内存使用步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.15.2.</span> <span class="nav-text">共享内存使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#shmget"><span class="nav-number">2.15.2.1.</span> <span class="nav-text">shmget</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmat"><span class="nav-number">2.15.2.2.</span> <span class="nav-text">shmat</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmdt"><span class="nav-number">2.15.2.3.</span> <span class="nav-text">shmdt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmctl"><span class="nav-number">2.15.2.4.</span> <span class="nav-text">shmctl</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ftok"><span class="nav-number">2.15.2.5.</span> <span class="nav-text">ftok</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%B8%80%E5%9D%97%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%A2%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%B3%E8%81%94"><span class="nav-number">2.15.3.</span> <span class="nav-text">操作系统如何知道一块共享内存被多少个进程关联</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D"><span class="nav-number">2.16.</span> <span class="nav-text">终端、进程组、会话</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF"><span class="nav-number">2.16.1.</span> <span class="nav-text">终端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">2.16.2.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">2.16.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">2.16.4.</span> <span class="nav-text">相关函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.17.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.17.1.</span> <span class="nav-text">守护进程的创建步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">3.</span> <span class="nav-text">Linux多线程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">3.1.2.</span> <span class="nav-text">线程和进程虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%92%8C%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">3.1.3.</span> <span class="nav-text">线程之间共享和非共享资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">线程相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-create"><span class="nav-number">3.2.1.</span> <span class="nav-text">pthread_create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-self"><span class="nav-number">3.2.2.</span> <span class="nav-text">pthread_self</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-equal"><span class="nav-number">3.2.3.</span> <span class="nav-text">pthread_equal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-exit"><span class="nav-number">3.2.4.</span> <span class="nav-text">pthread_exit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-join"><span class="nav-number">3.2.5.</span> <span class="nav-text">pthread_ join</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-detach"><span class="nav-number">3.2.6.</span> <span class="nav-text">pthread_detach</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-cancel"><span class="nav-number">3.2.7.</span> <span class="nav-text">pthread_cancel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">设置线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">相关函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.4.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.4.1.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">相关函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E6%94%B9%E8%BF%9B%E7%89%88"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">案例改进版</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.4.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.4.3.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-3"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">相关函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%B8%8D%E6%98%AF%E9%94%81-%E4%B8%8D%E5%A5%BD%E7%94%A8"><span class="nav-number">3.4.4.</span> <span class="nav-text">条件变量(不是锁,不好用)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.4.5.</span> <span class="nav-text">信号量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">Linux网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BS%E5%92%8CCS%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">BS和CS架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-x2F-S"><span class="nav-number">4.1.1.</span> <span class="nav-text">C&#x2F;S</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-x2F-S"><span class="nav-number">4.1.2.</span> <span class="nav-text">B&#x2F;S</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="nav-number">4.2.</span> <span class="nav-text">MAC地址,IP地址和端口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="nav-number">4.2.1.</span> <span class="nav-text">MAC地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="nav-number">4.2.2.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-number">4.2.3.</span> <span class="nav-text">端口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.3.</span> <span class="nav-text">网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">4.3.2.</span> <span class="nav-text">三种模型对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88TCP-x2F-IP%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-number">4.3.3.</span> <span class="nav-text">封装（TCP&#x2F;IP结构）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%94%A8"><span class="nav-number">4.3.4.</span> <span class="nav-text">分用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.4.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.4.1.</span> <span class="nav-text">UDP头部格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.4.2.</span> <span class="nav-text">TCP头部格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IPv4%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.4.3.</span> <span class="nav-text">IPv4头部结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.4.4.</span> <span class="nav-text">以太网帧格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.4.5.</span> <span class="nav-text">ARP报文格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket"><span class="nav-number">4.5.</span> <span class="nav-text">socket</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">4.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">4.5.2.</span> <span class="nav-text">字节序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">字节序转换函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IP%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%88%E6%9C%89%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="nav-number">4.5.3.</span> <span class="nav-text">IP转换函数（有字节序转换的功能）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#inet-pton"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">inet_pton</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#inet-ntop"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">inet_ntop</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sockaddr%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.4.</span> <span class="nav-text">sockaddr数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80-%E5%8F%AA%E4%B8%BAIPv4%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">通用socket地址(只为IPv4设计)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="nav-number">4.5.4.2.</span> <span class="nav-text">专用socket地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">4.6.</span> <span class="nav-text">TCP通信流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket%E5%87%BD%E6%95%B0"><span class="nav-number">4.7.</span> <span class="nav-text">socket函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%81%E5%8C%85%E5%90%AB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">4.7.1.</span> <span class="nav-text">要包含的头文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#socket-1"><span class="nav-number">4.7.2.</span> <span class="nav-text">socket</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bind"><span class="nav-number">4.7.3.</span> <span class="nav-text">bind</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#listen"><span class="nav-number">4.7.4.</span> <span class="nav-text">listen</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#accept"><span class="nav-number">4.7.5.</span> <span class="nav-text">accept</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#connect"><span class="nav-number">4.7.6.</span> <span class="nav-text">connect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#write-1"><span class="nav-number">4.7.7.</span> <span class="nav-text">write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#send"><span class="nav-number">4.7.8.</span> <span class="nav-text">(send)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read-1"><span class="nav-number">4.7.9.</span> <span class="nav-text">read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recv"><span class="nav-number">4.7.10.</span> <span class="nav-text">(recv)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fgets"><span class="nav-number">4.7.11.</span> <span class="nav-text">* fgets</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-x2F-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1"><span class="nav-number">4.8.</span> <span class="nav-text">代码实现服务器&#x2F;客户端通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-amp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">4.9.</span> <span class="nav-text">TCP三次握手 &amp; 四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%8F%91%E7%94%9F%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AFconnect-%E4%B8%AD"><span class="nav-number">4.9.1.</span> <span class="nav-text">三次握手(发生在客户端connect()中)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%A4%E7%AB%AFclose-%E4%B8%AD"><span class="nav-number">4.9.2.</span> <span class="nav-text">四次握手(发生在两端close()中)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">4.10.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="nav-number">4.10.1.</span> <span class="nav-text">发送方如何维护拥塞窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">4.10.1.1.</span> <span class="nav-text">慢开始和拥塞避免</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">4.10.1.2.</span> <span class="nav-text">快重传和快恢复</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-TCP%E4%B8%A4%E7%A7%8D%E9%87%8D%E4%BC%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">4.10.2.</span> <span class="nav-text">(补充)TCP两种重传方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%B9%B6%E5%8F%91"><span class="nav-number">4.11.</span> <span class="nav-text">TCP通信并发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.11.1.</span> <span class="nav-text">多进程实现并发服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%89%88"><span class="nav-number">4.11.1.1.</span> <span class="nav-text">第一版</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%89%88-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="nav-number">4.11.1.2.</span> <span class="nav-text">第二版(回收子进程资源)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.11.2.</span> <span class="nav-text">多线程实现并发服务器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%8D%8A%E5%85%B3%E9%97%AD%E3%80%81%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">4.12.</span> <span class="nav-text">TCP半关闭、端口复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shutdown"><span class="nav-number">4.12.1.</span> <span class="nav-text">shutdown</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setsockopt"><span class="nav-number">4.12.2.</span> <span class="nav-text">setsockopt</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#netstat"><span class="nav-number">4.12.3.</span> <span class="nav-text">netstat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E8%BD%AC%E6%8E%A5"><span class="nav-number">4.13.</span> <span class="nav-text">IO多路复用(转接)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.13.1.</span> <span class="nav-text">几种常见的I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BIO"><span class="nav-number">4.13.1.1.</span> <span class="nav-text">BIO</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#NIO"><span class="nav-number">4.13.1.2.</span> <span class="nav-text">NIO</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">4.13.2.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.13.2.1.</span> <span class="nav-text">select工作流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.13.2.2.</span> <span class="nav-text">select代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E7%BC%BA%E7%82%B9"><span class="nav-number">4.13.2.3.</span> <span class="nav-text">select缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">4.13.3.</span> <span class="nav-text">poll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#poll%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.13.3.1.</span> <span class="nav-text">poll代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#poll%E7%BC%BA%E7%82%B9"><span class="nav-number">4.13.3.2.</span> <span class="nav-text">poll缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">4.13.4.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.13.4.1.</span> <span class="nav-text">epoll代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#epoll%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.13.4.2.</span> <span class="nav-text">epoll两种工作模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="nav-number">4.14.</span> <span class="nav-text">UDP通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">4.14.1.</span> <span class="nav-text">UDP通信流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.14.2.</span> <span class="nav-text">UDP通信代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">4.15.</span> <span class="nav-text">广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E6%92%AD"><span class="nav-number">4.16.</span> <span class="nav-text">组播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">4.17.</span> <span class="nav-text">本地套接字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">项目实战与总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">5.1.</span> <span class="nav-text">阻塞和非阻塞、同步和异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix%E3%80%81Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">Unix、Linux上的五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">阻塞IO模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">非阻塞IO模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">5.2.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="nav-number">5.2.4.</span> <span class="nav-text">信号驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.5.</span> <span class="nav-text">异步IO模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.6.</span> <span class="nav-text">⭐️5种IO模型的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E4%BB%8B%E5%8F%8AHTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.3.</span> <span class="nav-text">Web服务器简介及HTTP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">服务器编程基本框架和两种高效的事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.1.</span> <span class="nav-text">两种高效的事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">Proactor模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5IO%E7%9A%84%E6%96%B9%E5%BC%8F%E6%A8%A1%E6%8B%9FProactor"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">⭐️使用同步IO的方式模拟Proactor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%B1%BB%E5%B0%81%E8%A3%85%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.5.</span> <span class="nav-text">线程同步机制类封装及线程池实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.5.1.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.6.</span> <span class="nav-text">项目整体流程代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">5.6.1.</span> <span class="nav-text">有限状态机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%A3%80%E6%B5%8B%E9%9D%9E%E6%B4%BB%E8%B7%83%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.7.</span> <span class="nav-text">定时检测非活跃连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-number">5.8.</span> <span class="nav-text">服务器压力测试</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
