<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="Linux高性能服务器编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="Linux高性能服务器编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028142406885.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028143032281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028154045633.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160925281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160951754.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028163708993.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028172215221.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174622965.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174905118.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175247985.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175559945.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028180448158.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029160442047.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029165648092.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029171653493.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029172431281.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030145918168.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030193146766.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VwZXJzbWFydEA=,size_11,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Center.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221031215037224.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101013945568.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143024126.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143922053.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102133524824.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102140508146.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102143252014.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144326483.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144456528.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102174749178.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102194024601.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103120849314.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103164530935.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165336300.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165127529.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165504053.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221104170616515.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105134241461.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105165609594.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105181155408.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106215842522.png">
<meta property="og:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106220232940.png">
<meta property="article:published_time" content="2022-08-10T07:54:39.000Z">
<meta property="article:modified_time" content="2022-11-06T14:20:59.255Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png">

<link rel="canonical" href="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux高性能服务器编程 | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux高性能服务器编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-10 15:54:39" itemprop="dateCreated datePublished" datetime="2022-08-10T15:54:39+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-06 22:20:59" itemprop="dateModified" datetime="2022-11-06T22:20:59+08:00">2022-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">linux && 服务器</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">Linux高性能服务器编程</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h3><p>清屏	<code>ctrl+l</code></p>
<p>自动补全 	<code>tab</code></p>
<h3 id="Linux操作"><a href="#Linux操作" class="headerlink" title="Linux操作"></a>Linux操作</h3><h4 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h4><p>touch	<code>touch [选项] [文件]</code>	如果文件不存在，使用touch命令默认创建一个空文件。</p>
<blockquote>
<p>-c -t	touch -c -t 06071930 file1	将文件file1现在的时间已经改为6月7日19点30分</p>
</blockquote>
<p>cp	<code>cp [选项] [源文件/目录] [目标文件/目录]</code>拷贝文件</p>
<blockquote>
<p><code>cp makefile makefile1</code>	将makefile另外复制一份为makefile1</p>
<p><code>cp -r a/ b/ ../lesson5</code> 将当前目录	a&#x2F;文件夹	b&#x2F;文件夹 递归拷贝到上一级目录下的lesson5目录</p>
</blockquote>
<p>file	<code>file [文件]</code>显示文件类型</p>
<p>tree 	<code>tree</code>查看该文件夹内垂直目录结构</p>
<p>pwd	<code>pwd</code>显示用户当前工作目录路径</p>
<p>ls 	<code>ls [选项] [文件]</code>查看当前目录下所有可见文件		</p>
<blockquote>
<p>-d	只显示当前文件夹	</p>
<p>-l	以长格式的形式查看当前目录下所有可见文件的详细属性,不包括隐藏文件</p>
<p>-la	查看文件详细信息，包括隐藏文件。</p>
<p>-ld	查看当前目录本身的权限与属性信息</p>
</blockquote>
<p>mkdir 	<code>mkdir [选项] [文件]</code>创建目录	</p>
<blockquote>
<p>-m xxx	创建具有xxx权限的目录</p>
</blockquote>
<p>rmdir	 <code>rmdir [选项] [文件]</code>删除目录</p>
<p>mv	<code>mv [选项] [源文件] [目标文件]</code>文件和目录改名、移动文件和目录路径  如<code>mv -f *.png picture</code></p>
<blockquote>
<p>-f	不询问，或者说覆盖前不询问<br>-i 	询问，或者说覆盖前询问<br>-n	不覆盖已存在的文件</p>
</blockquote>
<p>rm	<code>rm [选项] [文件]</code>删除文件或目录</p>
<blockquote>
<p>-f	 忽略不存在的文件，从不给出提示。</p>
<p>-i	进行交互式删除</p>
<p>-r	指示rm将参数中列出的全部目录和子目录均递归地删除。</p>
<p>-rf	无提示地强制递归删除文件</p>
<p>-v	详细显示进行的步骤</p>
</blockquote>
<p>wc	<code>wc [选项] [文件]</code>统计文件行数、单词数和字节数和字符数 		不加选项的话总是按行数、单词数、字节数、文件的顺序显示每项信息。</p>
<blockquote>
<p>-c或–bytes或–chars 	只显示Bytes数。</p>
<p>-l或–lines 	只显示列数。</p>
<p>-w或–words 	只显示字数。</p>
<p>-m	只显示字符数</p>
</blockquote>
<p>ln	<code>ln [选项] [源文件] [目标文件]</code>使用ln命令可以创建链接文件（包括软链接文件和硬链接文件）</p>
<blockquote>
<p>硬链接文件的使用	<code>echo hello &gt; a</code>	<code>ln a b</code></p>
<p>软链接文件的使用	<code>echo hello &gt; a</code>	<code>ln –s a b</code></p>
</blockquote>
<h4 id="文本内容显示"><a href="#文本内容显示" class="headerlink" title="文本内容显示"></a>文本内容显示</h4><p>cat	<code>cat [选项] [文件]</code>显示文本文件</p>
<blockquote>
<p>无选项 	显示文件内容</p>
<p>cat -n textfile1 &gt; textfile2  	把textfile1文件的内容加上行号后输入到textfile2文件中</p>
<p>cat &gt;mm.txt&lt;&lt;EOF 输入&gt;Hello	&gt;Linux	&gt;EOF	使用cat命令创建mm.txt并输入Hello Linux。</p>
</blockquote>
<p>more	<code>more [选项] [文件名]</code>分页显示文本文件</p>
<blockquote>
<p>无选项	分页显示该文件内容</p>
<p> more -s testfile	逐页显示testfile文件内容，如有连续两行以上空白行则以一行空白行显示</p>
<p> more +20 testfile	从第20行开始显示testfile文件的内容</p>
<p> more -2 &#x2F;etc&#x2F;passwd	一次两行显示&#x2F;etc&#x2F;passwd文件内容</p>
</blockquote>
<p>less	<code>less [选项] [文件名]</code>回卷显示文本文件</p>
<blockquote>
<p> less &#x2F;etc&#x2F;services	回卷显示&#x2F;etc&#x2F;services文件的内容</p>
</blockquote>
<p>head	<code>head［选项］[文件]</code>显示指定文件前若干行 如果没有给出具体行数值，默认为10行</p>
<blockquote>
<p>head -c -50 a	查看a文件前五十个字节数据</p>
<p>head -50 a	查看a文件前五十行数据</p>
</blockquote>
<p>tail	<code>tail［选项］[文件]</code>显示指定文件末尾若干行 如果没有给出具体行数值，默认为10行 具体选项用法完全同<code>head</code></p>
<h4 id="文本内容处理"><a href="#文本内容处理" class="headerlink" title="文本内容处理"></a>文本内容处理</h4><p>sort	<code>sort [选项] [文件]</code>对文件中的数据进行排序</p>
<blockquote>
<p>-r	倒序排序</p>
</blockquote>
<p>uniq	<code>uniq [选项] [文件] </code>将重复行从输出文件中删除</p>
<blockquote>
<p>-d	查看文件中重复的数据内容</p>
<p> -u	查看文件中不重复的数据内容</p>
</blockquote>
<p>cut	<code>cut [选项] [ 文件 ]</code>从文件每行中显示出选定的字节、字符或字段</p>
<blockquote>
<p>-b	以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</p>
<p>-c	以字符为单位进行分割。</p>
<p>-d	自定义分隔符，默认为制表符。</p>
<p>-f	与-d一起使用，指定显示哪个区域。</p>
<p>-n	取消分割多字节字符。仅和 -b 标志一起使用。</p>
</blockquote>
<blockquote>
<p>cut -f 1,5 -d: &#x2F;etc&#x2F;passwd 	显示文件&#x2F;etc&#x2F;passwd中的第1个和第5个字段，由冒号隔开。</p>
</blockquote>
<p>comm	<code>comm [选项] [文件1] [文件2]</code>逐行比较两个已排过序的文件</p>
<blockquote>
<p>-1	不输出文件1特有的行</p>
<p>-2	不输出文件2特有的行</p>
<p>-3	不输出两个文件共有的行</p>
</blockquote>
<p>diff	<code>diff ［选项］ [文件1] [文件2]</code>逐行比较两个文本文件，列出其不同之处</p>
<h4 id="文件和命令查找"><a href="#文件和命令查找" class="headerlink" title="文件和命令查找"></a>文件和命令查找</h4><p>grep	<code>grep [选项] [查找模式] [文件名] </code>查找文件中符合条件的字符串</p>
<blockquote>
<p>grep ‘test file’ kkk	在文件kkk中搜索匹配字符“test file”</p>
<p>grep ‘test’ d*	显示所有以d开头的文件中包含“test”的行数据内容</p>
<p>grep ^b &#x2F;root&#x2F;aa	 在&#x2F;root&#x2F;aa文件中找出以b开头的行内容</p>
<p>grep -v ^b &#x2F;root&#x2F;aa	在&#x2F;root&#x2F;aa文件中找出不以b开头的行内容</p>
<p>grep le$ &#x2F;root&#x2F;kkk	在&#x2F;root&#x2F;kkk文件中找出以le结尾的行内容</p>
<p>ps –ef|grep sshd	查找sshd进程信息</p>
</blockquote>
<p>find	<code>find [路径] [选项]</code>列出文件系统内符合条件的文件</p>
<blockquote>
<p>find &#x2F; -name ‘*.conf’	查找&#x2F;目录下所有以“.conf”为扩展名的文件</p>
<p>find . -ctime -20	列出当前目录及其子目录下所有最近20天内更改过的文件</p>
</blockquote>
<p>locate	<code>locate [选项][范本样式]</code>在数据库中查找文件</p>
<blockquote>
<p>locate httpd.conf	查找httpd.conf</p>
<p>locate -c httpd.conf	显示找到几个httpd.conf文件</p>
</blockquote>
<h4 id="系统信息显示"><a href="#系统信息显示" class="headerlink" title="系统信息显示"></a>系统信息显示</h4><p>uname	<code>uname [选项]</code>显示计算机及操作系统相关信息</p>
<blockquote>
<p>-r	显示操作系统的内核发行号</p>
<p>-m	显示计算机硬件架构名称</p>
<p>-a	显示操作系统的全部信息</p>
</blockquote>
<p>hostname	<code>设置主机名:hostname [选项] [主机名] 	显示主机名:hostname [选项] </code>显示或修改计算机主机名</p>
<p>free	<code>free [选项]</code>查看内存信息</p>
<blockquote>
<p>free	查看系统的物理内存和交换分区使用情况</p>
<p>free -m	以MB为单位查看系统的物理内存和交换分区使用情况</p>
<p>free -t	显示系统的物理内存加上交换分区总的容量</p>
</blockquote>
<p>du	<code>du [选项] [文件|目录]</code>显示目录或文件的磁盘占用量</p>
<blockquote>
<p>无选项	显示文件的磁盘占用量</p>
<p>-s	显示目录的磁盘占用量</p>
<p>-sh	以MB为单位显示目录磁盘占用量</p>
</blockquote>
<h4 id="查看日期与时间"><a href="#查看日期与时间" class="headerlink" title="查看日期与时间"></a>查看日期与时间</h4><p>cal	<code>cal [选项] [[[日] 月] 年]</code>显示日历信息</p>
<blockquote>
<p>cal	显示本月的月历</p>
<p>cal 2001	显示公元2001年年历。</p>
<p>cal 9 2007	显示公元2007年9月的月历。</p>
<p>cal -m 	以星期一为每周的第一天的方式显示本月的日历。</p>
<p>cal -jy	以1月1日起的天数显示今年的年历。</p>
</blockquote>
<p>date	<code>date [选项] [显示时间格式]（以+开头，后面接格式）</code>显示和设置系统日期和时间</p>
<blockquote>
<p>date	显示当前计算机上的日期和时间</p>
<p>date 0202191428	设置计算机日期和时间为2028年2月2日19点14分</p>
<p>date +’%r%a%d%h%y’	按照指定的格式显示计算机日期和时间</p>
<p>date -s 09:16:00	设置计算机时间为上午9点16分</p>
<p>date -s 240414	设置计算机时间为2024年4月14日</p>
</blockquote>
<p>hwclock	<code>hwclock [选项] </code>查看和设置硬件时钟</p>
<blockquote>
<p>hwclock	查看硬件时间</p>
<p>hwclock -w 	以系统时间更新硬件时间</p>
<p>hwclock -s	以硬件时间更新系统时间</p>
</blockquote>
<h4 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h4><p>echo	<code>echo [选项] [字符串] </code>在显示器上显示文字</p>
<blockquote>
<p>echo Hello Linux	将一段信息写到标准输出	结果:Hello Linux</p>
<p>echo Hello Linux &gt; notes	将文本“Hello Linux”添加到新文件notes中</p>
<p>echo $HOME	 显示$HOME变量的值</p>
</blockquote>
<p>mesg	<code>mesg [选项]</code>允许或拒绝写消息</p>
<blockquote>
<p>控制系统中的其它用户是否能够用 write 命令或 talk 命令向您发送消息。不带选项的情况下，mesg 命令显示当前主机消息许可设置</p>
</blockquote>
<p>wall	<code>wall [消息] </code>对全部已登录用户发送信息</p>
<blockquote>
<p>wall ‘aaaaaaa’	对全部已登录用户发送aaaaaaa</p>
</blockquote>
<p>write	<code>write [用户] [终端名称] </code>向用户发送消息</p>
<blockquote>
<p>write root tty3	向tty3终端上的root用户发送信息</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>clear	<code>clear</code>清屏</p>
<p>uptime	<code>uptime</code>显示系统已经运行的时间</p>
<h3 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装了远程连接服务器的工具,操作它就不要打开再操作了	<code>sudo yum install openssh-server</code></p>
<p>查看虚拟机ip地址	<code>ifconfig</code> </p>
<p>登录该虚拟机	<code>ssh kjg@172.16.208.128</code></p>
<p>利用Vscode远程连接该虚拟机</p>
<h4 id="Gcc编译"><a href="#Gcc编译" class="headerlink" title="Gcc编译"></a>Gcc编译</h4><h5 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h5><p>GCC 原名为 GNU C语言编译器（GNU C Compiler）</p>
<p>可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个C 标准。如，当使用 <code>-std = c99</code>启动 GCC时，编译器支持 C99 标准</p>
<h5 id="GCC命令"><a href="#GCC命令" class="headerlink" title="GCC命令"></a>GCC命令</h5><p>安装命令 <code>sudo yum install gcc g++ </code>（版本＞4.8.5）</p>
<p>查看版本 <code>gcc / g++ -v / --version</code></p>
<p>预处理指定的源文件,不进行编译[ .c -&gt; .i ]	<code>gcc test.c -E -o test.i</code></p>
<p>编译指定的源文件,但是不进行汇编[ .i -&gt; .s ]	<code>gcc test.i -S -o test.s</code></p>
<p>编译,汇编指定的源文件,但不进行链接[ .s -&gt; .o ]	<code>gcc test.s -c -o test.o</code></p>
<p>编译生成可执行文件[ .c -&gt; .out ]	<code>gcc test.c -o app</code>	如果<code>gcc test.c</code>则生成一个默认的<code>a.out</code>文件</p>
<p>运行	<code>./app</code> 或 <code>./a.out</code></p>
<h5 id="GCC工作流程"><a href="#GCC工作流程" class="headerlink" title="GCC工作流程"></a>GCC工作流程</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png" alt="image-20221026150832523" style="zoom:50%;">



<h5 id="gcc与g-区别"><a href="#gcc与g-区别" class="headerlink" title="gcc与g++区别"></a>gcc与g++区别</h5><p>gcc编译c文件，g++编译c++文件</p>
<p>编译可以用<code>gcc / g++</code> 链接可用 <code>g++</code> 或者 <code>gcc -lstdc++</code></p>
<h4 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h4><h5 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h5><ul>
<li><p>库是特殊的一种程序，提供给使用者一些可以直接拿来用的变量、函数或类,编写库的程序和编写一般的程序区别不大，只是库不能单独运待。</p>
</li>
<li><p>库文件有两种，静态库和动态库(共享库)区别是:</p>
<p>静态库在程序的链接阶段被复制到了程序中;</p>
<p>动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
</li>
<li><p>库的好处: 1.代码保密  2.方便部署和分发</p>
</li>
</ul>
<h5 id="静态库的命名规则"><a href="#静态库的命名规则" class="headerlink" title="静态库的命名规则"></a>静态库的命名规则</h5><p>Linux:	<code>libxxx.a</code>	(lib是固定前缀	a是固定后缀	中间的xxx是库名)</p>
<p>Windows:	<code>libxxx.lib</code></p>
<h5 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h5><ol>
<li><p><code>gcc - c</code>获得.o文件</p>
</li>
<li><p>将.o文件打包,使用ar工具(archive)    </p>
<p><code>ar rcs libxxx.a xxx.o xxx.o</code>		r是将文件插入备存文件(在这里是库文件)中 c是建立备存文件 s是索引</p>
</li>
</ol>
<h5 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56673429/article/details/124168013">静态库的使用</a></h5><p>得到了一个可用的静态库之后，将其与相应的头文件放到一个目录中(就相当于发布了)，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。</p>
<p>这里我把生成的静态库和相应的头文件放到temp文件夹中进行测试。<br>这里我们会用到gcc的两个参数</p>
<p>-l 	在程序编译的时候，指定使用的库。（静态库的名字一定要掐头去尾。如：libCalc.a变为Calc）<br>-L 	在程序编译的时候，指定使用的库的路径。</p>
<p>如:	<code>gcc main.c -o Calc -L ./ -l Calc</code> [第一个Calc是生成的可执行文件名]</p>
<p>运行:	<code>./Calc</code></p>
<h5 id="动态库的命名规则"><a href="#动态库的命名规则" class="headerlink" title="动态库的命名规则"></a>动态库的命名规则</h5><p>Linux:	<code>libxxx.so</code> 	lib:前缀(固定)	xxx ：库的名字，自己起 	so:后缀（固定）	在Linux下是一个可执行文件 </p>
<p>Windows:	<code>libxxx.dll</code></p>
<h5 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h5><p>gcc 得到.o文件，得到和位置无关的代码	 <code>gcc -c -fpic/-fPIC a.c b.c</code><br>gcc 得到动态库	<code>gcc －shared a.o b.o -o libcalc.so</code></p>
<h5 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h5><p>库文件是src里源文件的定义，头文件是src里源文件的声明；使用时需要将库文件和头文件都分发给src里的文件们</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028142406885.png" alt="image-20221028142406885" style="zoom:50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要将使用的库文件拷贝到当前lib目录下</span></span><br><span class="line">gcc main.c -o main -I include/ -L /lib -l calc   </span><br><span class="line"><span class="comment"># -I include/ 是为了找到head.h  	-L /lib是为了找到库文件的目录		-l calc是为了指定库文件名</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028143032281.png" alt="image-20221028143032281" style="zoom:50%;"> 



<h5 id="动态库加载失败的原因"><a href="#动态库加载失败的原因" class="headerlink" title="动态库加载失败的原因"></a>动态库加载失败的原因</h5><ul>
<li><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中</p>
</li>
<li><p>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中</p>
</li>
<li><p>程序启动之后，动态库会被动态加载到内存中，通过 <code>ldd </code> 命令检查动态库依赖关系 在上例中就是 <code>ldd main</code></p>
</li>
<li><p>如何定位共享库文件呢？</p>
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于<code>elf</code>格式的可执行程序，是由<code>ld-linux.so</code>来完成的，它先后搜索<code>elf</code>文件的 <code>DT_RPATH段</code>→<code>环境变量 LD_LIBRARY_PATH</code>→<code>/etc/1d.so.cache文件列表</code>→<code>/lib/</code>或<code>／usr/lib</code>目录找到库文件后将其载入内存。</p>
</li>
<li><p>解决动态库加载失败方式</p>
<ol>
<li>配置环境变量[一次性的,临时的]</li>
</ol>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028154045633.png" alt="image-20221028154045633"></p>
<ol start="2">
<li>在 <code>.bashrc</code>里配置 同图上同样内容	后输入<code>source .bashrc</code></li>
<li>在<code>/etc/profile</code>里配置 同图上同样内容    后输入<code>source /etc/profile</code></li>
</ol>
</li>
</ul>
<h5 id="动静态库优缺点"><a href="#动静态库优缺点" class="headerlink" title="动静态库优缺点"></a>动静态库优缺点</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160925281.png" alt="image-20221028160925281" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160951754.png" alt="image-20221028160951754" style="zoom: 33%;">





<h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><h5 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h5><ul>
<li><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shel1 脚本一样,也可以执行操作系统的命令</p>
</li>
<li><p>Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令[是Makefile的启动器]，整个工程完全自动编译，极大提高了软件开发效率。</p>
</li>
<li><p>make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi的make，Visual C++的 nmake，Linux下 GNU的make</p>
</li>
</ul>
<h5 id="Makefile文件命名和规则"><a href="#Makefile文件命名和规则" class="headerlink" title="Makefile文件命名和规则"></a>Makefile文件命名和规则</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028163708993.png" alt="image-20221028163708993" style="zoom: 50%;">

<p>例1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Makefile <span class="comment"># 不管当前目录有没有Makefile , 只要有你想编译的.c文件就行</span></span><br><span class="line"></span><br><span class="line">================================================</span><br><span class="line">app : add.c	sub.c	multi.c	div.c	main.c</span><br><span class="line">	gcc add.c	sub.c	multi.c	div.c	main.c -o app</span><br><span class="line">================================================</span><br><span class="line"></span><br><span class="line">make <span class="comment"># sudo yum install make</span></span><br></pre></td></tr></table></figure>

<p>例2:</p>
<p>如果第一个规则的依赖在当前目录暂时找不到, 那就往后查找看后面的规则的目标是否有满足的</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028172215221.png" alt="image-20221028172215221" style="zoom:50%;">

<p>但这样写太繁琐,	 如何简化呢?	下面引入变量和模式匹配和函数</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><h6 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h6><p>变量名＝ 变量值 	<code>var = hello</code></p>
<h6 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h6><p>AR 	归档维护程序的名称，默认值为 <code>ar</code></p>
<p>CC	C编译器的名称，默认值为 <code>cc</code></p>
<p>CXX	C＋＋编译器的名称，默认值为 <code>g++</code></p>
<p>$@	目标的完整名称</p>
<p>$&lt;	第一个依赖文件的名称</p>
<p>$^	所有的依赖文件</p>
<h6 id="获取变量的值"><a href="#获取变量的值" class="headerlink" title="获取变量的值"></a>获取变量的值</h6><p>＄（变量名）	如<code>$(var)</code></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174622965.png" alt="image-20221028174622965"></p>
<h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174905118.png" alt="image-20221028174905118" style="zoom:50%;">



<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h6><p>获取指定目录下指定类型的文件列表</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175247985.png" alt="image-20221028175247985"></p>
<h6 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175559945.png" alt="image-20221028175559945" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028180448158.png" alt="image-20221028180448158" style="zoom:50%;">



<h4 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h4><h5 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h5><p>GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，是Linux和许多类Unix系统中的标准开发环境。</p>
<p>一般来说，GDB主要帮助你完成下面四个方面的功能:</p>
<ol>
<li><p>启动程序，可以按照自定义的要求随心所欲的运行程序</p>
</li>
<li><p>可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)</p>
</li>
<li><p>当程序被停住时，可以检查此时程序中所发生的事</p>
</li>
<li><p>可以改变程序，将一个BUG产生的影响修正从而测试其他BUG</p>
</li>
</ol>
<h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><ul>
<li><p>通常，在为调试而编译时，我们会关掉编译器的优化选项(-o)，并打开调试选项(-g)</p>
<p>  另外，<code>-Wall</code>可以在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p>
</li>
<li><p><code>gcc -g -Wall program.c -o program</code></p>
</li>
<li><p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文</p>
<p>  件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p>
</li>
</ul>
<h5 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h5><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h5 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h5><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h5 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h5><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	(每次调试时(输入n, s), 如果a, b值发生变化的话, 自动打印指定变量(在这里是a, b)的值)</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<h4 id="Linux文件IO"><a href="#Linux文件IO" class="headerlink" title="Linux文件IO"></a>Linux文件IO</h4><ul>
<li><p>文件角度:	输入: 内存 -&gt; 文件	输出: 文件 -&gt; 内存	</p>
</li>
<li><p>内存角度:	输入: 文件 -&gt; 内存	输出: 内存 -&gt; 文件	【我们通常站在内存角度】</p>
</li>
</ul>
<h5 id="标准C库文件函数"><a href="#标准C库文件函数" class="headerlink" title="标准C库文件函数"></a>标准C库文件函数</h5><p>标准C库函数是带缓冲区的， <strong>Linux文件操作时可选用C库函数，效率更好。 网络通信时使用Linux自己的库函数，效率更好</strong></p>
<p>C语言写出的程序可以跨平台运行的原因是C库函数继续调用各系统的库函数</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029165648092.png" alt="image-20221029165648092" style="zoom:50%;">



<h5 id="标准C库IO和LinuxIO的区别"><a href="#标准C库IO和LinuxIO的区别" class="headerlink" title="标准C库IO和LinuxIO的区别"></a>标准C库IO和LinuxIO的区别</h5><p>即 C库IO <strong>调用</strong> LinuxIO</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029171653493.png" alt="image-20221029171653493" style="zoom:50%;">



<h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><ul>
<li><p>它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）</p>
</li>
<li><p>一个进程一个虚拟地址空间，该空间会被MMU映射到真实的内存中（以32位机器举例）</p>
</li>
<li><p>大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等</p>
</li>
<li><p>内核区可以通过调用Linux的API访问</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029172431281.png" alt="image-20221029172431281" style="zoom:50%;">



<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>负责 索引到对应的磁盘文件</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030145918168.png" alt="image-20221030145918168" style="zoom:50%;">







<h4 id="LInux系统函数"><a href="#LInux系统函数" class="headerlink" title="LInux系统函数"></a>LInux系统函数</h4><blockquote>
<p>   帮助文档 ：</p>
<p>  <code>man 2 关键词</code></p>
<p>  <code>关键词 --help</code></p>
</blockquote>
<h5 id="errno-amp-perror"><a href="#errno-amp-perror" class="headerlink" title="errno &amp; perror"></a>errno &amp; perror</h5><p><code>errno</code>	 记录错误号</p>
<p><code>void perror(const string *s)</code>	打印错误描述</p>
<h5 id="open-amp-close"><a href="#open-amp-close" class="headerlink" title="open &amp; close"></a>open &amp; close</h5><p><code>int open (const char *pathname, int flags);</code>	打开一个已经存在的文件， 返回一个新的文件描述符 FILe *</p>
<blockquote>
<p>  pathname 要打开的文件路径</p>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code>	<code>O_WRONLY</code>	<code>O_RDWR</code></p>
<p>  使用:	 <code>int fd = open(&quot;a.txt&quot;, O_RDONLY);</code></p>
</blockquote>
<p><code>int open (const char *pathname , int flags, mode_t mode);</code>	创建一个新的文件</p>
<blockquote>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code>	<code>O_WRONLY</code>	<code>_RDWR</code>  这里多一个可选项 <code>O_CREAT</code>: 文件不存在， 创建新文件</p>
<p>  mode:	八进制权限码，一定是在flags中使用了O_CREAT标志，mode记录待创建的文件的访问权限</p>
<p>  如	<code>fd = open(&quot;./file1&quot;, O_RDWR|O_CREAT, 0600);</code></p>
</blockquote>
<p><code>int close (int fd);</code></p>
<h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<blockquote>
<p>  fd	为文件描述符；buf	表示读出数据缓冲区地址；count	表示要读出的字节数。</p>
<p>  返回值：若读取成功，则返回读到的字节数；若失败，返回-1；若已达到文件尾，则返回0。因此读到的字节数可能小于count的值</p>
</blockquote>
<h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p><code>ssize_t write (int fd, const void *buf, size_t count);</code></p>
<h5 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h5><p>在程序中，在调用read函数之前，先调用了close函数和open函数，这是为了让光标移到文件的头，否则将读取失败。因此，就还需要用到lseek函数来移动文件中光标的位置。通过调用lseek函数可以改变光标的位置，其函数原型为</p>
<p><code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<blockquote>
<p>  其中，fd为文件描述符；offset指的是每一次读写操作所需移动距离，以字节为单位 ，可正可负，正值表示想文件尾部移动，负值表示向文件头部移动。whence表示当前位置的基点，主要有以下三个基点符号常量。</p>
<p>  SEEK_SEK	将光标移到距离文件头前后offset个字节；</p>
<p>  SEEK_CUR	将光标移到当前位置前后offset个字节；</p>
<p>  SEEK_END	将光标移到文件末尾前后offset个字节。</p>
<ul>
<li>除此之外,lseek函数还可以用来计算文件大小，因为他的返回值是以字节为单位，从文件的起始点开始计算到当前位置的字节数</li>
<li><code>int size_of_file = lseek(fd, 0, SEEK_END);</code></li>
</ul>
</blockquote>
<h5 id="stat-amp-lstat"><a href="#stat-amp-lstat" class="headerlink" title="stat &amp; lstat"></a>stat &amp; lstat</h5><p>stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carefree2005/article/details/122454333">stat</a>	<code>int stat（const char *pathname，struct stat *buf);</code>	(使用时要先<code>struct stat st;</code> 传入<code>&amp;st</code>)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/W1024201/article/details/125118032">lstat</a>	<code>int lstat (const char *pathname，struct stat buf);</code></p>
<blockquote>
<p>  stat	获取链接文件的信息时，具有穿透能力，直接穿越链接文件，获取所被链接文件的信息。</p>
<p>  lstat	获取链接文件的信息，无穿透能力</p>
<p>  st.st_mode	获取到的部分文件信息用st.st_mode 与下面这13个码分别相与得到，第一个&amp;得出4位，后面的每个&amp;得出1位</p>
<p>  st.st_xxx	其他的所有属性也在这里面，到时查手册即可</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030193146766.png" alt="image-20221030193146766" style="zoom:50%;">



<h4 id="Linux文件属性操作函数"><a href="#Linux文件属性操作函数" class="headerlink" title="Linux文件属性操作函数"></a>Linux文件属性操作函数</h4><h5 id="access"><a href="#access" class="headerlink" title="access"></a>access</h5><p><code>int access(const char* pathname, int mode);</code></p>
<blockquote>
<p>  返回值：成功0，失败-1</p>
<p>  mode：指定access的作用，取值如下</p>
<ol>
<li>F_OK 值为0，判断文件是否存在</li>
<li>X_OK 值为1，判断对文件是可执行权限</li>
<li>W_OK 值为2，判断对文件是否有写权限</li>
<li>R_OK 值为4，判断对文件是否有读权限</li>
</ol>
<p>   注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</p>
</blockquote>
<h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p><code>int chmod(const char * filename ,int mode) ;</code></p>
<p><code>chmod [-cfvR] [--help] [--version] mode file</code>	其中<code>mode</code>格式 : <code>[ugoa...] [[+ - =] [rwxX]...] [ ,... ]</code></p>
<blockquote>
<p>  <code>u</code> 表示该档案的拥有者，<code>g</code>表示与该档案的拥有者属于同一个群体(group)者，<code>o </code>表示其他以外的人，<code>a</code> 表示这三者皆是。</p>
<p>  <code>+</code>表示增加权限、<code>-</code> 表示取消权限、<code>=</code> 表示唯一设定权限。</p>
<p>  <code>r </code>表示可读取，<code>w</code> 表示可写入，<code>x</code> 表示可执行，<code>X</code> 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</p>
<p>  -c 	若该档案权限确实已经更改，才显示其更改动作</p>
<p>  -f 	若该档案权限无法被更改也不要显示错误讯息</p>
<p>  -v 	显示权限变更的详细资料</p>
<p>  -R 	对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</p>
<p>  –help	显示辅助说明</p>
<p>  –version	显示版本</p>
</blockquote>
<blockquote>
<p>  <code>chmod ugo+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod a+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod ug+w,o-w file1.txt file2.txt </code>	将档案 file1.txt 与 file2.txt 设为该档案拥有者与其同组可写入，其他人不可写入 </p>
<p>  <code>chmod u+x ex1.py </code>	将 ex1.py 设定为只有该档案拥有者可以执行 </p>
<p>  <code>chmod -R a+r * </code>	将目前目录下的所有档案与子目录皆设为任何人可读取 </p>
<p>  <code>chmod ug=rwx,o=x file </code>	设置该档案拥有者与其同组可读写执行，其他人只能执行</p>
</blockquote>
<h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p><code>int chown (const char *path, uid_ t owner, gid_ t group) ;</code></p>
<p><code>chown [参数] user[:group] [文件]</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>新的文件拥有者的使用者 ID</td>
</tr>
<tr>
<td>group</td>
<td>新的文件拥有者的使用者组(group)</td>
</tr>
<tr>
<td>-c</td>
<td>显示更改的部分的信息</td>
</tr>
<tr>
<td>-f</td>
<td>忽略错误信息</td>
</tr>
<tr>
<td>-h</td>
<td>-h 改变的是链接文件属主， 不加-h改变的是链接源文件属主</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>-R</td>
<td>处理指定目录以及其子目录下的所有文件</td>
</tr>
<tr>
<td>–help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<p>以下选项修改了在还指定了-R选项时遍历层次结构的方式。如果指定了多个，则只有最后一个生效。</p>
<blockquote>
<p>  -H 如果命令行参数是指向目录的符号链接，则遍历它</p>
<p>  -L 遍历遇到的每个指向目录的符号链接</p>
<p>  -P 不遍历任何符号链接（默认）</p>
</blockquote>
<h5 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h5><p><code>int truncate (const char *path, off_t length) ;</code></p>
<p><code>truncate OPTION... FILE...</code>	命令可以将一个文件缩小或者扩展到某个给定的大小.可以用-s选项来指定文件的大小</p>
<blockquote>
<p>  -c	do not create any files</p>
<p>  -o	treat SIZE as number of IO blocks instead of bytes</p>
<p>  -r	base size on RFILE</p>
<p>  -s	set or adjust the file size by SIZE bytes</p>
<p>  –help </p>
<p>  –version</p>
</blockquote>
<h4 id="Linux目录操作函数"><a href="#Linux目录操作函数" class="headerlink" title="Linux目录操作函数"></a>Linux目录操作函数</h4><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p><code>int mkdir (const char *pathname, mode t mode) ;</code></p>
<h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h5><p><code>int rmdir (const char *pathname) ;</code></p>
<h5 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h5><p><code>int rename (const char *oldname, const char * newname) ;</code></p>
<h5 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h5><p><code>char *getcwd (char *buf,size t size) ;</code></p>
<blockquote>
<p>  getcwd	会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</p>
</blockquote>
<h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h5><p><code>DIR* opendir (const char* name) ;</code></p>
<blockquote>
<p>  打开一个目录并建立一个目录流</p>
<p>  如果打开成功的话返回一个DIR结构的指针,该指针用于读取目录数据项。</p>
<p>  如果失败的话返回一个空指针如果文件中的文件过多也可能打开失败</p>
</blockquote>
<h5 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h5><p><code>int chdir (const char* path) ;</code></p>
<blockquote>
<p>  改变当前工作目录</p>
</blockquote>
<h5 id="readir"><a href="#readir" class="headerlink" title="readir"></a>readir</h5><p><code>struct dirent* readdir (DIR* dirp) ;</code></p>
<blockquote>
<p>  返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h5><p><code>int closedir (DIR* dirp) ;</code></p>
<h4 id="dup-amp-dup2"><a href="#dup-amp-dup2" class="headerlink" title="dup &amp; dup2"></a>dup &amp; dup2</h4><p><code>int dup ( int oldfd) ;</code></p>
<blockquote>
<p>  在 Linux 系统中， open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具 有读写权限；在 Linux 系统下，可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制。我们来学习下两个函数的用法以及它们之间的区别。</p>
<p>  复制得到的文件描述符与旧的文件描述符都指向了同一个文件表，假设 fd1 为原文件描述符， fd2 为复制得到的文件描述符，如下图所示：</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VwZXJzbWFydEA=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>  因为复制得到的文件描述符与旧的文件描述符指向的是同一个文件表，所以可知，这两个文件描述符的 属性是一样，譬如对文件的读写权限、文件状态标志、文件偏移量等，所以从这里也可知道“复制”的含义实则是复制文件表。同样，在使用完毕之后也需要使用 close 来关闭文件描述符。</p>
<p>  例子：若fd 等于 3 ，复制得到的新的文件描述符为可能为 5</p>
</blockquote>
<p><code>int dup2(int oldfd, int newfd);</code></p>
<blockquote>
<p>  oldfd ： 需要被复制的文件描述符。<br>  newfd ： 指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>  返回值： 成功时将返回一个新的文件描述符，即手动指定的文件描述符 newfd ；如复制失败将返回-1 ，并且会设置 errno 值。</p>
</blockquote>
<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><p><code>int fcntl(int fd, int cmd);</code></p>
<p><code>int fcntl(int fd, int cmd, long arg);</code></p>
<p><code>int fcntl(int fd, int cmd ,struct flock* lock);</code></p>
<blockquote>
<p>  fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</p>
<p>  cmd参数对应功能如下:</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Center.png" alt="img"></p>
<p>  记录锁：实现只锁文件的某个部分，并且可以灵活的选择是阻塞方式还是立刻返回方式</p>
<p>  当fcntl用于管理文件记录锁的操作时，第三个参数指向一个struct flock *lock的结构体</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">flock</span></span><br><span class="line">&#123;</span><br><span class="line">    short_l_type;    <span class="comment">/*锁的类型*/</span></span><br><span class="line">    short_l_whence;  <span class="comment">/*偏移量的起始位置：SEEK_SET,SEEK_CUR,SEEK_END*/</span></span><br><span class="line">    off_t_l_start;   <span class="comment">/*加锁的起始偏移*/</span></span><br><span class="line">    off_t_l_len;    <span class="comment">/*上锁字节*/</span></span><br><span class="line">    pid_t_l_pid;   <span class="comment">/*锁的属主进程ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Linux-多进程开发"><a href="#Linux-多进程开发" class="headerlink" title="Linux 多进程开发"></a>Linux 多进程开发</h3><h4 id="程序和进程概述"><a href="#程序和进程概述" class="headerlink" title="程序和进程概述"></a>程序和进程概述</h4><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB (Processing Control Block) 进程控制块，维护进程相关的信息。</p>
<p>Linux内核的进程控制块是<code>task_struct</code> 结构体。在<code>/usr/src/linux-headers-xxx/ include/linux/ sched.h</code>文件中可以查看其定义。</p>
<p>其内部成员有很多，我们只需要掌握以下部分即可:</p>
<blockquote>
<p>  进程id:系统中每个进程有唯一的id, 用pid_ t类型表示, 其实就是一个非负整数</p>
<p>  进程的状态:有就绪、运行、挂起、停止等状态</p>
<p>  进程切换时需要保存和恢复的一些CPU寄存器</p>
<p>  描述虚拟地址空间的信息</p>
<p>  描述控制终端的信息</p>
<p>  当前工作目录(Current Working Directory)</p>
<p>  umask掩杩</p>
<p>  文件描述符表，包含很多指向file 结构体的指针	<strong>(一个进程一个虚拟地址空间,该虚拟空间内核区有个PCB,PCB里有文件描述符表)</strong></p>
<p>  和信号相关的信息</p>
<p>  用户id和组id</p>
<p>  会话 (Session)和进程组</p>
<p>  进程可以使用的资源上限(Resource Limit)</p>
</blockquote>
<h5 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221031215037224.png" alt="image-20221031215037224" style="zoom: 67%;">



<h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h5><p><code>tty</code>	显示当前终端</p>
<h5 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h5><p><code>ulimit -a</code>	查看系统中所有资源使用情况</p>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p><code>ps aux / ajx</code>	查看进程</p>
<blockquote>
<p>  a:显示终端上的所有进程，包括其他用户的进程<br>  u:显示进程的详细信息<br>  x:显示没有控制终端的进程<br>  j:列出与作业控制相关的信息</p>
</blockquote>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p><code>top</code>	实时显示进程动态</p>
<p>可以在使用top命令时加上-d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示的结果进行排序:</p>
<blockquote>
<p>  M	根据内存使用量排序<br>  P	根据CPU占有率排序<br>  T	根据进程运行时间长短排序<br>  U	根据用户名来筛选进程.<br>  K	输入指定的PID杀死进程</p>
</blockquote>
<h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p><code>kill [-选项] pid</code>	杀死进程</p>
<blockquote>
<p>  kill -l	列出所有可选选项</p>
<p>  -9	强制杀死进程</p>
</blockquote>
<h5 id="获取pid函数"><a href="#获取pid函数" class="headerlink" title="获取pid函数"></a>获取pid函数</h5><p><code>pid_t getpid (void) ;</code>	获取当前进程号</p>
<p><code>pid_t getppid (void) ;</code>	获取父进程号</p>
<p><code>pid_t getpgid(pid_t pid) ;</code>	获取组进程号</p>
<blockquote>
<p>  进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID) 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</blockquote>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p><code>pid_t fork (void) ;</code>	系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<blockquote>
<p>  成功:子进程中返回 0，父进程中返回子进程 ID	失败:返回 -1</p>
<p>  失败的两个主要原因:</p>
<p>  1.当前系统的进程数已经达到了系统规定的上限，这时 <code>errno</code> 的值被设置为 <code>EAGAIN</code></p>
<p>  2.系统内存不足，这时 <code>errno</code> 的值被设置为 <code>ENOMEM</code></p>
</blockquote>
<h4 id="父子进程虚拟地址空间"><a href="#父子进程虚拟地址空间" class="headerlink" title="父子进程虚拟地址空间"></a>父子进程虚拟地址空间</h4><ol>
<li>内核区的pid(自己的)不同</li>
<li>使用<code>pid_t a = fork()</code>后,栈内的返回值不同,父进程栈里a为子进程号, 子进程栈里a为0</li>
<li>修改栈空间的变量互不干扰</li>
<li>父子进程有相同的文件描述符,指向相同的文件表,引用计数增加,共享文件偏移指针</li>
</ol>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101013945568.png" alt="image-20221101013945568" style="zoom: 67%;">



<h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><p>使用GDB调试的时候，GDB 默认只能跟踪一个进程， 可以在fork 函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<p><code>set follow- fork-mode [parent (默认) | child]</code>	</p>
<blockquote>
<p>  设置调试父进程或者子进程[被调试的进程停在断点处, 另一个进程顺利执行]</p>
</blockquote>
<p><code>set detach-on-fork [on| off]</code>	</p>
<blockquote>
<p>  设置调试模式默认为on，表示调试当前进程的时候，其它的进程继续运行，如果为off, 调试当前进程的时候，其它进程被GDB挂起。</p>
</blockquote>
<p><code>info inferiors</code>	查看调试的进程</p>
<p><code> inferior id</code>	切换当前调试的进程</p>
<p><code>detach inferiors id </code>	使进程脱离GDB调试</p>
<h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样,颇有些神似“三十六计”中的“金蝉脱壳”。只有调用失败了，它们才会返回-1， 从原程序的调用点接着往下执行。</p>
<p>exec函数族共有6种不同形式的函数。这6个函数可以划分为两组：</p>
<p>(1)execl、execle和execlp。</p>
<blockquote>
<p>  这里的l是list(列表)的意思，表示execl系列函数需要将每个命令行参数作为函数的参数进行传递；</p>
</blockquote>
<p>(2)execv、execve和execvp。</p>
<blockquote>
<p>  而v是vector(矢量)的意思，表示execv系列函数将所有函数包装到一个矢量数组中传递即可</p>
</blockquote>
<p><code>int execl(const char * path，const char * arg，…)；</code></p>
<p><code>int execle(const char * path，const char * arg，char * const envp[])；</code></p>
<p><code>int execlp(const char * file，const char * arg，…)；</code></p>
<p><code>int execv(const char * path，char * const argv[])；</code></p>
<p><code>int execve(const char * path，char * const argv[]，char * const envp[])；</code></p>
<p><code>int execvp(const char * file，char * const argv[])；</code></p>
<blockquote>
<p>path	要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execve、execl和execle这4个函数中，使用带路径名的文件名作为参数。</p>
<p>file	要执行的程序名称。如果该参数中包含“&#x2F;”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。</p>
<p>argv	命令行参数的矢量数组。</p>
<p>envp	带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用进程的环境变量。</p>
<p>arg	程序的第0个参数，即程序名自身。相当于argv[0]。</p>
<p>…	命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。</p>
</blockquote>
<h4 id="结束进程、孤儿进程、僵尸进程"><a href="#结束进程、孤儿进程、僵尸进程" class="headerlink" title="结束进程、孤儿进程、僵尸进程"></a>结束进程、孤儿进程、僵尸进程</h4><h5 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h5><p>exit是标准C库函数</p>
<p>_exit是标准Linux库函数</p>
<blockquote>
<p>  status是进程退出是的一个状态信息,父进程回收子进程资源时可以获取到</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143024126.png" alt="image-20221101143024126" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143922053.png" alt="image-20221101143922053" style="zoom: 67%;">



<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><ul>
<li><p>父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为孤儿进程(Orphan Process) 。</p>
</li>
<li><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init ,而init进程会循环地wait() 它的已经退出的子进程。当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
</li>
</ul>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><ul>
<li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。</p>
</li>
<li><p>进程终止时，父进程尚未回收它，子进程残留资源(PCB) 存放于内核中，变成僵尸(Zombie)进程。</p>
</li>
<li><p>僵尸进程不能被kill -9杀死。</p>
</li>
<li><p>这样就会导致一个问题，如果父进程不调用wait() 或waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
</li>
</ul>
<blockquote>
<p>  kill -9 僵尸进程号 杀不了僵尸进程, 只有把他父进程杀了&#x2F;在父进程中按<code>ctrl + c</code>&#x2F;调用<code>wait()</code>或<code>waitpid()</code>函数后, 他才会被杀死</p>
</blockquote>
<h4 id="wait、waitpid函数"><a href="#wait、waitpid函数" class="headerlink" title="wait、waitpid函数"></a>wait、waitpid函数</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主</p>
<p>要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。wait()和waitpid() 函数的功能一样</p>
<p>区别在于，wait()函数会阻塞  waitpid()可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</p>
<blockquote>
<p>  注意: 一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
</blockquote>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p><code> pid_t wait(int *stat_loc);</code></p>
<blockquote>
<p>  返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno 中</p>
</blockquote>
<blockquote>
<p>  stat_loc 可以是a, b, c 然后调用<code>WIFEXITED(a)</code> <code>WEXITSTATUS(b)</code> <code>WIFSIGNALED(stat_val)</code> <code>WTERMSIG(stat_val)</code> <code>WIFSTOPPED(stat_val)</code> <code>WSTOPSIG(stat_val)</code> <code>WIFCONTINUED(stat_val)</code>能获取各种返回状态</p>
</blockquote>
<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><p><code>pid_t waitpid(pid_t pid, int *stat_loc, int options);</code></p>
<blockquote>
<p>  pid &#x3D;&#x3D; -1	 等待任一子进程。与wait等效</p>
<p>  pid &gt; 0	等待其进程ID 与 pid 相等的子进程</p>
<p>  pid &#x3D;&#x3D; 0	 等待进程组ID 与 目前进程相同的任何子进程。（少用&#x2F;基本不用）</p>
<p>  pid &lt; -1	等待其组ID 等于 pid的绝对值的任一子进程。（少用&#x2F;基本不用)   </p>
</blockquote>
<blockquote>
<p>  options  &#x3D;&#x3D; 0，表示waitpid函数为阻塞的。（该函数会阻塞卡在这儿，若有子进程，就回收；若没有子进程，一直卡着）</p>
<p>  options &#x3D;&#x3D; WNOHANG，表示waitpid函数为非阻塞的（也即不管有没有子进程了，该函数都不会阻塞卡在这儿）</p>
</blockquote>
<h4 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h4><p>进程是一个独立的资源分配单元，不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC: Inter Processes Communication )。</p>
<p>进程通信的目的:</p>
<blockquote>
<p>  数据传输    一个进程需要将它的数据发送给另一个进程。</p>
<p>  通知事件    一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)</p>
<p>  资源共享    多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</p>
<p>  进程控制    有些进程希望完全控制另一个进程的执行(如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</blockquote>
<h5 id="Linux进程通信方式"><a href="#Linux进程通信方式" class="headerlink" title="* Linux进程通信方式"></a>* Linux进程通信方式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102133524824.png" alt="image-20221102133524824"></p>
<h4 id="匿名管道-管道"><a href="#匿名管道-管道" class="headerlink" title="匿名管道[管道]"></a>匿名管道[管道]</h4><blockquote>
<p>   用在父子或兄弟进程中</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102140508146.png" alt="image-20221102140508146"></p>
<h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><ul>
<li><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</p>
</li>
<li><p>管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体，有名管道有文件实体,但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102143252014.png" alt="image-20221102143252014" style="zoom:50%;">



<h5 id="匿名管道进程间通信原理"><a href="#匿名管道进程间通信原理" class="headerlink" title="匿名管道进程间通信原理"></a>匿名管道进程间通信原理</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144326483.png" alt="image-20221102144326483" style="zoom:50%;">



<h5 id="匿名管道的数据结构"><a href="#匿名管道的数据结构" class="headerlink" title="匿名管道的数据结构"></a>匿名管道的数据结构</h5><ul>
<li>逻辑环形队列</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144456528.png" alt="image-20221102144456528" style="zoom:50%;">



<h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><p> 使用	<code>xxx | xxx</code></p>
<h6 id="创建一个匿名管道"><a href="#创建一个匿名管道" class="headerlink" title="创建一个匿名管道"></a>创建一个匿名管道</h6><p><code>int pipe(int pipefd[2]);</code></p>
<blockquote>
<p>  pipefd 数组是一个传出参数	pipefd[0] 对应管道的读端 pipefd[1] 对应管道的写端</p>
<p>  返回值: 成功返回0, 失败返回-1</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在fork之前创建管道</span></span><br><span class="line">	<span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot; pipe&quot;</span> );</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//父进程, 读</span></span><br><span class="line">            <span class="comment">// 从管道的读取端读取数据, 返回读取到的字节数 若管道内没有数据自动阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>); <span class="comment">// 将buf置为全0</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//父进程, 写</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am a parent&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	    <span class="comment">//子进程, 写</span></span><br><span class="line">			<span class="type">char</span>* str = <span class="string">&quot;hello,i am a child&quot;</span>;</span><br><span class="line">			<span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 若没有sleep 则下面读模块会读取自己刚写的</span></span><br><span class="line">      </span><br><span class="line">            <span class="comment">// 子进程, 读	一定要在子进程写后 不然父子进程都阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="查看管道缓冲大小"><a href="#查看管道缓冲大小" class="headerlink" title="查看管道缓冲大小"></a>查看管道缓冲大小</h6><p><code>ulimit -a</code>	命令</p>
<p><code>long fpathconf (int fd, int name);</code>	函数</p>
<blockquote>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102174749178.png" alt="image-20221102174749178">
</blockquote>
<h6 id="设置管道非阻塞"><a href="#设置管道非阻塞" class="headerlink" title="设置管道非阻塞"></a>设置管道非阻塞</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_GETFL);		<span class="comment">//获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;		<span class="comment">//修改f1lag的值</span></span><br><span class="line"><span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_SETFL, flags);		<span class="comment">//设置新的flag</span></span><br></pre></td></tr></table></figure>



<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><blockquote>
<p>  用在没有关系的进程中</p>
</blockquote>
<ul>
<li><p>匿名管道，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO) ，也叫命名管道、FIF0文件。</p>
</li>
<li><p>有名管道(FIFO) 不同于匿名管道在于它提供了一个路径名与之关联，以FIFO 的文件形式存在于文件系统中，并且其打开方式与打开</p>
</li>
<li><p>一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。</p>
</li>
<li><p>一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;0系统调用了(如read()、 write ()和close())。与管道一样，FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。</p>
</li>
<li><p>有名管道(FIFO)和匿名管道(pipe) 有一些特点是相同的，不一样的地方在于:</p>
<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但FIFO 中的内容却存放在内存中。</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO有名字，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
</li>
</ul>
<h5 id="创建有名管道"><a href="#创建有名管道" class="headerlink" title="创建有名管道"></a>创建有名管道</h5><p><code>mkfifo 名字</code>		通过函数创建有名管道</p>
<p><code>int mkfifo (const char *pathname， mode_t mode) ;</code>		通过函数创建有名管道</p>
<blockquote>
<p>  mode 和 open 函数的mode是一样的</p>
</blockquote>
<blockquote>
<p>   一旦使用mkfifo 创建了一个FIFO， 就可以使用open打开，常见的文件I&#x2F;0函数都可用于fifo,如 close、read、 write、unlink</p>
<p>  FIFO严格遵循先进先出(First in First out)，对管道及FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
</blockquote>
<h5 id="使用有名管道"><a href="#使用有名管道" class="headerlink" title="使用有名管道"></a>使用有名管道</h5><ul>
<li>创建两个文件(两个进程)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向管道中写数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.一个为只读打开管道进程会阻塞，直到写端打开</span></span><br><span class="line"><span class="comment">2.一个为只写打开管道进程会阻塞，直到读端打开</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、先判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建管道文件</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        	<span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、打开管道，以只写的方式</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123; </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n &quot;</span>, i); 	<span class="comment">// sprintf函数调用的主要用途就是把一个字符串放在一个已知的字符数组里去</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从管道中读数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 ： 需要两个进程（这里是两个文件）同时执行</span></span><br></pre></td></tr></table></figure>



<h5 id="有名管道实现聊天功能"><a href="#有名管道实现聊天功能" class="headerlink" title="有名管道实现聊天功能"></a>有名管道实现聊天功能</h5><ul>
<li>这样的文件 (进程) 有两份 A文件中为以下代码，B文件与A中只读和只写的有名管道相反</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">//创建管道</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断管道2是否存在</span></span><br><span class="line">    ret=<span class="built_in">access</span>(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret ==- <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只写的方式打开fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道1fifo1成功, 等待写入数据\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以只读的方式打开fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功, 等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//4、循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">//读取标准输入的数据(test用户输入的东西)</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf,<span class="number">128</span>,stdin);</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        ret = <span class="built_in">write</span>(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、读管道数据</span></span><br><span class="line">        <span class="built_in">mset</span>(buf,<span class="number">0</span>,<span class="number">128</span>);<span class="comment">//清空数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf:%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6、关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端1</span></span><br><span class="line">gcc chatA.c -o a</span><br><span class="line">gcc chatB.c -o b</span><br><span class="line">./a</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 终端2</span></span><br><span class="line">./b</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br></pre></td></tr></table></figure>



<h4 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h4><blockquote>
<p>  关闭读描述符 <code>close(piped[0]);</code>		 写类似</p>
</blockquote>
<ul>
<li><strong>没有进程写，只有进程读</strong>	如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道的读端读数据，那么文件内的所有内容被读完后再次read就会返回0，就像读到文件结尾。</li>
<li><strong>写描述符没关，但也没写</strong>    如果有指向管道写端的文件描述符没有关闭（管道写段的引用计数大于0），而持有管道写端的进程没有向管道内写入数据，假如这时有进程从管道读端读数据，那么读完管道内剩余的数据后就会阻塞等待，直到有数据可读才读取数据并返回。</li>
<li><strong>没有进程读，只有进程写</strong>    如果所有指向管道读端的文件描述符都关闭，此时有进程通过写端文件描述符向管道内写数据时，则该进程就会收到SIGPIPE信号，并异常终止。</li>
<li><strong>读描述符没关，但也没读</strong>    如果有指向管道读端的文件描述符没有关闭（管道读端的引用计数大于0），而持有管道读端的进程没有从管道内读数据，假如此时有进程通过管道写段写数据，那么管道被写满后就会被阻塞，直到管道内有空位置后才写入数据并返回。</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102194024601.png" alt="image-20221102194024601" style="zoom: 67%;">



<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><ul>
<li><p>内存映射区通信，是非阻塞。</p>
</li>
<li><p>进程间有无关系都可以</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103120849314.png" alt="image-20221103120849314" style="zoom:50%;">

<h5 id="内存映射的相关系统调用"><a href="#内存映射的相关系统调用" class="headerlink" title="内存映射的相关系统调用"></a>内存映射的相关系统调用</h5><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size;</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<h5 id="使用内存映射实现进程间通信"><a href="#使用内存映射实现进程间通信" class="headerlink" title="使用内存映射实现进程间通信"></a>使用内存映射实现进程间通信</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>有关系的进程（父子进程）</span><br><span class="line">	- 还没有子进程的时候</span><br><span class="line">		- 通过唯一的父进程，先创建内存映射区</span><br><span class="line">	- 有了内存映射区以后，创建子进程</span><br><span class="line">	- 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>没有关系的进程间通信</span><br><span class="line">	- 准备一个大小不是<span class="number">0</span>的磁盘文件</span><br><span class="line">	- 进程<span class="number">1</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 进程<span class="number">2</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 使用内存映射区通信</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 test.txt 在里面写一点数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父子进程间通讯(两个独立的进程通信：将下面的代码拆成两个文件 需要各打开同一个文件，都得创建内存映射区)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);	<span class="comment">// 子进程往文件中写数据，写完了后父进程就将它回收，再读</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr); <span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;nihao a, son!!!&quot;</span>);	<span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="内存映射TIPS"><a href="#内存映射TIPS" class="headerlink" title="内存映射TIPS"></a>内存映射TIPS</h5><p>如果对mmap的返回值(ptr)做++操作(ptr++)，munmap是否能够成功?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * ptr = <span class="built_in">mmap</span>(...);</span><br><span class="line">ptr++;  <span class="comment">//可以对其进行++操作，但是不建议这样做，会导致无法正确释放映射</span></span><br><span class="line"><span class="built_in">munmap</span>(ptr, len);   <span class="comment">// 错误，要保存地址</span></span><br></pre></td></tr></table></figure>

<p>如果open时O_RDONLY, mmap 时 prot 参数指定PROT_READ | PROT_WRITE会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">错误，返回 <span class="function">MAP_FAILED</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">()</span>函数中的权限建议和 prot 参数的权限保持一致。</span></span><br></pre></td></tr></table></figure>

<p>如果文件偏移量为1000会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">偏移量必须是 <span class="number">4</span>K 的整数倍，返回 MAP_FAILED。</span><br></pre></td></tr></table></figure>

<p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- 可以的，但是创建的文件的大小如果为<span class="number">0</span>的话，肯定不行</span><br><span class="line">- 可以对新的文件进行扩展</span><br><span class="line">	- <span class="built_in">lseek</span>()</span><br><span class="line">  - <span class="built_in">truncate</span>()</span><br></pre></td></tr></table></figure>

<p>mmap后关闭文件描述符，对mmap映射有没有影响？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="built_in">mmap</span>(,,,,fd,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">close</span>(fd); <span class="comment">// 映射区还存在，创建映射区的fd被关闭，没有任何影响。</span></span><br></pre></td></tr></table></figure>



<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h5 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h5><ul>
<li><p>信号是Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下:</p>
<ol>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用kill 函数。</li>
</ol>
</li>
<li><p>使用信号的两个主要目的是:</p>
<ol>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ol>
</li>
<li><p>信号的特点:</p>
<ol>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ol>
</li>
<li><p>查看系统定义的信号列表    <code>kill -l</code>     (前31个信号为常规信号，其余为实时信号)</p>
</li>
</ul>
<h5 id="部分信号一览表"><a href="#部分信号一览表" class="headerlink" title="部分信号一览表"></a>部分信号一览表</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103164530935.png" alt="image-20221103164530935" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165336300.png" alt="image-20221103165336300" style="zoom: 50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165127529.png" alt="image-20221103165127529" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165504053.png" alt="image-20221103165504053" style="zoom:50%;">



<h6 id="举例：SIGCHILD"><a href="#举例：SIGCHILD" class="headerlink" title="举例：SIGCHILD"></a>举例：SIGCHILD</h6><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221104170616515.png" alt="image-20221104170616515"></p>
<h5 id="信号的五种默认处理动作"><a href="#信号的五种默认处理动作" class="headerlink" title="信号的五种默认处理动作"></a>信号的五种默认处理动作</h5><p>查看信号的详细信息	<code>man 7 signal</code></p>
<p>信号的5种默认处理动作：</p>
<ol>
<li>Term	终止进程</li>
<li>Ign    当前进程忽略掉这个信号</li>
<li>Core    终止进程，并生成一个Core文件</li>
<li>Stop    暂停当前进程</li>
<li>Cont    继续执行当前被暂停的进程</li>
</ol>
<p>信号的几种状态：	产生、未决（没到达进程）、递达（到达进程）</p>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p>
<h5 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h5><h6 id="kill-1"><a href="#kill-1" class="headerlink" title="kill"></a>kill</h6><p><code>int kill (pid_t pid, int sig) ;</code>		给任何进程或者进程组pid发送任何信号sig</p>
<blockquote>
<p>  pid:</p>
<p>  若 &gt; 0	将信号发送给指定的进程；</p>
<p>  &#x3D; 0	将信号发送给当前的进程组；</p>
<p>  &#x3D; -1	将信号发送给每一个有权限接收这个信号的进程</p>
<p>  &lt;-1：这个pid&#x3D;某个进程组的ID取反（-12345）</p>
<p>  sig	需要发送的信号的编号或者是宏值，0表示不发送任何信号</p>
</blockquote>
<h6 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h6><p><code>int raise (int sig) ;</code>		给当前进程发送信号</p>
<blockquote>
<p>  sig	要发送的信号</p>
<p>  返回值 	成功：0	失败：非0</p>
<p>  相当于  <code>kill(getpid(), sig);</code></p>
</blockquote>
<h6 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h6><p><code>void abort(void) ;</code>		发送SIGABRT信号给当前的进程，杀死当前进程</p>
<blockquote>
<p>  相当于 <code>kill(getpid(),SIGABRT);</code></p>
</blockquote>
<h6 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h6><p><code>unsigned int alarm (unsigned int seconds) ;</code>		</p>
<blockquote>
<p>  设置定时器(闹钟)。函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号 SIGALARM</p>
</blockquote>
<blockquote>
<p>  seconds	倒计时的时长，单位:秒。如果参数为0，定时器无效(不进行倒计时，不发送信号)</p>
<p>  取消一个定时器，通过alarm(0)</p>
<p>  返回值	之前没有定时器返回0, 之前有定时器，返回之前定时剩余的倒计时剩余的时间</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> seconds=<span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    seconds=<span class="built_in">alarm</span>(<span class="number">2</span>);<span class="comment">//不阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h6><p><code>int setitimer (int which, const struct itimerval *new_val, struct itimerval *old_value) ;</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能:设置定时器(闹钟)，可以替代alarm函数。精度us，可以实现周期性的定时</span></span><br><span class="line"><span class="comment">          参数:</span></span><br><span class="line"><span class="comment">              which:定时器以什么时间计时</span></span><br><span class="line"><span class="comment">                  ITIMER_REAL:真实时间，时间到达，发送SIGALRM 	常用</span></span><br><span class="line"><span class="comment">                  ITIMER_VIRTUAL:用户时间，时间到达，发送SIGVTALRM</span></span><br><span class="line"><span class="comment">                  ITIMER_PROF:以该进程在用户态和内核态下所消耗的时间来计时，时间到达，发送SIGPROF</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">              new_value:设置定时器的属性</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              struct itimerval &#123;//定时器的结构体</span></span><br><span class="line"><span class="comment">                 struct timeval it_interval; //每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="comment">                 struct timeval it_value;    //延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              struct timeval &#123;//时间的结构体</span></span><br><span class="line"><span class="comment">                 time_t      tv_sec;  //秒数</span></span><br><span class="line"><span class="comment">                 suseconds_t tv_usec; //微秒</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              过10s后每隔2s定时一次</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              old_value:记录上一次的定时的时间参数可以在这里获取到，用不到的话传递一个NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          	返回值:</span></span><br><span class="line"><span class="comment">              成功 0</span></span><br><span class="line"><span class="comment">              失败 -1 指定错误号</span></span><br><span class="line"><span class="comment">*/</span>            </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//过3s后每隔2s定时一次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置值</span></span><br><span class="line">    new_value.it_interval.tv_sec=<span class="number">2</span>;<span class="comment">//设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置延迟的时间,3s后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec=<span class="number">3</span>;<span class="comment">//s</span></span><br><span class="line">    new_value.it_value.tv_usec=<span class="number">0</span>;<span class="comment">//us</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">setitimer</span>(ITIMER_REAL,&amp;new_value,<span class="literal">NULL</span>); <span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>); <span class="comment">// 这里过了3s接收到sigALARM信号直接就终止了，如果想不终止，需要捕捉到信号后自定义处理</span></span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><p><code>sighandler_t signal (int signum, sighandle_ t handler) ;</code></p>
<blockquote>
<p>  signum	要捕捉的信号，也可以是宏</p>
<p>  handler		捕捉到信号要如何处理</p>
<ul>
<li>SIG_IGN	忽略信号</li>
<li>SIG DFL	使用信号默认的行为</li>
<li>回调函数	自定义函数（返回值一定要是 void 参数一定要是 int类型（或者信号宏名））</li>
</ul>
<p>  返回值</p>
<ul>
<li>成功，返回上一次注册的信号处理函数的地址。第次调用返回NULL</li>
<li>失败，返回SIG_ ERR， 设置错误号</li>
</ul>
<p>  <strong>SIGKILL SIGSTOP不能被捕捉或忽略</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalhandler</span><span class="params">(<span class="type">int</span> signo)</span></span>&#123;    <span class="comment">//signal函数会传递信号序号给这个函数</span></span><br><span class="line">    <span class="comment">//信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">14</span>, signalhandler);    <span class="comment">//收到14号信号「SIGALARM」时，就会执行对应的信号处理函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h6><p><code>int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);</code></p>
<blockquote>
<p>  sig 指出要捕获的信号类型，act 指定新的信号处理方式，oact 输出先前信号的处理方式（如果不为NULL的话）。</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">sigaction</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__sigaction_u</span> __sigaction_u;  <span class="comment">/* signal handler */</span></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask;               <span class="comment">/* signal mask to apply */</span></span><br><span class="line">  <span class="type">int</span> sa_flags;               <span class="comment">/* see signal options below */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">__sigaction_u</span> &#123;</span><br><span class="line">  <span class="built_in">void</span> (*__sa_handler)(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">void</span> (*__sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler      __sigaction_u.__sa_handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction    __sigaction_u.__sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>  sa_handler	此参数和signal()的参数handler相同，代表新的信号处理函数</p>
<p>  sa_mask	用来设置在处理该信号时暂时将sa_mask 指定的信号集搁置</p>
<p>  sa_flags	用来设置信号处理的其他相关操作，下列的数值可用</p>
<ul>
<li><p>SA_RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</p>
</li>
<li><p>SA_RESTART：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</p>
</li>
<li><p>SA_NODEFER ：一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了 SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p>其他查阅 <code>man sigaction</code></p>
</li>
</ul>
</blockquote>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因</p>
<p>此这种IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进</p>
<p>程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管</p>
<p>道是一种存在于内核的文件)，这种IPC技术的速度更快。</p>
<h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol>
<li><p>调用<code>shmget()</code>创建一个新共享内存段或取一个既有共享内存段的标识符( 即由其他进程创建的共享内存段 )。这个调用将返回后续调用中需要用到的共享内存标识符。</p>
</li>
<li><p>使用<code>shmat() </code>使该段成为调用进程的虚拟内存的一部分。</p>
</li>
<li><p>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由<code>shmat() </code>返回的addr 值，它是一个指向进程的虛拟地址空间中该共享内存段的起点的指针。</p>
</li>
<li><p>调用<code>shmdt() </code>来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</p>
</li>
<li><p>调用<code>shmctl()</code>来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</p>
</li>
</ol>
<h5 id="共享内存使用函数"><a href="#共享内存使用函数" class="headerlink" title="共享内存使用函数"></a>共享内存使用函数</h5><h6 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h6><p><code>int shmget (key_t key, size_t size, int shmflg) ;</code></p>
<blockquote>
<p>  成功完成后，将共享内存段标识符为返回。否则，返回-1并设置全局变量errno表示错误</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">key</span><br><span class="line"><span class="number">0</span>(IPC_PRIVATE)：会建立新共享内存对象</span><br><span class="line"></span><br><span class="line">大于<span class="number">0</span>的<span class="number">32</span>位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">大于<span class="number">0</span>的整数：新建的共享内存大小，以字节为单位</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：只获取共享内存时指定为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">shmflg</span><br><span class="line"><span class="number">0</span>：取共享内存标识符，若不存在则函数会报错</span><br><span class="line"></span><br><span class="line">IPC_CREAT：当shmflg&amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符</span><br><span class="line"></span><br><span class="line">IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h6><p><code>void* shmat (int shmid, const void * shmaddr, int shmflg) ;</code></p>
<blockquote>
<p>  成功：附加好的共享内存地址  出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid	共享内存标识符</p>
<p>  shmaddr	指定共享内存出现在进程内存地址的什么位置，直接指定为NULL让内核自己决定一个合适的地址位置</p>
<p>  shmflg	SHM_RDONLY：为只读模式， 0：为读写模式</p>
</blockquote>
<h6 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h6><p><code>int shmdt (const void *shmaddr) ;</code></p>
<blockquote>
<p>  成功返回0	出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmaddr	连接的共享内存的起始地址</p>
</blockquote>
<h6 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h6><p><code>int shmctl (int shmid, int cmd, struct shmid_ds *buf) ;</code></p>
<blockquote>
<p>  成功：0	出错：-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid：共享内存标识符</p>
<p>  cmd</p>
<blockquote>
<p>  IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</p>
<p>  IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内</p>
<p>  IPC_RMID：删除这片共享内存</p>
</blockquote>
<p>  buf	需要设置或者获取的共享内存的属性信息, 一般写NULL</p>
<blockquote>
<p>  IPC_ STAT 	buf存储数据<br>  IPC_ SET 	buf中需要初始化数据，设置到内核中<br>  IPC_ RMID 	没有用，NULL</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /home/kjg/Linux/sharememory/write_shm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一块共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联, 返回已开辟的内存的首地址</span></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按任意键继续</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.释放共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /home/kjg/Linux/sharememory/read_shm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取一块共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联, 返回已开辟的内存的首地址</span></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按任意键继续</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.释放共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h6><p><code>key_t ftok (const char *pathname, int proj_id);</code></p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105134241461.png" alt="image-20221105134241461">



<h5 id="操作系统如何知道一块共享内存被多少个进程关联"><a href="#操作系统如何知道一块共享内存被多少个进程关联" class="headerlink" title="操作系统如何知道一块共享内存被多少个进程关联"></a>操作系统如何知道一块共享内存被多少个进程关联</h5><ul>
<li>共享内存维护了一个结构体<code>struct shmid_ds</code> 这个结构体中有一个成员<code>shm nattach </code>记录了关联的进程个数</li>
<li>ipcs用法</li>
</ul>
<blockquote>
<p>  ipcs -a	&#x2F;&#x2F;打印当前系统中所有的进程间通信方式的信息</p>
<p>  ipcs -m	&#x2F;&#x2F;打印出使用共享内存进行进程间通信的信息</p>
<p>  ipcs -q	&#x2F;&#x2F;打印出使用消息队列进行进程间通信的信息</p>
<p>  ipcs -s	&#x2F;&#x2F;打印出使用信号进行进程间通信的信息</p>
</blockquote>
<ul>
<li>ipcrm用法</li>
</ul>
<blockquote>
<p>  ipcrm -M shmkey	&#x2F;&#x2F;移除用shmkey创建的共享内存段</p>
<p>  ipcrm -m shmid	&#x2F;&#x2F; 移除用 shmid标识的共享内存段</p>
<p>  ipcrm -Q msgkey	&#x2F;&#x2F;移除用msqkey创建的消息队列</p>
<p>  ipcrm -q msqid	&#x2F;&#x2F;移除用msqid标识的消息队列</p>
<p>  ipcrm -S semkey	&#x2F;&#x2F;移除用semkey创建的信号</p>
<p>  ipcrm -s semid	&#x2F;&#x2F; 移除用semid标识的信号</p>
</blockquote>
<h4 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h4><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><ul>
<li><p>查看当前终端的pid	<code>echo $$</code></p>
</li>
<li><p>在UNIX系统中，用户通过终端登录系统后得到一个shell 进程，这个终端成为shell 进程的控制终端(Controlling Terminal) ，进程中，控制终端是保存在PCB 中的信息，而fork() 会复制PCB中的信息，因此由shell 进程启动的其它进程的控制终端也是这个终端。</p>
</li>
<li><p>默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
</li>
<li><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生SIGINT 信号，Ctrl + \会产生SIGQUIT 信号。</p>
</li>
</ul>
<h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><ul>
<li><p>进程组和会话在进程之间形成了一种两级层次关系:进程组是一组相关进程的集合,会话是一组相关进程组的集合。进程组合会话是为支持shell 作业控制而定义的抽象概念，用户通过shell 能够交互式地在前台或后台运行命令。</p>
</li>
<li><p>进程组由一个或多个共享同一进程组标识符(PGID) 的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID, 新进程会继承其父进程所属的进程组ID。</p>
</li>
<li><p>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p>
</li>
</ul>
<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><ul>
<li><p>会话是一-组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</p>
</li>
<li><p>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</p>
</li>
<li><p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p>
</li>
<li><p>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105165609594.png" alt="image-20221105165609594">



<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p><code>pid_t getpgrp (void);</code>	用来取得进程所属的组识别码。此函数相当于调用 <code>getpgid(0); </code></p>
<p><code>pid_t getpgid (pid_t pid) ;</code></p>
<p><code>int setpgid(pid_t pid, pid_t pgid) ;</code></p>
<p><code>pid_t getsid(pid_t pid) ;</code></p>
<p><code>pid_t setsid(void) ;</code></p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><ul>
<li>守护进程 (Daemon Process) ，也就是通常说的Daemon 进程(精灵进程)，<strong>是Linux中的后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</li>
<li>守护进程具备下列特诊:<ul>
<li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如SIGINT、 SIGQUIT)。</li>
</ul>
</li>
<li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器inetd, web服务器httpd 等。</li>
</ul>
<h5 id="守护进程的创建步骤"><a href="#守护进程的创建步骤" class="headerlink" title="守护进程的创建步骤"></a>守护进程的创建步骤</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105181155408.png" alt="image-20221105181155408"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现一个守护进程的实例（每隔 10s 在／tmp/dameon.log 写入一句话）*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf=<span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Linux多线程开发"><a href="#Linux多线程开发" class="headerlink" title="Linux多线程开发"></a>Linux多线程开发</h3><h4 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h4><ul>
<li>与进程(process) 类似，线程(thread)是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的UNIX进程只是多线程程序的一个特例，该进程只包含一个线程)</li>
<li>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程 (LWP: Light Weight Process) ，在Linux环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号: <code>ps -Lf pid</code></li>
</ul>
<h5 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h5><ul>
<li><p>进程间的信息难以共享。 由于除去只读代码段外，父子进程并未共享内存，因此必须采一些进程间通信方式，在进程间进行信息交换</p>
</li>
<li><p>调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍热需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着fork() 调用很慢</p>
</li>
<li><p>线程之间能够方便、快速地共享信息。只需将数据复制到共享(全局或堆)变量中即可</p>
</li>
<li><p>创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</p>
</li>
</ul>
<h5 id="线程和进程虚拟地址空间"><a href="#线程和进程虚拟地址空间" class="headerlink" title="线程和进程虚拟地址空间"></a>线程和进程虚拟地址空间</h5><p>子进程复制父进程的虚拟地址空间，而线程间共享进程的虚拟地址空间，只不过各线程在 <code>栈空间</code> <code>  .text段</code>占据了各一部分</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106215842522.png" alt="image-20221106215842522" style="zoom:50%;">



<h5 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106220232940.png" alt="image-20221106220232940" style="zoom:50%;">



<h4 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h4><p><code>pthread_t pthread_self (void);</code></p>
<p><code>int pthread_equal (pthread_t t1, pthread_t t2);</code></p>
<p><code>int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void * (*start routine) (void *) , void *arg);</code></p>
<p><code>void pthread_exit (void *retval);</code></p>
<p><code>int pthread_join (pthread_ t thread, void **retval);</code></p>
<p><code>int pthread_detach (pthread_t thread);</code></p>
<p><code>int pthread_cancel (pthread_t thread);</code></p>
<h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void * (*start routine) (void *) , void *arg);</code>	创建一个子线程</p>
<blockquote>
<p>  thread	传出参数，线程创建成功后，子线程的线程ID被写到该变量</p>
<p>  attr	设置线程的属性，一般使用默认值，NULL</p>
<p>  start_ routine 	函数指针，这个函数是子线程需要处理的逻辑代码</p>
<p>  arg	给第三个参数使用，传参</p>
</blockquote>
<blockquote>
<p>  返回值:	成功: 0	失败:返回错误号。这个错误号和之前errno不太一样。</p>
<p>  获取错误号的信息:	<code>char * strerror(int errnum);</code></p>
</blockquote>
<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><h4 id="回收子线程资源"><a href="#回收子线程资源" class="headerlink" title="回收子线程资源"></a>回收子线程资源</h4><h4 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h4><h4 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h4><h4 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h4><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/" rel="prev" title="DP之简单题合集">
      <i class="fa fa-chevron-left"></i> DP之简单题合集
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" rel="next" title="17.电话号码的字母组合">
      17.电话号码的字母组合 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">1.</span> <span class="nav-text">Linux快捷键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">Linux操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">文件和目录操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA"><span class="nav-number">2.2.</span> <span class="nav-text">文本内容显示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">文本内容处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.</span> <span class="nav-text">文件和命令查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%98%BE%E7%A4%BA"><span class="nav-number">2.5.</span> <span class="nav-text">系统信息显示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="nav-number">2.6.</span> <span class="nav-text">查看日期与时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%B5%81"><span class="nav-number">2.7.</span> <span class="nav-text">信息交流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.8.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%85%A5%E9%97%A8"><span class="nav-number">3.</span> <span class="nav-text">Linux入门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gcc%E7%BC%96%E8%AF%91"><span class="nav-number">3.2.</span> <span class="nav-text">Gcc编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGCC"><span class="nav-number">3.2.1.</span> <span class="nav-text">什么是GCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCC%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.2.</span> <span class="nav-text">GCC命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.3.</span> <span class="nav-text">GCC工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gcc%E4%B8%8Eg-%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.4.</span> <span class="nav-text">gcc与g++区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">3.3.</span> <span class="nav-text">静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%93"><span class="nav-number">3.3.1.</span> <span class="nav-text">什么是库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">3.3.2.</span> <span class="nav-text">静态库的命名规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">3.3.3.</span> <span class="nav-text">静态库的制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.4.</span> <span class="nav-text">静态库的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">3.3.5.</span> <span class="nav-text">动态库的命名规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">3.3.6.</span> <span class="nav-text">动态库的制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.7.</span> <span class="nav-text">动态库的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.3.8.</span> <span class="nav-text">动态库加载失败的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.9.</span> <span class="nav-text">动静态库优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Makefile"><span class="nav-number">3.4.</span> <span class="nav-text">Makefile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMakefile"><span class="nav-number">3.4.1.</span> <span class="nav-text">什么是Makefile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Makefile%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E5%92%8C%E8%A7%84%E5%88%99"><span class="nav-number">3.4.2.</span> <span class="nav-text">Makefile文件命名和规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">自定义变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">预定义变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">获取变量的值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">3.4.4.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wildcard"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">wildcard</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#patsubst"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">patsubst</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="nav-number">3.5.</span> <span class="nav-text">GDB调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGDB"><span class="nav-number">3.5.1.</span> <span class="nav-text">什么是GDB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-1"><span class="nav-number">3.5.2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8-x2F-%E9%80%80%E5%87%BA-x2F-%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">3.5.3.</span> <span class="nav-text">GDB命令-启动&#x2F;退出&#x2F;查看代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.4.</span> <span class="nav-text">GDB命令-断点操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB%E5%91%BD%E4%BB%A4-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">3.5.5.</span> <span class="nav-text">GDB命令-调试命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6IO"><span class="nav-number">3.6.</span> <span class="nav-text">Linux文件IO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86C%E5%BA%93%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.1.</span> <span class="nav-text">标准C库文件函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86C%E5%BA%93IO%E5%92%8CLinuxIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.6.2.</span> <span class="nav-text">标准C库IO和LinuxIO的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">3.7.</span> <span class="nav-text">虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">3.8.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LInux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="nav-number">3.9.</span> <span class="nav-text">LInux系统函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#errno-amp-perror"><span class="nav-number">3.9.1.</span> <span class="nav-text">errno &amp; perror</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#open-amp-close"><span class="nav-number">3.9.2.</span> <span class="nav-text">open &amp; close</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read"><span class="nav-number">3.9.3.</span> <span class="nav-text">read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#write"><span class="nav-number">3.9.4.</span> <span class="nav-text">write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lseek"><span class="nav-number">3.9.5.</span> <span class="nav-text">lseek</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stat-amp-lstat"><span class="nav-number">3.9.6.</span> <span class="nav-text">stat &amp; lstat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">3.10.</span> <span class="nav-text">Linux文件属性操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#access"><span class="nav-number">3.10.1.</span> <span class="nav-text">access</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chmod"><span class="nav-number">3.10.2.</span> <span class="nav-text">chmod</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chown"><span class="nav-number">3.10.3.</span> <span class="nav-text">chown</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#truncate"><span class="nav-number">3.10.4.</span> <span class="nav-text">truncate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">3.11.</span> <span class="nav-text">Linux目录操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mkdir"><span class="nav-number">3.11.1.</span> <span class="nav-text">mkdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rmdir"><span class="nav-number">3.11.2.</span> <span class="nav-text">rmdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rename"><span class="nav-number">3.11.3.</span> <span class="nav-text">rename</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getcwd"><span class="nav-number">3.11.4.</span> <span class="nav-text">getcwd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#opendir"><span class="nav-number">3.11.5.</span> <span class="nav-text">opendir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chdir"><span class="nav-number">3.11.6.</span> <span class="nav-text">chdir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#readir"><span class="nav-number">3.11.7.</span> <span class="nav-text">readir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#closedir"><span class="nav-number">3.11.8.</span> <span class="nav-text">closedir</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dup-amp-dup2"><span class="nav-number">3.12.</span> <span class="nav-text">dup &amp; dup2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fcntl"><span class="nav-number">3.13.</span> <span class="nav-text">fcntl</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">4.</span> <span class="nav-text">Linux 多进程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">程序和进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PCB"><span class="nav-number">4.1.1.</span> <span class="nav-text">PCB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">五状态模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.</span> <span class="nav-text">进程相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tty"><span class="nav-number">4.2.1.</span> <span class="nav-text">tty</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ulimit"><span class="nav-number">4.2.2.</span> <span class="nav-text">ulimit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps"><span class="nav-number">4.2.3.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#top"><span class="nav-number">4.2.4.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kill"><span class="nav-number">4.2.5.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96pid%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.6.</span> <span class="nav-text">获取pid函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">4.4.</span> <span class="nav-text">父子进程虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GDB%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-number">4.5.</span> <span class="nav-text">GDB多进程调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">4.6.</span> <span class="nav-text">exec函数族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.7.</span> <span class="nav-text">结束进程、孤儿进程、僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.7.1.</span> <span class="nav-text">结束进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.7.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.7.3.</span> <span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E3%80%81waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">4.8.</span> <span class="nav-text">wait、waitpid函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wait"><span class="nav-number">4.8.1.</span> <span class="nav-text">wait</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#waitpid"><span class="nav-number">4.8.2.</span> <span class="nav-text">waitpid</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B"><span class="nav-number">4.9.</span> <span class="nav-text">进程间通信简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">4.9.1.</span> <span class="nav-text">* Linux进程通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-%E7%AE%A1%E9%81%93"><span class="nav-number">4.10.</span> <span class="nav-text">匿名管道[管道]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.10.1.</span> <span class="nav-text">管道的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">4.10.2.</span> <span class="nav-text">匿名管道进程间通信原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.10.3.</span> <span class="nav-text">匿名管道的数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.10.4.</span> <span class="nav-text">匿名管道的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">4.10.4.1.</span> <span class="nav-text">创建一个匿名管道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.10.4.2.</span> <span class="nav-text">查看管道缓冲大小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">4.10.4.3.</span> <span class="nav-text">设置管道非阻塞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">4.11.</span> <span class="nav-text">有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">4.11.1.</span> <span class="nav-text">创建有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">4.11.2.</span> <span class="nav-text">使用有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD"><span class="nav-number">4.11.3.</span> <span class="nav-text">有名管道实现聊天功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">4.12.</span> <span class="nav-text">使用管道的四种特殊情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">4.13.</span> <span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.13.1.</span> <span class="nav-text">内存映射的相关系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">4.13.2.</span> <span class="nav-text">使用内存映射实现进程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84TIPS"><span class="nav-number">4.13.3.</span> <span class="nav-text">内存映射TIPS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">4.14.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.14.1.</span> <span class="nav-text">信号的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E4%BF%A1%E5%8F%B7%E4%B8%80%E8%A7%88%E8%A1%A8"><span class="nav-number">4.14.2.</span> <span class="nav-text">部分信号一览表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9ASIGCHILD"><span class="nav-number">4.14.2.1.</span> <span class="nav-text">举例：SIGCHILD</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%94%E7%A7%8D%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C"><span class="nav-number">4.14.3.</span> <span class="nav-text">信号的五种默认处理动作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">4.14.4.</span> <span class="nav-text">信号相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#kill-1"><span class="nav-number">4.14.4.1.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#raise"><span class="nav-number">4.14.4.2.</span> <span class="nav-text">raise</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#abort"><span class="nav-number">4.14.4.3.</span> <span class="nav-text">abort</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#alarm"><span class="nav-number">4.14.4.4.</span> <span class="nav-text">alarm</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#setitimer"><span class="nav-number">4.14.4.5.</span> <span class="nav-text">setitimer</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-number">4.14.5.</span> <span class="nav-text">信号捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#signal"><span class="nav-number">4.14.5.1.</span> <span class="nav-text">signal</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sigaction"><span class="nav-number">4.14.5.2.</span> <span class="nav-text">sigaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">4.15.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.15.1.</span> <span class="nav-text">共享内存使用步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.15.2.</span> <span class="nav-text">共享内存使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#shmget"><span class="nav-number">4.15.2.1.</span> <span class="nav-text">shmget</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmat"><span class="nav-number">4.15.2.2.</span> <span class="nav-text">shmat</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmdt"><span class="nav-number">4.15.2.3.</span> <span class="nav-text">shmdt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shmctl"><span class="nav-number">4.15.2.4.</span> <span class="nav-text">shmctl</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ftok"><span class="nav-number">4.15.2.5.</span> <span class="nav-text">ftok</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%B8%80%E5%9D%97%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%A2%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%B3%E8%81%94"><span class="nav-number">4.15.3.</span> <span class="nav-text">操作系统如何知道一块共享内存被多少个进程关联</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D"><span class="nav-number">4.16.</span> <span class="nav-text">终端、进程组、会话</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF"><span class="nav-number">4.16.1.</span> <span class="nav-text">终端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">4.16.2.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">4.16.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">4.16.4.</span> <span class="nav-text">相关函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.17.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.17.1.</span> <span class="nav-text">守护进程的创建步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">5.</span> <span class="nav-text">Linux多线程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">5.1.2.</span> <span class="nav-text">线程和进程虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%92%8C%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">5.1.3.</span> <span class="nav-text">线程之间共享和非共享资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">线程相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-create"><span class="nav-number">5.2.1.</span> <span class="nav-text">pthread_create</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">5.3.</span> <span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="nav-number">5.4.</span> <span class="nav-text">回收子线程资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-number">5.5.</span> <span class="nav-text">线程分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-number">5.6.</span> <span class="nav-text">线程取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">5.7.</span> <span class="nav-text">设置线程属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.8.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">5.9.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.10.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.11.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.12.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.13.</span> <span class="nav-text">生产者消费者模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">5.14.</span> <span class="nav-text">信号量</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
