<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kjgggggg.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/public/search.xml"};
  </script>

  <meta name="description" content="C++语法">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://kjgggggg.github.io/2022/08/03/CPP/index.html">
<meta property="og:site_name" content="kjg&#39;s blog">
<meta property="og:description" content="C++语法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-03T05:43:42.000Z">
<meta property="article:modified_time" content="2023-04-24T08:25:47.909Z">
<meta property="article:author" content="kjg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kjgggggg.github.io/2022/08/03/CPP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ | kjg's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kjg's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kjgggggg.github.io/2022/08/03/CPP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG84.jpeg">
      <meta itemprop="name" content="kjg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kjg's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-03 13:43:42" itemprop="dateCreated datePublished" datetime="2022-08-03T13:43:42+08:00">2022-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-24 16:25:47" itemprop="dateModified" datetime="2023-04-24T16:25:47+08:00">2023-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C++语法</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span> &amp;a,<span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//声明一个模板，告诉编译器后面紧跟着的代码中的T不要报错，T是一个通用数据类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//两种方式使用函数模板 1.自动类型推导：mySwap(a,b)  2.显示指定类型：mySwap&lt;int&gt;(a,b)</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt; a&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> c=<span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(c,d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span> &lt;&lt; c&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;d=&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数模板注意事项：</span></span><br><span class="line"><span class="comment">1.自动类型推导，必须推导出一致的数据类型T才可以使用,就是这部分所有T对应一种类型</span></span><br><span class="line"><span class="comment">2.模板必须要确定出T的数据类型才能使用。 就是函数体要有T，如果没有，要使用显示指定类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">普通函数与函数模板的区别：</span></span><br><span class="line"><span class="comment">普通函数调用时，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">int myAdd(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void test()&#123;</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    int b = 20;</span></span><br><span class="line"><span class="comment">    char c = &#x27;c&#x27;; //A-65 a-97 </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; myAdd(a,c)&lt;&lt; endl;  //隐式类型转换，将字符型变量转换成了整型变量</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">函数模板调用时，如果可以利用自动类型推导，则不会发生隐式类型转换；若使用显示指定类型，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line"><span class="comment">函数模板也可以重载,并且如果普通函数和函数模板都可以调用，优先调用普通函数</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">void A(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ab&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;AB&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3,是对2的重载</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b,T c)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ABC&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时会调用1，但可以通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a=10,b=20;</span></span><br><span class="line"><span class="comment">    A&lt;&gt;(a,b);//通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T name,U age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T name;</span><br><span class="line">        U age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、类模板和函数模板的区别：</span></span><br><span class="line"><span class="comment">//1.类模板没有自动类型推导的使用方法 2.类模板在模板参数列表中可以有默认参数 template&lt;class T, class U = int&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、类模板中成员函数创建时机：普通类中的成员函数一开始就可以创建，类模板中的成员函数在调用时才创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、类模板对象做函数参数：</span></span><br><span class="line"><span class="comment">//一共有三种传入方式：1.指定传入的类型 2.参数模板化 3.整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.指定传入的类型 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.整个类模板化，建议使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、类模板与继承:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Son:public Base&#123;&#125;;   错误，需要指定Base的T类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想灵活指定父类中T类型，子类也需要变类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">public</span> Base&lt;T1&gt;&#123;</span><br><span class="line">    T2 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、类模板成员函数类外实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person1</span>(T3 name,T4 age);</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     this-&gt;name=name;this-&gt;age=age;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        T3 name;</span><br><span class="line">        T4 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line">Person1&lt;T3,T4&gt;::<span class="built_in">Person1</span>(T3 name,T4 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="type">void</span> Person1&lt;T3,T4&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sb&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  七、类模板分文件编写</span></span><br><span class="line"><span class="comment">//问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</span></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="comment">// 1.直接包含.cpp源文件:</span></span><br><span class="line"><span class="comment">//一般把类及其方法的声明放在.h文件中，把实现放在.cpp文件中。 </span></span><br><span class="line"><span class="comment">// 三个文件：person.h;person.cpp;main.cpp  在person.cpp中要写#include&quot;person.h&quot;  在main.cpp中要包含#include&quot;person.cpp&quot;</span></span><br><span class="line"><span class="comment">// 2.将声明和实现写到同一文件中，并更改后缀名为.hpp。hpp是业界约定，不是必须。 然后在main.cpp中包含#include&quot;person.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、类模板与友元</span></span><br><span class="line"><span class="comment">//掌握类模板配合友元函数的类内和类外实现</span></span><br><span class="line"><span class="comment">//全局函数类内实现：直接在类内声明友元即可   </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"><span class="comment">template&lt;class T5 , class T6&gt;</span></span><br><span class="line"><span class="comment">class Person2&#123;</span></span><br><span class="line"><span class="comment">    //全局函数 类内实现  friend关键字能访问private数据</span></span><br><span class="line"><span class="comment">    friend void printPerson(Person2&lt;T5,T6&gt; p)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot; age:&quot; &lt;&lt; p.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person2(T5 name,T6 age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    private:</span></span><br><span class="line"><span class="comment">        T5 name;</span></span><br><span class="line"><span class="comment">        T6 age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    Person2&lt;string,int&gt;p(&quot;aaa&quot;,18);</span></span><br><span class="line"><span class="comment">    printPerson(p);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//全局函数类外实现：需要提前让编译器知道全局函数的存在(较难)</span></span><br></pre></td></tr></table></figure>



<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">重载操作符的类的对象叫函数对象，重载的是()时，又叫仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、特点：</span></span><br><span class="line"><span class="comment">1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="comment">2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="comment">3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v1+v2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myadd myadd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Myprint</span>()&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count; <span class="comment">//内部自己状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myprint调用的次数是&quot;</span> &lt;&lt; myprint.count &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(Myprint &amp;mp,string s)</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    Myprint mp2;</span><br><span class="line">    <span class="built_in">doPrint</span>(mp2,<span class="string">&quot;cnm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、谓词</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回bool类型的仿函数称为谓词</span></span><br><span class="line"><span class="comment">如果operator接受一个参数，叫做一元谓词</span></span><br><span class="line"><span class="comment">如果operator接受两个参数，叫做二元谓词</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、内建函数对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stl内建了一些函数对象，能够拿来直接使用。这些仿函数所产生的对象，用法和一般函数完全相同。</span></span><br><span class="line"><span class="comment">使用内建函数对象需要包含#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">分类：算数，关系，逻辑仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.算数仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T plus&lt;T&gt;;        //加    plus&lt;int&gt; p; cout &lt;&lt; p(10,20) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T minus&lt;T&gt;;       //减</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T multiplies&lt;T&gt;;  //乘</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T divides&lt;T&gt;;     //除</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T modulus&lt;T&gt;;     //取模</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T negate&lt;T&gt;;      //取反 negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.关系仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt;;    //   greater&lt;int&gt;() 等价于之前的自定义的 Mycompare       greater&lt;int&gt;()要加()，代表对象的创建。</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.逻辑仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt;;      //与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt;;       //或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt;;      //非</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file readbinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief 读取二进制数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>]; </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p;<span class="comment">//接住读出的数据</span></span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));  <span class="comment">//函数原型：istream&amp; read(char * buffer,int len);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"><span class="comment">//文件类型有两种 1.文本文件：文件以文本的ASCII码形式存储在计算机中 2.二进制文件：文件以文本的二进制形式存储在计算机中，不能直接读懂</span></span><br><span class="line"><span class="comment">//操作文件的三大类  ofstream：写操作  ifstream：读操作  fstream：读写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件步骤——“包流开写闭”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #include &lt;fstream&gt;   //包含头文件</span></span><br><span class="line"><span class="comment">    ofstream ofs;      //创建流对象</span></span><br><span class="line"><span class="comment">    ofs.open(&quot;文件路径&quot;，打开方式);     //打开文件</span></span><br><span class="line"><span class="comment">    ofs &lt;&lt; &quot;写入的数据&quot;;     //写数据</span></span><br><span class="line"><span class="comment">    ofs.close();    //关闭文件</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件打开方式：</span></span><br><span class="line"><span class="comment">    ios::in         //为读文件而打开文件</span></span><br><span class="line"><span class="comment">    i0s::out        //为写文件而打开文件</span></span><br><span class="line"><span class="comment">    ios::ate        //初始位置：文件尾</span></span><br><span class="line"><span class="comment">    ios::app        //追加方式写文件</span></span><br><span class="line"><span class="comment">    ios::trunc      //如果文件存在，则先删除再创建</span></span><br><span class="line"><span class="comment">    ios::binary     //二进制方式</span></span><br><span class="line"><span class="comment">    ios::binary | ios::out      //用二进制方式写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test01.txt&quot;</span>,ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;name:kongjiangang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;gender:male&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file writebinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief  向二进制文件写数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包流开操闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//函数原型： ostream&amp; write(const char * buffer,int len);</span></span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><h5 id="stl-general"><a href="#stl-general" class="headerlink" title="stl general"></a>stl general</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl:标准模板库</span></span><br><span class="line"><span class="comment">//stl从广义上分为容器,算法,迭代器。 容器和算法通过迭代器无缝衔接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl六大组件:容器,算法,迭代器,仿函数,适配器(配接器),空间配置器</span></span><br><span class="line"><span class="comment">//1.容器:分为序列式容器(强调值的排序)和关联式容器(二叉树)。各种数据结构,如vector,list,deque,set,map等，用来存放数据</span></span><br><span class="line"><span class="comment">//2.算法:分为质变算法(拷贝，置换，删除)和非质变算法(查找，计数，遍历)。常用的函数,如sort,find,copy,for_each等</span></span><br><span class="line"><span class="comment">//3.迭代器:分为(输入(对数据只读),输出(对数据只写),前向,双向,随机访问)迭代器。能按序访问某个容器内所含元素又不暴露该容器内部表示方法。</span></span><br><span class="line"><span class="comment">//4.仿函数:行为类似函数,可作为算法的某种策略</span></span><br><span class="line"><span class="comment">//5.适配器:不做要求</span></span><br><span class="line"><span class="comment">//6.空间配置器:负责空间的配置与管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、容器算法迭代器初识：vector存放内置数据类型</span></span><br><span class="line"><span class="comment">//容器：vector 算法：for_each 迭代器：vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> <span class="comment">//需要包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//同上</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器中插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>(); <span class="comment">//起始迭代器，指向容器中的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();     <span class="comment">//结束迭代器，指向容器中的最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span> (itBegin != itEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种遍历方式，利用for_each算法,回掉</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),myPrint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、vector存放自定义数据类型,同一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容器中再嵌套一个容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="comment">//创建小容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在小容器中插入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小容器插入到大容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过大容器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator iterator=v.<span class="built_in">begin</span>();iterator!=v.<span class="built_in">end</span>();iterator++)&#123;</span><br><span class="line">        <span class="comment">//(*iterator) 是一维数组</span></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit=(*iterator).<span class="built_in">begin</span>();vit!=(*iterator).<span class="built_in">end</span>();vit++)</span><br><span class="line">            cout&lt;&lt; (*vit) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector,也称单端数组</span></span><br><span class="line"><span class="comment">//vector与普通数组区别:不同之处是数组是静态空间，而vector可以动态扩展</span></span><br><span class="line"><span class="comment">//vector容器的迭代器是支持随机访问的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v;</span></span><br><span class="line"><span class="comment">vector(v.begin(),v.end());      //将v[begin(),end()]区间中的元素赋值给vector，如 vector&lt;int&gt; v2(v1.begin(),v1.end());</span></span><br><span class="line"><span class="comment">vector(n,elem);     //初始值为n个elem</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">assign(begin,end);      //v2.assign(v1.begin(),v.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);     //v3.assign(10,20);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容量和大小</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">empty();        //判断容器是否为空</span></span><br><span class="line"><span class="comment">capicity();     //容器的容量，不是创建vector，插入10个元素容量就为10，可能为16</span></span><br><span class="line"><span class="comment">size();     //返回容器中元素数量</span></span><br><span class="line"><span class="comment">resize(int num);        //重新指定容器长度，若容器变长，则以默认值填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num,elem);       //重新指定容器长度，若容器变长，则以elem填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">pop_back();     //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos,elem);    </span></span><br><span class="line"><span class="comment">insert(const_iterator pos,int n,elem);       //在pos处插入n个elem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(const_iterator pos);      //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator begin,onst_iterator end);      //删除begin到end间的所有元素</span></span><br><span class="line"><span class="comment">clear();        //删除容器内所有元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、数据存取</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">at(int idx);</span></span><br><span class="line"><span class="comment">operator[];     // vector&lt;int&gt; v; cout &lt;&lt; v[n] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">front();        //返回容器内第一个元素</span></span><br><span class="line"><span class="comment">back();     //返回容器内最后一个元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、互换容器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">swap(vec);      //将vec与本身的元素进行互换 v1.swap(v2);</span></span><br><span class="line"><span class="comment">v.resize(3);vector&lt;int&gt;(v).swap(v);     //巧用swap收缩内存，vector&lt;int&gt;(v)是匿名对象，拷贝构造函数，同时匿名对象自动析构。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、预留空间</span></span><br><span class="line"><span class="comment">//减少vector在动态扩展容量时的扩展次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">reserve(int len);       //容器预留len个元素长度，但预留位置不初始化，且元素不可访问。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h6 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums)</span><br><span class="line">            mp[e]++;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que; <span class="comment">// priority_queue&lt;Type, Container, Functional&gt; </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); i ++)&#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*i);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>() &gt; k)  pri_que.<span class="built_in">pop</span>();<span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> comp = [&amp;](pii&amp; l, pii&amp; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> matrix[l.first][l.second] &gt; matrix[r.first][r.second];&#125;; <span class="comment">// 小根堆</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(comp)&gt; <span class="built_in">q</span>(comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) q.<span class="built_in">emplace</span>(i, <span class="number">0</span>); <span class="comment">// push fist colum i行0列</span></span><br><span class="line">        <span class="keyword">while</span>(--k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(j != n<span class="number">-1</span>) q.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">list(链表，stl中的链表是一个双向循环链表，每个结点都有data,prev,next域)常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">list&lt;T&gt; l;</span></span><br><span class="line"><span class="comment">list(begin,end);        //拷贝构造函数,list&lt;int&gt; l2(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">list(n,elem);       </span></span><br><span class="line"><span class="comment">list(const list &amp;l);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换：</span></span><br><span class="line"><span class="comment">assign(begin,end);      //list&lt;int&gt; l2; l2.assign(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;l);</span></span><br><span class="line"><span class="comment">swap(l)     //将l与本身的元素互换  l1.swap(l2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">resize(num);</span></span><br><span class="line"><span class="comment">resize(num,elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、插入和删除：</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">push_front(elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pop_back();</span></span><br><span class="line"><span class="comment">pop_front();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insert(pos,elem);       //返回新数据的位置</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);     //无返回值</span></span><br><span class="line"><span class="comment">insert(pos,begin,end);      //无返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个数据的位置</span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个数据的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">remove(elem);       //移除所有与elem匹配的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">clear();        //移除容器中所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、数据存取</span></span><br><span class="line"><span class="comment">front();</span></span><br><span class="line"><span class="comment">back();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、反转和排序</span></span><br><span class="line"><span class="comment">reverse();</span></span><br><span class="line"><span class="comment">sort();</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">map &amp; multimap 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map基本概念：</span></span><br><span class="line"><span class="comment">1.map中的所有元素都是pair</span></span><br><span class="line"><span class="comment">2.pair中的第一个元素为key，起索引作用。第二个元素为value(实际值)</span></span><br><span class="line"><span class="comment">3.所有元素都会根据元素的键值自动排序</span></span><br><span class="line"><span class="comment">4.map &amp; multimap区别：map不允许容器中有重复key值的元素，multimap允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造与赋值</span></span><br><span class="line"><span class="comment">map&lt;T1,T2&gt; mp;</span></span><br><span class="line"><span class="comment">map(const map &amp;mp);     </span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp);      //返回值是一个map的引用变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(mp);       //mp1.swap(mp2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);       //map&lt;int,int&gt; mp1;  mp1.insert(pair&lt;int,int&gt;(1,20));</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(key);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回mp.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、排序</span></span><br><span class="line"><span class="comment">默认按key值从小到大排序，但可以通过仿函数改变</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">map&lt;int,int,MyCompare&gt; mp;      //指定排序规则</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">set &amp; multiset 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">set基本概念：</span></span><br><span class="line"><span class="comment">1.所有元素都会在插入时自动被排序</span></span><br><span class="line"><span class="comment">2.set/multiset是关联式容器，底层用二叉树实现</span></span><br><span class="line"><span class="comment">3.set和multiset区别：set不允许容器中有相同元素，multiset允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st;</span></span><br><span class="line"><span class="comment">set(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(st);       //st1.swap(st2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(elem);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回st.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment">st.lower_bound(x); // 返回第一个&gt;=x的迭代器</span></span><br><span class="line"><span class="comment">st.upper_bound(x); // 返回第一个&gt;x的迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、set和multiset的区别</span></span><br><span class="line"><span class="comment">set插入数据时会返回是否插入成功，multiset不会</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、pair 对组的创建</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p(value1,value2);       //p.first和p.second分别访问不同部分</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p = make_pair(value1,value2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">八、set容器排序</span></span><br><span class="line"><span class="comment">学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</span></span><br><span class="line"><span class="comment">主要技术点：利用仿函数可以改变排序规则</span></span><br><span class="line"><span class="comment">1.set中存放内置数据类型</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">set&lt;int,MyCompare&gt; s2;      //指定排序规则</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.set中存放自定义数据类型</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person(string name,int age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        string name;</span></span><br><span class="line"><span class="comment">        int age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">class MyCompare2&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(const Person &amp;p1,const Person &amp;p2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return p1.age&gt;p2.age;       //按年龄降序排列</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    set&lt;Person,MyCompare2&gt; st;</span></span><br><span class="line"><span class="comment">    Person p1(&quot;lisi&quot;,19);</span></span><br><span class="line"><span class="comment">    Person p2(&quot;lisiguang&quot;,20);</span></span><br><span class="line"><span class="comment">    st.insert(p1);</span></span><br><span class="line"><span class="comment">    st.insert(p2);</span></span><br><span class="line"><span class="comment">    //迭代器输出，省略……</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stack常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; s;</span></span><br><span class="line"><span class="comment">stack(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);</span></span><br><span class="line"><span class="comment">pop();      //移除栈顶元素</span></span><br><span class="line"><span class="comment">top();      //返回栈顶元素</span></span><br><span class="line"><span class="comment">emplace();	//emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数.相当于emplace直接把原料拿进家，造了一个。而push是造好了之后，再复制到自己家里，多了复制这一步。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">queue常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; q;</span></span><br><span class="line"><span class="comment">queue(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h6 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一、 构造函数</span></span><br><span class="line"><span class="built_in">deque</span>();<span class="comment">// 创建一个空deque</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> nSize); <span class="comment">// 创建一个deque,元素个数为nSize</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> nSize,<span class="type">const</span> T&amp; t);<span class="comment">// 创建一个deque,元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;); <span class="comment">// 复制构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、 增加函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列头部增加一个元素X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列尾部增加一个元素x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列中某一元素前增加一个元素x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列中某一元素前增加n个相同的元素x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iterator last)</span></span>; <span class="comment">// 双端队列中某一元素前插入另一个相同类型向量的[first,last)间的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、删除函数</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>; <span class="comment">// 删除双端队列中的某一个元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>; <span class="comment">// 删除双端队列中[first,last）中的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">// 删除双端队列中最前一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">// 删除双端队列中最后一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清空双端队列中所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、遍历函数</span></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span></span>; <span class="comment">// 返回pos位置元素的引用</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span>; <span class="comment">// 返回首元素的引用</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>; <span class="comment">// 返回尾元素的引用</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>; <span class="comment">// 返回向量头指针，指向第一个元素</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>; <span class="comment">// 返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>; <span class="comment">// 反向迭代器，指向最后一个元素</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>; <span class="comment">// 反向迭代器，指向第一个元素的前一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 向量是否为空，若true,则向量中无元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 六、大小函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回向量中元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回最大可允许的双端对了元素数量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 七、其他函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(deque&amp;)</span></span>; <span class="comment">// 交换两个同类型向量的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 向量中第n个元素的值设置为x</span></span><br></pre></td></tr></table></figure>





<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//char*是一个指针；string是一个类，类内部封装了char*，是一个char*型的容器</span></span><br><span class="line"><span class="comment">//string类内部封装了很多成员方法，如find，copy，delete，replace，insert。 string类管理char*所分配的内存，不用担心复制越界和取值越界，由类内部负责管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string();      //创建一个空的字符串，例如string str;</span></span><br><span class="line"><span class="comment">string(const char* s);     //使用字符串s初始化，如   char* str = &quot;hello world&quot;; string s(str);</span></span><br><span class="line"><span class="comment">string(const string&amp; str);     //使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="comment">string(int n,char c);      //使用n个字符c初始化 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char* s);       //string str = &quot;aaa&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const string&amp; s);         //string str1 =str;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char c);        //strng str = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s);      //string str2; str2.assign(&quot;aaaaa&quot;);</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s,int n);        //把字符串s的前n个字符赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(const string &amp;s);        //把字符串s赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(int n,char c);       //用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、拼接</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char* str);       //string str=&quot;我&quot;; str+=&quot;爱玩游戏&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char c);         //string str=&quot;我&quot;; str+=&#x27;艹&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const &amp;string str);        //str1 += str2;</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s);      //string str=&quot;我&quot;; str.append(&quot;爱玩游戏&quot;);</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s,int n);        //把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s);        //str1.append(str2);</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s,int pos,int n);       //把字符串s从pos开始n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、查找和替换</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int find(const string&amp; str,int pos=0) const;        //查找str第一次出现的位置，从pos开始寻找。不写pos默认为0</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos=0) const;        //查找s第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos,int n) const;        //查找s的前n个字符第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char c ,int pos=0) const;        //查找字符c第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str,int pos=npos) const;        //查找str最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos=npos) const;        //查找s最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos,int n) const;        //查找s的前n个字符最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char c ,int pos=0) const;        //查找字符c最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const string&amp; str);       //替换从pos开始的n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const char* s);       //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、比较</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串是按字符的ASCII进行比较 =返回0;&gt;返回1;&lt;返回-1</span></span><br><span class="line"><span class="comment">int compare(const string&amp; s) const;</span></span><br><span class="line"><span class="comment">int compare(const char* s) const;   </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、获取(也可以赋值，修改)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n);        //通过[]方式获取字符 cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">char&amp; at(int n);        //通过at获取字符  cout &lt;&lt; str.at(i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const char* s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const string&amp; s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,int n,char c);       //在指定pos插入n个c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; erase(int pos,int n=npos);      //删除从pos开始的n个字符 ，nopos表示不存在的位置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、获取子串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string substr(int pos = 0;int n = npos) const;        //返回由pos开始n个字符组成的子串  </span></span><br><span class="line"><span class="comment">                                                      //如string str=&quot;abcdef&quot;; cout &lt;&lt; str.substr(1,3) &lt;&lt; endl;返回&quot;bcd&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="刷题输入输出"><a href="#刷题输入输出" class="headerlink" title="刷题输入输出"></a>刷题输入输出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1 最基本，也是最常用的用法</span></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;a+b&lt;&lt;endl;<span class="comment">// 输入：2[回车]3[回车]    输出：5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法2 接受一个字符串，遇	“ ”、[TAB]、[回车]都结束</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl; <span class="comment">// 输入：jkljkl jkljkl  输出：jkljkl(遇空格结束)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin.get()可以用来接收单个字符</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);	</span><br><span class="line">cout&lt;&lt;ch&lt;&lt;endl;	<span class="comment">// 输入：jljkljkl	输出：j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getchar() 接受一个字符，需包含“#include&lt;string&gt;”</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=<span class="built_in">getchar</span>();                      </span><br><span class="line">cout&lt;&lt;ch&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin.getline() 接受一个字符串，可以接收空格并输出</span></span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(m,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl; <span class="comment">// 输入：jkljkljkl  输出：jklj(\0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getline() 接受一个字符串，可以接收空格并输出，需包含“#include&lt;string&gt;”</span></span><br><span class="line">string st ;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Input st:&quot;</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin,st);</span><br><span class="line">cout&lt;&lt;st&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gets() 接受一个字符串，可以接收空格并输出，需包含“#include&lt;string&gt;”</span></span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">gets</span>(m);  <span class="comment">//不能写成m=gets();</span></span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br></pre></td></tr></table></figure>





<h4 id="刷题常用函数"><a href="#刷题常用函数" class="headerlink" title="刷题常用函数"></a>刷题常用函数</h4><h5 id="to-string-int-x"><a href="#to-string-int-x" class="headerlink" title="to_string(int x)"></a>to_string(int x)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="stoi-string-s"><a href="#stoi-string-s" class="headerlink" title="stoi(string s)"></a>stoi(string s)</h5><p>string 类型转为 int 类型</p>
<h5 id="reverse-iterator-begin-iterator-end"><a href="#reverse-iterator-begin-iterator-end" class="headerlink" title="reverse(iterator begin, iterator end)"></a>reverse(iterator begin, iterator end)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h5 id="islower-x2F-isupper-x2F-isalpha-x2F-isdigit"><a href="#islower-x2F-isupper-x2F-isalpha-x2F-isdigit" class="headerlink" title="islower&#x2F; isupper&#x2F;isalpha&#x2F;isdigit"></a>islower&#x2F; isupper&#x2F;isalpha&#x2F;isdigit</h5><h5 id="isalnum-char-ch"><a href="#isalnum-char-ch" class="headerlink" title="isalnum(char ch)"></a>isalnum(char ch)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">// 判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。</span></span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="tolower-char-ch-x2F-toupper-char-ch-x2F-tolower-string-s-x2F-toupper-string-s"><a href="#tolower-char-ch-x2F-toupper-char-ch-x2F-tolower-string-s-x2F-toupper-string-s" class="headerlink" title="tolower(char ch)&#x2F;toupper(char ch) &#x2F;tolower(string s)&#x2F;toupper(string s)"></a>tolower(char ch)&#x2F;toupper(char ch) &#x2F;tolower(string s)&#x2F;toupper(string s)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">// 判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。</span></span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="next-permutation-iterator-begin-iterator-end"><a href="#next-permutation-iterator-begin-iterator-end" class="headerlink" title="next_permutation(iterator begin, iterator end)"></a>next_permutation(iterator begin, iterator end)</h5><p>函数将按字母表顺序生成给定序列的下一个较大的排列，直到整个序列为降序为止。</p>
<h5 id="prev-permutation-iterator-begin-iterator-end"><a href="#prev-permutation-iterator-begin-iterator-end" class="headerlink" title="prev_permutation(iterator begin, iterator end)"></a>prev_permutation(iterator begin, iterator end)</h5><p>函数与之相反，是生成给定序列的上一个较小的排列。</p>
<h5 id="long-int-stol（const-string＆str"><a href="#long-int-stol（const-string＆str" class="headerlink" title="long int stol（const string＆str)"></a>long int stol（const string＆str)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next_permutation</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()) &amp;&amp; <span class="built_in">stol</span>(tmp) &lt;= INT_MAX ? <span class="built_in">stol</span>(tmp) : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此函数将在函数调用中作为参数提供的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>转换为long int。</p>
<h5 id="sort-amp-amp-stable-sort"><a href="#sort-amp-amp-stable-sort" class="headerlink" title="sort &amp;&amp; stable_sort"></a>sort &amp;&amp; stable_sort</h5><p>sort函数是algorithm库下的一个函数，sort函数是不稳定的，即大小相同的元素在排序后相对顺序可能发生改变，如果某些场景需要保持相同元素间的相对顺序，可使用<code>stable_sort</code>函数，这里不过多介绍</p>
<p>由于在排序过程中涉及到元素<em>交换</em>等操作，所以sort函数仅支持<strong>可随机访问</strong>的容器，如数组,  string, vector, deque等</p>
<p>方式一(默认)	<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()); <span class="comment">// sort函数如果不传入第三个参数，则默认是升序排列</span></span><br></pre></td></tr></table></figure>



<p>方式二(自定义)	<code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
<blockquote>
<p>  实现降序排列，需传入第三个参数–比较函数，<code>greater&lt;type&gt;()</code>，这里的元素为<code>int</code> 类型，即函数为<code> greater&lt;int&gt;()</code>;</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="lower-bound-x2F-upper-bound"><a href="#lower-bound-x2F-upper-bound" class="headerlink" title="lower_bound&#x2F; upper_bound"></a>lower_bound&#x2F; upper_bound</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个 &gt;=val 的元素的迭代器</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个	&gt;val 的元素的迭代器</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>) s.<span class="built_in">replace</span>(i, <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="C-Primer-Plus"><a href="#C-Primer-Plus" class="headerlink" title="C++ Primer Plus"></a>C++ Primer Plus</h4><ol>
<li><p><code>cout.put(&#39;A&#39;);</code> 与 <code>cout &lt;&lt; &#39;A&#39;;</code>区别 : 前者打印A的ASCII码,  后者打印A</p>
</li>
<li><p>const Month &#x3D; 12 这样便可以在程序中使用Month而不是12了</p>
</li>
<li><p>强制转换的语法有两种: <code>(typeName) value</code>和<code>typeName (value)</code> C++11新增:<code>static_cast&lt;typeName&gt; value</code></p>
</li>
<li><p>在初始化声明中，如果使用auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同</p>
</li>
<li><p>数组:</p>
<ol>
<li>声明 <code>typeName arrayName[arraySize];</code> 其中<code>arraySize</code>不能为变量。</li>
<li>初始化时可以 <code>int a[2]=&#123;1,2&#125; </code>也可以 <code>int a[3] =&#123;1,2&#125; </code>【长度为3，第三个元素默认为0】同样可以<code>int a[] = &#123;1,2&#125; </code>【长度为2】 </li>
<li>C++11初始化数组时可以省略 &#x3D; ；其次 <code>int a = &#123;&#125;</code>代表将a初始化为全0；最后 列表初始化禁止缩窄转换 如 不允许<code>long a[] = &#123;3, 1.2,1.3&#125;</code>。</li>
</ol>
</li>
<li><p>字符串<code>string</code>本质上是以<code>&#39;\0&#39;</code>结尾的char数组</p>
<ol>
<li><code>char a = &#39;A&#39; </code>正确 	 <code>char a = &quot;A&quot; </code>错误 因为” “是字符串 而’ ‘是字符</li>
<li>每次读取一行字符串输入: <code>cin.getline(name, 20)</code> &#x2F;&#x2F; 使用getline( )将姓名读入到一个包含20个元素的name数组中</li>
</ol>
</li>
<li><p>共用体:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共用体（union）是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">a</span>&#123;</span><br><span class="line">  <span class="type">int</span> int_val;</span><br><span class="line">  <span class="type">long</span> long_val;</span><br><span class="line">  <span class="type">double</span> double_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">a pail;</span><br><span class="line">pail.int_val = <span class="number">5</span>; <span class="comment">// valid</span></span><br><span class="line">pail.double_val = <span class="number">5.20</span> <span class="comment">// valid, int value is lost</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体 <code>enum color=&#123;red, green, blue&#125;</code> red等叫枚举量,分别对应0-2      也可以这样初始化<code>enum a =&#123;first, second = 100, third&#125;</code>这里，first在默认情况下为0。后面没有被初始化的枚举量的值将比 其前面的枚举量大1。因此，third的值为101。  也可以这样创建:<code>enrm a =&#123;aa, aaa = 0, bb, bbb = 1&#125;</code>  其中，aa和aaa都为0，bb和bbb都为1。</p>
</li>
<li><p>指针的写法可以:<code> int* ptr</code>或<code>int *ptr</code>或<code>int*ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="type">int</span>* ptr;</span><br><span class="line">ptr = <span class="number">0xB8000000</span>; <span class="comment">// 报错</span></span><br><span class="line">ptr = (<span class="type">int</span> *) <span class="number">0xB8000000</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">//正确,注意释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 错误,没有new 则不能delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. </span></span><br><span class="line"><span class="comment">// 动态数组和普通指针区别</span></span><br><span class="line"><span class="type">char</span> *p1 = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line"><span class="type">char</span> *p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1000</span>];</span><br><span class="line">*(p1 + <span class="number">4</span>) = <span class="number">12</span>; <span class="comment">// 等价于 p1[4] = 12;</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="type">int</span> * ar = <span class="keyword">new</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 则</span></span><br><span class="line">arr[i] = *(ar + i); </span><br><span class="line">&amp;arr[i] = ar + i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line">结构体对象访问成员用. 结构体指针访问成员用-&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类 型（如果有的话）以及参数的类型和数量告诉编译器。</p>
<ol>
<li><p>原型语法: <code>void funcA(int, char);</code></p>
</li>
<li><p>函数原型的作用:</p>
<p>1.帮助编译器正确处理函数返回值；</p>
<p>2.帮助 编译器检查使用的参数数目是否正确； </p>
<p>3.帮助编译器检查使用的参数类型是否正确。如果不正确，则转换为正确 的类型（如果可能的话）</p>
</li>
</ol>
</li>
<li><p>用<code>const</code>保护数组: 使用普通参数时，这种保护将 自动实现，这是由于C++按值传递数据，而且函数使用数据的副本。然而，接受数组名的函数将使用原始数据，为防止函数无意中修改数组的内容，可在声明形参时 使用关键字<code>const </code>    </p>
<ol>
<li>如 <code>void noChangeArr(const int arr[], int n);</code></li>
<li>原型里也要加<code>const</code></li>
</ol>
</li>
<li><p>指针和<code>const</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * var1 = &amp;a;  <span class="comment">//指向整形常量的指针，它指向的值不能修改</span></span><br><span class="line">*var1 = <span class="number">20</span>; <span class="comment">//错</span></span><br><span class="line">var = &amp;b; <span class="comment">// 对</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> var2;    <span class="comment">//指向整形的常量指针，它不能在指向别的变量，但指向（变量）的值可以修改。 </span></span><br><span class="line">*var2 = <span class="number">20</span>; <span class="comment">// 对</span></span><br><span class="line">var2 = b; <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> var3;  <span class="comment">//指向整形常量 的常量指针。它既不能再指向别的常量，指向的值也不能修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且 C++禁止将const的地址赋给非const指针。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当且仅当声明函数的形参时，下面两个声明才是等价的 <code>typeName arr[]</code>与<code>typeName *arr</code></p>
</li>
<li><p>假设要将<strong>字符串作为参数</strong>传递给函数，则表示字符串的方式有3种：</p>
<ol>
<li>char数组；</li>
<li>被设置为字符串的地址的char指针。</li>
<li>用引号括起的字符串常量（也称字符串字面值)</li>
</ol>
</li>
</ol>
<p>​		上述3种选择的类型都是char指针（准确的说是char*），因此可以将其作为字符串处理函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ghost[<span class="number">15</span>] = <span class="string">&quot;galloping&quot;</span>;</span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;galloping&quot;</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="built_in">strlen</span>(ghost);           <span class="comment">// ghost 是 &amp;ghost[0]  对应1</span></span><br><span class="line"><span class="type">int</span> n2 = <span class="built_in">strlen</span>(str);             <span class="comment">//str是 char 类型的指针  对应2</span></span><br><span class="line"><span class="type">int</span> n3 = <span class="built_in">strlen</span>(<span class="string">&quot;galloping&quot;</span>);     <span class="comment">//&quot;galloping&quot; 是 address of string  对应3</span></span><br></pre></td></tr></table></figure>

<ol start="15">
<li>函数指针:<ol>
<li>获取函数的地址：只要使用函数名（后面不跟参数）即可。如:think()是一个函数，则think就是该函数的地址。</li>
<li>如果要将函数作为参数进行传递，必须传递函数名。</li>
<li>函数括号中的形参可有可无，视情况而定。</li>
<li>与指针函数区别开来,指针函数是返回值类型为指针的函数</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数指针的声明方法为：</span><br><span class="line">返回值类型 ( * 指针变量名) ([形参列表]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">/* 声明一个函数 */</span></span><br><span class="line"><span class="built_in">int</span> (*f) (<span class="type">int</span> x); <span class="comment">/* 声明一个函数指针 */</span></span><br><span class="line">f=func; <span class="comment">/* 将func函数的首地址赋给指针f */</span></span><br><span class="line">f = &amp;func; <span class="comment">// 这也行,等同于上行的写法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用<span class="keyword">typedef</span>对函数指针进行简化:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> real;<span class="comment">//make real another name for double</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span><span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>  <span class="comment">//也可写成：char（*pFun)(int);</span></span></span><br><span class="line"><span class="function"><span class="comment">/*typedef的功能是定义新的类型。第一句就是定义了一种PFUN的类型，</span></span></span><br><span class="line"><span class="comment"><span class="function">并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。*/</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">glFun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="comment">//定义了一个函数glFun().该函数正好是一个以int为参数返回char的函数。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pFun =glFun; <span class="comment">//对指针进行赋值。</span></span><br><span class="line">	(*pFun)(<span class="number">2</span>); <span class="comment">//通过指针调用函数glFun。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>内联函数:编译器将使用相应的函数代码替换函数调用。[文本替换,会带来内存的占用]</li>
</ol>
<p>使用内联函数的措施：</p>
<ul>
<li>在函数声明前加上关键字inline；</li>
<li>在函数定义前加上关键字inline。</li>
</ul>
<ol start="17">
<li>引用变量:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建引用变量</span></span><br><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br><span class="line"><span class="comment">//上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元。</span></span><br><span class="line"><span class="comment">// 引用必须在声明时将其初始化。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用更接近const指针，一旦与某个变量关联，就将一直效忠于它。</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> pr = &amp;rats;</span><br></pre></td></tr></table></figure>





<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><h5 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 公共权限</span></span><br><span class="line">	<span class="type">int</span> radius; </span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calulateZC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * radius * PI; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	string sname;</span><br><span class="line">	string sid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取SID</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(string id)</span> </span>&#123; sid = id; &#125;</span><br><span class="line">	<span class="comment">// 获取SName</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; sname = name; &#125;</span><br><span class="line">	<span class="comment">//打印学生信息</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;学号：&quot;</span> &lt;&lt; sid &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; sname &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 实例化圆类</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	<span class="comment">// 给实例属性赋值</span></span><br><span class="line">	c1.radius = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 调用实例类中封装的行为--计算圆周长</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;半径为&quot;</span> &lt;&lt; c1.radius &lt;&lt; <span class="string">&quot;的圆，周长为&quot;</span> &lt;&lt; c1.<span class="built_in">calulateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例化学生类</span></span><br><span class="line">	Student stu1;</span><br><span class="line">	<span class="comment">// 学生类属性赋值</span></span><br><span class="line">	stu1.sid = <span class="string">&quot;10086&quot;</span>;</span><br><span class="line">	stu1.sname = <span class="string">&quot;移动&quot;</span>;</span><br><span class="line">	<span class="comment">// 调用实例用有的方法</span></span><br><span class="line">	stu1.<span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">	Student stu2;</span><br><span class="line">	stu2.<span class="built_in">setID</span>(<span class="string">&quot;110&quot;</span>);</span><br><span class="line">	stu2.<span class="built_in">setName</span>(<span class="string">&quot;刑警队&quot;</span>);</span><br><span class="line">	stu2.<span class="built_in">printInfo</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="正方体"><a href="#正方体" class="headerlink" title="正方体"></a>正方体</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_LWH</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123; <span class="comment">// 设置长宽高</span></span><br><span class="line">		length = l;</span><br><span class="line">		width = w;</span><br><span class="line">		height = h;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">caculateArea</span><span class="params">()</span> </span>&#123; <span class="comment">// 计算面积</span></span><br><span class="line">		<span class="keyword">if</span> ((length == <span class="number">0</span>) || (width == <span class="number">0</span>) || (height == <span class="number">0</span>)) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\aYou must set the length, width and height of cube by function: set_LWH .&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*(length * width +  width * height + length * height);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">caculateVolume</span><span class="params">()</span> </span>&#123; <span class="comment">// 计算体积</span></span><br><span class="line">		<span class="keyword">if</span> ((length == <span class="number">0</span>) || (width == <span class="number">0</span>) || (height == <span class="number">0</span>)) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\aYou must set the length, width and height of cube by function: set_LWH .&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> length * width * height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">isSame</span><span class="params">(Cube &amp;c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">caculateVolume</span>() == c.<span class="built_in">caculateVolume</span>()) cout &lt;&lt; <span class="string">&quot;两个立方体体积相等！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;两个立方体体积不相等！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isEqual</span><span class="params">(Cube &amp;c1, Cube &amp;c2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c1.<span class="built_in">caculateVolume</span>() == c2.<span class="built_in">caculateVolume</span>()) cout &lt;&lt; <span class="string">&quot;两个立方体体积相等！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;两个立方体体积不相等！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cube cube1;</span><br><span class="line">	cube1.<span class="built_in">set_LWH</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;面积为：&quot;</span> &lt;&lt; cube1.<span class="built_in">caculateArea</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; cube1.<span class="built_in">caculateVolume</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Cube cube2;</span><br><span class="line">	cube2.<span class="built_in">set_LWH</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;面积为：&quot;</span> &lt;&lt; cube2.<span class="built_in">caculateArea</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; cube2.<span class="built_in">caculateVolume</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断cube1与cube2体积是否相等</span></span><br><span class="line">	<span class="comment">// 全局方法</span></span><br><span class="line">	<span class="built_in">isEqual</span>(cube1, cube2);</span><br><span class="line">	<span class="comment">// 成员方法</span></span><br><span class="line">	cube2.<span class="built_in">isSame</span>(cube1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;无参构造函数！&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 无参构造</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123; age = a; cout &lt;&lt; <span class="string">&quot;有参构造函数！&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 有参构造</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123; <span class="comment">// 拷贝构造 必须加const</span></span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是拷贝构造函数！\t&quot;</span> &lt;&lt; age &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;这是析构函数！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用</span></span><br><span class="line"><span class="comment">// 2.1 括号法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p1;  <span class="comment">// 无参</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;  <span class="comment">// 拷贝</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2显示法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p1;  <span class="comment">// 无参</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">// 有参</span></span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);  <span class="comment">// 拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3隐式转换法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 无参</span></span><br><span class="line">	Person p2 = <span class="number">10</span>;  <span class="comment">// 有参</span></span><br><span class="line">	Person p3 = p2;  <span class="comment">// 拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h5><ul>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可修改</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showCls</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// ==&gt; const Pesron * const this</span></span><br><span class="line">		<span class="comment">// this-&gt;m_age = 100;  // 不可修改指针指向的值</span></span><br><span class="line">		<span class="comment">// this = NULL;  // 也不可修改地址指向</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_height = <span class="number">100.0</span>;  <span class="comment">// 可修改</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">float</span> m_height; <span class="comment">// 特殊变量，即在常函数中也可修改这个值，加mutable关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">showCls</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person p1;</span><br><span class="line">	<span class="comment">// p1.m_age = 20; 不可修改</span></span><br><span class="line">	p1.m_height = <span class="number">20.0</span>;  <span class="comment">// 可修改，因为类定义里该变量前加了mutable</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 常对象只能调用常函数</span></span><br><span class="line">	p1.<span class="built_in">showCls</span>();</span><br><span class="line">	<span class="comment">// p1.showAge(); // 常对象不可调用普通成员函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能利用全局函数重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person &amp;p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;class Person&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">	Person p;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint);</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myinteger</span>() &#123; m_Num = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前置递增运算符++重载 返回引用是为了对一个数进行递增</span></span><br><span class="line">	Myinteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		++m_Num;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后置递增运算符++重载</span></span><br><span class="line">	Myinteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		Myinteger temp = *<span class="keyword">this</span>; <span class="comment">// 记录当前的值</span></span><br><span class="line"></span><br><span class="line">		m_Num++; <span class="comment">// 加操作</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> temp; <span class="comment">// 返回记录值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前置递减运算符--重载</span></span><br><span class="line">	Myinteger&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		--m_Num;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后置递减运算符--重载</span></span><br><span class="line">	Myinteger <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">// 先记录原始值</span></span><br><span class="line">		Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 减操作</span></span><br><span class="line">		m_Num--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回记录值</span></span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint) &#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Myinteger myint;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ++myint &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; --myint &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; myint-- &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="x3D-重载"><a href="#x3D-重载" class="headerlink" title="&#x3D; 重载"></a>&#x3D; 重载</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line">		<span class="comment">// 编译器是提供浅拷贝</span></span><br><span class="line">		<span class="comment">// m_age = p.m_age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 应该先判断是否有属性在堆区，如果有先释放，然后再深拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 深拷贝</span></span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	p3 = p2 = p1;  <span class="comment">// 赋值操作</span></span><br><span class="line">	cout &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(string test)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyPrint myprint;</span><br><span class="line">	<span class="built_in">myprint</span>(<span class="string">&quot;hello world.&quot;</span>); <span class="comment">// 由于使用起来很像函数调用，因此也称为仿函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Person() &#123; cout &lt;&lt; &quot;Person类&quot; &lt;&lt; endl; &#125;</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showGrade</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;年级：&quot;</span> &lt;&lt; m_grade &lt;&lt; <span class="string">&quot;年级&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_grade = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:<span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showSex</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;男生&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> :<span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showSex</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;女生&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Man m;</span><br><span class="line">	m.<span class="built_in">showGrade</span>();</span><br><span class="line">	m.<span class="built_in">showSex</span>();</span><br><span class="line"></span><br><span class="line">	Woman w;</span><br><span class="line">	w.<span class="built_in">showGrade</span>();</span><br><span class="line">	w.<span class="built_in">showSex</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_a = <span class="number">10</span>;  <span class="comment">// 父类中的公共权限成员到子类中依然是公共权限</span></span><br><span class="line">		m_b = <span class="number">10</span>;  <span class="comment">// 父类中的保护权限成员到子类中依然是保护成员</span></span><br><span class="line">		<span class="comment">// m_c = 10;  // 父类中的保护权限成员  子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">protected</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_a = <span class="number">10</span>;  <span class="comment">// 父类中的公共权限成员到子类中是保护权限</span></span><br><span class="line">		m_b = <span class="number">10</span>;  <span class="comment">// 父类中的保护权限成员到子类中依然是保护权限</span></span><br><span class="line">		<span class="comment">// m_c = 10;  // 父类中的私有成员访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_a = <span class="number">100</span>;  <span class="comment">// 父类中的公共成员到子类中是私有权限</span></span><br><span class="line">		m_b = <span class="number">100</span>;  <span class="comment">// 父类中的保护权限成员到子类中是私有权限</span></span><br><span class="line">		<span class="comment">// m_c = 100;  // 父类中的私有成员访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson3</span>:<span class="keyword">public</span> Son3 &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// m_a; // m_a父类中已经通过私有继承将父父类中的公共权限变成私有权限，所以子类无法再继承该变量，m_b同理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 公共继承</span></span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_a = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// s1.m_b = 100;  // 父类中的保护权限成员到子类中依然是保护成员, 在类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护继承</span></span><br><span class="line">	Son2 s2;</span><br><span class="line">	<span class="comment">// s2.m_a = 100;  // 保护继承方式下父类的公共权限到子类中就是保护权限，类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有继承</span></span><br><span class="line">	Son3 s3;</span><br><span class="line">	<span class="comment">// s3.m_a;  // 私有继承方式下父类的公共权限到子类中就是私有权限，类外访问不到</span></span><br><span class="line">	<span class="comment">// s3.m_b;  // 私有继承方式下父类的保护权限到子类中就是私有权限，类外访问不到</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法：计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num1;</span><br><span class="line">	<span class="type">int</span> num2;</span><br><span class="line">	string flag;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num1 - num2; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">times</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num1 * num2; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">divided</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num1 / num2; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Caculator1</span>(<span class="type">int</span> n1, string f, <span class="type">int</span> n2) :<span class="built_in">num1</span>(n1), <span class="built_in">flag</span>(f), <span class="built_in">num2</span>(n2) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="string">&quot;+&quot;</span>) cout &lt;&lt; num1 &lt;&lt; flag &lt;&lt; num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; <span class="built_in">add</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="string">&quot;-&quot;</span>) cout &lt;&lt; num1 &lt;&lt; flag &lt;&lt; num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; <span class="built_in">minus</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="string">&quot;*&quot;</span>) cout &lt;&lt; num1 &lt;&lt; flag &lt;&lt; num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; <span class="built_in">times</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="string">&quot;/&quot;</span>) cout &lt;&lt; num1 &lt;&lt; flag &lt;&lt; num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; <span class="built_in">divided</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态实现计算器类</span></span><br><span class="line"><span class="comment">/* 多态带来的好处:</span></span><br><span class="line"><span class="comment">	1. 组织结构清晰</span></span><br><span class="line"><span class="comment">	2. 可读性强</span></span><br><span class="line"><span class="comment">	3. 对于前期和后期的维护性高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 实现计算器抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCaculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCaculator</span> :<span class="keyword">public</span> AbstractCaculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Num1 + m_Num2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinusCaculator</span> :<span class="keyword">public</span> AbstractCaculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Num1 - m_Num2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyCaculator</span> :<span class="keyword">public</span> AbstractCaculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Num1 * m_Num2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num1, num2;</span><br><span class="line">	string flag;</span><br><span class="line">	cin &gt;&gt; num1 &gt;&gt; flag &gt;&gt; num2;</span><br><span class="line">	<span class="function">Caculator1 <span class="title">c</span><span class="params">(num1, flag, num2)</span></span>;</span><br><span class="line">	c.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态写法测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 多态使用条件</span></span><br><span class="line">	<span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">	AbstractCaculator* abc = <span class="keyword">new</span> AddCaculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc; <span class="comment">// 只是销毁new对象在堆区的数据</span></span><br><span class="line"></span><br><span class="line">	abc = <span class="keyword">new</span> MinusCaculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line">	abc = <span class="keyword">new</span> MultiplyCaculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象cpu基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbsCPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">caculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 抽象显卡基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbsVideoCard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 抽象内存条基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbsMemory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intel厂商类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> AbsCPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">caculate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Intel CPU is caculating.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> AbsVideoCard &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Intel video card is working.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> AbsMemory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Intel memory is to storage.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lenovo厂商类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> AbsCPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">caculate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Lenovo CPU is caculating.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> AbsVideoCard &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Lenovo video card is working.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> AbsMemory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Lenovo memory is to storage.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(string* desc, AbsCPU *cpu, AbsVideoCard *vc, AbsMemory *mem) :<span class="built_in">m_desc</span>(desc), <span class="built_in">m_cpu</span>(cpu), <span class="built_in">m_vc</span>(vc), <span class="built_in">m_mem</span>(mem)&#123;&#125;</span><br><span class="line">	~<span class="built_in">Computer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>) &#123; <span class="keyword">delete</span> m_cpu; m_cpu = <span class="literal">NULL</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>) &#123; <span class="keyword">delete</span> m_vc; m_cpu = <span class="literal">NULL</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>) &#123; <span class="keyword">delete</span> m_mem; m_cpu = <span class="literal">NULL</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (m_desc != <span class="literal">NULL</span>) &#123; <span class="keyword">delete</span> m_desc; m_desc = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">25</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt;<span class="string">&quot;开始组装&quot;</span> &lt;&lt; *m_desc &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_cpu-&gt;<span class="built_in">caculate</span>();</span><br><span class="line">		m_vc-&gt;<span class="built_in">show</span>();</span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">30</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="string">&quot;组装完成&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string* m_desc;</span><br><span class="line">	AbsCPU* m_cpu;</span><br><span class="line">	AbsVideoCard* m_vc;</span><br><span class="line">	AbsMemory* m_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test003</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第一台电脑零件</span></span><br><span class="line">	AbsCPU* intelCPU = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	AbsVideoCard* intelVideoCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	AbsMemory* intelMemory = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建第一台电脑</span></span><br><span class="line">	string* computer_name1 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Intel电脑&quot;</span>);</span><br><span class="line">	Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(computer_name1, intelCPU, intelVideoCard, intelMemory);</span><br><span class="line">	computer1-&gt;<span class="built_in">makeup</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二台电脑零件</span></span><br><span class="line">	AbsCPU* lenovoCPU = <span class="keyword">new</span> LenovoCPU;</span><br><span class="line">	AbsVideoCard* lenovoVideoCard = <span class="keyword">new</span> LenovoVideoCard;</span><br><span class="line">	AbsMemory* lenovoMemory = <span class="keyword">new</span> LenovoMemory;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建第二台电脑</span></span><br><span class="line">	string* computer_name2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Lenovo电脑&quot;</span>);</span><br><span class="line">	Computer* computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(computer_name2, lenovoCPU, lenovoVideoCard, lenovoMemory);</span><br><span class="line">	computer2-&gt;<span class="built_in">makeup</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建第三台电脑</span></span><br><span class="line">	string* computer_name3 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;混搭电脑  &quot;</span>);</span><br><span class="line">	<span class="comment">// 直接在传参过程中new对象</span></span><br><span class="line">	Computer* computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(computer_name3, <span class="keyword">new</span> IntelCPU, nw LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">	computer3-&gt;<span class="built_in">makeup</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test003</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h4><p>写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="comment">// 1.添加头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.创建流对象</span></span><br><span class="line">	fstream ofs;</span><br><span class="line">    <span class="comment">// 3.指定打开方式</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="comment">// 4.写入内容，endl后会换行</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 5.关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;水仙花数.txt&quot;</span>, ios::out);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">		<span class="type">int</span> hunderd = num / <span class="number">100</span>;</span><br><span class="line">		<span class="type">int</span> ten = num % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> n = num % <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pow</span>(hunderd, <span class="number">3</span>) + <span class="built_in">pow</span>(ten, <span class="number">3</span>) + <span class="built_in">pow</span>(n, <span class="number">3</span>) == num) &#123;</span><br><span class="line">			ofs &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">// 读取方式1</span></span><br><span class="line">	<span class="comment">//while (!ifs.eof())</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	ifs.getline(buffer, 1024);</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">// 读取方式2</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buffer)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//ifs.close();</span></span><br><span class="line">	<span class="comment">// 读取方式3</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buffer, sizeof(buffer)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">// 读取方式4:一次只读一个字符</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF) &#123;  <span class="comment">// EOF : end of file</span></span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二进制方式读写文件"><a href="#二进制方式读写文件" class="headerlink" title="二进制方式读写文件"></a>二进制方式读写文件</h4><p>写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">fstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	<span class="comment">// 写入</span></span><br><span class="line">	Person p = &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">18</span> &#125;;</span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	<span class="function">fstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123; cout &lt;&lt; <span class="string">&quot;打开文件失败&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="comment">// 读文件</span></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	<span class="comment">// 打印内容</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;\t年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><h5 id="1-并行计算-Pi-的值"><a href="#1-并行计算-Pi-的值" class="headerlink" title="1. 并行计算 Pi 的值"></a>1. 并行计算 Pi 的值</h5><p>以下代码展示了如何使用多进程并行计算 Pi 的值。该程序将计算过程分为多个进程并行执行，最后将结果合并得到 Pi 的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_PROCESSES = <span class="number">4</span>; <span class="comment">// 进程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATIONS = <span class="number">1000000000</span>; <span class="comment">// 迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_pi</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="type">double</span> x = (i + <span class="number">0.5</span>) / NUM_ITERATIONS;</span><br><span class="line">        sum += <span class="number">4.0</span> / (<span class="number">1.0</span> + x * x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PROCESSES; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">calculate_pi</span>(i * NUM_ITERATIONS / NUM_PROCESSES, (i + <span class="number">1</span>) * NUM_ITERATIONS / NUM_PROCESSES);</span><br><span class="line">            <span class="built_in">exit</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Error: fork failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PROCESSES; i++) &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_pid = <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) pi += <span class="built_in">WEXITSTATUS</span>(status);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Error: child process &quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot; failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pi is approximately &quot;</span> &lt;&lt; pi / NUM_ITERATIONS &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-生产者消费者模型"><a href="#2-生产者消费者模型" class="headerlink" title="2.生产者消费者模型"></a>2.生产者消费者模型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>; <span class="comment">// 缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITEMS = <span class="number">100</span>; <span class="comment">// 生产的数据数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">buffer</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> data[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce_item</span><span class="params">(<span class="type">int</span> item)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Producing item: &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_item</span><span class="params">(<span class="type">int</span> item)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Consuming item: &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(buffer* buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITEMS; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (buf-&gt;count == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">produce_item</span>(i);</span><br><span class="line">        buf-&gt;data[buf-&gt;count++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(buffer* buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITEMS; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (buf-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> item = buf-&gt;data[--buf-&gt;count];</span><br><span class="line">        <span class="built_in">consume_item</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buffer* buf = (buffer*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buffer), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (buf == MAP_FAILED) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: mmap failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf-&gt;count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">consumer</span>(buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: fork failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">producer</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot; exited with status &quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: child process &quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot; failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">munmap</span>(buf, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="1-并行计算Pi的值"><a href="#1-并行计算Pi的值" class="headerlink" title="1.并行计算Pi的值"></a>1.并行计算Pi的值</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// 线程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATIONS = <span class="number">1000000000</span>; <span class="comment">// 迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_pi</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="type">double</span> x = (i + <span class="number">0.5</span>) / NUM_ITERATIONS;</span><br><span class="line">        sum += <span class="number">4.0</span> / (<span class="number">1.0</span> + x * x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([i, &amp;pi]() &#123;</span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">calculate_pi</span>(i * NUM_ITERATIONS / NUM_THREADS, (i + <span class="number">1</span>) * NUM_ITERATIONS / NUM_THREADS);</span><br><span class="line">            pi += result;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pi is approximately &quot;</span> &lt;&lt; pi / NUM_ITERATIONS &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程的数量</span></span><br><span class="line">    <span class="type">int</span> m_thread_number;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line">    <span class="type">pthread_t</span> * m_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    <span class="type">int</span> m_max_requests; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求队列 按理说应当叫 m_requestqueue</span></span><br><span class="line">    std::list&lt; T* &gt; m_workqueue;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line">    locker m_queuelocker;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">    sem m_queuestat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否结束线程          </span></span><br><span class="line">    <span class="type">bool</span> m_stop;                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : </span><br><span class="line">        <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), </span><br><span class="line">        <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_detach</span>( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt; T &gt;::<span class="built_in">append</span>( T* request )&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>(); <span class="comment">// V</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt; T &gt;::<span class="built_in">worker</span>( <span class="type">void</span>* arg )&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt; T &gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>(); <span class="comment">// P</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/02/python/" rel="prev" title="python">
      <i class="fa fa-chevron-left"></i> python
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/03/GOLANG/" rel="next" title="GOLANG">
      GOLANG <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.</span> <span class="nav-text">类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E3%80%81%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">读、写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL"><span class="nav-number">5.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#stl-general"><span class="nav-number">5.1.</span> <span class="nav-text">stl general</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vector"><span class="nav-number">5.2.</span> <span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#priority-queue"><span class="nav-number">5.2.1.</span> <span class="nav-text">priority_queue</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#list"><span class="nav-number">5.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-number">5.4.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set"><span class="nav-number">5.5.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stack"><span class="nav-number">5.6.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#queue"><span class="nav-number">5.7.</span> <span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#deque"><span class="nav-number">5.7.1.</span> <span class="nav-text">deque</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#string"><span class="nav-number">5.8.</span> <span class="nav-text">string</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B7%E9%A2%98%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">6.</span> <span class="nav-text">刷题输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">刷题常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#to-string-int-x"><span class="nav-number">7.1.</span> <span class="nav-text">to_string(int x)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stoi-string-s"><span class="nav-number">7.2.</span> <span class="nav-text">stoi(string s)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reverse-iterator-begin-iterator-end"><span class="nav-number">7.3.</span> <span class="nav-text">reverse(iterator begin, iterator end)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#islower-x2F-isupper-x2F-isalpha-x2F-isdigit"><span class="nav-number">7.4.</span> <span class="nav-text">islower&#x2F; isupper&#x2F;isalpha&#x2F;isdigit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isalnum-char-ch"><span class="nav-number">7.5.</span> <span class="nav-text">isalnum(char ch)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tolower-char-ch-x2F-toupper-char-ch-x2F-tolower-string-s-x2F-toupper-string-s"><span class="nav-number">7.6.</span> <span class="nav-text">tolower(char ch)&#x2F;toupper(char ch) &#x2F;tolower(string s)&#x2F;toupper(string s)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#next-permutation-iterator-begin-iterator-end"><span class="nav-number">7.7.</span> <span class="nav-text">next_permutation(iterator begin, iterator end)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#prev-permutation-iterator-begin-iterator-end"><span class="nav-number">7.8.</span> <span class="nav-text">prev_permutation(iterator begin, iterator end)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#long-int-stol%EF%BC%88const-string%EF%BC%86str"><span class="nav-number">7.9.</span> <span class="nav-text">long int stol（const string＆str)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort-amp-amp-stable-sort"><span class="nav-number">7.10.</span> <span class="nav-text">sort &amp;&amp; stable_sort</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lower-bound-x2F-upper-bound"><span class="nav-number">7.11.</span> <span class="nav-text">lower_bound&#x2F; upper_bound</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#replace"><span class="nav-number">7.12.</span> <span class="nav-text">replace</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-Primer-Plus"><span class="nav-number">8.</span> <span class="nav-text">C++ Primer Plus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Example1"><span class="nav-number">9.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E6%96%B9%E4%BD%93"><span class="nav-number">9.2.</span> <span class="nav-text">正方体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%90%E6%9E%84"><span class="nav-number">9.3.</span> <span class="nav-text">析构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.</span> <span class="nav-text">常函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">9.5.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#x3D-%E9%87%8D%E8%BD%BD"><span class="nav-number">9.5.1.</span> <span class="nav-text">&#x3D; 重载</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">9.6.</span> <span class="nav-text">仿函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">9.7.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">9.7.1.</span> <span class="nav-text">计算器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%B5%E8%84%91"><span class="nav-number">9.7.2.</span> <span class="nav-text">电脑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">10.</span> <span class="nav-text">读写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">11.</span> <span class="nav-text">二进制方式读写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-Pi-%E7%9A%84%E5%80%BC"><span class="nav-number">12.1.</span> <span class="nav-text">1. 并行计算 Pi 的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.2.</span> <span class="nav-text">2.生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97Pi%E7%9A%84%E5%80%BC"><span class="nav-number">13.1.</span> <span class="nav-text">1.并行计算Pi的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">13.2.</span> <span class="nav-text">2.线程池</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kjg"
      src="/images/WechatIMG84.jpeg">
  <p class="site-author-name" itemprop="name">kjg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kjgggggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kjgggggg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/651373472@qq.com" title="E-Mail → 651373472@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
</div>

<span style="text-align:center;display:block;">
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span <div>wmr</div> </span>
</span>

        
<span style="text-align:center;display:block;">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问人数：
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider"></span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        本站总访问量： 
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
</span>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '16px',
  right: '28px',
  left: 'unset',
  time: '0.3s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
