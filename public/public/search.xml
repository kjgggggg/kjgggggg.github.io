<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.两数之和</title>
    <url>/2022/08/04/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i]) != mp.<span class="built_in">end</span>())&#123;	<span class="comment">// mp.end()指向最后元素下一个元素的迭代器</span></span><br><span class="line">                <span class="keyword">return</span> &#123;mp.<span class="built_in">find</span>(target-nums[i])-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        d = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span>[d[target-num],i]</span><br><span class="line">            <span class="keyword">else</span>: d[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2022/08/05/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：</p>
<p>输入：l1 &#x3D; [2, 4, 3],  l2 &#x3D; [5, 6, 4]<br>输出：[7, 0, 8]<br>解释：342 + 465 &#x3D; 807</p>
<p>示例 2：</p>
<p>输入：l1 &#x3D; [0],  l2 &#x3D; [0]<br>输出：[0]</p>
<p>示例 3：</p>
<p>输入：l1 &#x3D; [9, 9, 9, 9, 9, 9, 9],  l2 &#x3D; [9, 9, 9, 9]<br>输出：[8, 9, 9, 9, 0, 0, 0, 1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">dfs</span><span class="params">(ListNode* l, ListNode* r, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r &amp;&amp; !i) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        <span class="type">int</span> sum = (l ? l-&gt;val : <span class="number">0</span>) + (r ? r-&gt;val : <span class="number">0</span>) + i;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        node-&gt;next = <span class="built_in">dfs</span>(l ? l-&gt;next : <span class="literal">nullptr</span>, r ? r-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">l, r, i</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r <span class="keyword">and</span> <span class="keyword">not</span> i: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            s = (l.val <span class="keyword">if</span> l <span class="keyword">else</span> <span class="number">0</span>) + (r.val <span class="keyword">if</span> r <span class="keyword">else</span> <span class="number">0</span>) + i</span><br><span class="line">            node = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># Python中//是模运算，/是整除运算</span></span><br><span class="line">            node.<span class="built_in">next</span> = dfs(l.<span class="built_in">next</span> <span class="keyword">if</span> l <span class="keyword">else</span> <span class="literal">None</span>, r.<span class="built_in">next</span> <span class="keyword">if</span> r <span class="keyword">else</span> <span class="literal">None</span>, s // <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> dfs(l1, l2, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Self Attention</title>
    <url>/2022/07/31/Self-Attention/</url>
    <content><![CDATA[<h3 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/881659278403_.pic.jpg" alt="881659278403_.pic"></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30866925-c326e92942025a3a6c6b1e8b96ccc0ce.png" alt="30866925-c326e92942025a3a6c6b1e8b96ccc0ce"></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><img src="/2022/07/31/Self-Attention/30867091-d28fe5868178a62d9faab212486b474b.png" alt="30867091-d28fe5868178a62d9faab212486b474b"></p>
<h3 id="Muiltihead-Self-Attention"><a href="#Muiltihead-Self-Attention" class="headerlink" title="Muiltihead Self Attention"></a>Muiltihead Self Attention</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/image-20220801014946983.png" alt="image-20220801014946983"></p>
<h4 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30867156-2219b84d50e04f41dd60cbe13b2994ac.png" alt="30867156-2219b84d50e04f41dd60cbe13b2994ac"></p>
<ul>
<li>这里的 a i 和 a j 是同一个输入(可以理解为下图的X)</li>
</ul>
<h4 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h4><p><img src="/2022/07/31/Self-Attention/QQ20220801-015325.png" alt="QQ20220801-015325"></p>
<p><img src="/2022/07/31/Self-Attention/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjE0NjM2,size_16,color_FFFFFF,t_70-20220801020808429.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>八个头相当于八个不同的表征子空间，类似于apple拥有水果的含义，同时也有商标的含义，不同的含义由不同的表征子空间学习。</p>
</li>
<li><p>让其他词的Q来和apple这个词不同组的K-V进行attention。</p>
</li>
<li><p>再把所有的attention结果拼接起来，通过一个全连接层（矩阵变换）得到最终结果。</p>
</li>
<li><p>X是一开始经过Embedding的词向量矩阵，R为之前层输出的，他俩都可以进行Multihead Self Attention</p>
</li>
</ul>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>blog</title>
    <url>/2022/07/29/blog/</url>
    <content><![CDATA[<h3 id="Markdown基本操作"><a href="#Markdown基本操作" class="headerlink" title="Markdown基本操作"></a>Markdown基本操作</h3><ul>
<li>标题</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># A (一级标题)</span></span><br><span class="line"><span class="section">## A</span></span><br><span class="line"><span class="section">### A</span></span><br><span class="line"><span class="section">#### A</span></span><br><span class="line"><span class="section">##### A</span></span><br><span class="line"><span class="section">###### A （六级标题）</span></span><br></pre></td></tr></table></figure>



<ul>
<li>字体</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜粗体*</span>**</span></span><br></pre></td></tr></table></figure>



<ul>
<li>分割线、下划线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>脚注</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^鼠标移到我身上]：会弹出我！</span><br></pre></td></tr></table></figure>



<ul>
<li>列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项		</span><br><span class="line"><span class="bullet">*</span> 第二项		</span><br><span class="line"><span class="bullet">*</span> 第三项   </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项		</span><br><span class="line"><span class="bullet">-</span> 第二项		</span><br><span class="line"><span class="bullet">-</span> 第三项  </span><br></pre></td></tr></table></figure>



<ul>
<li>最左边的竖线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; </span></span><br></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`print()`</span> </span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>



<ul>
<li>链接</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>图片</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>表格</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line"></span><br><span class="line">我们可以设置表格的对齐方式：</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>



<h3 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a>Hexo基本操作</h3><ul>
<li>发布文章</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure>

<p>去&#x2F;Users&#x2F;jiangangkong&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;文章名.md 下写文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li>每篇文章下最大的标题为三级标题</li>
<li>并列关系用 * </li>
<li>顺序关系用1. 2. </li>
<li>文章开头的信息里（tags，categories，descriptions后面要加‘空格）否则会报错</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP</title>
    <url>/2022/08/03/CPP/</url>
    <content><![CDATA[<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span> &amp;a,<span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//声明一个模板，告诉编译器后面紧跟着的代码中的T不要报错，T是一个通用数据类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//两种方式使用函数模板 1.自动类型推导：mySwap(a,b)  2.显示指定类型：mySwap&lt;int&gt;(a,b)</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt; a&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> c=<span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(c,d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span> &lt;&lt; c&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;d=&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数模板注意事项：</span></span><br><span class="line"><span class="comment">1.自动类型推导，必须推导出一致的数据类型T才可以使用,就是这部分所有T对应一种类型</span></span><br><span class="line"><span class="comment">2.模板必须要确定出T的数据类型才能使用。 就是函数体要有T，如果没有，要使用显示指定类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">普通函数与函数模板的区别：</span></span><br><span class="line"><span class="comment">普通函数调用时，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">int myAdd(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void test()&#123;</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    int b = 20;</span></span><br><span class="line"><span class="comment">    char c = &#x27;c&#x27;; //A-65 a-97 </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; myAdd(a,c)&lt;&lt; endl;  //隐式类型转换，将字符型变量转换成了整型变量</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">函数模板调用时，如果可以利用自动类型推导，则不会发生隐式类型转换；若使用显示指定类型，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line"><span class="comment">函数模板也可以重载,并且如果普通函数和函数模板都可以调用，优先调用普通函数</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">void A(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ab&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;AB&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3,是对2的重载</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b,T c)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ABC&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时会调用1，但可以通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a=10,b=20;</span></span><br><span class="line"><span class="comment">    A&lt;&gt;(a,b);//通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T name,U age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T name;</span><br><span class="line">        U age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、类模板和函数模板的区别：</span></span><br><span class="line"><span class="comment">//1.类模板没有自动类型推导的使用方法 2.类模板在模板参数列表中可以有默认参数 template&lt;class T, class U = int&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、类模板中成员函数创建时机：普通类中的成员函数一开始就可以创建，类模板中的成员函数在调用时才创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、类模板对象做函数参数：</span></span><br><span class="line"><span class="comment">//一共有三种传入方式：1.指定传入的类型 2.参数模板化 3.整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.指定传入的类型 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.整个类模板化，建议使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、类模板与继承:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Son:public Base&#123;&#125;;   错误，需要指定Base的T类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想灵活指定父类中T类型，子类也需要变类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">public</span> Base&lt;T1&gt;&#123;</span><br><span class="line">    T2 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、类模板成员函数类外实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person1</span>(T3 name,T4 age);</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     this-&gt;name=name;this-&gt;age=age;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        T3 name;</span><br><span class="line">        T4 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line">Person1&lt;T3,T4&gt;::<span class="built_in">Person1</span>(T3 name,T4 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="type">void</span> Person1&lt;T3,T4&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sb&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  七、类模板分文件编写</span></span><br><span class="line"><span class="comment">//问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</span></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="comment">// 1.直接包含.cpp源文件:</span></span><br><span class="line"><span class="comment">//一般把类及其方法的声明放在.h文件中，把实现放在.cpp文件中。 </span></span><br><span class="line"><span class="comment">// 三个文件：person.h;person.cpp;main.cpp  在person.cpp中要写#include&quot;person.h&quot;  在main.cpp中要包含#include&quot;person.cpp&quot;</span></span><br><span class="line"><span class="comment">// 2.将声明和实现写到同一文件中，并更改后缀名为.hpp。hpp是业界约定，不是必须。 然后在main.cpp中包含#include&quot;person.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、类模板与友元</span></span><br><span class="line"><span class="comment">//掌握类模板配合友元函数的类内和类外实现</span></span><br><span class="line"><span class="comment">//全局函数类内实现：直接在类内声明友元即可   </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"><span class="comment">template&lt;class T5 , class T6&gt;</span></span><br><span class="line"><span class="comment">class Person2&#123;</span></span><br><span class="line"><span class="comment">    //全局函数 类内实现  friend关键字能访问private数据</span></span><br><span class="line"><span class="comment">    friend void printPerson()&#123;Person2&lt;T5,T6&gt; p&#125;&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot; age:&quot; &lt;&lt; p.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person2(T5 name,T6 age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    private:</span></span><br><span class="line"><span class="comment">        T5 name;</span></span><br><span class="line"><span class="comment">        T6 age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    Person2&lt;string,int&gt;p(&quot;aaa&quot;,18);</span></span><br><span class="line"><span class="comment">    printPerson(p);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//全局函数类外实现：需要提前让编译器知道全局函数的存在(较难)</span></span><br></pre></td></tr></table></figure>



<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">重载操作符的类的对象叫函数对象，重载的是()时，又叫仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、特点：</span></span><br><span class="line"><span class="comment">1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="comment">2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="comment">3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v1+v2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myadd myadd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Myprint</span>()&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count; <span class="comment">//内部自己状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myprint调用的次数是&quot;</span> &lt;&lt; myprint.count &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(Myprint &amp;mp,string s)</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    Myprint mp2;</span><br><span class="line">    <span class="built_in">doPrint</span>(mp2,<span class="string">&quot;cnm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、谓词</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回bool类型的仿函数称为谓词</span></span><br><span class="line"><span class="comment">如果operator接受一个参数，叫做一元谓词</span></span><br><span class="line"><span class="comment">如果operator接受两个参数，叫做二元谓词</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、内建函数对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stl内建了一些函数对象，能够拿来直接使用。这些仿函数所产生的对象，用法和一般函数完全相同。</span></span><br><span class="line"><span class="comment">使用内建函数对象需要包含#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">分类：算数，关系，逻辑仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.算数仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T plus&lt;T&gt;;        //加    plus&lt;int&gt; p; cout &lt;&lt; p(10,20) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T minus&lt;T&gt;;       //减</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T multiplies&lt;T&gt;;  //乘</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T divides&lt;T&gt;;     //除</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T modulus&lt;T&gt;;     //取模</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T negate&lt;T&gt;;      //取反 negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.关系仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt;;    //   greater&lt;int&gt;() 等价于之前的自定义的 Mycompare       greater&lt;int&gt;()要加()，代表对象的创建。</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.逻辑仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt;;      //与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt;;       //或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt;;      //非</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file readbinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief 读取二进制数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>]; </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p;<span class="comment">//接住读出的数据</span></span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));  <span class="comment">//函数原型：istream&amp; read(char * buffer,int len);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"><span class="comment">//文件类型有两种 1.文本文件：文件以文本的ASCII码形式存储在计算机中 2.二进制文件：文件以文本的二进制形式存储在计算机中，不能直接读懂</span></span><br><span class="line"><span class="comment">//操作文件的三大类  ofstream：写操作  ifstream：读操作  fstream：读写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件步骤——“包流开写闭”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #include &lt;fstream&gt;   //包含头文件</span></span><br><span class="line"><span class="comment">    ofstream ofs;      //创建流对象</span></span><br><span class="line"><span class="comment">    ofs.open(&quot;文件路径&quot;，打开方式);     //打开文件</span></span><br><span class="line"><span class="comment">    ofs &lt;&lt; &quot;写入的数据&quot;;     //写数据</span></span><br><span class="line"><span class="comment">    ofs.close();    //关闭文件</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件打开方式：</span></span><br><span class="line"><span class="comment">    ios::in         //为读文件而打开文件</span></span><br><span class="line"><span class="comment">    i0s::out        //为写文件而打开文件</span></span><br><span class="line"><span class="comment">    ios::ate        //初始位置：文件尾</span></span><br><span class="line"><span class="comment">    ios::app        //追加方式写文件</span></span><br><span class="line"><span class="comment">    ios::trunc      //如果文件存在，则先删除再创建</span></span><br><span class="line"><span class="comment">    ios::binary     //二进制方式</span></span><br><span class="line"><span class="comment">    ios::binary | ios::out      //用二进制方式写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test01.txt&quot;</span>,ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;name:kongjiangang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;gender:male&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file writebinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief  向二进制文件写数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包流开操闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//函数原型： ostream&amp; write(const char * buffer,int len);</span></span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><h5 id="stl-general"><a href="#stl-general" class="headerlink" title="stl general"></a>stl general</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl:标准模板库</span></span><br><span class="line"><span class="comment">//stl从广义上分为容器,算法,迭代器。 容器和算法通过迭代器无缝衔接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl六大组件:容器,算法,迭代器,仿函数,适配器(配接器),空间配置器</span></span><br><span class="line"><span class="comment">//1.容器:分为序列式容器(强调值的排序)和关联式容器(二叉树)。各种数据结构,如vector,list,deque,set,map等，用来存放数据</span></span><br><span class="line"><span class="comment">//2.算法:分为质变算法(拷贝，置换，删除)和非质变算法(查找，计数，遍历)。常用的函数,如sort,find,copy,for_each等</span></span><br><span class="line"><span class="comment">//3.迭代器:分为(输入(对数据只读),输出(对数据只写),前向,双向,随机访问)迭代器。能按序访问某个容器内所含元素又不暴露该容器内部表示方法。</span></span><br><span class="line"><span class="comment">//4.仿函数:行为类似函数,可作为算法的某种策略</span></span><br><span class="line"><span class="comment">//5.适配器:不做要求</span></span><br><span class="line"><span class="comment">//6.空间配置器:负责空间的配置与管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、容器算法迭代器初识：vector存放内置数据类型</span></span><br><span class="line"><span class="comment">//容器：vector 算法：for_each 迭代器：vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> <span class="comment">//需要包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//同上</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器中插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>(); <span class="comment">//起始迭代器，指向容器中的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();     <span class="comment">//结束迭代器，指向容器中的最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span> (itBegin != itEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种遍历方式，利用for_each算法,回掉</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),myPrint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、vector存放自定义数据类型,同一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容器中再嵌套一个容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="comment">//创建小容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在小容器中插入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小容器插入到大容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过大容器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator iterator=v.<span class="built_in">begin</span>();iterator!=v.<span class="built_in">end</span>();iterator++)&#123;</span><br><span class="line">        <span class="comment">//(*iterator) 是一维数组</span></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit=(*iterator).<span class="built_in">begin</span>();vit!=(*iterator).<span class="built_in">end</span>();vit++)</span><br><span class="line">            cout&lt;&lt; (*vit) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector,也称单端数组</span></span><br><span class="line"><span class="comment">//vector与普通数组区别:不同之处是数组是静态空间，而vector可以动态扩展</span></span><br><span class="line"><span class="comment">//vector容器的迭代器是支持随机访问的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v;</span></span><br><span class="line"><span class="comment">vector(v.begin(),v.end());      //将v[begin(),end()]区间中的元素赋值给vector，如 vector&lt;int&gt; v2(v1.begin(),v1.end());</span></span><br><span class="line"><span class="comment">vector(n,elem);     //初始值为n个elem</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">assign(begin,end);      //v2.assign(v1.begin(),v.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);     //v3.assign(10,20);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容量和大小</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">empty();        //判断容器是否为空</span></span><br><span class="line"><span class="comment">capicity();     //容器的容量，不是创建vector，插入10个元素容量就为10，可能为16</span></span><br><span class="line"><span class="comment">size();     //返回容器中元素数量</span></span><br><span class="line"><span class="comment">resize(int num);        //重新指定容器长度，若容器变长，则以默认值填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num,elem);       //重新指定容器长度，若容器变长，则以elem填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">pop_back();     //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos,elem);    </span></span><br><span class="line"><span class="comment">insert(const_iterator pos,int n,elem);       //在pos处插入n个elem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(const_iterator pos);      //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator begin,onst_iterator end);      //删除begin到end间的所有元素</span></span><br><span class="line"><span class="comment">clear();        //删除容器内所有元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、数据存取</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">at(int idx);</span></span><br><span class="line"><span class="comment">operator[];     // vector&lt;int&gt; v; cout &lt;&lt; v[n] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">front();        //返回容器内第一个元素</span></span><br><span class="line"><span class="comment">back();     //返回容器内最后一个元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、互换容器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">swap(vec);      //将vec与本身的元素进行互换 v1.swap(v2);</span></span><br><span class="line"><span class="comment">v.resize(3);vector&lt;int&gt;(v).swap(v);     //巧用swap收缩内存，vector&lt;int&gt;(v)是匿名对象，拷贝构造函数，同时匿名对象自动析构。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、预留空间</span></span><br><span class="line"><span class="comment">//减少vector在动态扩展容量时的扩展次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">reserve(int len);       //容器预留len个元素长度，但预留位置不初始化，且元素不可访问。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">list(链表，stl中的链表是一个双向循环链表，每个结点都有data,prev,next域)常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">list&lt;T&gt; l;</span></span><br><span class="line"><span class="comment">list(begin,end);        //拷贝构造函数,list&lt;int&gt; l2(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">list(n,elem);       </span></span><br><span class="line"><span class="comment">list(const list &amp;l);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换：</span></span><br><span class="line"><span class="comment">assign(begin,end);      //list&lt;int&gt; l2; l2.assign(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;l);</span></span><br><span class="line"><span class="comment">swap(l)     //将l与本身的元素互换  l1.swap(l2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">resize(num);</span></span><br><span class="line"><span class="comment">resize(num,elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、插入和删除：</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">push_front(elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pop_back();</span></span><br><span class="line"><span class="comment">pop_front();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insert(pos,elem);       //返回新数据的位置</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);     //无返回值</span></span><br><span class="line"><span class="comment">insert(pos,begin,end);      //无返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个数据的位置</span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个数据的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">remove(elem);       //移除所有与elem匹配的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">clear();        //移除容器中所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、数据存取</span></span><br><span class="line"><span class="comment">front();</span></span><br><span class="line"><span class="comment">back();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、反转和排序</span></span><br><span class="line"><span class="comment">reverse();</span></span><br><span class="line"><span class="comment">sort();</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">map &amp; multimap 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map基本概念：</span></span><br><span class="line"><span class="comment">1.map中的所有元素都是pair</span></span><br><span class="line"><span class="comment">2.pair中的第一个元素为key，起索引作用。第二个元素为value(实际值)</span></span><br><span class="line"><span class="comment">3.所有元素都会根据元素的键值自动排序</span></span><br><span class="line"><span class="comment">4.map &amp; multimap区别：map不允许容器中有重复key值的元素，multimap允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造与赋值</span></span><br><span class="line"><span class="comment">map&lt;T1,T2&gt; mp;</span></span><br><span class="line"><span class="comment">map(const map &amp;mp);     </span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp);      //返回值是一个map的引用变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(mp);       //mp1.swap(mp2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);       //map&lt;int,int&gt; mp1;  mp1.insert(pair&lt;int,int&gt;(1,20));</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(key);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回mp.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、排序</span></span><br><span class="line"><span class="comment">默认按key值从小到大排序，但可以通过仿函数改变</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">map&lt;int,int,MyCompare&gt; mp;      //指定排序规则</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">set &amp; multiset 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">set基本概念：</span></span><br><span class="line"><span class="comment">1.所有元素都会在插入时自动被排序</span></span><br><span class="line"><span class="comment">2.set/multiset是关联式容器，底层用二叉树实现</span></span><br><span class="line"><span class="comment">3.set和multiset区别：set不允许容器中有相同元素，multiset允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st;</span></span><br><span class="line"><span class="comment">set(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(st);       //st1.swap(st2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(elem);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回st.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、set和multiset的区别</span></span><br><span class="line"><span class="comment">set插入数据时会返回是否插入成功，multiset不会</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、pair 对组的创建</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p(value1,value2);       //p.first和p.second分别访问不同部分</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p = make_pair(value1,value2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">八、set容器排序</span></span><br><span class="line"><span class="comment">学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</span></span><br><span class="line"><span class="comment">主要技术点：利用仿函数可以改变排序规则</span></span><br><span class="line"><span class="comment">1.set中存放内置数据类型</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">set&lt;int,MyCompare&gt; s2;      //指定排序规则</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.set中存放自定义数据类型</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person(string name,int age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        string name;</span></span><br><span class="line"><span class="comment">        int age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">class MyCompare2&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(const Person &amp;p1,const Person &amp;p2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return p1.age&gt;p2.age;       //按年龄降序排列</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    set&lt;Person,MyCompare2&gt; st;</span></span><br><span class="line"><span class="comment">    Person p1(&quot;lisi&quot;,19);</span></span><br><span class="line"><span class="comment">    Person p2(&quot;lisiguang&quot;,20);</span></span><br><span class="line"><span class="comment">    st.insert(p1);</span></span><br><span class="line"><span class="comment">    st.insert(p2);</span></span><br><span class="line"><span class="comment">    //迭代器输出，省略……</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stack常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; s;</span></span><br><span class="line"><span class="comment">stack(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);</span></span><br><span class="line"><span class="comment">pop();      //移除栈顶元素</span></span><br><span class="line"><span class="comment">top();      //返回栈顶元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">queue常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; q;</span></span><br><span class="line"><span class="comment">queue(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//char*是一个指针；string是一个类，类内部封装了char*，是一个char*型的容器</span></span><br><span class="line"><span class="comment">//string类内部封装了很多成员方法，如find，copy，delete，replace，insert。 string类管理char*所分配的内存，不用担心复制越界和取值越界，由类内部负责管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string();      //创建一个空的字符串，例如string str;</span></span><br><span class="line"><span class="comment">string(const char* s);     //使用字符串s初始化，如   char* str = &quot;hello world&quot;; string s(str);</span></span><br><span class="line"><span class="comment">string(const string&amp; str);     //使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="comment">string(int n,char c);      //使用n个字符c初始化 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char* s);       //string str = &quot;aaa&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const string&amp; s);         //string str1 =str;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char c);        //strng str = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s);      //string str2; str2.assign(&quot;aaaaa&quot;);</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s,int n);        //把字符串s的前n个字符赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(const string &amp;s);        //把字符串s赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(int n,char c);       //用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、拼接</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char* str);       //string str=&quot;我&quot;; str+=&quot;爱玩游戏&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char c);         //string str=&quot;我&quot;; str+=&#x27;艹&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const &amp;string str);        //str1 += str2;</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s);      //string str=&quot;我&quot;; str.append(&quot;爱玩游戏&quot;);</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s,int n);        //把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s);        //str1.append(str2);</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s,int pos,int n);       //把字符串s从pos开始n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、查找和替换</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int find(const string&amp; str,int pos=0) const;        //查找str第一次出现的位置，从pos开始寻找。不写pos默认为0</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos=0) const;        //查找s第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos,int n) const;        //查找s的前n个字符第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char c ,int pos=0) const;        //查找字符c第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str,int pos=npos) const;        //查找str最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos=npos) const;        //查找s最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos,int n) const;        //查找s的前n个字符最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char c ,int pos=0) const;        //查找字符c最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const string&amp; str);       //替换从pos开始的n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const char* s);       //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、比较</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串是按字符的ASCII进行比较 =返回0;&gt;返回1;&lt;返回-1</span></span><br><span class="line"><span class="comment">int compare(const string&amp; s) const;</span></span><br><span class="line"><span class="comment">int compare(const char* s) const;   </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、获取(也可以赋值，修改)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n);        //通过[]方式获取字符 cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">char&amp; at(int n);        //通过at获取字符  cout &lt;&lt; str.at(i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const char* s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const string&amp; s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,int n,char c);       //在指定pos插入n个c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; erase(int pos,int n=npos);      //删除从pos开始的n个字符 ，nopos表示不存在的位置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、获取子串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string substr(int pos = 0;int n = npos) const;        //返回由pos开始n个字符组成的子串  </span></span><br><span class="line"><span class="comment">                                                      //如string str=&quot;abcdef&quot;; cout &lt;&lt; str.substr(1,3) &lt;&lt; endl;返回&quot;bcd&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2022/08/02/python/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&quot;Zhihu&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取第二位</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1:-2]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>result：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]:  Runoob</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>]:  [<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第三个元素为 :  <span class="number">1997</span></span><br><span class="line">更新后的第三个元素为 :  <span class="number">2001</span></span><br><span class="line">更新后的列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="append与extend的区别"><a href="#append与extend的区别" class="headerlink" title="append与extend的区别"></a>append与extend的区别</h4><ul>
<li>ist.append(object) 向列表中添加一个对象object</li>
<li>list.extend(sequence) 把一个序列seq的内容添加到列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista = [<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listb = [<span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista.extend(listb)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista</span><br><span class="line">[<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>, <span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;原始列表 : &quot;</span>, <span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原始列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">删除第三个元素 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure>



<h4 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h4><table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print(x, end&#x3D;” “)</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h4 id="列表截取与拼接"><a href="#列表截取与拼接" class="headerlink" title="列表截取与拼接"></a>列表截取与拼接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">输出从第二个元素开始后的所有元素</td>
</tr>
</tbody></table>
<h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="列表比较"><a href="#列表比较" class="headerlink" title="列表比较"></a>列表比较</h4><p>列表比较需要引入 <strong>operator</strong> 模块的 <strong>eq</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 operator 模块</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">c = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(a,b): &quot;</span>, operator.eq(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(c,b): &quot;</span>, operator.eq(c,b))</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">operator.eq(a,b):  <span class="literal">False</span></span><br><span class="line">operator.eq(c,b):  <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h4><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td>
</tr>
</tbody></table>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典是另一种可变容器模型，且可存储任意类型对象。</span></span><br><span class="line"><span class="comment"># 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 &#123;&#125; 中 ,格式如下所示：</span></span><br><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 键必须是唯一的，但值则不必。</span></span><br><span class="line"><span class="comment"># 值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的字典实例：</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可如此创建字典：</span></span><br><span class="line">tinydict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">tinydict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h4 id="访问具体的值"><a href="#访问具体的值" class="headerlink" title="访问具体的值"></a>访问具体的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="comment"># tinydict[&#x27;Age&#x27;]:  7</span></span><br></pre></td></tr></table></figure>

<h4 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h4><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  小菜鸟</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(dict) 计算字典元素个数，即键的总数。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">str(dict) 输出字典，可以打印的字符串表示。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">pop(key[,default])</a> 删除字典 key（键）所对应的值，返回被删除的值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody></table>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li><em>Numpy</em> 是 <em>Python</em> 中科学计算的核心库，<em>NumPy</em> 这个词来源于 <em>Numerical</em> 和 <em>Python</em> 两个单词。它提供了一个高性能的多维<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>对象，以及大量的库函数和操作，可以帮助程序员轻松地进行数值计算，广泛应用于机器学习模型、图像处理和计算机图形学、数学任务等领域。</li>
</ul>
<h4 id="Numpy数组：ndarray"><a href="#Numpy数组：ndarray" class="headerlink" title="Numpy数组：ndarray"></a>Numpy数组：ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型，它是描述相同类型的元素集合。ndarray 中的每个元素都是数据类型对象(dtype)的对象。ndarray 中的每个元素在内存中使用相同大小的块。</span></span><br><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>object	任何暴露数组接口方法的对象</p>
</li>
<li><p>dtype	数据类型</p>
</li>
<li><p>copy	如果为 True，则 object 对象被复制，否则，只有当array返回副本，object 是嵌套序列，或者需要副本来满足任何其他要求（dtype，order等）时，才会生成副本。</p>
</li>
<li><p>order	指定阵列的内存布局。 如果 object 不是数组，则新创建的数组将按行排列（C），如果指定了（F），则按列排列。 如果 object 是一个数组，则以下成立。C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）</p>
</li>
<li><p>subok	默认情况下，返回的数组被强制为基类数组。 如果为 True，则返回子类。</p>
</li>
<li><p>ndmin	返回数组的最小维数</p>
</li>
</ul>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="comment"># 注意：list 打印显示是 [1, 2, 3]，而 ndarray 打印显示是 [1 2 3]，当中没有逗号。</span></span><br></pre></td></tr></table></figure>



<h5 id="例2-dtype-参数用法示例"><a href="#例2-dtype-参数用法示例" class="headerlink" title="例2:dtype 参数用法示例"></a>例2:dtype 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, dtype=np.float_)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">b = np.array(a, dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">float64</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.float64&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h5 id="例3-copy-参数的用法"><a href="#例3-copy-参数的用法" class="headerlink" title="例3:copy 参数的用法"></a>例3:copy 参数的用法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">True</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 可以看到 a 和 b 的值不同，说明 b 是 a 的副本，两个是不同的对象。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">False</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a 改变同时引起了 b 的改变，说明 a 和 b 指向的是同一个对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="例4：ndmin-参数用法示例"><a href="#例4：ndmin-参数用法示例" class="headerlink" title="例4：ndmin 参数用法示例"></a>例4：ndmin 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, ndmin=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>



<h5 id="例5：subok-参数用法示例"><a href="#例5：subok-参数用法示例" class="headerlink" title="例5：subok 参数用法示例"></a>例5：subok 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.matrix(<span class="string">&#x27;1 2 7; 3 4 8; 5 6 9&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">at = np.array(a, subok=<span class="literal">True</span>)</span><br><span class="line">af = np.array(a, subok=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(at))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(af))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">9</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h4><ul>
<li>ndarray.ndim	秩，即轴的数量或维度的数量</li>
<li>ndarray.shape	数组的维度，对于矩阵，n 行 m 列</li>
<li>ndarray.size	数组元素的总个数，相当于 .shape 中 n*m 的值</li>
<li>ndarray.dtype	ndarray 对象的元素类型</li>
<li>ndarray.itemsize	ndarray 对象中每个元素的大小，以字节为单位</li>
<li>ndarray.flags	ndarray 对象的内存信息</li>
<li>ndarray.real	ndarray 元素的实部（复数的实部）</li>
<li>ndarray.imag	ndarray 元素的虚部（复数的虚部）</li>
<li>ndarray.data	包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h4 id="Numpy中的常数"><a href="#Numpy中的常数" class="headerlink" title="Numpy中的常数"></a>Numpy中的常数</h4><ul>
<li>正无穷：Inf &#x3D; inf &#x3D; infty &#x3D; Infinity &#x3D; PINF</li>
<li>负无穷：NINF</li>
<li>正零：PZERO</li>
<li>负零：NZERO</li>
<li>非数值：nan &#x3D; NaN &#x3D; NAN</li>
<li>自然数e：e</li>
<li>π：pi</li>
<li>伽马：euler_gamma</li>
<li>None 的别名：newaxis</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.inf)</span><br><span class="line"><span class="built_in">print</span>(np.NINF)</span><br><span class="line"><span class="built_in">print</span>(np.PZERO)</span><br><span class="line"><span class="built_in">print</span>(np.NZERO)</span><br><span class="line"><span class="built_in">print</span>(np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.e)</span><br><span class="line"><span class="built_in">print</span>(np.pi)</span><br><span class="line"><span class="built_in">print</span>(np.euler_gamma)</span><br><span class="line"><span class="built_in">print</span>(np.newaxis)</span><br><span class="line"><span class="comment"># inf</span></span><br><span class="line"><span class="comment"># -inf</span></span><br><span class="line"><span class="comment"># 0.0</span></span><br><span class="line"><span class="comment"># -0.0</span></span><br><span class="line"><span class="comment"># nan</span></span><br><span class="line"><span class="comment"># 2.718281828459045</span></span><br><span class="line"><span class="comment"># 3.141592653589793</span></span><br><span class="line"><span class="comment"># 0.5772156649015329</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h4><h5 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方法用来创建一个指定维度（shape）、数据类型（dtype）的未初始化的数组。</span></span><br><span class="line">numpy.empty(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.empty([<span class="number">3</span>, <span class="number">2</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="numpy-full"><a href="#numpy-full" class="headerlink" title="numpy.full"></a>numpy.full</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回给定维度和类型的新数组，填充 fill_value。</span></span><br><span class="line">numpy.full(shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>



<h4 id="Numpy从数值范围创建数组"><a href="#Numpy从数值范围创建数组" class="headerlink" title="Numpy从数值范围创建数组"></a>Numpy从数值范围创建数组</h4><h5 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该函数等效于 Python 内置 range 函数，但返回的是 ndarray 而不是列表。</span></span><br><span class="line">arange([start,] stop[, step,], dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个一维等差数列的数组，与 arange 函数不同，arange 是固定步长，而 linspace 则是固定元素数量。</span></span><br><span class="line">linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span>]</span><br><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span> <span class="number">5.</span>        ]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.logspace 函数用于创建一个等比数列。</span></span><br><span class="line">numpy.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值为：base ** start （幂运算）</li>
<li>stop	序列的终止值为：base ** stop。如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的等步长的样本数量，默认为50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>base	对数 log 的底数。</li>
<li>dtype	ndarray 的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.logspace(<span class="number">1</span>, <span class="number">4</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [   10.   100.  1000. 10000.]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-geomspace"><a href="#numpy-geomspace" class="headerlink" title="numpy.geomspace"></a>numpy.geomspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.geomspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值</li>
<li>stop	序列的终止值，如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的样本数量，默认为 50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>dtype	ndarray 的数据类型</li>
<li>axis	1.16.0 版本中的新功能 ，没看懂怎么用，官网上连个例子都没有，值为 0 和 -1 的时候结果相同，其他时候都报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.geomspace(<span class="number">1</span>, <span class="number">8</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1. 2. 4. 8.]</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy从已有的数组创建数组"><a href="#Numpy从已有的数组创建数组" class="headerlink" title="Numpy从已有的数组创建数组"></a>Numpy从已有的数组创建数组</h4><h5 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.asarray 类似 numpy.array，但 numpy.asarray 的参数只有三个。</span></span><br><span class="line">numpy.asarray(a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>a</th>
<th>输入数据，可以转换为数组的任何形式。 这包括列表，元组列表，元组，元组元组，列表元组和 ndarray。</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>数据类型</td>
</tr>
<tr>
<td>order</td>
<td>在计算机内存中的存储元素的顺序，只支持 ‘C’（按行）、‘F’（按列），默认 ‘C’</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</span></span><br><span class="line">numpy.frombuffer(buffer, dtype=<span class="built_in">float</span>, count=-<span class="number">1</span>, offset=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>buffer</th>
<th>实现了 <code>__buffer__</code> 方法的对象，（绝对不是菜鸟教程上说的任意对象都可以）</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>返回数组的数据类型</td>
</tr>
<tr>
<td>count</td>
<td>读取的数据数量，默认为 -1，读取所有数据。</td>
</tr>
<tr>
<td>offset</td>
<td>读取的起始位置，默认为 0。</td>
</tr>
</tbody></table>
<p>例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</span></span><br><span class="line">a = np.frombuffer(<span class="string">b&#x27;Hello World&#x27;</span>, dtype=<span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [b&#x27;H&#x27; b&#x27;e&#x27; b&#x27;l&#x27; b&#x27;l&#x27; b&#x27;o&#x27; b&#x27; &#x27; b&#x27;W&#x27; b&#x27;o&#x27; b&#x27;r&#x27; b&#x27;l&#x27; b&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>



<p>例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">a = array.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">na = np.frombuffer(a, dtype=np.int_)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line"><span class="comment">#array.array 创建的数组对象内存是连续的（这里不能用 list，会报：AttributeError: ‘list’ object has no attribute ‘buffer’）</span></span><br><span class="line"><span class="comment"># numpy.frombuffer 从 array.array 的内存中创建数组，从上例中可以看出，改变 array.array 的值，numpy.frombuffer 的值也会跟着改变，由此可见。</span></span><br><span class="line"><span class="comment"># array.array 数组中的值改变是可以的，但是如果是添加值，那就不行了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [1, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [1 2 3 4]</span></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [10, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [10  2  3  4]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a>numpy.fromiter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</span></span><br><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">iterable = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">a = np.fromiter(iterable, <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 0  1  4  9 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看起来有点像 numpy.array，array 方法需要传入的是一个 list，而 fromiter 可以传入可迭代对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-empty-like"><a href="#numpy-empty-like" class="headerlink" title="numpy.empty_like"></a>numpy.empty_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty_like(prototype, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-zeros-like"><a href="#numpy-zeros-like" class="headerlink" title="numpy.zeros_like"></a>numpy.zeros_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-ones-like"><a href="#numpy-ones-like" class="headerlink" title="numpy.ones_like"></a>numpy.ones_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-full-like"><a href="#numpy-full-like" class="headerlink" title="numpy.full_like"></a>numpy.full_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.full_like(a, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer pytorch</title>
    <url>/2022/08/01/Transformer-pytorch/</url>
    <content><![CDATA[<h3 id="Transformer概览"><a href="#Transformer概览" class="headerlink" title="Transformer概览"></a>Transformer概览</h3><p><img src="/2022/08/01/Transformer-pytorch/901659325530_.pic_%E5%89%AF%E6%9C%AC.png" alt="901659325530_.pic"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="comment"># === Pytorch手写Transformer完整代码</span></span><br><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"></span><br><span class="line">device = <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="comment"># device = &#x27;cuda&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># transformer epochs</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我没有用什么大型的数据集，而是手动输入了两对中文→英语的句子</span></span><br><span class="line"><span class="comment"># 还有每个字的索引也是我手动硬编码上去的，主要是为了降低代码阅读难度</span></span><br><span class="line"><span class="comment"># S: Symbol that shows starting of decoding input</span></span><br><span class="line"><span class="comment"># E: Symbol that shows starting of decoding output</span></span><br><span class="line"><span class="comment"># P: Symbol that will fill in blank sequence if current batch data size is short than time steps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># 中文和英语的单词个数不要求相同</span></span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 一 个 好 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have a good friend .&#x27;</span>, <span class="string">&#x27;i have a good friend . E&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have zero girl friend .&#x27;</span>, <span class="string">&#x27;i have zero girl friend . E&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集（希望transformer能达到的效果）</span></span><br><span class="line"><span class="comment"># 输入：&quot;我 有 一 个 女 朋 友&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;i have a girlfriend&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文和英语的单词要分开建立词库</span></span><br><span class="line"><span class="comment"># Padding Should be Zero</span></span><br><span class="line">src_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;我&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;有&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;一&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;个&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;好&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;朋&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;友&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;零&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;女&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">src_idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(src_vocab)&#125;</span><br><span class="line">src_vocab_size = <span class="built_in">len</span>(src_vocab)</span><br><span class="line"></span><br><span class="line">tgt_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;have&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;good&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;friend&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;zero&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;girl&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(tgt_vocab)&#125;</span><br><span class="line">tgt_vocab_size = <span class="built_in">len</span>(tgt_vocab)</span><br><span class="line"></span><br><span class="line">src_len = <span class="number">8</span>  <span class="comment"># （源句子的长度）enc_input max sequence length</span></span><br><span class="line">tgt_len = <span class="number">7</span>  <span class="comment"># dec_input(=dec_output) max sequence length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transformer Parameters</span></span><br><span class="line">d_model = <span class="number">512</span>  <span class="comment"># Embedding Size 每个词被嵌入成几维词向量</span></span><br><span class="line">d_ff = <span class="number">2048</span>  <span class="comment"># FeedForward dimension (两次线性层中的隐藏层 512-&gt;2048-&gt;512，线性层是用来做特征提取的），当然最后会再接一个projection层</span></span><br><span class="line">d_k = d_v = <span class="number">64</span>  <span class="comment"># dimension of K(=Q), V（Q和K的维度需要相同，这里为了方便让K=V）</span></span><br><span class="line">n_layers = <span class="number">6</span>  <span class="comment"># number of Encoder of Decoder Layer（Block的个数）</span></span><br><span class="line">n_heads = <span class="number">8</span>  <span class="comment"># number of heads in Multi-Head Attention（有几个头）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==============================================================================================</span></span><br><span class="line"><span class="comment"># 数据构建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_data</span>(<span class="params">sentences</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把单词序列转换为数字序列&quot;&quot;&quot;</span></span><br><span class="line">    enc_inputs, dec_inputs, dec_outputs = [], [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sentences)):</span><br><span class="line">        enc_input = [[src_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">0</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_input = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">1</span>].split()]]  <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_output = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">2</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line"></span><br><span class="line">        enc_inputs.extend(enc_input) <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_inputs.extend(dec_input) <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_outputs.extend(dec_output) <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line">        <span class="comment"># A = [1, 2, 3]</span></span><br><span class="line">        <span class="comment"># B = [[&#x27;a&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line">        <span class="comment"># A.extend([4])</span></span><br><span class="line">        <span class="comment"># A.extend([5, 6])</span></span><br><span class="line">        <span class="comment"># B.extend([&#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class="line">        <span class="comment"># B.extend([[&#x27;e&#x27;, &#x27;f&#x27;]])</span></span><br><span class="line">        <span class="comment"># print(A)</span></span><br><span class="line">        <span class="comment"># print(B)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># result:</span></span><br><span class="line">        <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="comment"># [[&#x27;a&#x27;, &#x27;b&#x27;], &#x27;c&#x27;, &#x27;d&#x27;, [&#x27;e&#x27;, &#x27;f&#x27;]]</span></span><br><span class="line">    <span class="keyword">return</span> torch.LongTensor(enc_inputs), torch.LongTensor(dec_inputs), torch.LongTensor(dec_outputs)</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>(Data.Dataset):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义DataLoader&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, enc_inputs, dec_inputs, dec_outputs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyDataSet, self).__init__()</span><br><span class="line">        self.enc_inputs = enc_inputs</span><br><span class="line">        self.dec_inputs = dec_inputs</span><br><span class="line">        self.dec_outputs = dec_outputs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs[idx], self.dec_inputs[idx], self.dec_outputs[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># data.DataLoader</span></span><br><span class="line"><span class="comment"># dataset：（数据类型 dataset）</span></span><br><span class="line"><span class="comment"># batch_size：（数据类型 int）</span></span><br><span class="line"><span class="comment"># shuffle：（数据类型 bool）洗牌。默认设置为False。在每次迭代训练时是否将数据洗牌，默认设置是False。将输入数据的顺序打乱，是为了使数据更有独立性，但如果数据是有序列特征的，就不要设置成True了。</span></span><br><span class="line"><span class="comment"># batch_sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># num_workers：（数据类型 Int）</span></span><br><span class="line"><span class="comment"># pin_memory：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># drop_last：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># timeout：（数据类型 numeric）</span></span><br><span class="line"></span><br><span class="line">loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)  <span class="comment"># 2个batch是训练两句话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="comment"># Transformer模型(省去了Embedding层，因为我们之前自己定义过src_vocab和tgt_vocab)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout=<span class="number">0.1</span>, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(torch.arange(0, 5, dtype=torch.float).unsqueeze(1))</span></span><br><span class="line">        <span class="comment"># tensor([[0.],</span></span><br><span class="line">        <span class="comment">#         [1.],</span></span><br><span class="line">        <span class="comment">#         [2.],</span></span><br><span class="line">        <span class="comment">#         [3.],</span></span><br><span class="line">        <span class="comment">#         [4.]])</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        <span class="comment"># div_term = torch.exp(torch.arange(0, 10, 2).float() * (-math.log(10000.0) / 10))</span></span><br><span class="line">        <span class="comment"># print(div_term)</span></span><br><span class="line">        <span class="comment"># tensor([1.0000e+00, 1.5849e-01, 2.5119e-02, 3.9811e-03, 6.3096e-04])</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># a = torch.tensor([1, 2, 3])</span></span><br><span class="line">        <span class="comment"># print(a.unsqueeze(0))</span></span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: [seq_len, batch_size, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = x + self.pe[:x.size(<span class="number">0</span>), :]</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_pad_mask</span>(<span class="params">seq_q, seq_k</span>):<span class="comment">#序列（句子），不够长时用pad填补。为了让pad的位置不参与权重计算，将pad=0的位置设为true</span></span><br><span class="line">    <span class="comment"># pad mask的作用：在对value向量加权平均的时候，可以让pad对应的alpha_ij=0，这样注意力就不会考虑到pad向量</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里的q,k表示的是两个序列（跟注意力机制的q,k没有关系），例如encoder_inputs (x1,x2,..xm)和encoder_inputs (x1,x2..xm)</span></span><br><span class="line"><span class="string">    encoder和decoder都可能调用这个函数，所以seq_len视情况而定</span></span><br><span class="line"><span class="string">    seq_q: [batch_size, seq_len] 两个句子，每个句子单词个数</span></span><br><span class="line"><span class="string">    seq_k: [batch_size, seq_len]</span></span><br><span class="line"><span class="string">    seq_len could be src_len or it could be tgt_len</span></span><br><span class="line"><span class="string">    seq_len in seq_q and seq_len in seq_k maybe not equal</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    batch_size, len_q = seq_q.size()  <span class="comment"># 这个seq_q只是用来expand维度的</span></span><br><span class="line">    batch_size, len_k = seq_k.size()</span><br><span class="line">    <span class="comment"># eq(zero) is PAD token</span></span><br><span class="line">    <span class="comment"># 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]</span></span><br><span class="line">    <span class="comment"># 判断是否为0，是0则为True，True则masked，并扩一个维度。# 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]，--&gt;[[F,F,F,F,T],[F,F,F,F,T]]</span></span><br><span class="line">    pad_attn_mask = seq_k.data.eq(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># [batch_size, 1, len_k]</span></span><br><span class="line">    <span class="keyword">return</span> pad_attn_mask.expand(batch_size, len_q, len_k)  <span class="comment"># [batch_size, len_q, len_k] 构成一个立方体(batch_size个这样的矩阵)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_subsequence_mask</span>(<span class="params">seq</span>):<span class="comment">#一次只翻译一个词</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;建议打印出来看看是什么的输出（一目了然）</span></span><br><span class="line"><span class="string">    seq: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    attn_shape = [seq.size(<span class="number">0</span>), seq.size(<span class="number">1</span>), seq.size(<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># attn_shape: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">    subsequence_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>)  <span class="comment"># 生成一个上三角矩阵</span></span><br><span class="line">    subsequence_mask = torch.from_numpy(subsequence_mask).byte()</span><br><span class="line">    <span class="keyword">return</span> subsequence_mask  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># subsequence_mask = np.triu(np.ones([2,3,3]), k=1)  # 生成一个上三角矩阵</span></span><br><span class="line"><span class="comment"># subsequence_mask = torch.Tensor(subsequence_mask).byte()</span></span><br><span class="line"><span class="comment"># print(subsequence_mask)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># tensor([[[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]],</span></span><br><span class="line"><span class="comment">#         [[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]]], dtype=torch.uint8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x = torch.tensor(2, 2, 2)</span></span><br><span class="line">        <span class="comment"># t = x.view(1, 8)  # 输出数组的大小为1*8</span></span><br><span class="line">        <span class="comment"># t = x.view(-1, 4)  # 输出数组的大小为2*4, -1表示自行判断</span></span><br><span class="line">        <span class="comment"># t = x.view(8)  # 输出数组的大小为8*1</span></span><br><span class="line">        <span class="comment"># t = x.view(-1)  # 输出数组的大小为1*8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderLayer, self).__init__()</span><br><span class="line">        self.enc_self_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, enc_self_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;E</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        enc_self_attn_mask: [batch_size, src_len, src_len]  mask矩阵(pad mask or sequence mask)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 第一个enc_inputs * W_Q = Q</span></span><br><span class="line">        <span class="comment"># 第二个enc_inputs * W_K = K</span></span><br><span class="line">        <span class="comment"># 第三个enc_inputs * W_V = V</span></span><br><span class="line">        enc_outputs, attn = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># enc_inputs to same Q,K,V（未线性变换前）</span></span><br><span class="line">        enc_outputs = self.pos_ffn(enc_outputs)</span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.dec_self_attn = MultiHeadAttention()</span><br><span class="line">        self.dec_enc_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        dec_self_attn_mask: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"><span class="string">        dec_enc_attn_mask: [batch_size, tgt_len, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len]</span></span><br><span class="line">        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs,</span><br><span class="line">                                                        dec_self_attn_mask)  <span class="comment"># 这里的Q,K,V全是Decoder自己的输入</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs,</span><br><span class="line">                                                      dec_enc_attn_mask)  <span class="comment"># Attention层的Q(来自decoder) 和 K,V(来自encoder)</span></span><br><span class="line">        dec_outputs = self.pos_ffn(dec_outputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn  <span class="comment"># dec_self_attn, dec_enc_attn这两个是为了可视化的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line">        self.src_emb = nn.Embedding(src_vocab_size, d_model)  <span class="comment"># token Embedding</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)  <span class="comment"># Transformer中位置编码时固定的，不需要学习</span></span><br><span class="line">        self.layers = nn.ModuleList([EncoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_outputs = self.src_emb(enc_inputs)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs = self.pos_emb(enc_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="comment"># Encoder输入序列的pad mask矩阵</span></span><br><span class="line">        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)  <span class="comment"># [batch_size, src_len, src_len]</span></span><br><span class="line">        enc_self_attns = []  <span class="comment"># 在计算中不需要用到，它主要用来保存你接下来返回的attention的值（这个主要是为了你画热力图等，用来看各个词之间的关系</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:  <span class="comment"># for循环访问nn.ModuleList对象</span></span><br><span class="line">            <span class="comment"># 上一个block的输出enc_outputs作为当前block的输入</span></span><br><span class="line">            <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">            enc_outputs, enc_self_attn = layer(enc_outputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># 传入的enc_outputs其实是input，传入mask矩阵是因为你要做self attention</span></span><br><span class="line">            enc_self_attns.append(enc_self_attn)  <span class="comment"># 这个只是为了可视化</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, enc_self_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.tgt_emb = nn.Embedding(tgt_vocab_size, d_model)  <span class="comment"># Decoder输入的embed词表</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([DecoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])  <span class="comment"># Decoder的blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_inputs, enc_outputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]   # 用在Encoder-Decoder Attention层</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dec_outputs = self.tgt_emb(dec_inputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        dec_outputs = self.pos_emb(dec_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="comment"># Decoder输入序列的pad mask矩阵（这个例子中decoder是没有加pad的，实际应用中都是有pad填充的）</span></span><br><span class="line">        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">        <span class="comment"># Masked Self_Attention：当前时刻是看不到未来的信息的</span></span><br><span class="line">        dec_self_attn_subsequence_mask = get_attn_subsequence_mask(dec_inputs).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        dec_self_attns, dec_enc_attns = [], []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">            <span class="comment"># Decoder的Block是上一个Block的输出dec_outputs（变化）和Encoder网络的输出enc_outputs（固定）</span></span><br><span class="line">            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask,</span><br><span class="line">                                                             dec_enc_attn_mask)</span><br><span class="line">            dec_self_attns.append(dec_self_attn)</span><br><span class="line">            dec_enc_attns.append(dec_enc_attn)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        self.encoder = Encoder().to(device)</span><br><span class="line">        self.decoder = Decoder().to(device)</span><br><span class="line">        self.projection = nn.Linear(d_model, tgt_vocab_size, bias=<span class="literal">False</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, dec_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Transformers的输入：两个序列</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># tensor to store decoder outputs</span></span><br><span class="line">        <span class="comment"># outputs = torch.zeros(batch_size, tgt_len, tgt_vocab_size).to(self.device)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attns: [n_layers, batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 经过Encoder网络后，得到的输出还是[batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs, enc_self_attns = self.encoder(enc_inputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attns: [n_layers, batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [n_layers, batch_size, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model] -&gt; dec_logits: [batch_size, tgt_len, tgt_vocab_size]</span></span><br><span class="line">        dec_logits = self.projection(dec_outputs)</span><br><span class="line">        <span class="keyword">return</span> dec_logits.view(-<span class="number">1</span>, dec_logits.size(-<span class="number">1</span>)), enc_self_attns, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Transformer().to(device)</span><br><span class="line"><span class="comment"># 这里的损失函数里面设置了一个参数 ignore_index=0，因为 &quot;pad&quot; 这个单词的索引为 0，这样设置以后，就不会计算 &quot;pad&quot; 的损失（因为本来 &quot;pad&quot; 也没有意义，不需要计算）</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(ignore_index=<span class="number">0</span>)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>, momentum=<span class="number">0.99</span>)  <span class="comment"># 用adam的话效果不好</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> enc_inputs, dec_inputs, dec_outputs <span class="keyword">in</span> loader:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        dec_outputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_inputs, dec_inputs, dec_outputs = enc_inputs.to(device), dec_inputs.to(device), dec_outputs.to(device)</span><br><span class="line">        <span class="comment"># outputs: [batch_size * tgt_len, tgt_vocab_size]</span></span><br><span class="line">        outputs, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs)</span><br><span class="line">        loss = criterion(outputs, dec_outputs.view(-<span class="number">1</span>))  <span class="comment"># dec_outputs.view(-1):[batch_size * tgt_len * tgt_vocab_size]</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;loss =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greedy_decoder</span>(<span class="params">model, enc_input, start_symbol</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心编码</span></span><br><span class="line"><span class="string">    For simplicity, a Greedy Decoder is Beam search when K=1. This is necessary for inference as we don&#x27;t know the</span></span><br><span class="line"><span class="string">    target sequence input. Therefore we try to generate the target input word by word, then feed it into the transformer.</span></span><br><span class="line"><span class="string">    Starting Reference: http://nlp.seas.harvard.edu/2018/04/03/attention.html#greedy-decoding</span></span><br><span class="line"><span class="string">    :param model: Transformer Model</span></span><br><span class="line"><span class="string">    :param enc_input: The encoder input</span></span><br><span class="line"><span class="string">    :param start_symbol: The start symbol. In this example it is &#x27;S&#x27; which corresponds to index 4</span></span><br><span class="line"><span class="string">    :return: The target input</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    enc_outputs, enc_self_attns = model.encoder(enc_input)</span><br><span class="line">    dec_input = torch.zeros(<span class="number">1</span>, <span class="number">0</span>).type_as(enc_input.data)  <span class="comment"># 初始化一个空的tensor: tensor([], size=(1, 0), dtype=torch.int64)</span></span><br><span class="line">    terminal = <span class="literal">False</span></span><br><span class="line">    next_symbol = start_symbol</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> terminal:</span><br><span class="line">        <span class="comment"># 预测阶段：dec_input序列会一点点变长（每次添加一个新预测出来的单词）</span></span><br><span class="line">        dec_input = torch.cat([dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span><br><span class="line">                              -<span class="number">1</span>)</span><br><span class="line">        dec_outputs, _, _ = model.decoder(dec_input, enc_input, enc_outputs)</span><br><span class="line">        projected = model.projection(dec_outputs)</span><br><span class="line">        prob = projected.squeeze(<span class="number">0</span>).<span class="built_in">max</span>(dim=-<span class="number">1</span>, keepdim=<span class="literal">False</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 增量更新（我们希望重复单词预测结果是一样的）</span></span><br><span class="line">        <span class="comment"># 我们在预测是会选择性忽略重复的预测的词，只摘取最新预测的单词拼接到输入序列中</span></span><br><span class="line">        next_word = prob.data[-<span class="number">1</span>]  <span class="comment"># 拿出当前预测的单词(数字)。我们用x&#x27;_t对应的输出z_t去预测下一个单词的概率，不用z_1,z_2..z_&#123;t-1&#125;</span></span><br><span class="line">        next_symbol = next_word</span><br><span class="line">        <span class="keyword">if</span> next_symbol == tgt_vocab[<span class="string">&quot;E&quot;</span>]:</span><br><span class="line">            terminal = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># print(next_word)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># greedy_dec_predict = torch.cat(</span></span><br><span class="line">    <span class="comment">#     [dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span></span><br><span class="line">    <span class="comment">#     -1)</span></span><br><span class="line">    greedy_dec_predict = dec_input[:, <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> greedy_dec_predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="comment"># 预测阶段</span></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line">test_loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)</span><br><span class="line">enc_inputs, _, _ = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_loader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;利用训练好的Transformer模型将中文句子&#x27;我 有 零 个 女 朋 友&#x27; 翻译成英文句子: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc_inputs)):</span><br><span class="line">    greedy_dec_predict = greedy_decoder(model, enc_inputs[i].view(<span class="number">1</span>, -<span class="number">1</span>).to(device), start_symbol=tgt_vocab[<span class="string">&quot;S&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(enc_inputs[i], <span class="string">&#x27;-&gt;&#x27;</span>, greedy_dec_predict.squeeze())</span><br><span class="line">    <span class="built_in">print</span>([src_idx2word[t.item()] <span class="keyword">for</span> t <span class="keyword">in</span> enc_inputs[i]], <span class="string">&#x27;-&gt;&#x27;</span>,</span><br><span class="line">          [idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> greedy_dec_predict.squeeze()])</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="Tensor数据类型转换"><a href="#Tensor数据类型转换" class="headerlink" title="Tensor数据类型转换"></a>Tensor数据类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. CPU和GPU的Tensor之间转换</span></span><br><span class="line"><span class="comment">#从cpu –&gt; gpu，使用data.cuda()即可。</span></span><br><span class="line"><span class="comment">#若从gpu –&gt; cpu，则使用data.cpu()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. Tensor与Numpy Array之间的转换</span></span><br><span class="line"><span class="comment">#Tensor –&gt; Numpy.ndarray 可以使用 data.numpy()，其中data的类型为torch.Tensor。</span></span><br><span class="line"><span class="comment">#Numpy.ndarray –&gt; Tensor 可以使用torch.from_numpy(data)，其中data的类型为numpy.ndarray。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. Tensor的基本类型转换</span></span><br><span class="line"><span class="comment">#为了方便测试，我们构建一个新的张量，你要转变成不同的类型只需要根据自己的需求选择即可</span></span><br><span class="line"></span><br><span class="line">tensor = torch.Tensor(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.long() 将tensor投射为long类型</span></span><br><span class="line">newtensor = tensor.long()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.half()将tensor投射为半精度浮点(16位浮点)类型</span></span><br><span class="line">newtensor = tensor.half()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.int()将该tensor投射为int类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">int</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.double()将该tensor投射为double类型</span></span><br><span class="line">newtensor = tensor.double()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.float()将该tensor投射为float类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.char()将该tensor投射为char类型</span></span><br><span class="line">newtensor = tensor.char()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.byte()将该tensor投射为byte类型</span></span><br><span class="line">newtensor = tensor.byte()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.short()将该tensor投射为short类型</span></span><br><span class="line">newtensor = tensor.short()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ScaledDotProductionAttention"><a href="#ScaledDotProductionAttention" class="headerlink" title="ScaledDotProductionAttention"></a>ScaledDotProductionAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/30933330-a4d34b59f098ee806e9467a65f7c2770.png" alt="30933330-a4d34b59f098ee806e9467a65f7c2770"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br></pre></td></tr></table></figure>



<h4 id="MultiheadAttention"><a href="#MultiheadAttention" class="headerlink" title="MultiheadAttention"></a>MultiheadAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/6d551c2d2f7d42d3a6ae851cef300b05.png" alt="MultiheadAttention"></p>
<p><img src="/2022/08/01/Transformer-pytorch/59c6160448f5436f9bd55e71ba054176.png" alt="img"></p>
<p><img src="/2022/08/01/Transformer-pytorch/5c7875a11923457f87f2ad57ed30ec75.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Add-amp-Norm"><a href="#Add-amp-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h4><p><img src="/2022/08/01/Transformer-pytorch/7534cf449cc0414695ffcfc0f6eb3c14.png" alt="img"></p>
<ul>
<li>Add指 X+MultiHeadAttention(X)，是一种残差连接，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到</li>
<li>Norm指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>deeplearning pytorch</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
        <tag>Transformer</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
</search>
