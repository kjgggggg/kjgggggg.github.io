<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.两数之和</title>
    <url>/2022/08/04/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i]) != mp.<span class="built_in">end</span>())&#123;	<span class="comment">// mp.end()指向最后元素下一个元素的迭代器</span></span><br><span class="line">                <span class="keyword">return</span> &#123;mp.<span class="built_in">find</span>(target-nums[i])-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        d = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span>[d[target-num],i]</span><br><span class="line">            <span class="keyword">else</span>: d[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>17.电话号码的字母组合</title>
    <url>/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;af&quot;</span>,<span class="string">&quot;bd&quot;</span>,<span class="string">&quot;be&quot;</span>,<span class="string">&quot;bf&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ce&quot;</span>,<span class="string">&quot;cf&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：digits <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;2&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; combinations;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt; phoneMap&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        string combination;</span><br><span class="line">        <span class="built_in">dfs</span>(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; combinations, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, string&gt;&amp; phoneMap, <span class="type">const</span> string&amp; digits, <span class="type">int</span> index, string&amp; combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            combinations.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> digit = digits[index];</span><br><span class="line">            <span class="type">const</span> string&amp; letters = phoneMap.<span class="built_in">at</span>(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; letter: letters) &#123;</span><br><span class="line">                combination.<span class="built_in">push_back</span>(letter);</span><br><span class="line">              	<span class="comment">//index从0开始，到==size结束，所以比正常多一轮</span></span><br><span class="line">                <span class="built_in">dfs</span>(combinations, phoneMap, digits, index + <span class="number">1</span>, combination); </span><br><span class="line">                combination.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">index: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">                combinations.append(<span class="string">&quot;&quot;</span>.join(combination))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digit = digits[index]</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                    combination.append(letter)</span><br><span class="line">                    dfs(index + <span class="number">1</span>)</span><br><span class="line">                    combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = <span class="built_in">list</span>()</span><br><span class="line">        combinations = <span class="built_in">list</span>()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>map</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2022/08/07/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1, list2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">if</span> list1.val&lt;=list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>



<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><h5 id="顺序合并"><a href="#顺序合并" class="headerlink" title="顺序合并"></a>顺序合并</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个变量 ans 来维护以及合并的链表，第 i次循环把第 i 个链表和 ans 合并，答案保存到 ans 中。</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* ans=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>;i&lt;lists.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans = <span class="built_in">mergeTwoLists</span>(ans,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="分治合并"><a href="#分治合并" class="headerlink" title="分治合并"></a>分治合并</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid =(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists,l,mid),<span class="built_in">merge</span>(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,lists, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left&gt;right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> left == right:    <span class="keyword">return</span> lists[left]</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        l1 = self.merge(lists, left, mid)</span><br><span class="line">        l2 = self.merge(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(l1, l2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1, list2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">if</span> list1.val&lt;=list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/2022/08/06/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 我写的</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int lengthOfLongestSubstring(string s) &#123;</span></span><br><span class="line"><span class="comment">        if(s.size()==0) return 0;</span></span><br><span class="line"><span class="comment">        if(s.size()==1) return 1;</span></span><br><span class="line"><span class="comment">        set&lt;char&gt; s1;</span></span><br><span class="line"><span class="comment">        int ret=0;</span></span><br><span class="line"><span class="comment">        for( int i = 0 ; i &lt; s.size(); i++ )&#123;</span></span><br><span class="line"><span class="comment">            s1.clear();</span></span><br><span class="line"><span class="comment">            for( int j = i; j &lt; s.size(); j++ )&#123;</span></span><br><span class="line"><span class="comment">                if(s1.find(s.at(j))!=s1.end())&#123; //能在集合中找到</span></span><br><span class="line"><span class="comment">                    ret = max(j-i,ret);</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                s1.insert(s.at(j)); //找不到就将该字符放入集合</span></span><br><span class="line"><span class="comment">                ret = max(j-i+1,ret);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ret;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk  &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk])) &#123;  <span class="comment">// count(key);    //统计值为key的元素个数</span></span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[rk]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        rk,ans = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                occ.remove(s[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk &lt; n <span class="keyword">and</span> s[rk] <span class="keyword">not</span> <span class="keyword">in</span>  occ:</span><br><span class="line">                occ.add(s[rk])</span><br><span class="line">                rk+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>( ans, rk-i )</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>set</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>14.最长公共前缀</title>
    <url>/2022/08/09/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cnt = <span class="number">0</span>; cnt&lt;strs[<span class="number">0</span>].<span class="built_in">length</span>(); cnt++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i].<span class="built_in">length</span>()&lt;=cnt || strs[i].<span class="built_in">at</span>(cnt)!=strs[<span class="number">0</span>].<span class="built_in">at</span>(cnt))&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(strs[i])&lt;=cnt <span class="keyword">or</span> strs[i][cnt]!=strs[<span class="number">0</span>][cnt]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:cnt]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>53.最大子数组和</title>
    <url>/2022/08/09/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[5,4,-1,7,8]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">-999</span>)</span></span>;<span class="comment">//dp[i]是以nums[i]结尾的连续的最大子数组和</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ret=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(ret&lt;dp[i]) ret=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [-<span class="number">999</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(nums)==<span class="number">1</span>): <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        ret = dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(nums[i],dp[i-<span class="number">1</span>]+nums[i])</span><br><span class="line">            <span class="keyword">if</span> ret&lt;dp[i]: ret=dp[i]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2022/08/05/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：</p>
<p>输入：l1 &#x3D; [2, 4, 3],  l2 &#x3D; [5, 6, 4]<br>输出：[7, 0, 8]<br>解释：342 + 465 &#x3D; 807</p>
<p>示例 2：</p>
<p>输入：l1 &#x3D; [0],  l2 &#x3D; [0]<br>输出：[0]</p>
<p>示例 3：</p>
<p>输入：l1 &#x3D; [9, 9, 9, 9, 9, 9, 9],  l2 &#x3D; [9, 9, 9, 9]<br>输出：[8, 9, 9, 9, 0, 0, 0, 1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">dfs</span><span class="params">(ListNode* l, ListNode* r, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r &amp;&amp; !i) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        <span class="type">int</span> sum = (l ? l-&gt;val : <span class="number">0</span>) + (r ? r-&gt;val : <span class="number">0</span>) + i;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        node-&gt;next = <span class="built_in">dfs</span>(l ? l-&gt;next : <span class="literal">nullptr</span>, r ? r-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">l, r, i</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r <span class="keyword">and</span> <span class="keyword">not</span> i: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            s = (l.val <span class="keyword">if</span> l <span class="keyword">else</span> <span class="number">0</span>) + (r.val <span class="keyword">if</span> r <span class="keyword">else</span> <span class="number">0</span>) + i</span><br><span class="line">            node = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># Python中//是模运算，/是整除运算</span></span><br><span class="line">            node.<span class="built_in">next</span> = dfs(l.<span class="built_in">next</span> <span class="keyword">if</span> l <span class="keyword">else</span> <span class="literal">None</span>, r.<span class="built_in">next</span> <span class="keyword">if</span> r <span class="keyword">else</span> <span class="literal">None</span>, s // <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> dfs(l1, l2, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP</title>
    <url>/2022/08/03/CPP/</url>
    <content><![CDATA[<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span> &amp;a,<span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//声明一个模板，告诉编译器后面紧跟着的代码中的T不要报错，T是一个通用数据类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//两种方式使用函数模板 1.自动类型推导：mySwap(a,b)  2.显示指定类型：mySwap&lt;int&gt;(a,b)</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt; a&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> c=<span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(c,d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span> &lt;&lt; c&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;d=&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数模板注意事项：</span></span><br><span class="line"><span class="comment">1.自动类型推导，必须推导出一致的数据类型T才可以使用,就是这部分所有T对应一种类型</span></span><br><span class="line"><span class="comment">2.模板必须要确定出T的数据类型才能使用。 就是函数体要有T，如果没有，要使用显示指定类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">普通函数与函数模板的区别：</span></span><br><span class="line"><span class="comment">普通函数调用时，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">int myAdd(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void test()&#123;</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    int b = 20;</span></span><br><span class="line"><span class="comment">    char c = &#x27;c&#x27;; //A-65 a-97 </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; myAdd(a,c)&lt;&lt; endl;  //隐式类型转换，将字符型变量转换成了整型变量</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">函数模板调用时，如果可以利用自动类型推导，则不会发生隐式类型转换；若使用显示指定类型，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line"><span class="comment">函数模板也可以重载,并且如果普通函数和函数模板都可以调用，优先调用普通函数</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">void A(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ab&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;AB&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3,是对2的重载</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b,T c)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ABC&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时会调用1，但可以通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a=10,b=20;</span></span><br><span class="line"><span class="comment">    A&lt;&gt;(a,b);//通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T name,U age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T name;</span><br><span class="line">        U age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、类模板和函数模板的区别：</span></span><br><span class="line"><span class="comment">//1.类模板没有自动类型推导的使用方法 2.类模板在模板参数列表中可以有默认参数 template&lt;class T, class U = int&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、类模板中成员函数创建时机：普通类中的成员函数一开始就可以创建，类模板中的成员函数在调用时才创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、类模板对象做函数参数：</span></span><br><span class="line"><span class="comment">//一共有三种传入方式：1.指定传入的类型 2.参数模板化 3.整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.指定传入的类型 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.整个类模板化，建议使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、类模板与继承:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Son:public Base&#123;&#125;;   错误，需要指定Base的T类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想灵活指定父类中T类型，子类也需要变类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">public</span> Base&lt;T1&gt;&#123;</span><br><span class="line">    T2 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、类模板成员函数类外实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person1</span>(T3 name,T4 age);</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     this-&gt;name=name;this-&gt;age=age;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        T3 name;</span><br><span class="line">        T4 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line">Person1&lt;T3,T4&gt;::<span class="built_in">Person1</span>(T3 name,T4 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="type">void</span> Person1&lt;T3,T4&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sb&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  七、类模板分文件编写</span></span><br><span class="line"><span class="comment">//问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</span></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="comment">// 1.直接包含.cpp源文件:</span></span><br><span class="line"><span class="comment">//一般把类及其方法的声明放在.h文件中，把实现放在.cpp文件中。 </span></span><br><span class="line"><span class="comment">// 三个文件：person.h;person.cpp;main.cpp  在person.cpp中要写#include&quot;person.h&quot;  在main.cpp中要包含#include&quot;person.cpp&quot;</span></span><br><span class="line"><span class="comment">// 2.将声明和实现写到同一文件中，并更改后缀名为.hpp。hpp是业界约定，不是必须。 然后在main.cpp中包含#include&quot;person.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、类模板与友元</span></span><br><span class="line"><span class="comment">//掌握类模板配合友元函数的类内和类外实现</span></span><br><span class="line"><span class="comment">//全局函数类内实现：直接在类内声明友元即可   </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"><span class="comment">template&lt;class T5 , class T6&gt;</span></span><br><span class="line"><span class="comment">class Person2&#123;</span></span><br><span class="line"><span class="comment">    //全局函数 类内实现  friend关键字能访问private数据</span></span><br><span class="line"><span class="comment">    friend void printPerson()&#123;Person2&lt;T5,T6&gt; p&#125;&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot; age:&quot; &lt;&lt; p.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person2(T5 name,T6 age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    private:</span></span><br><span class="line"><span class="comment">        T5 name;</span></span><br><span class="line"><span class="comment">        T6 age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    Person2&lt;string,int&gt;p(&quot;aaa&quot;,18);</span></span><br><span class="line"><span class="comment">    printPerson(p);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//全局函数类外实现：需要提前让编译器知道全局函数的存在(较难)</span></span><br></pre></td></tr></table></figure>



<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">重载操作符的类的对象叫函数对象，重载的是()时，又叫仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、特点：</span></span><br><span class="line"><span class="comment">1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="comment">2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="comment">3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v1+v2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myadd myadd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Myprint</span>()&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count; <span class="comment">//内部自己状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myprint调用的次数是&quot;</span> &lt;&lt; myprint.count &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(Myprint &amp;mp,string s)</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    Myprint mp2;</span><br><span class="line">    <span class="built_in">doPrint</span>(mp2,<span class="string">&quot;cnm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、谓词</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回bool类型的仿函数称为谓词</span></span><br><span class="line"><span class="comment">如果operator接受一个参数，叫做一元谓词</span></span><br><span class="line"><span class="comment">如果operator接受两个参数，叫做二元谓词</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、内建函数对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stl内建了一些函数对象，能够拿来直接使用。这些仿函数所产生的对象，用法和一般函数完全相同。</span></span><br><span class="line"><span class="comment">使用内建函数对象需要包含#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">分类：算数，关系，逻辑仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.算数仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T plus&lt;T&gt;;        //加    plus&lt;int&gt; p; cout &lt;&lt; p(10,20) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T minus&lt;T&gt;;       //减</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T multiplies&lt;T&gt;;  //乘</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T divides&lt;T&gt;;     //除</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T modulus&lt;T&gt;;     //取模</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T negate&lt;T&gt;;      //取反 negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.关系仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt;;    //   greater&lt;int&gt;() 等价于之前的自定义的 Mycompare       greater&lt;int&gt;()要加()，代表对象的创建。</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.逻辑仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt;;      //与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt;;       //或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt;;      //非</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file readbinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief 读取二进制数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>]; </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p;<span class="comment">//接住读出的数据</span></span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));  <span class="comment">//函数原型：istream&amp; read(char * buffer,int len);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"><span class="comment">//文件类型有两种 1.文本文件：文件以文本的ASCII码形式存储在计算机中 2.二进制文件：文件以文本的二进制形式存储在计算机中，不能直接读懂</span></span><br><span class="line"><span class="comment">//操作文件的三大类  ofstream：写操作  ifstream：读操作  fstream：读写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件步骤——“包流开写闭”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #include &lt;fstream&gt;   //包含头文件</span></span><br><span class="line"><span class="comment">    ofstream ofs;      //创建流对象</span></span><br><span class="line"><span class="comment">    ofs.open(&quot;文件路径&quot;，打开方式);     //打开文件</span></span><br><span class="line"><span class="comment">    ofs &lt;&lt; &quot;写入的数据&quot;;     //写数据</span></span><br><span class="line"><span class="comment">    ofs.close();    //关闭文件</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件打开方式：</span></span><br><span class="line"><span class="comment">    ios::in         //为读文件而打开文件</span></span><br><span class="line"><span class="comment">    i0s::out        //为写文件而打开文件</span></span><br><span class="line"><span class="comment">    ios::ate        //初始位置：文件尾</span></span><br><span class="line"><span class="comment">    ios::app        //追加方式写文件</span></span><br><span class="line"><span class="comment">    ios::trunc      //如果文件存在，则先删除再创建</span></span><br><span class="line"><span class="comment">    ios::binary     //二进制方式</span></span><br><span class="line"><span class="comment">    ios::binary | ios::out      //用二进制方式写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test01.txt&quot;</span>,ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;name:kongjiangang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;gender:male&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file writebinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief  向二进制文件写数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包流开操闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//函数原型： ostream&amp; write(const char * buffer,int len);</span></span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><h5 id="stl-general"><a href="#stl-general" class="headerlink" title="stl general"></a>stl general</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl:标准模板库</span></span><br><span class="line"><span class="comment">//stl从广义上分为容器,算法,迭代器。 容器和算法通过迭代器无缝衔接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl六大组件:容器,算法,迭代器,仿函数,适配器(配接器),空间配置器</span></span><br><span class="line"><span class="comment">//1.容器:分为序列式容器(强调值的排序)和关联式容器(二叉树)。各种数据结构,如vector,list,deque,set,map等，用来存放数据</span></span><br><span class="line"><span class="comment">//2.算法:分为质变算法(拷贝，置换，删除)和非质变算法(查找，计数，遍历)。常用的函数,如sort,find,copy,for_each等</span></span><br><span class="line"><span class="comment">//3.迭代器:分为(输入(对数据只读),输出(对数据只写),前向,双向,随机访问)迭代器。能按序访问某个容器内所含元素又不暴露该容器内部表示方法。</span></span><br><span class="line"><span class="comment">//4.仿函数:行为类似函数,可作为算法的某种策略</span></span><br><span class="line"><span class="comment">//5.适配器:不做要求</span></span><br><span class="line"><span class="comment">//6.空间配置器:负责空间的配置与管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、容器算法迭代器初识：vector存放内置数据类型</span></span><br><span class="line"><span class="comment">//容器：vector 算法：for_each 迭代器：vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> <span class="comment">//需要包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//同上</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器中插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>(); <span class="comment">//起始迭代器，指向容器中的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();     <span class="comment">//结束迭代器，指向容器中的最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span> (itBegin != itEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种遍历方式，利用for_each算法,回掉</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),myPrint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、vector存放自定义数据类型,同一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容器中再嵌套一个容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="comment">//创建小容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在小容器中插入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小容器插入到大容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过大容器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator iterator=v.<span class="built_in">begin</span>();iterator!=v.<span class="built_in">end</span>();iterator++)&#123;</span><br><span class="line">        <span class="comment">//(*iterator) 是一维数组</span></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit=(*iterator).<span class="built_in">begin</span>();vit!=(*iterator).<span class="built_in">end</span>();vit++)</span><br><span class="line">            cout&lt;&lt; (*vit) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector,也称单端数组</span></span><br><span class="line"><span class="comment">//vector与普通数组区别:不同之处是数组是静态空间，而vector可以动态扩展</span></span><br><span class="line"><span class="comment">//vector容器的迭代器是支持随机访问的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v;</span></span><br><span class="line"><span class="comment">vector(v.begin(),v.end());      //将v[begin(),end()]区间中的元素赋值给vector，如 vector&lt;int&gt; v2(v1.begin(),v1.end());</span></span><br><span class="line"><span class="comment">vector(n,elem);     //初始值为n个elem</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">assign(begin,end);      //v2.assign(v1.begin(),v.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);     //v3.assign(10,20);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容量和大小</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">empty();        //判断容器是否为空</span></span><br><span class="line"><span class="comment">capicity();     //容器的容量，不是创建vector，插入10个元素容量就为10，可能为16</span></span><br><span class="line"><span class="comment">size();     //返回容器中元素数量</span></span><br><span class="line"><span class="comment">resize(int num);        //重新指定容器长度，若容器变长，则以默认值填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num,elem);       //重新指定容器长度，若容器变长，则以elem填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">pop_back();     //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos,elem);    </span></span><br><span class="line"><span class="comment">insert(const_iterator pos,int n,elem);       //在pos处插入n个elem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(const_iterator pos);      //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator begin,onst_iterator end);      //删除begin到end间的所有元素</span></span><br><span class="line"><span class="comment">clear();        //删除容器内所有元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、数据存取</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">at(int idx);</span></span><br><span class="line"><span class="comment">operator[];     // vector&lt;int&gt; v; cout &lt;&lt; v[n] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">front();        //返回容器内第一个元素</span></span><br><span class="line"><span class="comment">back();     //返回容器内最后一个元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、互换容器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">swap(vec);      //将vec与本身的元素进行互换 v1.swap(v2);</span></span><br><span class="line"><span class="comment">v.resize(3);vector&lt;int&gt;(v).swap(v);     //巧用swap收缩内存，vector&lt;int&gt;(v)是匿名对象，拷贝构造函数，同时匿名对象自动析构。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、预留空间</span></span><br><span class="line"><span class="comment">//减少vector在动态扩展容量时的扩展次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">reserve(int len);       //容器预留len个元素长度，但预留位置不初始化，且元素不可访问。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">list(链表，stl中的链表是一个双向循环链表，每个结点都有data,prev,next域)常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">list&lt;T&gt; l;</span></span><br><span class="line"><span class="comment">list(begin,end);        //拷贝构造函数,list&lt;int&gt; l2(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">list(n,elem);       </span></span><br><span class="line"><span class="comment">list(const list &amp;l);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换：</span></span><br><span class="line"><span class="comment">assign(begin,end);      //list&lt;int&gt; l2; l2.assign(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;l);</span></span><br><span class="line"><span class="comment">swap(l)     //将l与本身的元素互换  l1.swap(l2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">resize(num);</span></span><br><span class="line"><span class="comment">resize(num,elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、插入和删除：</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">push_front(elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pop_back();</span></span><br><span class="line"><span class="comment">pop_front();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insert(pos,elem);       //返回新数据的位置</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);     //无返回值</span></span><br><span class="line"><span class="comment">insert(pos,begin,end);      //无返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个数据的位置</span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个数据的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">remove(elem);       //移除所有与elem匹配的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">clear();        //移除容器中所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、数据存取</span></span><br><span class="line"><span class="comment">front();</span></span><br><span class="line"><span class="comment">back();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、反转和排序</span></span><br><span class="line"><span class="comment">reverse();</span></span><br><span class="line"><span class="comment">sort();</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">map &amp; multimap 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map基本概念：</span></span><br><span class="line"><span class="comment">1.map中的所有元素都是pair</span></span><br><span class="line"><span class="comment">2.pair中的第一个元素为key，起索引作用。第二个元素为value(实际值)</span></span><br><span class="line"><span class="comment">3.所有元素都会根据元素的键值自动排序</span></span><br><span class="line"><span class="comment">4.map &amp; multimap区别：map不允许容器中有重复key值的元素，multimap允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造与赋值</span></span><br><span class="line"><span class="comment">map&lt;T1,T2&gt; mp;</span></span><br><span class="line"><span class="comment">map(const map &amp;mp);     </span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp);      //返回值是一个map的引用变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(mp);       //mp1.swap(mp2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);       //map&lt;int,int&gt; mp1;  mp1.insert(pair&lt;int,int&gt;(1,20));</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(key);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回mp.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、排序</span></span><br><span class="line"><span class="comment">默认按key值从小到大排序，但可以通过仿函数改变</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">map&lt;int,int,MyCompare&gt; mp;      //指定排序规则</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">set &amp; multiset 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">set基本概念：</span></span><br><span class="line"><span class="comment">1.所有元素都会在插入时自动被排序</span></span><br><span class="line"><span class="comment">2.set/multiset是关联式容器，底层用二叉树实现</span></span><br><span class="line"><span class="comment">3.set和multiset区别：set不允许容器中有相同元素，multiset允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st;</span></span><br><span class="line"><span class="comment">set(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(st);       //st1.swap(st2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(elem);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回st.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、set和multiset的区别</span></span><br><span class="line"><span class="comment">set插入数据时会返回是否插入成功，multiset不会</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、pair 对组的创建</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p(value1,value2);       //p.first和p.second分别访问不同部分</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p = make_pair(value1,value2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">八、set容器排序</span></span><br><span class="line"><span class="comment">学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</span></span><br><span class="line"><span class="comment">主要技术点：利用仿函数可以改变排序规则</span></span><br><span class="line"><span class="comment">1.set中存放内置数据类型</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">set&lt;int,MyCompare&gt; s2;      //指定排序规则</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.set中存放自定义数据类型</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person(string name,int age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        string name;</span></span><br><span class="line"><span class="comment">        int age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">class MyCompare2&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(const Person &amp;p1,const Person &amp;p2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return p1.age&gt;p2.age;       //按年龄降序排列</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    set&lt;Person,MyCompare2&gt; st;</span></span><br><span class="line"><span class="comment">    Person p1(&quot;lisi&quot;,19);</span></span><br><span class="line"><span class="comment">    Person p2(&quot;lisiguang&quot;,20);</span></span><br><span class="line"><span class="comment">    st.insert(p1);</span></span><br><span class="line"><span class="comment">    st.insert(p2);</span></span><br><span class="line"><span class="comment">    //迭代器输出，省略……</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stack常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; s;</span></span><br><span class="line"><span class="comment">stack(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);</span></span><br><span class="line"><span class="comment">pop();      //移除栈顶元素</span></span><br><span class="line"><span class="comment">top();      //返回栈顶元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">queue常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; q;</span></span><br><span class="line"><span class="comment">queue(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//char*是一个指针；string是一个类，类内部封装了char*，是一个char*型的容器</span></span><br><span class="line"><span class="comment">//string类内部封装了很多成员方法，如find，copy，delete，replace，insert。 string类管理char*所分配的内存，不用担心复制越界和取值越界，由类内部负责管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string();      //创建一个空的字符串，例如string str;</span></span><br><span class="line"><span class="comment">string(const char* s);     //使用字符串s初始化，如   char* str = &quot;hello world&quot;; string s(str);</span></span><br><span class="line"><span class="comment">string(const string&amp; str);     //使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="comment">string(int n,char c);      //使用n个字符c初始化 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char* s);       //string str = &quot;aaa&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const string&amp; s);         //string str1 =str;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char c);        //strng str = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s);      //string str2; str2.assign(&quot;aaaaa&quot;);</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s,int n);        //把字符串s的前n个字符赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(const string &amp;s);        //把字符串s赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(int n,char c);       //用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、拼接</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char* str);       //string str=&quot;我&quot;; str+=&quot;爱玩游戏&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char c);         //string str=&quot;我&quot;; str+=&#x27;艹&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const &amp;string str);        //str1 += str2;</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s);      //string str=&quot;我&quot;; str.append(&quot;爱玩游戏&quot;);</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s,int n);        //把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s);        //str1.append(str2);</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s,int pos,int n);       //把字符串s从pos开始n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、查找和替换</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int find(const string&amp; str,int pos=0) const;        //查找str第一次出现的位置，从pos开始寻找。不写pos默认为0</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos=0) const;        //查找s第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos,int n) const;        //查找s的前n个字符第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char c ,int pos=0) const;        //查找字符c第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str,int pos=npos) const;        //查找str最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos=npos) const;        //查找s最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos,int n) const;        //查找s的前n个字符最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char c ,int pos=0) const;        //查找字符c最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const string&amp; str);       //替换从pos开始的n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const char* s);       //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、比较</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串是按字符的ASCII进行比较 =返回0;&gt;返回1;&lt;返回-1</span></span><br><span class="line"><span class="comment">int compare(const string&amp; s) const;</span></span><br><span class="line"><span class="comment">int compare(const char* s) const;   </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、获取(也可以赋值，修改)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n);        //通过[]方式获取字符 cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">char&amp; at(int n);        //通过at获取字符  cout &lt;&lt; str.at(i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const char* s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const string&amp; s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,int n,char c);       //在指定pos插入n个c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; erase(int pos,int n=npos);      //删除从pos开始的n个字符 ，nopos表示不存在的位置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、获取子串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string substr(int pos = 0;int n = npos) const;        //返回由pos开始n个字符组成的子串  </span></span><br><span class="line"><span class="comment">                                                      //如string str=&quot;abcdef&quot;; cout &lt;&lt; str.substr(1,3) &lt;&lt; endl;返回&quot;bcd&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Self Attention</title>
    <url>/2022/07/31/Self-Attention/</url>
    <content><![CDATA[<h3 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/881659278403_.pic.jpg" alt="881659278403_.pic"></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30866925-c326e92942025a3a6c6b1e8b96ccc0ce.png" alt="30866925-c326e92942025a3a6c6b1e8b96ccc0ce"></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><img src="/2022/07/31/Self-Attention/30867091-d28fe5868178a62d9faab212486b474b.png" alt="30867091-d28fe5868178a62d9faab212486b474b"></p>
<h3 id="Muiltihead-Self-Attention"><a href="#Muiltihead-Self-Attention" class="headerlink" title="Muiltihead Self Attention"></a>Muiltihead Self Attention</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/image-20220801014946983.png" alt="image-20220801014946983"></p>
<h4 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30867156-2219b84d50e04f41dd60cbe13b2994ac.png" alt="30867156-2219b84d50e04f41dd60cbe13b2994ac"></p>
<ul>
<li>这里的 a i 和 a j 是同一个输入(可以理解为下图的X)</li>
</ul>
<h4 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h4><p><img src="/2022/07/31/Self-Attention/QQ20220801-015325.png" alt="QQ20220801-015325"></p>
<p><img src="/2022/07/31/Self-Attention/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjE0NjM2,size_16,color_FFFFFF,t_70-20220801020808429.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>八个头相当于八个不同的表征子空间，类似于apple拥有水果的含义，同时也有商标的含义，不同的含义由不同的表征子空间学习。</p>
</li>
<li><p>让其他词的Q来和apple这个词不同组的K-V进行attention。</p>
</li>
<li><p>再把所有的attention结果拼接起来，通过一个全连接层（矩阵变换）得到最终结果。</p>
</li>
<li><p>X是一开始经过Embedding的词向量矩阵，R为之前层输出的，他俩都可以进行Multihead Self Attention</p>
</li>
</ul>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>blog</title>
    <url>/2022/07/29/blog/</url>
    <content><![CDATA[<h3 id="Markdown基本操作"><a href="#Markdown基本操作" class="headerlink" title="Markdown基本操作"></a>Markdown基本操作</h3><ul>
<li>标题</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># A (一级标题)</span></span><br><span class="line"><span class="section">## A</span></span><br><span class="line"><span class="section">### A</span></span><br><span class="line"><span class="section">#### A</span></span><br><span class="line"><span class="section">##### A</span></span><br><span class="line"><span class="section">###### A （六级标题）</span></span><br></pre></td></tr></table></figure>



<ul>
<li>字体</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜粗体*</span>**</span></span><br></pre></td></tr></table></figure>



<ul>
<li>分割线、下划线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>脚注</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^鼠标移到我身上]：会弹出我！</span><br></pre></td></tr></table></figure>



<ul>
<li>列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项		</span><br><span class="line"><span class="bullet">*</span> 第二项		</span><br><span class="line"><span class="bullet">*</span> 第三项   </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项		</span><br><span class="line"><span class="bullet">-</span> 第二项		</span><br><span class="line"><span class="bullet">-</span> 第三项  </span><br></pre></td></tr></table></figure>



<ul>
<li>最左边的竖线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; </span></span><br></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`print()`</span> </span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>



<ul>
<li>链接</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>图片</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>表格</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line"></span><br><span class="line">我们可以设置表格的对齐方式：</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>



<h3 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a>Hexo基本操作</h3><ul>
<li>发布文章</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure>

<p>去&#x2F;Users&#x2F;jiangangkong&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;文章名.md 下写文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li>每篇文章下最大的标题为三级标题</li>
<li>并列关系用 * </li>
<li>顺序关系用1. 2. </li>
<li>文章开头的信息里（tags，categories，descriptions后面要加‘空格）否则会报错</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer pytorch</title>
    <url>/2022/08/01/Transformer-pytorch/</url>
    <content><![CDATA[<h3 id="Transformer概览"><a href="#Transformer概览" class="headerlink" title="Transformer概览"></a>Transformer概览</h3><p><img src="/2022/08/01/Transformer-pytorch/901659325530_.pic_%E5%89%AF%E6%9C%AC.png" alt="901659325530_.pic"></p>
<p><img src="/2022/08/01/Transformer-pytorch/7613b15f43674c298bd4b21fd372b140.png" alt="img"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="comment"># === Pytorch手写Transformer完整代码</span></span><br><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"></span><br><span class="line">device = <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="comment"># device = &#x27;cuda&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># transformer epochs</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我没有用什么大型的数据集，而是手动输入了两对中文→英语的句子</span></span><br><span class="line"><span class="comment"># 还有每个字的索引也是我手动硬编码上去的，主要是为了降低代码阅读难度</span></span><br><span class="line"><span class="comment"># S: Symbol that shows starting of decoding input</span></span><br><span class="line"><span class="comment"># E: Symbol that shows starting of decoding output</span></span><br><span class="line"><span class="comment"># P: Symbol that will fill in blank sequence if current batch data size is short than time steps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># 中文和英语的单词个数不要求相同</span></span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 一 个 好 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have a good friend .&#x27;</span>, <span class="string">&#x27;i have a good friend . E&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have zero girl friend .&#x27;</span>, <span class="string">&#x27;i have zero girl friend . E&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集（希望transformer能达到的效果）</span></span><br><span class="line"><span class="comment"># 输入：&quot;我 有 一 个 女 朋 友&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;i have a girlfriend&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文和英语的单词要分开建立词库</span></span><br><span class="line"><span class="comment"># Padding Should be Zero</span></span><br><span class="line">src_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;我&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;有&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;一&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;个&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;好&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;朋&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;友&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;零&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;女&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">src_idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(src_vocab)&#125;</span><br><span class="line">src_vocab_size = <span class="built_in">len</span>(src_vocab)</span><br><span class="line"></span><br><span class="line">tgt_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;have&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;good&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;friend&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;zero&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;girl&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(tgt_vocab)&#125;</span><br><span class="line">tgt_vocab_size = <span class="built_in">len</span>(tgt_vocab)</span><br><span class="line"></span><br><span class="line">src_len = <span class="number">8</span>  <span class="comment"># （源句子的长度）enc_input max sequence length</span></span><br><span class="line">tgt_len = <span class="number">7</span>  <span class="comment"># dec_input(=dec_output) max sequence length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transformer Parameters</span></span><br><span class="line">d_model = <span class="number">512</span>  <span class="comment"># Embedding Size 每个词被嵌入成几维词向量</span></span><br><span class="line">d_ff = <span class="number">2048</span>  <span class="comment"># FeedForward dimension (两次线性层中的隐藏层 512-&gt;2048-&gt;512，线性层是用来做特征提取的），当然最后会再接一个projection层</span></span><br><span class="line">d_k = d_v = <span class="number">64</span>  <span class="comment"># dimension of K(=Q), V（Q和K的维度需要相同，这里为了方便让K=V）</span></span><br><span class="line">n_layers = <span class="number">6</span>  <span class="comment"># number of Encoder of Decoder Layer（Block的个数）</span></span><br><span class="line">n_heads = <span class="number">8</span>  <span class="comment"># number of heads in Multi-Head Attention（有几个头）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==============================================================================================</span></span><br><span class="line"><span class="comment"># 数据构建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_data</span>(<span class="params">sentences</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把单词序列转换为数字序列&quot;&quot;&quot;</span></span><br><span class="line">    enc_inputs, dec_inputs, dec_outputs = [], [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sentences)):</span><br><span class="line">        enc_input = [[src_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">0</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_input = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">1</span>].split()]]  <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_output = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">2</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line"></span><br><span class="line">        enc_inputs.extend(enc_input) <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_inputs.extend(dec_input) <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_outputs.extend(dec_output) <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line">        <span class="comment"># A = [1, 2, 3]</span></span><br><span class="line">        <span class="comment"># B = [[&#x27;a&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line">        <span class="comment"># A.extend([4])</span></span><br><span class="line">        <span class="comment"># A.extend([5, 6])</span></span><br><span class="line">        <span class="comment"># B.extend([&#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class="line">        <span class="comment"># B.extend([[&#x27;e&#x27;, &#x27;f&#x27;]])</span></span><br><span class="line">        <span class="comment"># print(A)</span></span><br><span class="line">        <span class="comment"># print(B)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># result:</span></span><br><span class="line">        <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="comment"># [[&#x27;a&#x27;, &#x27;b&#x27;], &#x27;c&#x27;, &#x27;d&#x27;, [&#x27;e&#x27;, &#x27;f&#x27;]]</span></span><br><span class="line">    <span class="keyword">return</span> torch.LongTensor(enc_inputs), torch.LongTensor(dec_inputs), torch.LongTensor(dec_outputs)</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>(Data.Dataset):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义DataLoader&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, enc_inputs, dec_inputs, dec_outputs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyDataSet, self).__init__()</span><br><span class="line">        self.enc_inputs = enc_inputs</span><br><span class="line">        self.dec_inputs = dec_inputs</span><br><span class="line">        self.dec_outputs = dec_outputs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs[idx], self.dec_inputs[idx], self.dec_outputs[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># data.DataLoader</span></span><br><span class="line"><span class="comment"># dataset：（数据类型 dataset）</span></span><br><span class="line"><span class="comment"># batch_size：（数据类型 int）</span></span><br><span class="line"><span class="comment"># shuffle：（数据类型 bool）洗牌。默认设置为False。在每次迭代训练时是否将数据洗牌，默认设置是False。将输入数据的顺序打乱，是为了使数据更有独立性，但如果数据是有序列特征的，就不要设置成True了。</span></span><br><span class="line"><span class="comment"># batch_sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># num_workers：（数据类型 Int）</span></span><br><span class="line"><span class="comment"># pin_memory：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># drop_last：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># timeout：（数据类型 numeric）</span></span><br><span class="line"></span><br><span class="line">loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)  <span class="comment"># 2个batch是训练两句话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="comment"># Transformer模型(省去了Embedding层，因为我们之前自己定义过src_vocab和tgt_vocab)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout=<span class="number">0.1</span>, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(torch.arange(0, 5, dtype=torch.float).unsqueeze(1))</span></span><br><span class="line">        <span class="comment"># tensor([[0.],</span></span><br><span class="line">        <span class="comment">#         [1.],</span></span><br><span class="line">        <span class="comment">#         [2.],</span></span><br><span class="line">        <span class="comment">#         [3.],</span></span><br><span class="line">        <span class="comment">#         [4.]])</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        <span class="comment"># div_term = torch.exp(torch.arange(0, 10, 2).float() * (-math.log(10000.0) / 10))</span></span><br><span class="line">        <span class="comment"># print(div_term)</span></span><br><span class="line">        <span class="comment"># tensor([1.0000e+00, 1.5849e-01, 2.5119e-02, 3.9811e-03, 6.3096e-04])</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># a = torch.tensor([1, 2, 3])</span></span><br><span class="line">        <span class="comment"># print(a.unsqueeze(0))</span></span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: [seq_len, batch_size, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = x + self.pe[:x.size(<span class="number">0</span>), :]</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_pad_mask</span>(<span class="params">seq_q, seq_k</span>):<span class="comment">#序列（句子），不够长时用pad填补。为了让pad的位置不参与权重计算，将pad=0的位置设为true</span></span><br><span class="line">    <span class="comment"># pad mask的作用：在对value向量加权平均的时候，可以让pad对应的alpha_ij=0，这样注意力就不会考虑到pad向量</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里的q,k表示的是两个序列（跟注意力机制的q,k没有关系），例如encoder_inputs (x1,x2,..xm)和encoder_inputs (x1,x2..xm)</span></span><br><span class="line"><span class="string">    encoder和decoder都可能调用这个函数，所以seq_len视情况而定</span></span><br><span class="line"><span class="string">    seq_q: [batch_size, seq_len] 两个句子，每个句子单词个数</span></span><br><span class="line"><span class="string">    seq_k: [batch_size, seq_len]</span></span><br><span class="line"><span class="string">    seq_len could be src_len or it could be tgt_len</span></span><br><span class="line"><span class="string">    seq_len in seq_q and seq_len in seq_k maybe not equal</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    batch_size, len_q = seq_q.size()  <span class="comment"># 这个seq_q只是用来expand维度的</span></span><br><span class="line">    batch_size, len_k = seq_k.size()</span><br><span class="line">    <span class="comment"># eq(zero) is PAD token</span></span><br><span class="line">    <span class="comment"># 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]</span></span><br><span class="line">    <span class="comment"># 判断是否为0，是0则为True，True则masked，并扩一个维度。# 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]，--&gt;[[F,F,F,F,T],[F,F,F,F,T]]</span></span><br><span class="line">    pad_attn_mask = seq_k.data.eq(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># [batch_size, 1, len_k]</span></span><br><span class="line">    <span class="keyword">return</span> pad_attn_mask.expand(batch_size, len_q, len_k)  <span class="comment"># [batch_size, len_q, len_k] 构成一个立方体(batch_size个这样的矩阵)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_subsequence_mask</span>(<span class="params">seq</span>):<span class="comment">#一次只翻译一个词</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;建议打印出来看看是什么的输出（一目了然）</span></span><br><span class="line"><span class="string">    seq: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    attn_shape = [seq.size(<span class="number">0</span>), seq.size(<span class="number">1</span>), seq.size(<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># attn_shape: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">    subsequence_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>)  <span class="comment"># 生成一个上三角矩阵</span></span><br><span class="line">    subsequence_mask = torch.from_numpy(subsequence_mask).byte()</span><br><span class="line">    <span class="keyword">return</span> subsequence_mask  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># subsequence_mask = np.triu(np.ones([2,3,3]), k=1)  # 生成一个上三角矩阵</span></span><br><span class="line"><span class="comment"># subsequence_mask = torch.Tensor(subsequence_mask).byte()</span></span><br><span class="line"><span class="comment"># print(subsequence_mask)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># tensor([[[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]],</span></span><br><span class="line"><span class="comment">#         [[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]]], dtype=torch.uint8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x = torch.tensor(2, 2, 2)</span></span><br><span class="line">        <span class="comment"># t = x.view(1, 8)  # 输出数组的大小为1*8</span></span><br><span class="line">        <span class="comment"># t = x.view(-1, 4)  # 输出数组的大小为2*4, -1表示自行判断</span></span><br><span class="line">        <span class="comment"># t = x.view(8)  # 输出数组的大小为8*1</span></span><br><span class="line">        <span class="comment"># t = x.view(-1)  # 输出数组的大小为1*8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderLayer, self).__init__()</span><br><span class="line">        self.enc_self_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, enc_self_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;E</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        enc_self_attn_mask: [batch_size, src_len, src_len]  mask矩阵(pad mask or sequence mask)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 第一个enc_inputs * W_Q = Q</span></span><br><span class="line">        <span class="comment"># 第二个enc_inputs * W_K = K</span></span><br><span class="line">        <span class="comment"># 第三个enc_inputs * W_V = V</span></span><br><span class="line">        enc_outputs, attn = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># enc_inputs to same Q,K,V（未线性变换前）</span></span><br><span class="line">        enc_outputs = self.pos_ffn(enc_outputs)</span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.dec_self_attn = MultiHeadAttention()</span><br><span class="line">        self.dec_enc_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        dec_self_attn_mask: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"><span class="string">        dec_enc_attn_mask: [batch_size, tgt_len, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len]</span></span><br><span class="line">        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs,</span><br><span class="line">                                                        dec_self_attn_mask)  <span class="comment"># 这里的Q,K,V全是Decoder自己的输入</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs,</span><br><span class="line">                                                      dec_enc_attn_mask)  <span class="comment"># Attention层的Q(来自decoder) 和 K,V(来自encoder)</span></span><br><span class="line">        dec_outputs = self.pos_ffn(dec_outputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn  <span class="comment"># dec_self_attn, dec_enc_attn这两个是为了可视化的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line">        self.src_emb = nn.Embedding(src_vocab_size, d_model)  <span class="comment"># token Embedding</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)  <span class="comment"># Transformer中位置编码时固定的，不需要学习</span></span><br><span class="line">        self.layers = nn.ModuleList([EncoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_outputs = self.src_emb(enc_inputs)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs = self.pos_emb(enc_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="comment"># Encoder输入序列的pad mask矩阵</span></span><br><span class="line">        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)  <span class="comment"># [batch_size, src_len, src_len]</span></span><br><span class="line">        enc_self_attns = []  <span class="comment"># 在计算中不需要用到，它主要用来保存你接下来返回的attention的值（这个主要是为了你画热力图等，用来看各个词之间的关系</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:  <span class="comment"># for循环访问nn.ModuleList对象</span></span><br><span class="line">            <span class="comment"># 上一个block的输出enc_outputs作为当前block的输入</span></span><br><span class="line">            <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">            enc_outputs, enc_self_attn = layer(enc_outputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># 传入的enc_outputs其实是input，传入mask矩阵是因为你要做self attention</span></span><br><span class="line">            enc_self_attns.append(enc_self_attn)  <span class="comment"># 这个只是为了可视化</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, enc_self_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.tgt_emb = nn.Embedding(tgt_vocab_size, d_model)  <span class="comment"># Decoder输入的embed词表</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([DecoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])  <span class="comment"># Decoder的blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_inputs, enc_outputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]   # 用在Encoder-Decoder Attention层</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dec_outputs = self.tgt_emb(dec_inputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        dec_outputs = self.pos_emb(dec_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="comment"># Decoder输入序列的pad mask矩阵（这个例子中decoder是没有加pad的，实际应用中都是有pad填充的）</span></span><br><span class="line">        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">        <span class="comment"># Masked Self_Attention：当前时刻是看不到未来的信息的</span></span><br><span class="line">        dec_self_attn_subsequence_mask = get_attn_subsequence_mask(dec_inputs).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        dec_self_attns, dec_enc_attns = [], []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">            <span class="comment"># Decoder的Block是上一个Block的输出dec_outputs（变化）和Encoder网络的输出enc_outputs（固定）</span></span><br><span class="line">            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask,</span><br><span class="line">                                                             dec_enc_attn_mask)</span><br><span class="line">            dec_self_attns.append(dec_self_attn)</span><br><span class="line">            dec_enc_attns.append(dec_enc_attn)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        self.encoder = Encoder().to(device)</span><br><span class="line">        self.decoder = Decoder().to(device)</span><br><span class="line">        self.projection = nn.Linear(d_model, tgt_vocab_size, bias=<span class="literal">False</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, dec_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Transformers的输入：两个序列</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># tensor to store decoder outputs</span></span><br><span class="line">        <span class="comment"># outputs = torch.zeros(batch_size, tgt_len, tgt_vocab_size).to(self.device)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attns: [n_layers, batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 经过Encoder网络后，得到的输出还是[batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs, enc_self_attns = self.encoder(enc_inputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attns: [n_layers, batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [n_layers, batch_size, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model] -&gt; dec_logits: [batch_size, tgt_len, tgt_vocab_size]</span></span><br><span class="line">        dec_logits = self.projection(dec_outputs)</span><br><span class="line">        <span class="keyword">return</span> dec_logits.view(-<span class="number">1</span>, dec_logits.size(-<span class="number">1</span>)), enc_self_attns, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Transformer().to(device)</span><br><span class="line"><span class="comment"># 这里的损失函数里面设置了一个参数 ignore_index=0，因为 &quot;pad&quot; 这个单词的索引为 0，这样设置以后，就不会计算 &quot;pad&quot; 的损失（因为本来 &quot;pad&quot; 也没有意义，不需要计算）</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(ignore_index=<span class="number">0</span>)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>, momentum=<span class="number">0.99</span>)  <span class="comment"># 用adam的话效果不好</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> enc_inputs, dec_inputs, dec_outputs <span class="keyword">in</span> loader:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        dec_outputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_inputs, dec_inputs, dec_outputs = enc_inputs.to(device), dec_inputs.to(device), dec_outputs.to(device)</span><br><span class="line">        <span class="comment"># outputs: [batch_size * tgt_len, tgt_vocab_size]</span></span><br><span class="line">        outputs, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs)</span><br><span class="line">        loss = criterion(outputs, dec_outputs.view(-<span class="number">1</span>))  <span class="comment"># dec_outputs.view(-1):[batch_size * tgt_len * tgt_vocab_size]</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;loss =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greedy_decoder</span>(<span class="params">model, enc_input, start_symbol</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心编码</span></span><br><span class="line"><span class="string">    For simplicity, a Greedy Decoder is Beam search when K=1. This is necessary for inference as we don&#x27;t know the</span></span><br><span class="line"><span class="string">    target sequence input. Therefore we try to generate the target input word by word, then feed it into the transformer.</span></span><br><span class="line"><span class="string">    Starting Reference: http://nlp.seas.harvard.edu/2018/04/03/attention.html#greedy-decoding</span></span><br><span class="line"><span class="string">    :param model: Transformer Model</span></span><br><span class="line"><span class="string">    :param enc_input: The encoder input</span></span><br><span class="line"><span class="string">    :param start_symbol: The start symbol. In this example it is &#x27;S&#x27; which corresponds to index 4</span></span><br><span class="line"><span class="string">    :return: The target input</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    enc_outputs, enc_self_attns = model.encoder(enc_input)</span><br><span class="line">    dec_input = torch.zeros(<span class="number">1</span>, <span class="number">0</span>).type_as(enc_input.data)  <span class="comment"># 初始化一个空的tensor: tensor([], size=(1, 0), dtype=torch.int64)</span></span><br><span class="line">    terminal = <span class="literal">False</span></span><br><span class="line">    next_symbol = start_symbol</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> terminal:</span><br><span class="line">        <span class="comment"># 预测阶段：dec_input序列会一点点变长（每次添加一个新预测出来的单词）</span></span><br><span class="line">        dec_input = torch.cat([dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span><br><span class="line">                              -<span class="number">1</span>)</span><br><span class="line">        dec_outputs, _, _ = model.decoder(dec_input, enc_input, enc_outputs)</span><br><span class="line">        projected = model.projection(dec_outputs)</span><br><span class="line">        prob = projected.squeeze(<span class="number">0</span>).<span class="built_in">max</span>(dim=-<span class="number">1</span>, keepdim=<span class="literal">False</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 增量更新（我们希望重复单词预测结果是一样的）</span></span><br><span class="line">        <span class="comment"># 我们在预测是会选择性忽略重复的预测的词，只摘取最新预测的单词拼接到输入序列中</span></span><br><span class="line">        next_word = prob.data[-<span class="number">1</span>]  <span class="comment"># 拿出当前预测的单词(数字)。我们用x&#x27;_t对应的输出z_t去预测下一个单词的概率，不用z_1,z_2..z_&#123;t-1&#125;</span></span><br><span class="line">        next_symbol = next_word</span><br><span class="line">        <span class="keyword">if</span> next_symbol == tgt_vocab[<span class="string">&quot;E&quot;</span>]:</span><br><span class="line">            terminal = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># print(next_word)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># greedy_dec_predict = torch.cat(</span></span><br><span class="line">    <span class="comment">#     [dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span></span><br><span class="line">    <span class="comment">#     -1)</span></span><br><span class="line">    greedy_dec_predict = dec_input[:, <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> greedy_dec_predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="comment"># 预测阶段</span></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line">test_loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)</span><br><span class="line">enc_inputs, _, _ = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_loader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;利用训练好的Transformer模型将中文句子&#x27;我 有 零 个 女 朋 友&#x27; 翻译成英文句子: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc_inputs)):</span><br><span class="line">    greedy_dec_predict = greedy_decoder(model, enc_inputs[i].view(<span class="number">1</span>, -<span class="number">1</span>).to(device), start_symbol=tgt_vocab[<span class="string">&quot;S&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(enc_inputs[i], <span class="string">&#x27;-&gt;&#x27;</span>, greedy_dec_predict.squeeze())</span><br><span class="line">    <span class="built_in">print</span>([src_idx2word[t.item()] <span class="keyword">for</span> t <span class="keyword">in</span> enc_inputs[i]], <span class="string">&#x27;-&gt;&#x27;</span>,</span><br><span class="line">          [idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> greedy_dec_predict.squeeze()])</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="Tensor数据类型转换"><a href="#Tensor数据类型转换" class="headerlink" title="Tensor数据类型转换"></a>Tensor数据类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. CPU和GPU的Tensor之间转换</span></span><br><span class="line"><span class="comment">#从cpu –&gt; gpu，使用data.cuda()即可。</span></span><br><span class="line"><span class="comment">#若从gpu –&gt; cpu，则使用data.cpu()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. Tensor与Numpy Array之间的转换</span></span><br><span class="line"><span class="comment">#Tensor –&gt; Numpy.ndarray 可以使用 data.numpy()，其中data的类型为torch.Tensor。</span></span><br><span class="line"><span class="comment">#Numpy.ndarray –&gt; Tensor 可以使用torch.from_numpy(data)，其中data的类型为numpy.ndarray。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. Tensor的基本类型转换</span></span><br><span class="line"><span class="comment">#为了方便测试，我们构建一个新的张量，你要转变成不同的类型只需要根据自己的需求选择即可</span></span><br><span class="line"></span><br><span class="line">tensor = torch.Tensor(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.long() 将tensor投射为long类型</span></span><br><span class="line">newtensor = tensor.long()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.half()将tensor投射为半精度浮点(16位浮点)类型</span></span><br><span class="line">newtensor = tensor.half()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.int()将该tensor投射为int类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">int</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.double()将该tensor投射为double类型</span></span><br><span class="line">newtensor = tensor.double()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.float()将该tensor投射为float类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.char()将该tensor投射为char类型</span></span><br><span class="line">newtensor = tensor.char()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.byte()将该tensor投射为byte类型</span></span><br><span class="line">newtensor = tensor.byte()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.short()将该tensor投射为short类型</span></span><br><span class="line">newtensor = tensor.short()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ScaledDotProductionAttention"><a href="#ScaledDotProductionAttention" class="headerlink" title="ScaledDotProductionAttention"></a>ScaledDotProductionAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/30933330-a4d34b59f098ee806e9467a65f7c2770.png" alt="30933330-a4d34b59f098ee806e9467a65f7c2770"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br></pre></td></tr></table></figure>



<h4 id="MultiheadAttention"><a href="#MultiheadAttention" class="headerlink" title="MultiheadAttention"></a>MultiheadAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/6d551c2d2f7d42d3a6ae851cef300b05.png" alt="MultiheadAttention"></p>
<p><img src="/2022/08/01/Transformer-pytorch/59c6160448f5436f9bd55e71ba054176.png" alt="img"></p>
<p><img src="/2022/08/01/Transformer-pytorch/5c7875a11923457f87f2ad57ed30ec75.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Add-amp-Norm"><a href="#Add-amp-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h4><p><img src="/2022/08/01/Transformer-pytorch/7534cf449cc0414695ffcfc0f6eb3c14.png" alt="img"></p>
<ul>
<li>Add指 X+MultiHeadAttention(X)，是一种残差连接，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到</li>
<li>Norm指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>deeplearning pytorch</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
        <tag>Transformer</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2022/08/08/linux/</url>
    <content><![CDATA[<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul>
<li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。<br>Shell 本身并不是内核的一部分，它只是在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。<br>然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。</p>
<h3 id="bash与zsh的区别"><a href="#bash与zsh的区别" class="headerlink" title="bash与zsh的区别"></a>bash与zsh的区别</h3></li>
<li><p>一句话，二者均是shell的一种，zsh能基本完美兼容bash的命令，并且使用起来更加优雅。由于bash或zsh本质上都是解释器，他们所共同服务的是shell语言，因此在命令语法上基本相同，部分兼容性差异可参考：zsh和bash的兼容性差异。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash <span class="comment"># 切换bash</span></span><br><span class="line">chsh -s /bin/zsh <span class="comment"># 切换zsh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bash读取的配置文件：<del>&#x2F;.bash_profile文件<br>zsh读取的配置文件：</del>&#x2F;.zshrc文件<br>当从bash切换为zsh时，如果不想重新配置一遍.zshrc文件，可以__在.zshrc文件中加上source ~&#x2F;.bash_profile，从而直接从.bash_profile文件读取配置。</p>
</li>
</ul>
<h3 id="yum和rpm"><a href="#yum和rpm" class="headerlink" title="yum和rpm"></a>yum和rpm</h3><ul>
<li>rpm命令和yum命令都可以用来安装软件</li>
<li>但与yum命令最大的区别为yum命令在安装软件时如果碰到了依赖性的问题，yum会去主动尝试解决依赖性，如果解决不了才会反馈给用户。而rpm命令一旦遇到了依赖性的问题不会去解决依赖性，而是直接反馈给用户，让用户自行解决</li>
</ul>
<h4 id="repo源"><a href="#repo源" class="headerlink" title="repo源"></a>repo源</h4><ul>
<li>repo文件是linux中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！</li>
</ul>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><ul>
<li>homebrew是MacOS系统里面包的管理工具，类似于CentOS系统里面的<a href="https://so.csdn.net/so/search?q=yum&spm=1001.2101.3001.7020">yum</a>，主要解决软件或者包下载时的各种依赖包。</li>
<li>拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</li>
</ul>
<h3 id="mac终端和linux"><a href="#mac终端和linux" class="headerlink" title="mac终端和linux"></a>mac终端和linux</h3><ul>
<li><p>Mac和Linux基于都是基于Unix，命令也很多都是仿照Unix的，所以常用命令基本没有区别，如查看文件(ls)，查找文件(find)，复制文件(cp)，创建目录(mkdir)，打包文件(tar)等等，以及他们的软件包安装都是基于相同的理念(.&#x2F;configure，install)。</p>
</li>
<li><p>但是一些细节是不同的，比如Linux因为是用C语言写的，所以命令需要区分大小写，而Mac是不存在的。</p>
<p>使用mac的终端时候，需要递归复制目录，在Linux系统中一般是-r参数，请注意在mac中是-Rp，如果复制的路径是在&#x2F;usr&#x2F;local等级别的路径下，还需要sudo权限</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -Rp <span class="built_in">source</span> /usr/local/source_copy</span><br></pre></td></tr></table></figure>

<ul>
<li>linux中的yum工具在mac中用homebrew替代</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉系统软件包配置迁移测试</title>
    <url>/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="第一轮测试"><a href="#第一轮测试" class="headerlink" title="第一轮测试"></a>第一轮测试</h3><h4 id="1-mac进入root状态"><a href="#1-mac进入root状态" class="headerlink" title="1.mac进入root状态"></a>1.mac进入root状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开终端</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="comment"># 然后输入本机账号的密码0000</span></span><br></pre></td></tr></table></figure>

<h4 id="2-mac连接远程服务器"><a href="#2-mac连接远程服务器" class="headerlink" title="2.mac连接远程服务器"></a>2.mac连接远程服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进入root状态</span></span><br><span class="line">ssh 服务器用户名@ip <span class="comment"># ssh rpmtest@172.29.7.204</span></span><br><span class="line"><span class="comment"># 输入服务器连接密码</span></span><br></pre></td></tr></table></figure>

<h4 id="查看已安装rpm包-若没有-则安装"><a href="#查看已安装rpm包-若没有-则安装" class="headerlink" title="*查看已安装rpm包 若没有 则安装"></a>*查看已安装rpm包 若没有 则安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qi 包名</span><br><span class="line">yum list installed|grep dbus <span class="comment">#模糊查询</span></span><br><span class="line">sudo yum install dconf-editor-3.28.0-1.el7 <span class="comment">#安装</span></span><br></pre></td></tr></table></figure>

<h4 id="3-在centos服务器上的test文件夹下运行test-py生成迁移脚本"><a href="#3-在centos服务器上的test文件夹下运行test-py生成迁移脚本" class="headerlink" title="3.在centos服务器上的test文件夹下运行test.py生成迁移脚本"></a>3.在centos服务器上的test文件夹下运行test.py生成迁移脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#查看文件列表</span></span><br><span class="line">python3 test.py dbus-1.10.24-12.el7.x86_64.rpm x86_64</span><br><span class="line"><span class="comment"># 生成对应的.sh和.json文件</span></span><br></pre></td></tr></table></figure>

<h4 id="4-将-sh发送到欧拉服务器上的test文件夹下"><a href="#4-将-sh发送到欧拉服务器上的test文件夹下" class="headerlink" title="4.将.sh发送到欧拉服务器上的test文件夹下"></a>4.将.sh发送到欧拉服务器上的test文件夹下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp dbus-1.10.24-12.el7.x86_64.rpm.sh 172.29.7.209:~/test</span><br><span class="line"><span class="comment"># 输入ls 查看有无backup 和 configfile 文件夹</span></span><br></pre></td></tr></table></figure>

<h4 id="5-在centos服务器上查看对应的-json文件"><a href="#5-在centos服务器上查看对应的-json文件" class="headerlink" title="5.在centos服务器上查看对应的.json文件"></a>5.在centos服务器上查看对应的.json文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim dbus-1.10.24-12.el7.x86_64.rpm x86_64.json</span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># %! python3 -m json.tool 后输入该条指令将该json文件夹格式化方便查看</span></span><br></pre></td></tr></table></figure>

<h4 id="6-比对"><a href="#6-比对" class="headerlink" title="6.比对"></a>6.比对</h4><p>查看configfile文件夹中修改后的系统配置文件并与backup文件夹中的原文件进行比较，查看修改部分是否同之前的json文件中的内容保持一致(修改后配置项的值应为src_current_value)，也可以与对应sh脚本中echo和sed内容进行对比是否一致，若不一致，需记录。</p>
<h3 id="第二轮测试"><a href="#第二轮测试" class="headerlink" title="第二轮测试"></a>第二轮测试</h3><h4 id="1-mac进入root状态-1"><a href="#1-mac进入root状态-1" class="headerlink" title="1.mac进入root状态"></a>1.mac进入root状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开终端</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="comment"># 然后输入本机账号的密码0000</span></span><br></pre></td></tr></table></figure>

<h4 id="2-mac连接远程服务器-1"><a href="#2-mac连接远程服务器-1" class="headerlink" title="2.mac连接远程服务器"></a>2.mac连接远程服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进入root状态</span></span><br><span class="line">ssh 服务器用户名@ip <span class="comment"># ssh rpmtest@172.29.7.221</span></span><br><span class="line"><span class="comment"># 输入服务器连接密码</span></span><br></pre></td></tr></table></figure>

<h4 id="3-进入linux的-etc-x2F-yum-repos-d-目录"><a href="#3-进入linux的-etc-x2F-yum-repos-d-目录" class="headerlink" title="3.进入linux的 etc&#x2F;yum.repos.d 目录"></a>3.进入linux的 etc&#x2F;yum.repos.d 目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd ~    回到根目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br></pre></td></tr></table></figure>

<h4 id="4-查看所有可用软件包"><a href="#4-查看所有可用软件包" class="headerlink" title="4.查看所有可用软件包"></a>4.查看所有可用软件包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要测试 clamav-milter-0.103.5-1.el7.x86_64.rpm 包</span></span><br><span class="line">yum --disablerepo=<span class="string">&#x27;*&#x27;</span> --enablerepo=<span class="string">&#x27;huawei-*&#x27;</span> list clamav-milter --showduplicate</span><br><span class="line"><span class="comment"># 结果如下图 说明要降级软件包</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811163753844.png" alt="image-20220811163753844" style="zoom:67%;">

<h4 id="5-升级-x2F-降级软件包"><a href="#5-升级-x2F-降级软件包" class="headerlink" title="5.升级&#x2F;降级软件包"></a>5.升级&#x2F;降级软件包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级</span></span><br><span class="line">sudo yum upgrade clamav-milter-0.103.5-1.el7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降级</span></span><br><span class="line">sudo yum downgrade clamav-milter-0.103.5-1.el7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提示信息同时升级/降级软件包依赖(大文件放最后)</span></span><br><span class="line">sudo yum downgrade python-firewall-0.5.3-5.el7 firewalld-filesystem-0.5.3-5.el7 firewalld-0.5.3-5.el7</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811174709752.png" alt="image-20220811174709752" style="zoom:50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有其他的包依赖需要降级的这个包，因此两个需要一起downgrade就可以了</span></span><br><span class="line">sudo yum downgrade cronie-anacron-1.4.11-19.el7 cronie-1.4.11-19.el7</span><br></pre></td></tr></table></figure>

<h4 id="6-备份配置文件"><a href="#6-备份配置文件" class="headerlink" title="6.备份配置文件"></a>6.备份配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/test</span><br><span class="line">python3 test.py cronie-1.4.11-19.el7.x86_64.rpm x86_64</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811181850807.png" alt="image-20220811181850807"></p>
<ul>
<li>第一个是CentOS当前配置文件路径</li>
<li>第二个是CentOS默认配置文件路径</li>
<li>第三个是OpenEuler默认配置文件路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先以root权限备份CentOS当前配置文件和OpenEuler默认配置文件到backup文件夹对应的子文件夹下。backup文件夹分别有两个子文件夹centos_default\openeuler。backup文件夹分别有两个子文件夹centos_current 、openeuler。</span></span><br><span class="line"><span class="built_in">cp</span> -p /usr/lib/systemd/system/crond.service backup/centos_current/</span><br><span class="line"><span class="built_in">cp</span> -p database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/crond.service backup/openeuler/</span><br><span class="line"><span class="comment"># 此时~/test/backup/centos_current/crond.service 和~/test/backup/openeuler/crond.service已经建立</span></span><br></pre></td></tr></table></figure>

<h4 id="7-修改配置项"><a href="#7-修改配置项" class="headerlink" title="7.修改配置项"></a>7.修改配置项</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/crond.service</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811184451341.png" alt="image-20220811184451341" style="zoom:50%;">

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811193700367.png" alt="image-20220811193700367" style="zoom:50%;">



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim  database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/crond.service</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811193525150.png" alt="image-20220811193525150" style="zoom:50%;">

<h4 id="8-在centos服务器上的test文件夹下运行test-py生成迁移脚本"><a href="#8-在centos服务器上的test文件夹下运行test-py生成迁移脚本" class="headerlink" title="8.在centos服务器上的test文件夹下运行test.py生成迁移脚本"></a>8.在centos服务器上的test文件夹下运行test.py生成迁移脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#查看文件列表</span></span><br><span class="line">python3 test.py cronie-1.4.11-19.el7.x86_64.rpm x86_64</span><br><span class="line"><span class="comment"># 生成对应的.sh和.json文件</span></span><br></pre></td></tr></table></figure>

<h4 id="9-将-sh发送到欧拉服务器上的test文件夹下"><a href="#9-将-sh发送到欧拉服务器上的test文件夹下" class="headerlink" title="9.将.sh发送到欧拉服务器上的test文件夹下"></a>9.将.sh发送到欧拉服务器上的test文件夹下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp cronie-1.4.11-19.el7.x86_64.rpm.sh 172.29.7.209:~/test</span><br><span class="line"><span class="comment"># 输入ls 查看有无backup 和 configfile 文件夹</span></span><br></pre></td></tr></table></figure>

<h4 id="10-在centos服务器上查看对应的-json文件"><a href="#10-在centos服务器上查看对应的-json文件" class="headerlink" title="10.在centos服务器上查看对应的.json文件"></a>10.在centos服务器上查看对应的.json文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim dbus-1.10.24-12.el7.x86_64.rpm x86_64.json</span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># %! python3 -m json.tool 后输入该条指令将该json文件夹格式化方便查看</span></span><br></pre></td></tr></table></figure>

<h4 id="11-比对"><a href="#11-比对" class="headerlink" title="11.比对"></a>11.比对</h4><p>检查OpenEuler服务器上是否有对应版本的rpm包，若没有，则安装。若存在，则复制脚本到OpenEuler服务器，以root权限运行该脚本。脚本会备份要修改的配置文件到同目录下backup文件夹，修改后的配置文件到同目录下configfile文件夹。若有错误日志输出，需记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum list clamav-milter --showduplicate</span></span><br><span class="line"><span class="comment"># sudo yum install XXX</span></span><br><span class="line"></span><br><span class="line">sudo ./cronie-1.4.11-19.el7.x86_64.rpm.sh</span><br><span class="line"></span><br><span class="line">vim backup/crond.service</span><br></pre></td></tr></table></figure>

<p>对比openeuler服务器上backup和configfile目录下配置项的值，是否符合json文件中is_sync为true的配置项</p>
<p>backup为修改前默认配置文件，值是json文件中的openeuler_default_value</p>
<p>configfile为后修改后的配置文件，值是json文件中src_current_value</p>
<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811205126703.png" alt="image-20220811205126703" style="zoom:50%;">

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811205336588.png" alt="image-20220811205336588" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src_current_value的值为当前centos环境的配置项值,从环境中查询</span></span><br><span class="line"><span class="comment">// src_default_value的值为centos的rpm包的配置项默认值，从数据库中查询</span></span><br><span class="line"><span class="comment">// openEuler_default_value的值为对应openEuler上rpm包的配置项默认值，从数据库中查询</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;crond.service&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;rpm_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cronie-1.4.11-19.el7.x86_64.rpm&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;filename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;crond.service&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;src_os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;centos&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;target_os &quot;</span><span class="punctuation">:</span> <span class="string">&quot;openeuler&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;arch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command Scheduler&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command Scheduler&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;After&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auditd.service systemd-user-sessions.service time-sync.target&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auditd.service nss-user-lookup.target systemd-user-sessions.service time-sync.target ypbind.service autofs.service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;insert &quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;insert1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;alter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /etc/sysconfig/crond &quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;alter1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS item1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS item2&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /etc/sysconfig/crond item1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /etc/sysconfig/crond item2&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h4 id="12-在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径"><a href="#12-在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径" class="headerlink" title="12.在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径"></a>12.在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -p backup/centos_current/crond.service /usr/lib/systemd/system/</span><br><span class="line">sudo <span class="built_in">cp</span> -p backup/openeuler/crond.service  database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2022/08/02/python/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&quot;Zhihu&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取第二位</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1:-2]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>result：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]:  Runoob</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>]:  [<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第三个元素为 :  <span class="number">1997</span></span><br><span class="line">更新后的第三个元素为 :  <span class="number">2001</span></span><br><span class="line">更新后的列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="append与extend的区别"><a href="#append与extend的区别" class="headerlink" title="append与extend的区别"></a>append与extend的区别</h4><ul>
<li>ist.append(object) 向列表中添加一个对象object</li>
<li>list.extend(sequence) 把一个序列seq的内容添加到列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista = [<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listb = [<span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista.extend(listb)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista</span><br><span class="line">[<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>, <span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;原始列表 : &quot;</span>, <span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原始列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">删除第三个元素 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure>



<h4 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h4><table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print(x, end&#x3D;” “)</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h4 id="列表截取与拼接"><a href="#列表截取与拼接" class="headerlink" title="列表截取与拼接"></a>列表截取与拼接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">输出从第二个元素开始后的所有元素</td>
</tr>
</tbody></table>
<h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="列表比较"><a href="#列表比较" class="headerlink" title="列表比较"></a>列表比较</h4><p>列表比较需要引入 <strong>operator</strong> 模块的 <strong>eq</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 operator 模块</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">c = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(a,b): &quot;</span>, operator.eq(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(c,b): &quot;</span>, operator.eq(c,b))</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">operator.eq(a,b):  <span class="literal">False</span></span><br><span class="line">operator.eq(c,b):  <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h4><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td>
</tr>
</tbody></table>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典是另一种可变容器模型，且可存储任意类型对象。</span></span><br><span class="line"><span class="comment"># 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 &#123;&#125; 中 ,格式如下所示：</span></span><br><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 键必须是唯一的，但值则不必。</span></span><br><span class="line"><span class="comment"># 值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的字典实例：</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可如此创建字典：</span></span><br><span class="line">tinydict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">tinydict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h4 id="访问具体的值"><a href="#访问具体的值" class="headerlink" title="访问具体的值"></a>访问具体的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="comment"># tinydict[&#x27;Age&#x27;]:  7</span></span><br></pre></td></tr></table></figure>

<h4 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h4><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  小菜鸟</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(dict) 计算字典元素个数，即键的总数。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">str(dict) 输出字典，可以打印的字符串表示。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">pop(key[,default])</a> 删除字典 key（键）所对应的值，返回被删除的值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody></table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 这里演示的是去重功能</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 快速判断元素是否在集合内</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</span></span><br><span class="line">s.add( x )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</span></span><br><span class="line">s.update( x )</span><br></pre></td></tr></table></figure>

<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</span></span><br><span class="line">s.remove( x ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</span></span><br><span class="line">s.discard( x )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以设置随机删除集合中的一个元素，语法格式如下：</span></span><br><span class="line">s.pop()</span><br></pre></td></tr></table></figure>

<h4 id="计算元素个数"><a href="#计算元素个数" class="headerlink" title="计算元素个数"></a>计算元素个数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>

<h4 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>

<h4 id="集合内置函数-amp-方法"><a href="#集合内置函数-amp-方法" class="headerlink" title="集合内置函数&amp;方法"></a>集合内置函数&amp;方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td>
<td align="left">为集合添加元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td>
<td align="left">移除集合中的所有元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td>
<td align="left">拷贝一个集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td>
<td align="left">返回多个集合的差集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td>
<td align="left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td>
<td align="left">删除集合中指定的元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td>
<td align="left">返回集合的交集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td>
<td align="left">返回集合的交集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td>
<td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td>
<td align="left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td>
<td align="left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td>
<td align="left">随机移除元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td>
<td align="left">移除指定元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td>
<td align="left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td>
<td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td>
<td align="left">返回两个集合的并集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td>
<td align="left">给集合添加元素</td>
</tr>
</tbody></table>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li><em>Numpy</em> 是 <em>Python</em> 中科学计算的核心库，<em>NumPy</em> 这个词来源于 <em>Numerical</em> 和 <em>Python</em> 两个单词。它提供了一个高性能的多维<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>对象，以及大量的库函数和操作，可以帮助程序员轻松地进行数值计算，广泛应用于机器学习模型、图像处理和计算机图形学、数学任务等领域。</li>
</ul>
<h4 id="Numpy数组：ndarray"><a href="#Numpy数组：ndarray" class="headerlink" title="Numpy数组：ndarray"></a>Numpy数组：ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型，它是描述相同类型的元素集合。ndarray 中的每个元素都是数据类型对象(dtype)的对象。ndarray 中的每个元素在内存中使用相同大小的块。</span></span><br><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>object	任何暴露数组接口方法的对象</p>
</li>
<li><p>dtype	数据类型</p>
</li>
<li><p>copy	如果为 True，则 object 对象被复制，否则，只有当array返回副本，object 是嵌套序列，或者需要副本来满足任何其他要求（dtype，order等）时，才会生成副本。</p>
</li>
<li><p>order	指定阵列的内存布局。 如果 object 不是数组，则新创建的数组将按行排列（C），如果指定了（F），则按列排列。 如果 object 是一个数组，则以下成立。C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）</p>
</li>
<li><p>subok	默认情况下，返回的数组被强制为基类数组。 如果为 True，则返回子类。</p>
</li>
<li><p>ndmin	返回数组的最小维数</p>
</li>
</ul>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="comment"># 注意：list 打印显示是 [1, 2, 3]，而 ndarray 打印显示是 [1 2 3]，当中没有逗号。</span></span><br></pre></td></tr></table></figure>



<h5 id="例2-dtype-参数用法示例"><a href="#例2-dtype-参数用法示例" class="headerlink" title="例2:dtype 参数用法示例"></a>例2:dtype 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, dtype=np.float_)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">b = np.array(a, dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">float64</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.float64&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h5 id="例3-copy-参数的用法"><a href="#例3-copy-参数的用法" class="headerlink" title="例3:copy 参数的用法"></a>例3:copy 参数的用法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">True</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 可以看到 a 和 b 的值不同，说明 b 是 a 的副本，两个是不同的对象。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">False</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a 改变同时引起了 b 的改变，说明 a 和 b 指向的是同一个对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="例4：ndmin-参数用法示例"><a href="#例4：ndmin-参数用法示例" class="headerlink" title="例4：ndmin 参数用法示例"></a>例4：ndmin 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, ndmin=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>



<h5 id="例5：subok-参数用法示例"><a href="#例5：subok-参数用法示例" class="headerlink" title="例5：subok 参数用法示例"></a>例5：subok 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.matrix(<span class="string">&#x27;1 2 7; 3 4 8; 5 6 9&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">at = np.array(a, subok=<span class="literal">True</span>)</span><br><span class="line">af = np.array(a, subok=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(at))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(af))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">9</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h4><ul>
<li>ndarray.ndim	秩，即轴的数量或维度的数量</li>
<li>ndarray.shape	数组的维度，对于矩阵，n 行 m 列</li>
<li>ndarray.size	数组元素的总个数，相当于 .shape 中 n*m 的值</li>
<li>ndarray.dtype	ndarray 对象的元素类型</li>
<li>ndarray.itemsize	ndarray 对象中每个元素的大小，以字节为单位</li>
<li>ndarray.flags	ndarray 对象的内存信息</li>
<li>ndarray.real	ndarray 元素的实部（复数的实部）</li>
<li>ndarray.imag	ndarray 元素的虚部（复数的虚部）</li>
<li>ndarray.data	包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h4 id="Numpy中的常数"><a href="#Numpy中的常数" class="headerlink" title="Numpy中的常数"></a>Numpy中的常数</h4><ul>
<li>正无穷：Inf &#x3D; inf &#x3D; infty &#x3D; Infinity &#x3D; PINF</li>
<li>负无穷：NINF</li>
<li>正零：PZERO</li>
<li>负零：NZERO</li>
<li>非数值：nan &#x3D; NaN &#x3D; NAN</li>
<li>自然数e：e</li>
<li>π：pi</li>
<li>伽马：euler_gamma</li>
<li>None 的别名：newaxis</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.inf)</span><br><span class="line"><span class="built_in">print</span>(np.NINF)</span><br><span class="line"><span class="built_in">print</span>(np.PZERO)</span><br><span class="line"><span class="built_in">print</span>(np.NZERO)</span><br><span class="line"><span class="built_in">print</span>(np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.e)</span><br><span class="line"><span class="built_in">print</span>(np.pi)</span><br><span class="line"><span class="built_in">print</span>(np.euler_gamma)</span><br><span class="line"><span class="built_in">print</span>(np.newaxis)</span><br><span class="line"><span class="comment"># inf</span></span><br><span class="line"><span class="comment"># -inf</span></span><br><span class="line"><span class="comment"># 0.0</span></span><br><span class="line"><span class="comment"># -0.0</span></span><br><span class="line"><span class="comment"># nan</span></span><br><span class="line"><span class="comment"># 2.718281828459045</span></span><br><span class="line"><span class="comment"># 3.141592653589793</span></span><br><span class="line"><span class="comment"># 0.5772156649015329</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h4><h5 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方法用来创建一个指定维度（shape）、数据类型（dtype）的未初始化的数组。</span></span><br><span class="line">numpy.empty(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.empty([<span class="number">3</span>, <span class="number">2</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="numpy-full"><a href="#numpy-full" class="headerlink" title="numpy.full"></a>numpy.full</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回给定维度和类型的新数组，填充 fill_value。</span></span><br><span class="line">numpy.full(shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>



<h4 id="Numpy从数值范围创建数组"><a href="#Numpy从数值范围创建数组" class="headerlink" title="Numpy从数值范围创建数组"></a>Numpy从数值范围创建数组</h4><h5 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该函数等效于 Python 内置 range 函数，但返回的是 ndarray 而不是列表。</span></span><br><span class="line">arange([start,] stop[, step,], dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个一维等差数列的数组，与 arange 函数不同，arange 是固定步长，而 linspace 则是固定元素数量。</span></span><br><span class="line">linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span>]</span><br><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span> <span class="number">5.</span>        ]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.logspace 函数用于创建一个等比数列。</span></span><br><span class="line">numpy.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值为：base ** start （幂运算）</li>
<li>stop	序列的终止值为：base ** stop。如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的等步长的样本数量，默认为50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>base	对数 log 的底数。</li>
<li>dtype	ndarray 的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.logspace(<span class="number">1</span>, <span class="number">4</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [   10.   100.  1000. 10000.]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-geomspace"><a href="#numpy-geomspace" class="headerlink" title="numpy.geomspace"></a>numpy.geomspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.geomspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值</li>
<li>stop	序列的终止值，如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的样本数量，默认为 50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>dtype	ndarray 的数据类型</li>
<li>axis	1.16.0 版本中的新功能 ，没看懂怎么用，官网上连个例子都没有，值为 0 和 -1 的时候结果相同，其他时候都报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.geomspace(<span class="number">1</span>, <span class="number">8</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1. 2. 4. 8.]</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy从已有的数组创建数组"><a href="#Numpy从已有的数组创建数组" class="headerlink" title="Numpy从已有的数组创建数组"></a>Numpy从已有的数组创建数组</h4><h5 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.asarray 类似 numpy.array，但 numpy.asarray 的参数只有三个。</span></span><br><span class="line">numpy.asarray(a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>a</th>
<th>输入数据，可以转换为数组的任何形式。 这包括列表，元组列表，元组，元组元组，列表元组和 ndarray。</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>数据类型</td>
</tr>
<tr>
<td>order</td>
<td>在计算机内存中的存储元素的顺序，只支持 ‘C’（按行）、‘F’（按列），默认 ‘C’</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</span></span><br><span class="line">numpy.frombuffer(buffer, dtype=<span class="built_in">float</span>, count=-<span class="number">1</span>, offset=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>buffer</th>
<th>实现了 <code>__buffer__</code> 方法的对象，（绝对不是菜鸟教程上说的任意对象都可以）</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>返回数组的数据类型</td>
</tr>
<tr>
<td>count</td>
<td>读取的数据数量，默认为 -1，读取所有数据。</td>
</tr>
<tr>
<td>offset</td>
<td>读取的起始位置，默认为 0。</td>
</tr>
</tbody></table>
<p>例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</span></span><br><span class="line">a = np.frombuffer(<span class="string">b&#x27;Hello World&#x27;</span>, dtype=<span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [b&#x27;H&#x27; b&#x27;e&#x27; b&#x27;l&#x27; b&#x27;l&#x27; b&#x27;o&#x27; b&#x27; &#x27; b&#x27;W&#x27; b&#x27;o&#x27; b&#x27;r&#x27; b&#x27;l&#x27; b&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>



<p>例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">a = array.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">na = np.frombuffer(a, dtype=np.int_)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line"><span class="comment">#array.array 创建的数组对象内存是连续的（这里不能用 list，会报：AttributeError: ‘list’ object has no attribute ‘buffer’）</span></span><br><span class="line"><span class="comment"># numpy.frombuffer 从 array.array 的内存中创建数组，从上例中可以看出，改变 array.array 的值，numpy.frombuffer 的值也会跟着改变，由此可见。</span></span><br><span class="line"><span class="comment"># array.array 数组中的值改变是可以的，但是如果是添加值，那就不行了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [1, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [1 2 3 4]</span></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [10, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [10  2  3  4]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a>numpy.fromiter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</span></span><br><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">iterable = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">a = np.fromiter(iterable, <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 0  1  4  9 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看起来有点像 numpy.array，array 方法需要传入的是一个 list，而 fromiter 可以传入可迭代对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-empty-like"><a href="#numpy-empty-like" class="headerlink" title="numpy.empty_like"></a>numpy.empty_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty_like(prototype, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-zeros-like"><a href="#numpy-zeros-like" class="headerlink" title="numpy.zeros_like"></a>numpy.zeros_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-ones-like"><a href="#numpy-ones-like" class="headerlink" title="numpy.ones_like"></a>numpy.ones_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-full-like"><a href="#numpy-full-like" class="headerlink" title="numpy.full_like"></a>numpy.full_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.full_like(a, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议族详解</title>
    <url>/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="全书测试网络"><a href="#全书测试网络" class="headerlink" title="全书测试网络"></a><em><strong>全书测试网络</strong></em></h3><p>为了深入理解网络通信和网络编程，我们准备了图1-8所示的测试网络，其中包括两台主机A和B，以及一个连接到因特网的路由器。后文如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813092011827.png" alt="image-20220813092011827"></p>
<center>图 1-8 测试网络</center>

<p>该测试网络主要用于分析ARP协议、IP协议、ICMP协议、TCP协议和DNS协议。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。这样，以理论结合实践，我们就清楚TCP&#x2F;IP通信具体是如何进行的了。作者编写的多个客户端、服务器程序都是使用该网络来调试和测试的。对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而忽略了ISP（Internet Service Provider，因特网服务提供商）给它分配的WAN网络IP地址，因为全书的讨论都不涉及它。</p>
<h3 id="TCP-x2F-IP协议族"><a href="#TCP-x2F-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h3><p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220810163355071.png" alt="image-20220810163355071"></p>
<center>图 1-1 TCP/IP协议族体系结构及主要协议</center>

<ol>
<li>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。</li>
</ol>
<ul>
<li>数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换。 <strong>ARP：IP-&gt;MAC</strong></li>
</ul>
<ol start="2">
<li>网络层实现数据包的选路和转发。WAN（Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN（Local Area Network，局域网）,因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。</li>
</ol>
<ul>
<li><p>网络层最核心的协议是IP协议（Internet Protocol，因特网协议）。IP协议根据数据包的目的IP来决定如何投递它。如果数据包		  不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（next hop）路由器，并将数据包交付给该路由器来转发。多次重复该过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。IP协议使用逐跳（hop by hop）的方式确定通信路径。</p>
</li>
<li><p>网络层另外一个重要的协议是ICMP协议（Internet Control Message Protocol，因特网控制报文协议）。它是IP协议的重要补充，    主要用于检测网络连接。ICMP协议使用的报文格式如图所示。</p>
</li>
</ul>
<img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220810165616398.png" alt="image-20220810165616398" style="zoom: 50%;">

<ul>
<li>8位类型字段用于区分报文类型。它将ICMP报文分为两大类：一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）；另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（CyclicRedundancy Check，CRC），以检验报文在传输过程中是否损坏。</li>
</ul>
<ol start="3">
<li>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。它负责数据的收发、链路的超时重连等。传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。</li>
</ol>
<ul>
<li>SCTP协议（Stream Control Transmission Protocol，流控制传输协议）是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。这里不讨论SCTP协议。</li>
</ul>
<ol start="4">
<li>应用层负责处理应用程序的逻辑，在用户空间实现，负责处理众多逻辑，比如文件传输、名称查询和网络管理等，如果在内核中实现，会使内核变得庞大。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现。应用层协议：</li>
</ol>
<ul>
<li><p>ping是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
</li>
<li><p>telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，后续章节将会多次使用telnet客户端登录到其他服务上。</p>
</li>
<li><p>OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
</li>
<li><p>DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
</li>
</ul>
<p>应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议（或程序）通常既可以使</p>
<p>用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过&#x2F;etc&#x2F;services文件查看所有知名的应用层协议，以及它们都能使用哪</p>
<p>些传输层服务。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220810220933496.png" alt="image-20220810220933496"></p>
<center>图 1-4 封装</center>

<ul>
<li>经过TCP&#x2F;UDP封装后的数据称为TCP报文段（TCP message segment），或者简称TCP段&#x2F;UDP段。</li>
<li>经过IP封装后的数据称为IP数据报（IP datagram）</li>
<li>经过数据链路层封装的数据称为帧（frame）</li>
</ul>
<img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220810222545190.png" alt="image-20220810222545190" style="zoom:50%;">

<center>图 1-6 以太网帧封装</center>

<p>​		帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限		制。图所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数报可能需要被分片（fragment）传输。</p>
<h4 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h4><p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220810223345081.png" alt="image-20220810223345081"></p>
<center>图 1-7 以太网帧的分用过程</center>

<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。以以太网帧为例，它使用2字节的类型字段来标识上层协议。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报，以太网驱动程序就将帧交付给IP模块；若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块；若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模块。</p>
<p>同样，因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。TCP报文段和UDP数据报则通过其头部中的16位的端口号（portnumber）字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议（Hyper-Text Transfer Protocol，超文本传送协议）对应的端口号是80。所有知名应用层协议使用的端口号都可在&#x2F;etc&#x2F;services文件中找到。帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务。这样，在顶层目标服务看来，封装和分用似乎没有发生过。</p>
<h4 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h4><p>ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。其工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>
<h5 id="ARP请求-x2F-应答报文详解"><a href="#ARP请求-x2F-应答报文详解" class="headerlink" title="ARP请求&#x2F;应答报文详解"></a>ARP请求&#x2F;应答报文详解</h5><p>以太网ARP请求&#x2F;应答报文的格式如图1-9所示</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813092713755.png" alt="image-20220813092713755"></p>
<center>图 1-9 以太网ARP请求/应答报文</center>

<p>❑硬件类型字段定义物理地址的类型，它的值为1表示MAC地址。</p>
<p>❑协议类型字段表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p>❑硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为4。 </p>
<p>❑操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。</p>
<p>❑最后4个字段指定通信双方的以太网地址和IP地址。发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之（当然，如前所述，操作字段需要设置为2）。<strong>以太网地址即为MAC地址</strong></p>
<blockquote>
<p> 由图1-9可知，ARP请求&#x2F;应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节（见图1-6），则一个携带ARP请求&#x2F;应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节（见图1-4），此时ARP请求&#x2F;应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求&#x2F;应答报文的以太网帧长度为64字节。</p>
</blockquote>
<h5 id="ARP高速缓存的查看与修改"><a href="#ARP高速缓存的查看与修改" class="headerlink" title="ARP高速缓存的查看与修改"></a>ARP高速缓存的查看与修改</h5><p>通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如，ernest-laptop在某一时刻（注意，ARP高速缓存是动态变化的）的ARP缓存内容如下（使用arp-a命令）：</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813100212614.png" alt="image-20220813100212614"></p>
<p>其中，第一项描述的是另一台测试机器Kongming20（注意，其IP地址、MAC地址都与图1-8描述的一致），第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项：</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813100318552.png" alt="image-20220813100318552"></p>
<h5 id="使用tcpdump观察ARP通信过程"><a href="#使用tcpdump观察ARP通信过程" class="headerlink" title="使用tcpdump观察ARP通信过程"></a>使用tcpdump观察ARP通信过程</h5><p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet命令登录Kongming20的echo服务（已经开启），并用tcpdump（详见第17章）抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下：</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813101613921.png" alt="image-20220813101613921"></p>
<p>在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输 出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容）。tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出（数据包前面的编号是笔者加入的，后同）：</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813102928621.png" alt="image-20220813102928621"></p>
<blockquote>
<p>由tcpdump抓取的数据包本质上是以太网帧，我们通过该命令的众多选项来控制帧的过滤（比如用dst和src指定通信的目的端IP地址和源端IP地址）和显示（比如用-e选项开启以太网帧头部信息的显示）</p>
</blockquote>
<ul>
<li><p>第一个数据包中，ARP通信的源端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop），目的端的物理地址是ff:ff:ff:ff:ff:ff，这是以太网的广播地址，用以表示整个LAN。该LAN上的所有机器都会收到并处理这样的帧。数值0x806是以太网帧头部的类型字段的值，它表示分用的目标是ARP模块。<strong>该以太网帧的长度为42字节（实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段）</strong>，其中数据部分长度为28字节。“Request”表示这是一个ARP请求，“who-has192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的MAC地址。</p>
</li>
<li><p>第二个数据包中，ARP通信的源端的物理地址是08:00:27:53:10:67（Kongming20），目的端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop）。“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20报告其物理地址。<strong>该以太网帧的长度为60字节（实际上是64字节）</strong>，可见它使用了填充字节来满足最小帧长度</p>
</li>
</ul>
<p>为了便于理解，我们将上述讨论用图1-10来详细说明。</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813103621923.png" alt="image-20220813103621923"></p>
<center>图 1-10 ARP通信过程</center>

<ul>
<li><p>第一，我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
</li>
<li><p>第二，ARP请求和应答是从以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧（比如携带IP数据报的以太网帧）的区别。</p>
</li>
<li><p>第三，路由器也将接收到以太网帧1，因为该帧是一个广播帧。不过很显然，路由器并没有回应其中的ARP请求，正如前文讨论的那样。</p>
</li>
</ul>
<h4 id="DNS协议工作原理"><a href="#DNS协议工作原理" class="headerlink" title="DNS协议工作原理"></a>DNS协议工作原理</h4><p>我们通常使用机器的域名来访问这台机器，而不直接使用其IP地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢？这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS（Network Information Service，网络信息服务）、DNS和本地静态文件等。本节主要讨论DNS</p>
<h5 id="DNS查询和应答报文详解"><a href="#DNS查询和应答报文详解" class="headerlink" title="DNS查询和应答报文详解"></a>DNS查询和应答报文详解</h5><p>DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。<strong>DNS查询和应答报文的格式如图1-11所示：</strong></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813105711291.png" alt="image-20220813105711291"></p>
<center>图 1-11 DNS查询和应答报文</center>

<p>16位标识字段用于标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。</p>
<p>16位标志字段用于协商具体的通信方式和反馈通信状态。<strong>DNS报文头部的16位标志字段的细节如图1-12所示</strong></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813105921715-0359563.png" alt="image-20220813105921715"></p>
<center>图 1-12 DNS报文头部的标志字段</center>

<p>❑QR，查询&#x2F;应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p>❑opcode，定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态。</p>
<p>❑AA，授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p>❑TC，截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p>❑RD，递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考。</p>
<p>❑RA，允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p>❑zero，这3位未用，必须都设置为0。 </p>
<p>❑rcode，4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p><strong>查询问题的格式如图1-13所示</strong></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813110838789.png" alt="image-20220813110838789"></p>
<center>图 1-13 DNS查询问题的格式</center>

<p>图1-13中，查询名以一定的格式封装了要查询的主机域名。16位查询类型表示如何执行查询操作，常见的类型有如下几种：</p>
<p>❑类型A，值是1，表示获取目标主机的IP地址。</p>
<p>❑类型CNAME，值是5，表示获得目标主机的别名。</p>
<p>❑类型PTR，值是12，表示反向查询。</p>
<p>16位查询类通常为1，表示获取因特网地址（IP地址）。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录（ResourceRecord，RR）格式。<strong>资源记录格式如图1-14所示</strong></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813111217837.png" alt="image-20220813111217837"></p>
<center>图 1-14 资源记录格式</center>

<p>图1-14中，32位域名是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。16位类型和16位类字段的含义也与DNS查</p>
<p>询问题的对应字段相同。</p>
<p>32位生存时间表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p>16位资源数据长度字段和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）。</p>
<h5 id="Linux下访问DNS服务"><a href="#Linux下访问DNS服务" class="headerlink" title="Linux下访问DNS服务"></a>Linux下访问DNS服务</h5><p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;resolv.conf文件来存放DNS服务器的IP地址。</p>
<p>机器ernest-laptop上，该文件的内容如下：</p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813112602076.png" alt="image-20220813112602076"></p>
<blockquote>
<p>其中的两个IP地址分别是首选DNS服务器地址和备选DNS服务器地址。文件中的注释语句“Generated by Network Manager”告诉我们，这两个DNS服务器地址是由网络管理程序写入的。</p>
</blockquote>
<p>Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813112723353.png" alt="image-20220813112723353"></p>
<p>host命令的输出告诉我们，机器名<a href="http://www.baidu.com是www.a.shifen.com.的别名,并且该机器名对应两个ip地址.host命令使用dns协议和dns服务器通信,其-t选项告诉dns协议使用哪种查询类型.我们这里使用的是a类型,即通过机器的域名获得其ip地址(但实际上返回的资源记录中还包含机器的别名).关于host命令的详细使用方法,请参考其man手册/">www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。关于host命令的详细使用方法，请参考其man手册</a>.</p>
<h5 id="使用tcpdump观察DNS通信过程"><a href="#使用tcpdump观察DNS通信过程" class="headerlink" title="使用tcpdump观察DNS通信过程"></a>使用tcpdump观察DNS通信过程</h5><p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行host命令以查询主机<a href="http://www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下：">www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下：</a></p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813113501982.png" alt="image-20220813113501982"></p>
<blockquote>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示只抓取使用domain（域名）服务的数据包，即DNS查询和应答报文。tcpdump的输出如下:</p>
</blockquote>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813113757380.png" alt="image-20220813113757380"></p>
<p>这两个数据包开始的“IP”指出，它们后面的内容描述的是IP数据报。tcpdump以“IP地址.端口号”的形式来描述通信的某一端；以“＞”表示数据传输的方向，“＞”前面是源端，后面是目的端。可见，第一个数据包是测试机器ernest-laptop（IP地址是192.168.1.108）向其首DNS服务器（IP地址是219.239.26.42）发送的DNS查询报文（目标端口53是DNS服务使用的端口，这一点我们在前面介绍过），第二个数据包是服务器反馈的DNS应答报文</p>
<p>第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A?”表示使用A类型的查询方式。“<a href="http://www.baidu.com”则是dns查询问题中的查询名.括号中的数值31是dns查询报文的长度(以字节为单位)/">www.baidu.com”则是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度（以字节为单位）</a></p>
<p>第二个数据包中，“3&#x2F;4&#x2F;4”表示该报文中包含3个应答资源记录、4个授权资源记录和4个额外信息记录。“CNAME <a href="http://www.a.shifen.com.,a/">www.a.shifen.com.，A</a> 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。该应答报文的长度为226字节</p>
<blockquote>
<p>注意 我们抓包的时候没有开启tcpdump的-X选项（或者-x选项）。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就能明白上面31字节的查询报文和226字节的应答报文的具体含义。限于篇幅，这里不再讨论</p>
</blockquote>
<h4 id="socket和TCP-x2F-IP协议族的关系"><a href="#socket和TCP-x2F-IP协议族的关系" class="headerlink" title="socket和TCP&#x2F;IP协议族的关系"></a>socket和TCP&#x2F;IP协议族的关系</h4><p>前文提到，数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（ApplicationProgramming Interface，应用程序编程接口）主要有两套：socket和XTI。XTI现在基本不再使用，本书仅讨论socket。图1-1显示了socket与TCP&#x2F;IP协议族的关系。</p>
<p>由socket定义的这一组API提供如下两点功能：</p>
<ul>
<li><p>将应用程序数据从用户缓冲区中复制到TCP&#x2F;UDP内核发送缓冲区，以交付内核来发送数据（比如图1-5所示的send函数），或者是从内核TCP&#x2F;UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；</p>
</li>
<li><p>应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。</p>
</li>
</ul>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220813114452246.png" alt="image-20220813114452246"></p>
<center>图 1-5 TCP报文段封装过程</center>

<p>值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP&#x2F;IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）</p>
<h3 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h3><p>IP协议是TCP&#x2F;IP协议族的核心协议，也是socket网络编程的基础之一。本章从两个方面较为深入地探讨IP协议：</p>
<p>❑IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。</p>
<p>❑IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。</p>
<p>由于32位表示的IP地址即将全部使用完，因此人们开发出了新版本的IP协议，称为IPv6协议，而原来的版本则称为IPv4协议。本章前面部分的讨论都是基于IPv4协议的，只在最后一节简要讨论IPv6协议。在开始讨论前，我们先简单介绍一下IP服务。</p>
<h4 id="IP服务"><a href="#IP服务" class="headerlink" title="IP服务"></a>IP服务</h4><p><strong>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</strong></p>
<p><strong>无状态（stateless）</strong>是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。</p>
<p>虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。</p>
<p>无状态服务的优点也很明显：简单、高效。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如UDP协议和HTTP协议都是无状态协议。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p>
<p><strong>无连接（connectionless）</strong>是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p>
<p><strong>不可靠</strong>是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h4 id="IPv4头部结构-1总8片首4"><a href="#IPv4头部结构-1总8片首4" class="headerlink" title="IPv4头部结构(1总8片首4)"></a>IPv4头部结构(1总8片首4)</h4><p>IPv4的头部结构如图2-1所示。其长度为20-60字节 </p>
<p><img src="/2022/08/10/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20220814011241854.png" alt="image-20220814011241854"></p>
<center>图 2-1 IPv4头部结构</center>

<ul>
<li><p>4位版本号（version）指定IP协议的版本。对IPv4来说，其值是4。</p>
</li>
<li><p>4位头部长度（header length）标识该IP头部有多少个32 bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节。</p>
</li>
<li><p>8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p>
</li>
<li><p>16位总长度（total length）是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535（2 ^16-1）字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输。</p>
</li>
<li><p>16位标识（identification）唯一地标识主机发送的每一个数据报。其初始值由系统随机生成；每发送一个数据报，其值就加1。该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具有相同的标识值</p>
</li>
<li><p>3位标志字段的第一位保留。第二位（Don’t Fragment，DF）表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位（More Fragment，MF）表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p>
</li>
<li><p>13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合适的偏移值）。</p>
</li>
<li><p>8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置（常见的值是64）。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。</p>
</li>
<li><p>8位协议（protocol）用来区分上层协议，我们在第1章讨论过。&#x2F;etc&#x2F;protocols文件定义了所有上层协议对应的protocol字段的数值。其中，ICMP是1，TCP是6，UDP是17。&#x2F;etc&#x2F;protocols文件是RFC 1700的一个子集。</p>
</li>
<li><p>16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程中是否损坏。</p>
</li>
<li><p>32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。</p>
</li>
<li><p>IPv4最后一个选项字段（option）是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。可用的IP选项包括：</p>
<ul>
<li><p>记录路由（record route），告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递路径</p>
</li>
<li><p>时间戳（timestamp），告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间</p>
</li>
<li><p>松散源路由选择（loose source routing），指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器</p>
</li>
<li><p>严格源路由选择（strict source routing），数据报只能经过被指定的路由器</p>
<ul>
<li>这些选项字段很少被使用，使用松散源路由选择和严格源路由选择选项的例子大概仅有traceroute程序。此外，作为记录路由IP选项的替代品，traceroute程序使用UDP报文和ICMP报文实现了更可靠的记录路由功能，详情请参考文档RFC 1393。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>《Linux高性能服务器编程》</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
