<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.两数之和</title>
    <url>/2022/08/04/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i]) != mp.<span class="built_in">end</span>())&#123;	<span class="comment">// mp.end()指向最后元素下一个元素的迭代器</span></span><br><span class="line">                <span class="keyword">return</span> &#123;mp.<span class="built_in">find</span>(target-nums[i])-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        d = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span>[d[target-num],i]</span><br><span class="line">            <span class="keyword">else</span>: d[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>112.路径总和 113.路径总和II 257.二叉树的所有路径 437.路径总和III</title>
    <url>/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsum1.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsum2.jpg" alt="img"></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(<span class="number">1</span> <span class="comment">--&gt; 2): 和为 3</span></span><br><span class="line">(<span class="number">1</span> <span class="comment">--&gt; 3): 和为 4</span></span><br><span class="line">不存在 <span class="built_in">sum</span> = <span class="number">5</span> 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">输入<span class="built_in">：root</span> = [], targetSum = <span class="number">0</span></span><br><span class="line">输出<span class="built_in">：false</span></span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(targetSum == root -&gt; val &amp;&amp; root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root -&gt; left, targetSum - root -&gt; val) || <span class="built_in">hasPathSum</span>(root -&gt; right, targetSum - root -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsumii1.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,null,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,null,null,<span class="number">5</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="string">[[5,4,11,2],[5,8,4,5]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsum2-20221007111645663.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1,2,3]</span>, targetSum = 5</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1,2]</span>, targetSum = 0</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root -&gt; val);</span><br><span class="line">        targetSum -= root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(targetSum == <span class="number">0</span> &amp;&amp; root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;]</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum, vector&lt;<span class="type">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root -&gt; val);</span><br><span class="line">        targetSum -= root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(targetSum == <span class="number">0</span> &amp;&amp; root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, targetSum, path);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, targetSum, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/paths-tree.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="string">&quot;1-&gt;2-&gt;5&quot;</span>,<span class="string">&quot;1-&gt;3&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="string">&quot;1&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;string&gt;&amp; res, string path)</span></span>&#123; <span class="comment">// &amp; res 表示直接修改的是全局变量的那个res</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        string temp = <span class="built_in">to_string</span>(root -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            path += temp;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, res, path + temp + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, res, path + temp + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// path.pop_back(); 如果path作为一个形参传入dfs中就不需要这步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/06/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/pathsum3-1-tree.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">8</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：和等于 <span class="number">8</span> 的路径有 <span class="number">3</span> 条，如图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
<li><code>-109 &lt;= Node.val &lt;= 109</code> </li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123; </span><br><span class="line">        <span class="built_in">inorder</span>(root,targetSum); <span class="comment">//中序遍历每个节点,都做一次dfs</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">long</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum -= root -&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) cnt++;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="type">long</span> sum)</span></span>&#123; <span class="comment">//sum 不加 &amp; 的话 就不会变化,每次都为 targetSum</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root -&gt; left, sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root,sum);</span><br><span class="line">        <span class="built_in">inorder</span>(root -&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>114.二叉树展开为链表</title>
    <url>/2022/10/07/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/07/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/flaten.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路1:先序遍历二叉树,将每个节点放入 res , 然后遍历 res 改变树结构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root -&gt; left &amp;&amp; ! root -&gt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            root -&gt; right = res[i];</span><br><span class="line">            root -&gt; left = <span class="literal">nullptr</span>;</span><br><span class="line">            root = root -&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">preorder</span>(root -&gt; left);</span><br><span class="line">        <span class="built_in">preorder</span>(root -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>思路2 从后往前链接,先 4-&gt;5,再3-&gt;4-&gt;5, 2-&gt;3-&gt;4-&gt;5, 最后 1-&gt;2-&gt;3-&gt;4-&gt;5  本来先序顺序是 根-&gt;左-&gt;右 这里变成 右-&gt;左-&gt;根</li>
</ul>
<img src="/2022/10/07/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20221007131404252.png" alt="image-20221007131404252" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* last = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">  <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">  root-&gt;right = last;</span><br><span class="line">  root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">  last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>思路3:寻找前驱节点</li>
</ul>
<p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1)的做法呢？</p>
<p>注意到前序遍历访问各节点的顺序是根、左、右。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。<strong>该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点</strong></p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left)&#123;</span><br><span class="line">            pre = root -&gt; left;</span><br><span class="line">            <span class="keyword">while</span>(pre -&gt;right)&#123;</span><br><span class="line">                pre = pre -&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre -&gt; right = root -&gt;right; </span><br><span class="line">            root -&gt; right = root -&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root -&gt; left =<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">flatten</span> (root -&gt; right); <span class="comment">//把所有点都弄到root右边来了,所以只需向右走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>120.三角形最小路径和</title>
    <url>/2022/11/02/120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></h3><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">输出：11</span><br><span class="line">解释：如下面简图所示：</span><br><span class="line">   2</span><br><span class="line"> <span class="number"> 3 </span>4</span><br><span class="line"><span class="number"> 6 </span>5 7</span><br><span class="line">4<span class="number"> 1 </span>8 3</span><br><span class="line">自顶向下的最小路径和为 11（即，2 +<span class="number"> 3 </span>+<span class="number"> 5 </span>+<span class="number"> 1 </span>= 11）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：triangle = <span class="string">[[-10]]</span></span><br><span class="line">输出：<span class="number">-10</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= triangle.length &lt;= 200</code></li>
<li><code>triangle[0].length == 1</code></li>
<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>
<li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>二维DP</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lvlMin = INT_MAX;</span><br><span class="line">        <span class="type">int</span> r = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++)&#123;</span><br><span class="line">            dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        lvlMin = <span class="built_in">min</span>(dp[r - <span class="number">1</span>][r - <span class="number">1</span>],dp[r - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">                <span class="keyword">if</span>(i == r - <span class="number">1</span>)&#123;</span><br><span class="line">                    lvlMin = <span class="built_in">min</span>(lvlMin, dp[r - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lvlMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同思路简洁版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(f[n - <span class="number">1</span>].<span class="built_in">begin</span>(), f[n - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>改进版</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为dp[i] [...] 的状态只和dp[i - 1] [...] 的状态有关, 所以只需两个数组轮流存储遍历到的最末尾两行的信息</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针II</title>
    <url>/2022/10/19/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/19/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/116_sample.png" alt="img"></p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="meta">#,2,3,#,4,5,6,7,#]</span></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 <span class="keyword">next</span> 指针连接，<span class="string">&#x27;#&#x27;</span> 标志着每一层的结束。</span><br></pre></td></tr></table></figure>



<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li>
<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><img src="/2022/10/19/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/image-20221019113647196.png" alt="image-20221019113647196" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left) root -&gt; left -&gt; next = root -&gt; right;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right) root -&gt; right -&gt; next = root -&gt; next ? root -&gt; next -&gt; left : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">connect</span>(root -&gt; left);</span><br><span class="line">        <span class="built_in">connect</span>(root -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><p>给定一个二叉树</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>示例：</strong></p>
<p><img src="/2022/10/19/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/117_sample.png" alt="img"></p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="meta">#,2,3,#,4,5,7,#]</span></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 <span class="keyword">next</span> 指针连接），<span class="string">&#x27;#&#x27;</span> 表示每层的末尾。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数小于 <code>6000</code></li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><img src="/2022/10/19/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/image-20221019150026247.png" alt="image-20221019150026247" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; right) root -&gt; left -&gt; next = root -&gt; right; <span class="comment">// 父节点有有孩子</span></span><br><span class="line">            <span class="keyword">else</span> root -&gt; left -&gt; next = <span class="built_in">getNext</span>(root -&gt; next);<span class="comment">// 父节点没有右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; next) root -&gt; right -&gt; next = <span class="built_in">getNext</span>(root -&gt; next);</span><br><span class="line">            <span class="keyword">else</span> root -&gt; right -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connect</span>(root -&gt; right);</span><br><span class="line">        <span class="built_in">connect</span>(root -&gt; left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">getNext</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left) <span class="keyword">return</span> root -&gt; left;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right) <span class="keyword">return</span> root -&gt; right;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getNext</span>(root -&gt; next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>129.求根节点到叶节点数字之和</title>
    <url>/2022/10/07/129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/07/129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/num1tree.jpg" alt="img"></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/07/129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/num2tree.jpg" alt="img"></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="keyword">return</span> sum * <span class="number">10</span> + root -&gt; val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root -&gt; left, sum * <span class="number">10</span> + root -&gt; val) + <span class="built_in">dfs</span>(root -&gt; right, sum * <span class="number">10</span> + root -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>130.被围绕的区域 面试题13. 机器人的运动范围</title>
    <url>/2022/10/09/130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/09/130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/xogrid.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>]]</span><br><span class="line">输出：[[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>],[<span class="string">&quot;X&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;X&quot;</span>]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="string">&#x27;O&#x27;</span> 都不会被填充为 <span class="string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="string">&#x27;O&#x27;</span> 相连的 <span class="string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="string">&#x27;X&#x27;</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：board = <span class="string">[[&quot;X&quot;]]</span></span><br><span class="line">输出：<span class="string">[[&quot;X&quot;]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>与<a href="https://kjgggggg.github.io/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿系列</a>问题思路一致</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> c = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">1</span> || c == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || i == r <span class="number">-1</span> || j == c - <span class="number">1</span>|| j == <span class="number">0</span>) <span class="built_in">dfs</span>(board, i, j);</span><br><span class="line">                    <span class="comment">// if(board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; 不能在这写是因为刚变为N后 又被变为O了，然后又被变为X了</span></span><br><span class="line">                    <span class="comment">// if(board[i][j] == &#x27;N&#x27;) board[i][j] = &#x27;O&#x27;; </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r ; i++)&#123; <span class="comment">// N变为O O变为X</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;N&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt; board.<span class="built_in">size</span>() - <span class="number">1</span> || c &lt; <span class="number">0</span> || c &gt; board[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[r][c] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[r][c] = <span class="string">&#x27;N&#x27;</span>; <span class="comment">// 先遍历边界的O,将与之相连的O全改成N </span></span><br><span class="line">        <span class="built_in">dfs</span>(board, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="built_in">dfs</span>(board, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="built_in">dfs</span>(board, r, c + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(board, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">面试题13. 机器人的运动范围</a></h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, <span class="built_in">n</span> = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>与<a href="https://kjgggggg.github.io/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿系列</a>问题思路一致</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始化为m行n列的0</span></span><br><span class="line">        <span class="built_in">dfs</span>(m, n, <span class="number">0</span>, <span class="number">0</span>, k, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt; m - <span class="number">1</span> || c &lt; <span class="number">0</span> || c &gt; n - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((r % <span class="number">10</span> + r / <span class="number">10</span> + c % <span class="number">10</span> + c / <span class="number">10</span>) &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[r][c] != <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 已经被访问过</span></span><br><span class="line">        visited[r][c] = <span class="number">1</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="built_in">dfs</span>(m, n, r + <span class="number">1</span>, c, k, visited);</span><br><span class="line">        <span class="built_in">dfs</span>(m, n, r - <span class="number">1</span>, c, k, visited);</span><br><span class="line">        <span class="built_in">dfs</span>(m, n, r , c + <span class="number">1</span>, k, visited);</span><br><span class="line">        <span class="built_in">dfs</span>(m, n, r , c - <span class="number">1</span>, k, visited);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>14.最长公共前缀</title>
    <url>/2022/08/09/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cnt = <span class="number">0</span>; cnt&lt;strs[<span class="number">0</span>].<span class="built_in">length</span>(); cnt++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i].<span class="built_in">length</span>()&lt;=cnt || strs[i].<span class="built_in">at</span>(cnt)!=strs[<span class="number">0</span>].<span class="built_in">at</span>(cnt))&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(strs[i])&lt;=cnt <span class="keyword">or</span> strs[i][cnt]!=strs[<span class="number">0</span>][cnt]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:cnt]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>140.单词拆分II</title>
    <url>/2022/10/19/140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/</url>
    <content><![CDATA[<h3 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a></h3><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。</p>
<p><strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入:s = <span class="string">&quot;catsanddog&quot;</span>, wordDict = [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cats&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;sand&quot;</span>,<span class="string">&quot;dog&quot;</span>]</span><br><span class="line">输出:[<span class="string">&quot;cats and dog&quot;</span>,<span class="string">&quot;cat sand dog&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入:s = <span class="string">&quot;pineapplepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;pen&quot;</span>,<span class="string">&quot;applepen&quot;</span>,<span class="string">&quot;pine&quot;</span>,<span class="string">&quot;pineapple&quot;</span>]</span><br><span class="line">输出:[<span class="string">&quot;pine apple pen apple&quot;</span>,<span class="string">&quot;pineapple pen apple&quot;</span>,<span class="string">&quot;pine applepen apple&quot;</span>]</span><br><span class="line">解释: 注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">输入<span class="symbol">:s</span> = <span class="string">&quot;catsandog&quot;</span>, wordDict = [<span class="string">&quot;cats&quot;</span>,<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;sand&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出<span class="symbol">:[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
<li><code>wordDict</code> 中所有字符串都 <strong>不同</strong></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路: DFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(s, wordDict, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict, vector&lt;string&gt;&amp; res, string path)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">set&lt;string&gt; <span class="title">st</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">0</span>; L &lt; n + <span class="number">1</span>; L ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, L)) != st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                string temp= s.<span class="built_in">substr</span>(<span class="number">0</span>, L);</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(L), wordDict, res, s.<span class="built_in">substr</span>(L).<span class="built_in">empty</span>() ? path + temp : path + temp + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(s, wordDict, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict, string path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">set&lt;string&gt; <span class="title">st</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">0</span>; L &lt; n + <span class="number">1</span>; L ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, L)) != st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                string temp= s.<span class="built_in">substr</span>(<span class="number">0</span>, L);</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(L), wordDict, s.<span class="built_in">substr</span>(L).<span class="built_in">empty</span>() ? path + temp : path + temp + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>146.LRU缓存</title>
    <url>/2022/11/27/146-LRU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h3><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;LRUCache&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;put&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;get&quot;</span>]</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">4</span>]]</span><br><span class="line">输出</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="number">-1</span>, <span class="literal">null</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = <span class="keyword">new</span> <span class="type">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">lRUCache.put(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.put(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.put(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.put(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>双链表 + unordered_map </li>
<li>最左和最右Node不存储值</li>
<li>自定义remove 和 insert 两个函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义双链表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key,value;</span><br><span class="line">        Node* left ,*right;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> _key,<span class="type">int</span> _value): <span class="built_in">key</span>(_key),<span class="built_in">value</span>(_value),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;*L,*R;<span class="comment">//双链表的最左和最右节点，不存贮值。</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt;hash;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        p-&gt;right-&gt;left = p-&gt;left;</span><br><span class="line">        p-&gt;left-&gt;right = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line">        p-&gt;right = L-&gt;right;</span><br><span class="line">        p-&gt;left = L;</span><br><span class="line">        L-&gt;right-&gt;left = p;</span><br><span class="line">        L-&gt;right = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        L = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>,<span class="number">-1</span>),R = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        L-&gt;right = R;</span><br><span class="line">        R-&gt;left = L;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不存在关键字 key </span></span><br><span class="line">        <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">        <span class="built_in">remove</span>(p);</span><br><span class="line">        <span class="built_in">insert</span>(p);<span class="comment">//将当前节点放在双链表的第一位</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key))&#123; <span class="comment">//如果key存在，则修改对应的value</span></span><br><span class="line">            <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">            p-&gt;value = value;</span><br><span class="line">            <span class="built_in">remove</span>(p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">size</span>() == n)&#123; <span class="comment">//如果缓存已满，则删除双链表最右侧的节点</span></span><br><span class="line">                <span class="keyword">auto</span>  p = R-&gt;left;</span><br><span class="line">                <span class="built_in">remove</span>(p);</span><br><span class="line">                hash.<span class="built_in">erase</span>(p-&gt;key); <span class="comment">//更新哈希表</span></span><br><span class="line">                <span class="keyword">delete</span> p; <span class="comment">//释放内存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，插入(key, value)</span></span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">            hash[key] = p;</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>156.上下翻转二叉树</title>
    <url>/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156. 上下翻转二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-upside-down/">156. 上下翻转二叉树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，请你将此二叉树上下翻转，并返回新的根节点。</p>
<p>你可以按下面的步骤翻转一棵二叉树：</p>
<ol>
<li>原来的左子节点变成新的根节点</li>
<li>原来的根节点变成新的右子节点</li>
<li>原来的右子节点变成新的左子节点</li>
</ol>
<p><img src="/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/main.jpg" alt="img"></p>
<p>上面的步骤逐层进行。题目数据保证每个右节点都有一个同级节点（即共享同一父节点的左节点）且不存在子节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/updown.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 10]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 10</code></li>
<li>树中的每个右节点都有一个同级节点（即共享同一父节点的左节点）</li>
<li>树中的每个右节点都没有子节点</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><img src="/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230221000757070.png" alt="image-20230221000757070" style="zoom:33%;">

<img src="/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230221000833962.png" alt="image-20230221000833962" style="zoom:30%;">

<img src="/2023/02/21/156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230221000945169.png" alt="image-20230221000945169" style="zoom:39%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">upsideDownBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || (!root -&gt; left &amp;&amp; !root -&gt; right)) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* cur = root, * pre = root;</span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; left) pre = cur, cur = cur -&gt; left;</span><br><span class="line">        cur -&gt; left = pre -&gt; right;</span><br><span class="line">        pre-&gt;left = pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        cur -&gt; right = <span class="built_in">dfs</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>15.三数之和</title>
    <url>/2022/12/02/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[-1,0,1,2,-1,-4]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[-1,-1,2]</span>,<span class="comment">[-1,0,1]</span>]</span></span><br><span class="line">解释：</span><br><span class="line">nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> + nums<span class="comment">[2]</span> = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums<span class="comment">[1]</span> + nums<span class="comment">[2]</span> + nums<span class="comment">[4]</span> = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums<span class="comment">[0]</span> + nums<span class="comment">[3]</span> + nums<span class="comment">[4]</span> = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 <span class="comment">[-1,0,1]</span> 和 <span class="comment">[-1,-1,2]</span> 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[0,1,1]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[0,0,0]]</span></span><br><span class="line">解释：唯一可能的三元组和为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first = <span class="number">0</span>; first &lt; n ; first ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="type">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(second &lt; third)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[first] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">                <span class="type">int</span> sum = nums[first] + nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (second&lt;third &amp;&amp; nums[second] == nums[second+<span class="number">1</span>]) second++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (second&lt;third &amp;&amp; nums[third] == nums[third<span class="number">-1</span>]) third--; <span class="comment">// 去重</span></span><br><span class="line">                    second ++;</span><br><span class="line">                    third --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) second++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) third--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,2,1,<span class="string">-4</span>], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (<span class="string">-1</span> + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], <span class="keyword">target</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> closeNum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dist = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first = <span class="number">0</span>; first &lt; n ; first ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="type">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(second &lt; third)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[first] + nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target - sum) &lt; dist)&#123;</span><br><span class="line">                    dist = <span class="built_in">abs</span>(target - sum);</span><br><span class="line">                    closeNum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) second++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) third--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closeNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>17.电话号码的字母组合</title>
    <url>/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2022/08/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;af&quot;</span>,<span class="string">&quot;bd&quot;</span>,<span class="string">&quot;be&quot;</span>,<span class="string">&quot;bf&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ce&quot;</span>,<span class="string">&quot;cf&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：digits <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;2&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; combinations;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt; phoneMap&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        string combination;</span><br><span class="line">        <span class="built_in">dfs</span>(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; combinations, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, string&gt;&amp; phoneMap, <span class="type">const</span> string&amp; digits, <span class="type">int</span> index, string&amp; combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            combinations.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> digit = digits[index];</span><br><span class="line">            <span class="type">const</span> string&amp; letters = phoneMap.<span class="built_in">at</span>(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; letter: letters) &#123;</span><br><span class="line">                combination.<span class="built_in">push_back</span>(letter);</span><br><span class="line">              	<span class="comment">//index从0开始，到==size结束，所以比正常多一轮</span></span><br><span class="line">                <span class="built_in">dfs</span>(combinations, phoneMap, digits, index + <span class="number">1</span>, combination); </span><br><span class="line">                combination.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">index: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">                combinations.append(<span class="string">&quot;&quot;</span>.join(combination))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digit = digits[index]</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                    combination.append(letter)</span><br><span class="line">                    dfs(index + <span class="number">1</span>)</span><br><span class="line">                    combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = <span class="built_in">list</span>()</span><br><span class="line">        combinations = <span class="built_in">list</span>()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>199.二叉树的右视图 513.找树左下角的值</title>
    <url>/2022/10/07/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/10/07/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/tree.jpg" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">[1,null,3]</span></span><br><span class="line">输出: <span class="comment">[1,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">[]</span></span><br><span class="line">输出: <span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">bfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">back</span>()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; left) q.<span class="built_in">push</span>(temp -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; right) q.<span class="built_in">push</span>(temp -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/10/07/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/tree1.jpg" alt="img"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: root = [2,1,3]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="/2022/10/07/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/tree2.jpg" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,104]</code></li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(root -&gt; left == nullptr &amp;&amp; root -&gt; right == nullptr) return root -&gt; val; </span></span><br><span class="line">        <span class="built_in">bfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            res = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">                temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; left) q.<span class="built_in">push</span>(temp -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; right) q.<span class="built_in">push</span>(temp -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>bfs</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2022/08/05/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：</p>
<p>输入：l1 &#x3D; [2, 4, 3],  l2 &#x3D; [5, 6, 4]<br>输出：[7, 0, 8]<br>解释：342 + 465 &#x3D; 807</p>
<p>示例 2：</p>
<p>输入：l1 &#x3D; [0],  l2 &#x3D; [0]<br>输出：[0]</p>
<p>示例 3：</p>
<p>输入：l1 &#x3D; [9, 9, 9, 9, 9, 9, 9],  l2 &#x3D; [9, 9, 9, 9]<br>输出：[8, 9, 9, 9, 0, 0, 0, 1]</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">dfs</span><span class="params">(ListNode* l, ListNode* r, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r &amp;&amp; !i) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        <span class="type">int</span> sum = (l ? l-&gt;val : <span class="number">0</span>) + (r ? r-&gt;val : <span class="number">0</span>) + i;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//可能有l1与l2都为空但carry不为0的情况</span></span><br><span class="line">        node-&gt;next = <span class="built_in">dfs</span>(l ? l-&gt;next : <span class="literal">nullptr</span>, r ? r-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">l, r, i</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r <span class="keyword">and</span> <span class="keyword">not</span> i: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            s = (l.val <span class="keyword">if</span> l <span class="keyword">else</span> <span class="number">0</span>) + (r.val <span class="keyword">if</span> r <span class="keyword">else</span> <span class="number">0</span>) + i</span><br><span class="line">            node = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># Python中//是模运算，/是整除运算</span></span><br><span class="line">            node.<span class="built_in">next</span> = dfs(l.<span class="built_in">next</span> <span class="keyword">if</span> l <span class="keyword">else</span> <span class="literal">None</span>, r.<span class="built_in">next</span> <span class="keyword">if</span> r <span class="keyword">else</span> <span class="literal">None</span>, s // <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> dfs(l1, l2, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>





<h3 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/">445. 两数相加 II</a></h3><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2022/08/05/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/1626420025-fZfzMX-image.png" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[7,2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,8,0,7]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[8,0,7]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为<code> [1, 100]</code></li>
<li><code>0 &lt;= node.val &lt;= 9</code></li>
<li>输入数据保证链表代表的数字无前导 0</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1,s2; <span class="comment">// 栈顶都是最后一位</span></span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(l1 -&gt; val);</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(l2 -&gt; val);</span><br><span class="line">            l2 =l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() || !s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(((s1.<span class="built_in">empty</span>() ? <span class="number">0</span> : s1.<span class="built_in">top</span>()) + (s2.<span class="built_in">empty</span>() ? <span class="number">0</span> : s2.<span class="built_in">top</span>()) + carry) % <span class="number">10</span>, nxt);</span><br><span class="line">            carry = ((s1.<span class="built_in">empty</span>() ? <span class="number">0</span> : s1.<span class="built_in">top</span>()) + (s2.<span class="built_in">empty</span>() ? <span class="number">0</span> : s2.<span class="built_in">top</span>()) + carry) / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>()) s1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>()) s2.<span class="built_in">pop</span>();</span><br><span class="line">            nxt = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若没有下句，则输入[5],[5]输出为[0]</span></span><br><span class="line">        <span class="keyword">if</span>(carry) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry, nxt); </span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>200.岛屿数量 463.岛屿的周长 695.岛屿的最大面积 1254. 统计封闭岛屿的数目</title>
    <url>/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cnt;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !<span class="built_in">isIn</span>(grid,r,c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( grid[r][c] != <span class="string">&#x27;1&#x27;</span> ) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r+<span class="number">1</span>,c);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r<span class="number">-1</span>,c);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIn</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= grid.<span class="built_in">size</span>() || r&lt;<span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || c&lt;<span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    cnt = cnt + <span class="number">1</span> <span class="comment">#python没有cnt++这种写法 ,也不能写成cnt+1,这种写法没有真正给cnt赋值</span></span><br><span class="line">                    self.dfs(grid,i,j)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,grid,r,c</span>):</span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(grid)) <span class="keyword">or</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(grid[<span class="number">0</span>])): <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[r][c] != <span class="string">&quot;1&quot;</span>: <span class="keyword">return</span></span><br><span class="line">        grid[r][c] = <span class="string">&quot;2&quot;</span></span><br><span class="line">        self.dfs(grid,r+<span class="number">1</span>,c)</span><br><span class="line">        self.dfs(grid,r-<span class="number">1</span>,c)</span><br><span class="line">        self.dfs(grid,r,c+<span class="number">1</span>)</span><br><span class="line">        self.dfs(grid,r,c-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></h3><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>
<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/island.png" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[0,1,0,0]</span>,<span class="comment">[1,1,1,0]</span>,<span class="comment">[0,1,0,0]</span>,<span class="comment">[1,1,0,0]</span>]</span></span><br><span class="line">输出：16</span><br><span class="line">解释：它的周长是上面图片中的 16 个黄色的边</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[1]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[1,0]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>row == grid.length</code></li>
<li><code>col == grid[i].length</code></li>
<li><code>1 &lt;= row, col &lt;= 100</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j,cnt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c,<span class="type">int</span>&amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( r&gt;=grid.<span class="built_in">size</span>() || r&lt;<span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() || c&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c]!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r&lt; grid.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[r+<span class="number">1</span>][c]==<span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == grid.<span class="built_in">size</span>()<span class="number">-1</span>) cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[r<span class="number">-1</span>][c]==<span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">0</span>) cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c&lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[r][c+<span class="number">1</span>]==<span class="number">0</span> ) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c==grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[r][c<span class="number">-1</span>]==<span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>) cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(grid,r+<span class="number">1</span>,c,cnt);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c+<span class="number">1</span>,cnt);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r<span class="number">-1</span>,c,cnt);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c<span class="number">-1</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/maxarea1-grid.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0,0,1,0</span>,<span class="number">0,0,0,1</span>,<span class="number">0,0,0,0</span>,<span class="number">0</span>],[<span class="number">0,0,0,0</span>,<span class="number">0,0,0,1</span>,<span class="number">1,1,0,0</span>,<span class="number">0</span>],[<span class="number">0,1,1,0</span>,<span class="number">1,0,0,0</span>,<span class="number">0,0,0,0</span>,<span class="number">0</span>],[<span class="number">0,1,0,0</span>,<span class="number">1,1,0,0</span>,<span class="number">1,0,1,0</span>,<span class="number">0</span>],[<span class="number">0,1,0,0</span>,<span class="number">1,1,0,0</span>,<span class="number">1,1,1,0</span>,<span class="number">0</span>],[<span class="number">0,0,0,0</span>,<span class="number">0,0,0,0</span>,<span class="number">0,0,1,0</span>,<span class="number">0</span>],[<span class="number">0,0,0,0</span>,<span class="number">0,0,0,1</span>,<span class="number">1,1,0,0</span>,<span class="number">0</span>],[<span class="number">0,0,0,0</span>,<span class="number">0,0,0,1</span>,<span class="number">1,0,0,0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：答案不应该是 <span class="number">11</span> ，因为岛屿只能包含水平或垂直这四个方向上的 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,0,0,0,0,0,0,0]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, s = <span class="number">0</span>, r = grid.<span class="built_in">size</span>(), c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    s = <span class="number">0</span>; <span class="comment">//不加这句话，每经过一次dfs，s都增加</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j,s);</span><br><span class="line">                    max = s &gt; max ? s : max;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span>&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=grid.<span class="built_in">size</span>() || r&lt;<span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() || c&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c]!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="number">2</span>;</span><br><span class="line">        s++;</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r+<span class="number">1</span>,c,s);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r<span class="number">-1</span>,c,s);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c+<span class="number">1</span>,s);        </span><br><span class="line">        <span class="built_in">dfs</span>(grid,r,c<span class="number">-1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode.cn/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></h3><p>二维矩阵 <code>grid</code> 由 <code>0</code> （土地）和 <code>1</code> （水）组成。岛是由最大的4个方向连通的 <code>0</code> 组成的群，封闭岛是一个 <code>完全</code> 由1包围（左、上、右、下）的岛。</p>
<p>请返回 <em>封闭岛屿</em> 的数目。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/sample_3_1610.png" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1,1,1,1</span>,<span class="number">1,1,1,0</span>],[<span class="number">1,0,0,0</span>,<span class="number">0,1,1,0</span>],[<span class="number">1,0,1,0</span>,<span class="number">1,1,1,0</span>],[<span class="number">1,0,0,0</span>,<span class="number">0,1,0,1</span>],[<span class="number">1,1,1,1</span>,<span class="number">1,1,1,0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 <span class="number">1</span> 区域包围）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/09/28/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/sample_4_1610.png" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[1,1,1,1,1,1,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,0,0,0,0,0,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,0,1,1,1,0,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,0,1,0,1,0,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,0,1,1,1,0,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,0,0,0,0,0,1]</span>,</span></span><br><span class="line"><span class="comment">             <span class="comment">[1,1,1,1,1,1,1]</span>]</span></span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>
<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closedIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j, val);</span><br><span class="line">                    cnt += val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span>&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= grid.<span class="built_in">size</span>() || r &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || c &lt; <span class="number">0</span>) &#123; <span class="comment">//也就是如果搜索到边界的时候，val的值就变为0了，因为已经接触到边界了，因为这样的岛屿是不符合要求的，所以不进行统计</span></span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[r][c] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c, val);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c, val);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>, val);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>207.课程表 210.课程表II</title>
    <url>/2022/10/06/207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：numCourses = <span class="number">2</span>, prerequisites = <span class="string">[[1,0]]</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span> 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：numCourses = <span class="number">2</span>, prerequisites = <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span> ；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span> 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 105</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges; <span class="comment">// 将prerequisites的每个元素看成一条边</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited; <span class="comment">// 是否正在检查中 0未检查 1检查中 2已完成</span></span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>; <span class="comment">// 是否有环 false表示有环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;       </span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 正在检查u点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123; <span class="comment">// 检查以u为起始的每个终点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123; <span class="comment">// 如果 valid 为 false 就返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// u点已完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses); </span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]); <span class="comment">// 对[0,1],[2,1]来说 edges[1].push_back[0]和edges[1].push_back[2] 所以edges[1]的元素为[0,2]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><ul>
<li>未AC 不知原因</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">self, numCourses, prerequisites</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.edges = []</span><br><span class="line">        self.visited = []</span><br><span class="line">        self.valid = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u</span>):</span><br><span class="line">            self.visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> self.edges[u]:</span><br><span class="line">                <span class="keyword">if</span> self.visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.valid: </span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> self.visited[v] == <span class="number">1</span>:</span><br><span class="line">                    self.valid = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            self.visited[u] = <span class="number">2</span>        </span><br><span class="line"></span><br><span class="line">        self.edges = [[] * numCourses] * numCourses</span><br><span class="line">        self.visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            self.edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">            <span class="keyword">if</span> self.valid <span class="keyword">and</span> <span class="keyword">not</span> self.visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        <span class="keyword">return</span> self.valid</span><br></pre></td></tr></table></figure>



<h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h3><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：numCourses = <span class="number">2</span>, prerequisites = <span class="string">[[1,0]]</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：总共有 <span class="number">2</span> 门课程。要学习课程 <span class="number">1</span>，你需要先完成课程 <span class="number">0</span>。因此，正确的课程顺序为 [<span class="number">0</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = <span class="comment">[<span class="comment">[1,0]</span>,<span class="comment">[2,0]</span>,<span class="comment">[3,1]</span>,<span class="comment">[3,2]</span>]</span></span><br><span class="line">输出：<span class="comment">[0,2,1,3]</span></span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 <span class="comment">[0,1,2,3]</span> 。另一个正确的排序是 <span class="comment">[0,2,1,3]</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>ai != bi</code></li>
<li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能在 dfs 中 紧跟着visited[u] = 1;加入res数组,因为那样输出的就是从根节点到一个没有出度的结点的路径 而非拓扑排序路径 如下图:</span></span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/image-20221006185650480.png" alt="image-20221006185650480" style="zoom:33%;">

<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; info : prerequisites)&#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>());</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()!= numCourses) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 如果 res 的长度没有达到 numCourses 说明找到了一条未成环的路径,但该路径并没有将所有节点包含在内</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v : edges[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>) <span class="built_in">dfs</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>124.二叉树中的最大路径和</title>
    <url>/2023/03/14/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2023/03/14/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/exx1.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是<span class="number"> 2 </span>-&gt;<span class="number"> 1 </span>-&gt;<span class="number"> 3 </span>，路径和为<span class="number"> 2 </span>+<span class="number"> 1 </span>+<span class="number"> 3 </span>= 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2023/03/14/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/exx2.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是<span class="number"> 15 </span>-&gt;<span class="number"> 20 </span>-&gt;<span class="number"> 7 </span>，路径和为<span class="number"> 15 </span>+<span class="number"> 20 </span>+<span class="number"> 7 </span>= 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">核心是注意当前节点的最大路径，与当前节点作为子节点时的贡献是两个不同的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前节点的最大路径： max(自己，自己+左边，自己+右边，自己 + 左边 + 右边）</span></span><br><span class="line"><span class="comment">当前节点作为子节点时的贡献：max(自己，自己+左边，自己+右边）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">maxGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">maxGain</span>(root -&gt; left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">maxGain</span>(root -&gt; right);</span><br><span class="line">        res = <span class="built_in">max</span>(&#123;res, l + r + root -&gt; val, r + root -&gt; val, l + root -&gt; val, root -&gt; val&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(&#123;root -&gt; val, root -&gt; val + l, root -&gt; val + r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>209.长度最小的子数组</title>
    <url>/2023/03/02/209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1e8</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r ++)&#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span>(l &lt; n &amp;&amp; sum &gt;= target) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[l ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">1e8</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>220207刷题</title>
    <url>/2023/02/07/220207%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a></h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p>
<p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;egg&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;add&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;foo&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;paper&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;title&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>t.length == s.length</code></li>
<li><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; mpST;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; mpTS;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mpST[s[i]] &amp;&amp; mpST[s[i]] != t[i]) || </span><br><span class="line">            (mpTS[t[i]] &amp;&amp; mpTS[t[i]] != s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            mpST[s[i]] = t[i]; </span><br><span class="line">            mpTS[t[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>220208刷题</title>
    <url>/2023/02/08/220208%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h3><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">num1</span> = <span class="string">&quot;11&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 104</code></li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry)&#123;</span><br><span class="line">            <span class="type">int</span> a = i &gt;= <span class="number">0</span> ? (num1[i] - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = j &gt;= <span class="number">0</span> ? (num2[j] - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> c = (a + b + carry)%<span class="number">10</span>;</span><br><span class="line">            res += c + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            carry = (a + b + carry)/<span class="number">10</span>;</span><br><span class="line">            i --;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></h3><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;2&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出: <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;123&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>
<li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li>
<li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> times = num2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            string temp = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(times -- &gt;<span class="number">0</span>)</span><br><span class="line">                temp = <span class="built_in">addStrings</span>(temp, num1);</span><br><span class="line">            temp.<span class="built_in">append</span>(cnt++, <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 第一次后每次要在 中间结果补0</span></span><br><span class="line">            res = <span class="built_in">addStrings</span>(res, temp);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry)&#123;</span><br><span class="line">            <span class="type">int</span> a = i &gt;= <span class="number">0</span> ? (num1[i] - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = j &gt;= <span class="number">0</span> ? (num2[j] - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> c = (a + b + carry)%<span class="number">10</span>;</span><br><span class="line">            res += c + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            carry = (a + b + carry)/<span class="number">10</span>;</span><br><span class="line">            i --;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1115-交替打印-FooBar"><a href="#1115-交替打印-FooBar" class="headerlink" title="1115. 交替打印 FooBar"></a><a href="https://leetcode.cn/problems/print-foobar-alternately/">1115. 交替打印 FooBar</a></h3><p>给你一个类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个不同的线程将会共用一个 <code>FooBar</code> 实例：</p>
<ul>
<li>线程 A 将会调用 <code>foo()</code> 方法，而</li>
<li>线程 B 将会调用 <code>bar()</code> 方法</li>
</ul>
<p>请设计修改程序，以确保 <code>&quot;foobar&quot;</code> 被输出 <code>n</code> 次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;foobar&quot;</span></span><br><span class="line">解释：这里有两个线程被异步启动。其中一个调用 <span class="built_in">foo</span>() 方法, 另一个调用 <span class="built_in">bar</span>() 方法，<span class="string">&quot;foobar&quot;</span> 将被输出一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;foobarfoobar&quot;</span></span><br><span class="line">解释：<span class="string">&quot;foobar&quot;</span> 将被输出两次。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><ul>
<li>互斥锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    mutex m1, m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        m1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m1.<span class="built_in">lock</span>();</span><br><span class="line">        	<span class="built_in">printFoo</span>();</span><br><span class="line">            m2.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m2.<span class="built_in">lock</span>();</span><br><span class="line">        	<span class="built_in">printBar</span>();</span><br><span class="line">            m1.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>信号量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">sem_t</span> foo_done,bar_done;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;foo_done,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 中间变量为0 用在线程间，非0用在进程间</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;bar_done,<span class="number">0</span>,<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;bar_done); <span class="comment">// P(bar_done)</span></span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;foo_done); <span class="comment">// V(foo_doneV)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(&amp;foo_done); <span class="comment">// P(foo_done)</span></span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;bar_done); <span class="comment">// V(bar_done)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>原子操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt;foo_done=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooBar</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(foo_done) this_thread::<span class="built_in">yield</span>();       </span><br><span class="line">            <span class="built_in">printFoo</span>();</span><br><span class="line">            foo_done=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(foo_done==<span class="literal">false</span>) this_thread::<span class="built_in">yield</span>();        </span><br><span class="line">            <span class="built_in">printBar</span>();</span><br><span class="line">            foo_done=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h3><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>], limit = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[<span class="number">8</span>] 最大绝对差 |<span class="type">8</span><span class="number">-8</span>| <span class="type">= 0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>] 最大绝对差 |<span class="type">8</span><span class="number">-2</span>| <span class="type">= 6</span> &gt; <span class="number">4.</span> </span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="type">8</span><span class="number">-2</span>| <span class="type">= 6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="type">8</span><span class="number">-2</span>| <span class="type">= 6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>] 最大绝对差 |<span class="type">2</span><span class="number">-2</span>| <span class="type">= 0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="type">2</span><span class="number">-4</span>| <span class="type">= 2</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="type">2</span><span class="number">-7</span>| <span class="type">= 5</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>] 最大绝对差 |<span class="type">4</span><span class="number">-4</span>| <span class="type">= 0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="type">4</span><span class="number">-7</span>| <span class="type">= 3</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">7</span>] 最大绝对差 |<span class="type">7</span><span class="number">-7</span>| <span class="type">= 0</span> &lt;= <span class="number">4.</span> </span><br><span class="line">因此，满足题意的最长子数组的长度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>], limit = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：满足题意的最长子数组是 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>]，其最大绝对差 |<span class="type">2</span><span class="number">-7</span>| <span class="type">= 5</span> &lt;= <span class="number">5</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4,2,2,2</span>,<span class="number">4,4,2,2</span>], limit = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; st; <span class="comment">// cpp中 map和set都自带红黑树,可排序 begin()最小, rbegin()最大</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(nums[r ++]);</span><br><span class="line">            <span class="keyword">while</span>(*st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>() &gt; limit) st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(nums[l++]));</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="面试题59-II-队列的最大值"><a href="#面试题59-II-队列的最大值" class="headerlink" title="面试题59 - II. 队列的最大值"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">面试题59 - II. 队列的最大值</a></h3><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;max_value&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [null,null,null,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : *st.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        st.<span class="built_in">insert</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(res));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>220211刷题</title>
    <url>/2023/02/11/220211%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h3><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,1,0</span>,<span class="number">0,0,1,1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], K = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：[<span class="number">1,1,1,0</span>,<span class="number">0,1,1,1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">粗体数字从 <span class="number">0</span> 翻转到 <span class="number">1</span>，最长的子数组长度为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,0,1,1</span>,<span class="number">0,0,1,1</span>,<span class="number">1,0,1,1</span>,<span class="number">0,0,0,1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], K = <span class="number">3</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：[<span class="number">0,0,1,1</span>,<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>,<span class="number">0,0,0,1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">粗体数字从 <span class="number">0</span> 翻转到 <span class="number">1</span>，最长的子数组长度为 <span class="number">10</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>
<li><code>0 &lt;= k &lt;= nums.length</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>第二部分正常二维遍历会超时</li>
<li>lower_bound使用二分法返回 参数1，参数2 范围内第一个不小于 参数3的迭代器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preZero</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>; <span class="comment">// [i]表示在nums[i]前共有多少0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            preZero[i] = preZero[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!nums[i - <span class="number">1</span>])  preZero[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">lower_bound</span>(preZero.<span class="built_in">begin</span>(), preZero.<span class="built_in">end</span>(), preZero[r + <span class="number">1</span>] - k) - preZero.<span class="built_in">begin</span>(); <span class="comment">// 不减begin()返回元素 ， 减begin()返回该元素下标</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554. 砖墙"></a><a href="https://leetcode.cn/problems/brick-wall/">554. 砖墙</a></h3><p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p>
<p>你现在要画一条 <strong>自顶向下</strong> 的、穿过 <strong>最少</strong> 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>
<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2023/02/11/220211%E5%88%B7%E9%A2%98/cutwall-grid.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：wall = <span class="comment">[<span class="comment">[1,2,2,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,4]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[1,3,1,1]</span>]</span></span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：wall = <span class="string">[[1],[1],[1]]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == wall.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>1 &lt;= wall[i].length &lt;= 104</code></li>
<li><code>1 &lt;= sum(wall[i].length) &lt;= 2 * 104</code></li>
<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 是相同的</li>
<li><code>1 &lt;= wall[i][j] &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastBricks</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// mp[i]表示 该列有空隙的层数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : wall)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> len = e.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                sum += e[j];</span><br><span class="line">                mp[sum] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; e : mp)</span><br><span class="line">            res = <span class="built_in">max</span>(res, e.second);</span><br><span class="line">        <span class="keyword">return</span> wall.<span class="built_in">size</span>() - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h3><p>传送带上的包裹必须在 <code>days</code> 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量（<code>weights</code>）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 <code>days</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重<span class="number"> 15 </span>就能够在<span class="number"> 5 </span>天内送达所有包裹，如下所示：</span><br><span class="line">第<span class="number"> 1 </span>天：1, 2, 3, 4, 5</span><br><span class="line">第<span class="number"> 2 </span>天：6, 7</span><br><span class="line">第<span class="number"> 3 </span>天：8</span><br><span class="line">第<span class="number"> 4 </span>天：9</span><br><span class="line">第<span class="number"> 5 </span>天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为<span class="number"> 14 </span>的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重<span class="number"> 6 </span>就能够在<span class="number"> 3 </span>天内送达所有包裹，如下所示：</span><br><span class="line">第<span class="number"> 1 </span>天：3, 2</span><br><span class="line">第<span class="number"> 2 </span>天：2, 4</span><br><span class="line">第<span class="number"> 3 </span>天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,1,1], days = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第<span class="number"> 1 </span>天：1</span><br><span class="line">第<span class="number"> 2 </span>天：2</span><br><span class="line">第<span class="number"> 3 </span>天：3</span><br><span class="line">第<span class="number"> 4 </span>天：1, 1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= days &lt;= weights.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= weights[i] &lt;= 500</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weights, <span class="type">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = *<span class="built_in">max_element</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> res = start; ; res ++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(days, res)</span></span>; </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(buckets, weights)) <span class="keyword">return</span> res;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; buckets, vector&lt;<span class="type">int</span>&gt;&amp; weights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>) &gt; buckets.<span class="built_in">size</span>() * buckets[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weights.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(buckets[j] &lt; weights[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == buckets.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                buckets[j] -= weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a><a href="https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串</a></h3><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;(abcd)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;dcba&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;(u(love)i)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;iloveu&quot;</span></span><br><span class="line">解释：先反转子字符串 <span class="string">&quot;love&quot;</span> ，然后反转整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;(ed(et(oc))el)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;leetcode&quot;</span></span><br><span class="line">解释：先反转子字符串 <span class="string">&quot;oc&quot;</span> ，接着反转 <span class="string">&quot;etco&quot;</span> ，然后反转整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;a(bcdefghijkl(mno)p)q&quot;</span></span><br><span class="line">输出：<span class="string">&quot;apmnolkjihgfedcbq&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 中只有小写英文字母和括号</li>
<li>题目测试用例确保所有括号都是成对出现的</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><ul>
<li>栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e ==<span class="string">&#x27;(&#x27;</span> || <span class="built_in">isalpha</span>(e)) stk.<span class="built_in">push</span>(e);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span>(stk.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    temp += stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> e : temp)&#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(string&amp; s, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(idx &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[idx] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                idx ++;</span><br><span class="line">                res += <span class="built_in">dfs</span>(s, idx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[idx] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                idx ++;</span><br><span class="line">                <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res += s[idx ++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode.cn/problems/rabbits-in-forest/">781. 森林中的兔子</a></h3><p>森林中有未知数量的兔子。提问其中若干只兔子 <strong>“还有多少只兔子与你（指被提问的兔子）颜色相同?”</strong> ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p>
<p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：answers = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">两只回答了 <span class="string">&quot;1&quot;</span> 的兔子可能有相同的颜色，设为红色。 </span><br><span class="line">之后回答了 <span class="string">&quot;2&quot;</span> 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 <span class="string">&quot;2&quot;</span> 的兔子为蓝色。 </span><br><span class="line">此外，森林中还应有另外 <span class="number">2</span> 只蓝色兔子的回答没有包含在数组中。 </span><br><span class="line">因此森林中兔子的最少数量是 <span class="number">5</span> 只：<span class="number">3</span> 只回答的和 <span class="number">2</span> 只没有回答的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：answers </span>=<span class="string"> [10,10,10]</span></span><br><span class="line"><span class="string">输出：11</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= answers.length &lt;= 1000</code></li>
<li><code>0 &lt;= answers[i] &lt; 1000</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRabbits</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; answers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 13只 answers[i]==5 的; </span></span><br><span class="line">        <span class="comment">// mp[5(x)] = 13(y)   ceil(y / x + 1) * (x + 1)</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : answers)</span><br><span class="line">            mp[e] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k,v] : mp)</span><br><span class="line">            res += (v%(k + <span class="number">1</span>) ? v/(k + <span class="number">1</span>) + <span class="number">1</span> : v/(k + <span class="number">1</span>)) * (k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>220212刷题</title>
    <url>/2023/02/12/220212%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="6355-统计公平数对的数目"><a href="#6355-统计公平数对的数目" class="headerlink" title="6355. 统计公平数对的数目"></a><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">6355. 统计公平数对的数目</a></h3><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>
<p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; n</code>，且</li>
<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="keyword">lower</span> = <span class="number">3</span>, <span class="keyword">upper</span> = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：共计 <span class="number">6</span> 个公平数对：(<span class="number">0</span>,<span class="number">3</span>)、(<span class="number">0</span>,<span class="number">4</span>)、(<span class="number">0</span>,<span class="number">5</span>)、(<span class="number">1</span>,<span class="number">3</span>)、(<span class="number">1</span>,<span class="number">4</span>) 和 (<span class="number">1</span>,<span class="number">5</span>) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>], <span class="keyword">lower</span> = <span class="number">11</span>, <span class="keyword">upper</span> = <span class="number">11</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有单个公平数对：(<span class="number">2</span>,<span class="number">3</span>) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>nums.length == n</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= lower &lt;= upper &lt;= 109</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// [0,1,4,4,5,7] 3 6.   对0来说，选择4,4,5都可以 共3种</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="type">int</span> minNum = lower - *it; <span class="comment">// 3</span></span><br><span class="line">            <span class="type">int</span> maxNum = upper - *it; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">lower_bound</span>(it + <span class="number">1</span>, nums.<span class="built_in">end</span>(), minNum); <span class="comment">// 在[1,4,4,5,7] 中返回第一个&gt;= 3的</span></span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">upper_bound</span>(it + <span class="number">1</span>, nums.<span class="built_in">end</span>(), maxNum); <span class="comment">// 在[4,5,7]中返回第一个 &gt;6 的</span></span><br><span class="line">            res += y - x; <span class="comment">//两迭代器相减返回距离差为int</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;255.255.11.135&quot;</span>,<span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;0000&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.0.0.0&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;101023&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.0.10.23&quot;</span>,<span class="string">&quot;1.0.102.3&quot;</span>,<span class="string">&quot;10.1.0.23&quot;</span>,<span class="string">&quot;10.10.2.3&quot;</span>,<span class="string">&quot;101.0.2.3&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅由数字组成</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>回溯</li>
</ul>
<p><img src="/2023/02/12/220212%E5%88%B7%E9%A2%98/image-20230212160351747.png" alt="image-20230212160351747"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> idx, <span class="type">int</span> cnt)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span> || idx == s.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4</span> &amp;&amp; idx ==s.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>,str.<span class="built_in">size</span>()<span class="number">-1</span>));  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++)&#123; <span class="comment">// i是每次取substr的长度</span></span><br><span class="line">            <span class="keyword">if</span>(s[idx] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 一定要加 i == 3， 不然“31” &gt; &quot;255&quot;直接就返回了</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; s.<span class="built_in">substr</span>(idx,i) &gt; <span class="string">&quot;255&quot;</span>) <span class="keyword">return</span>; </span><br><span class="line">            <span class="keyword">if</span>(idx + i &gt; s.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            str += s.<span class="built_in">substr</span>(idx,i); </span><br><span class="line">            str += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(s, idx + i, cnt + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回撤  把 s.substr(idx,i) 和 &#x27;.&#x27; 清掉</span></span><br><span class="line">            str = str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">size</span>() - <span class="number">1</span> - i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a></h3><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2023/02/12/220212%E5%88%B7%E9%A2%98/interleave.jpg" alt="img"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">&quot;aabcc&quot;</span>, <span class="built_in">s2</span> = <span class="string">&quot;dbbca&quot;</span>, <span class="built_in">s3</span> = <span class="string">&quot;aadbbcbcac&quot;</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">&quot;aabcc&quot;</span>, <span class="built_in">s2</span> = <span class="string">&quot;dbbca&quot;</span>, <span class="built_in">s3</span> = <span class="string">&quot;aadbbbaccc&quot;</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">&quot;&quot;</span>, <span class="built_in">s2</span> = <span class="string">&quot;&quot;</span>, <span class="built_in">s3</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>
<li><code>0 &lt;= s3.length &lt;= 200</code></li>
<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>
</ul>
<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><ul>
<li>三指针正向超时，反向不超时</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s3.<span class="built_in">size</span>() != s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s1, s2, s3, <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(string s1, string s2, string s3 , <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = s1.<span class="built_in">size</span>(), len2 = s2.<span class="built_in">size</span>(), len3 = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(k &lt; len3)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s3[k] == s1[i] &amp;&amp; s3[k] == s2[j] &amp;&amp; i &lt; len1 &amp;&amp; j &lt; len2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(s1,s2,s3,i + <span class="number">1</span>,j,k + <span class="number">1</span>) </span><br><span class="line">                || <span class="built_in">dfs</span>(s1,s2,s3,i,j + <span class="number">1</span>,k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s3[k] == s1[i] &amp;&amp; i &lt; len1)&#123;</span><br><span class="line">                i ++; </span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s3[k] == s2[j] &amp;&amp; j &lt; len2)&#123;</span><br><span class="line">                j ++; </span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//   public:</span></span><br><span class="line"><span class="comment">//     bool impl(string &amp;s1, string &amp;s2, string &amp;s3, int p, int q, int m) &#123;</span></span><br><span class="line"><span class="comment">//         while (m &gt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//             if (p &gt;= 0 &amp;&amp; s1[p] == s3[m] &amp;&amp; q &gt;= 0 &amp;&amp; s2[q] == s3[m]) &#123;</span></span><br><span class="line"><span class="comment">//                 return impl(s1, s2, s3, p - 1, q, m - 1) ||</span></span><br><span class="line"><span class="comment">//                        impl(s1, s2, s3, p, q - 1, m - 1);</span></span><br><span class="line"><span class="comment">//             &#125; else if (p &gt;= 0 &amp;&amp; s1[p] == s3[m]) &#123;</span></span><br><span class="line"><span class="comment">//                 p--, m--;</span></span><br><span class="line"><span class="comment">//             &#125; else if (q &gt;= 0 &amp;&amp; s2[q] == s3[m]) &#123;</span></span><br><span class="line"><span class="comment">//                 q--, m--;</span></span><br><span class="line"><span class="comment">//             &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                 return false;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     bool isInterleave(string s1, string s2, string s3) &#123;</span></span><br><span class="line"><span class="comment">//         // s1 x s2 -&gt; s3</span></span><br><span class="line"><span class="comment">//         int p = s1.size(), q = s2.size(), m = s3.size();</span></span><br><span class="line"><span class="comment">//         if (p + q != m) return false;</span></span><br><span class="line"><span class="comment">//         return impl(s1, s2, s3, p - 1, q - 1, m - 1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>





<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a href="https://leetcode.cn/problems/excel-sheet-column-title/">168. Excel表列名称</a></h3><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p>
<p>例如：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：columnNumber <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：columnNumber <span class="operator">=</span> <span class="number">28</span></span><br><span class="line">输出：<span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：columnNumber <span class="operator">=</span> <span class="number">701</span></span><br><span class="line">输出：<span class="string">&quot;ZY&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：columnNumber <span class="operator">=</span> <span class="number">2147483647</span></span><br><span class="line">输出：<span class="string">&quot;FXSHRXW&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= columnNumber &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            --columnNumber;</span><br><span class="line">            res += columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>220209刷题</title>
    <url>/2023/02/09/220209%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1909-删除一个元素使数组严格递增"><a href="#1909-删除一个元素使数组严格递增" class="headerlink" title="1909. 删除一个元素使数组严格递增"></a><a href="https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/">1909. 删除一个元素使数组严格递增</a></h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>
<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line"><span class="string">[3,1,2]</span> 是删除下标 <span class="number">0</span> 处元素后得到的结果。</span><br><span class="line"><span class="string">[2,1,2]</span> 是删除下标 <span class="number">1</span> 处元素后得到的结果。</span><br><span class="line"><span class="string">[2,3,2]</span> 是删除下标 <span class="number">2</span> 处元素后得到的结果。</span><br><span class="line"><span class="string">[2,3,1]</span> 是删除下标 <span class="number">3</span> 处元素后得到的结果。</span><br><span class="line">没有任何结果数组是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：删除任意元素后的结果都是 [<span class="number">1</span>,<span class="number">1</span>] 。</span><br><span class="line"><span class="string">[1,1]</span> 不是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canBeIncreasing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">2</span>])&#123;</span><br><span class="line">                    nums[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前K个高频单词</a></h3><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: words = [<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;leetcode&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;coding&quot;</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>]</span><br><span class="line">解析: <span class="string">&quot;i&quot;</span> 和 <span class="string">&quot;love&quot;</span> 为出现次数最多的两个单词，均为<span class="number">2</span>次。</span><br><span class="line">    注意，按字母顺序 <span class="string">&quot;i&quot;</span> 在 <span class="string">&quot;love&quot;</span> 之前。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;is&quot;</span>], k = <span class="number">4</span></span><br><span class="line">输出: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;day&quot;</span>]</span><br><span class="line">解析: <span class="string">&quot;the&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span> 和 <span class="string">&quot;day&quot;</span> 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span> 和 <span class="number">1</span> 次。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 500</code></li>
<li><code>1 &lt;= words[i] &lt;= 10</code></li>
<li><code>words[i]</code> 由小写英文字母组成。</li>
<li><code>k</code> 的取值范围是 <code>[1, **不同** words[i] 的数量]</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: words)&#123;</span><br><span class="line">            mp[e] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : mp)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mp[a] == mp[b] ? a &lt; b : mp[a] &gt; mp[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>() + k, res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>220213刷题</title>
    <url>/2023/02/13/220213%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h3><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 +<span class="number"> 92 </span>= 82</span><br><span class="line">82 +<span class="number"> 22 </span>= 68</span><br><span class="line">62 +<span class="number"> 82 </span>= 100</span><br><span class="line">12 +<span class="number"> 02 </span>+<span class="number"> 02 </span>= 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 231 - 1</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>set判断循环，无限次默认100（可增加）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">10</span>) <span class="keyword">return</span> (n == <span class="number">1</span>|| n ==<span class="number">10</span> || n == <span class="number">7</span>);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>, cnt = <span class="number">100</span>; <span class="comment">// 次数</span></span><br><span class="line">        <span class="keyword">while</span>(cnt -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                temp += <span class="built_in">pow</span>(n%<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">find</span>(temp) == st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                st.<span class="built_in">insert</span>(temp);</span><br><span class="line">                n = temp;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166. 分数到小数"></a><a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></h3><p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>
<p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>104</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">numerator</span> = <span class="number">1</span>, <span class="attr">denominator</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;0.5&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">numerator</span> = <span class="number">2</span>, <span class="attr">denominator</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">numerator</span> = <span class="number">4</span>, <span class="attr">denominator</span> = <span class="number">333</span></span><br><span class="line">输出：<span class="string">&quot;0.(012)&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li>
<li><code>denominator != 0</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> n = numerator, d = denominator;</span><br><span class="line">        <span class="keyword">if</span>(n % d == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">to_string</span>(n / d);</span><br><span class="line"></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n * d &lt; <span class="number">0</span>) res += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        n = <span class="built_in">abs</span>(n), d = <span class="built_in">abs</span>(d);</span><br><span class="line">        res += <span class="built_in">to_string</span>(n / d) + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        n %= d;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> len = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; !mp.<span class="built_in">count</span>(n))&#123;</span><br><span class="line">            mp[n] = len ++;</span><br><span class="line">            n *= <span class="number">10</span>;</span><br><span class="line">            res += <span class="built_in">to_string</span>(n/d);</span><br><span class="line">            n %= d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n) res = res.<span class="built_in">substr</span>(<span class="number">0</span>, mp[n]) + <span class="string">&#x27;(&#x27;</span> + res.<span class="built_in">substr</span>(mp[n]) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>221.最大正方形</title>
    <url>/2022/10/21/221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h3><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/21/221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/max1grid.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/21/221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/max2grid.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[&quot;0&quot;]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> edgeLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> c = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>)); <span class="comment">//dp[i][j] 表示以以matrix[i][j]为底角的正方形的边长</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edgeLength = <span class="built_in">max</span>(edgeLength, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edgeLength * edgeLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>235.BST最近公共祖先 236.二叉树最近公共祖先</title>
    <url>/2022/10/05/235-BST%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="/2022/10/05/235-BST%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarysearchtree_improved.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span></span><br><span class="line"><span class="section">输出: 6 </span></span><br><span class="line"><span class="section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; q-&gt;val &amp;&amp; root-&gt;val &gt; p-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; q-&gt;val &amp;&amp; root-&gt;val &lt; p-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/05/235-BST%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarytree.png" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="selector-tag">p</span> = <span class="number">5</span>, <span class="selector-tag">q</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/05/235-BST%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarytree.png" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="selector-tag">p</span> = <span class="number">5</span>, <span class="selector-tag">q</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="selector-attr">[1,2]</span>, <span class="selector-tag">p</span> = <span class="number">1</span>, <span class="selector-tag">q</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isInTree</span>(root-&gt;left,p) &amp;&amp; <span class="built_in">isInTree</span>(root-&gt;left,q)) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isInTree</span>(root-&gt;right,p) &amp;&amp; <span class="built_in">isInTree</span>(root-&gt;right,q)) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInTree</span><span class="params">(TreeNode* root, TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInTree</span>(root-&gt;left,p) || <span class="built_in">isInTree</span>(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><ul>
<li>超时 暂未解决</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isInTree</span>(<span class="params">root,p</span>):</span><br><span class="line">            <span class="keyword">if</span> root == p:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> isInTree(root.left, p) <span class="keyword">or</span> isInTree(root.right, p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> isInTree(root.left, p) <span class="keyword">and</span> isInTree(root.left, q):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> isInTree(root.right, p) <span class="keyword">and</span> isInTree(root.right, q):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>295.数据流的中位数</title>
    <url>/2023/03/12/295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h3><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li>
<li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>实现 MedianFinder 类:</p>
<ul>
<li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;MedianFinder&quot;</span>, <span class="string">&quot;addNum&quot;</span>, <span class="string">&quot;addNum&quot;</span>, <span class="string">&quot;findMedian&quot;</span>, <span class="string">&quot;addNum&quot;</span>, <span class="string">&quot;findMedian&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [<span class="number">3</span>], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, <span class="number">1.5</span>, null, <span class="number">2.0</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line"><span class="symbol">MedianFinder</span> medianFinder = new <span class="symbol">MedianFinder</span>();</span><br><span class="line">medianFinder.addNum(<span class="number">1</span>);    // arr = [<span class="number">1</span>]</span><br><span class="line">medianFinder.addNum(<span class="number">2</span>);    // arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">medianFinder.findMedian(); // 返回 <span class="number">1.5</span> ((<span class="number">1</span> + <span class="number">2</span>) / <span class="number">2</span>)</span><br><span class="line">medianFinder.addNum(<span class="number">3</span>);    // arr[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">medianFinder.findMedian(); // return <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>-105 &lt;= num &lt;= 105</code></li>
<li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素</li>
<li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><img src="/2023/03/12/295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20230312234351648.png" alt="image-20230312234351648">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; queMin; <span class="comment">// 大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; queMax; <span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">empty</span>() || num &lt;= queMin.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            queMin.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() + <span class="number">1</span> &lt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMax.<span class="built_in">push</span>(queMin.<span class="built_in">top</span>());</span><br><span class="line">                queMin.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queMax.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() &gt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMin.<span class="built_in">push</span>(queMax.<span class="built_in">top</span>());</span><br><span class="line">                queMax.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">size</span>() &gt; queMax.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queMin.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (queMin.<span class="built_in">top</span>() + queMax.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/2022/08/06/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 我写的</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int lengthOfLongestSubstring(string s) &#123;</span></span><br><span class="line"><span class="comment">        if(s.size()==0) return 0;</span></span><br><span class="line"><span class="comment">        if(s.size()==1) return 1;</span></span><br><span class="line"><span class="comment">        set&lt;char&gt; s1;</span></span><br><span class="line"><span class="comment">        int ret=0;</span></span><br><span class="line"><span class="comment">        for( int i = 0 ; i &lt; s.size(); i++ )&#123;</span></span><br><span class="line"><span class="comment">            s1.clear();</span></span><br><span class="line"><span class="comment">            for( int j = i; j &lt; s.size(); j++ )&#123;</span></span><br><span class="line"><span class="comment">                if(s1.find(s.at(j))!=s1.end())&#123; //能在集合中找到</span></span><br><span class="line"><span class="comment">                    ret = max(j-i,ret);</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                s1.insert(s.at(j)); //找不到就将该字符放入集合</span></span><br><span class="line"><span class="comment">                ret = max(j-i+1,ret);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ret;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk  &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk])) &#123;  <span class="comment">// count(key);    //统计值为key的元素个数</span></span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[rk]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        rk,ans = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">                occ.remove(s[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk &lt; n <span class="keyword">and</span> s[rk] <span class="keyword">not</span> <span class="keyword">in</span>  occ:</span><br><span class="line">                occ.add(s[rk])</span><br><span class="line">                rk+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>( ans, rk-i )</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>31.下一个排列</title>
    <url>/2022/12/05/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h3><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[1,3,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,1]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,5]</span></span><br><span class="line">输出：<span class="comment">[1,5,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</span></span><br><span class="line"><span class="comment">(1) 在尽可能靠右的低位进行交换，需要从后向前查找</span></span><br><span class="line"><span class="comment">(2) 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</span></span><br><span class="line"><span class="comment">(3) 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> largerMin = INT_MAX;</span><br><span class="line">    <span class="type">int</span> largerMinIdx = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums [i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i - <span class="number">1</span>; j --)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j] &lt; largerMin &amp;&amp; nums[j] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                        largerMin = nums[j];</span><br><span class="line">                        largerMinIdx = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(nums[largerMinIdx], nums [i - <span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>()); <span class="comment">// 将大数换到前面后，需要将大数后面的所有数重置为升序</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>297.二叉树的序列化与反序列化</title>
    <url>/2022/10/30/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode.cn/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/30/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/serdeser.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>DFS 先序遍历【满二叉树给定一种遍历序列即可建树（该遍历序列里有每个节点左右孩子为空的信息）】</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    string res;</span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">// 先序</span></span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) res += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += <span class="string">&quot;,#&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) res += <span class="built_in">to_string</span>(root -&gt; val);</span><br><span class="line">            <span class="keyword">else</span> res += <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(root -&gt; val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;   </span><br><span class="line">        vector&lt;string&gt; Data = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string data)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch != <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                path += ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">                path.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">DFS</span><span class="params">(vector&lt;string&gt;&amp; Data)</span></span>&#123;     <span class="comment">// [1,2,3,#,#,4,#,#,5,#,#] 先序遍历建树</span></span><br><span class="line">        <span class="keyword">if</span>(Data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(Data.<span class="built_in">front</span>() == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">            Data.<span class="built_in">erase</span>(Data.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(Data.<span class="built_in">front</span>()));</span><br><span class="line">        Data.<span class="built_in">erase</span>(Data.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">        root -&gt; left = <span class="built_in">DFS</span>(Data);</span><br><span class="line">        root -&gt; right = <span class="built_in">DFS</span>(Data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>316.去除重复字母</title>
    <url>/2022/10/25/316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h3><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;bcabc&quot;</span></span><br><span class="line">输出：<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbacdcbc&quot;</span></span><br><span class="line">输出：<span class="string">&quot;acdb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vis(26)用来存储是否存在栈中，当布尔型用</span></span><br><span class="line">        <span class="comment">//num(26)用来存储字符的个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">num</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>]++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[ch - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 不在栈中</span></span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">back</span>() &gt; ch) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (num[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;  <span class="comment">// 后面还有同样的字符</span></span><br><span class="line">                        vis[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>; </span><br><span class="line">                        stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>; </span><br><span class="line">                stk.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>; <span class="comment">// 将新加入的字符的剩余数量减1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>378.有序矩阵中第 K 小的元素</title>
    <url>/2023/03/12/378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h3><p>给你一个 <code>n x n</code> 矩阵 <code>matrix</code> ，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong> 的元素。</p>
<p>你必须找到一个内存复杂度优于 <code>O(n2)</code> 的解决方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,5,9]</span>,<span class="comment">[10,11,13]</span>,<span class="comment">[12,13,15]</span>]</span>, k = 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 <span class="comment">[1,5,9,10,11,12,13,13,15]</span>，第 8 小元素是 13</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[-5]]</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>
<li>题目数据 <strong>保证</strong> <code>matrix</code> 中的所有行和列都按 <strong>非递减顺序</strong> 排列</li>
<li><code>1 &lt;= k &lt;= n2</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> comp = [&amp;](pii&amp; l, pii&amp; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> matrix[l.first][l.second] &gt; matrix[r.first][r.second];&#125;; <span class="comment">// 小根堆</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(comp)&gt; <span class="built_in">q</span>(comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) q.<span class="built_in">emplace</span>(i, <span class="number">0</span>); <span class="comment">// push fist colum i行0列</span></span><br><span class="line">        <span class="keyword">while</span>(--k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(j != n<span class="number">-1</span>) q.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>46.全排列 47.全排列II</title>
    <url>/2022/09/27/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[0,1],[1,0]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(res,path,used,nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 不能遍历i，否则从2开始就不能凑满3个数了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;<span class="type">bool</span>&gt;&amp; used, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);  <span class="comment">//res 一定要加&amp; 不然不会改变主函数中实参res的值,输出为[]</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">backtracking</span>(res,path,used,nums);</span><br><span class="line"></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>] * n</span><br><span class="line">        path = []</span><br><span class="line">        self.backtracking(res,path,used,nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,res,path,used,nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path)==<span class="built_in">len</span>(nums):</span><br><span class="line">            temp = [] <span class="comment"># 不能直接 res.append(path) , 会输出[[],[],[],[],[],[]]</span></span><br><span class="line">            temp[:] = path[:] <span class="comment"># 使用temp数组来保存解，因为直接将path加入，会在回溯时候，path改变导致res中的解也跟着变</span></span><br><span class="line">            res.append(temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i] == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                self.backtracking(res,path,used,nums)</span><br><span class="line"></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h3><p>难度中等1203</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[<span class="comment">[1,1,2]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[1,2,1]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[2,1,1]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="built_in">backtracking</span>(res,path,used,nums,st);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;<span class="type">bool</span>&gt;&amp; used, vector&lt;<span class="type">int</span>&gt;&amp; nums, set&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">insert</span>(path).second)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">backtracking</span>(res,path,used,nums,st);</span><br><span class="line"></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><p>set不能添加list，dict, set的原因<br>python 的集合set中的元素是唯一的，即哈希表（hashable）类型，因此集合中的元素必须是不可变类型</p>
<p>而list，dict， set是可变类型， number，string，tuple是不可变类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr_set = <span class="built_in">set</span>()</span><br><span class="line">arr_set.add([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(arr_set)</span><br></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">编译提示：</span><br><span class="line"></span><br><span class="line">arr_set.add([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">TypeError: unhashable <span class="keyword">type</span>: <span class="symbol">&#x27;list</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>494.目标和</title>
    <url>/2022/11/25/494-%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有<span class="number"> 5 </span>种方法让最终目标和为<span class="number"> 3 </span>。</span><br><span class="line">-1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 -<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>-<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>-<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>-<span class="number"> 1 </span>= 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// if(idx == nums.size()) return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(nums, target, sum + nums[idx], idx + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, target, sum - nums[idx], idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>515.在每个树行中找最大值</title>
    <url>/2022/10/08/515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h3><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2022/10/08/515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/largest_e1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: root = <span class="comment">[1,3,2,5,3,null,9]</span></span><br><span class="line">输出: <span class="comment">[1,3,9]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: root = <span class="comment">[1,2,3]</span></span><br><span class="line">输出: <span class="comment">[1,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,104]</code></li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>DFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res, <span class="type">int</span> currHeight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() == currHeight)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root -&gt; val); <span class="comment">//如果当前层还没有最大值, 先随便push一个当前层结点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        res[currHeight] = <span class="built_in">max</span>(root -&gt; val, res[currHeight]); <span class="comment">// 如果当前层有值了,选最大的</span></span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, res, currHeight + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, res, currHeight + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>BFS(略)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>48.旋转图像</title>
    <url>/2022/12/03/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/03/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/mat1.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line">输出：<span class="string">[[7,4,1],[8,5,2],[9,6,3]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/12/03/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/mat2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[5,1,9,11]</span>,<span class="comment">[2,4,8,10]</span>,<span class="comment">[13,3,6,7]</span>,<span class="comment">[15,14,12,16]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[15,13,2,5]</span>,<span class="comment">[14,3,4,1]</span>,<span class="comment">[12,6,8,9]</span>,<span class="comment">[16,7,10,11]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先上下反转，再主对角反转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; m/<span class="number">2</span>; r ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; c ++)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[m - <span class="number">1</span> - r][c], matrix[r][c]);</span><br><span class="line">            &#125;<span class="number">48.4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">1</span>; r &lt; m; r ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; r; c ++)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[r][c], matrix[c][r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>54.螺旋矩阵</title>
    <url>/2022/12/02/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/02/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/spiral.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col = left; col &lt;= right; col ++)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[top][col]);</span><br><span class="line">            &#125;<span class="keyword">if</span>(++ top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> row = top; row &lt;= bottom; row ++)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[row][right]);</span><br><span class="line">            &#125;<span class="keyword">if</span>(-- right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col = right; col &gt;= left; col --)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[bottom][col]);</span><br><span class="line">            &#125;<span class="keyword">if</span>(-- bottom &lt; top) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> row = bottom; row &gt;= top; row --)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[row][left]);</span><br><span class="line">            &#125;<span class="keyword">if</span>(++ left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/02/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/spiraln.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col = left; col &lt;= right; col ++)&#123;</span><br><span class="line">                res[top][col] = num ++;</span><br><span class="line">            &#125; top ++;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; n*n) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> row = top; row &lt;= bottom; row ++)&#123;</span><br><span class="line">                res[row][right] = num ++;</span><br><span class="line">            &#125; right --;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; n*n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col = right; col &gt;= left; col --)&#123;</span><br><span class="line">                res[bottom][col] = num ++;</span><br><span class="line">            &#125; bottom --;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; n*n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> row = bottom; row &gt;= top; row --)&#123;</span><br><span class="line">                res[row][left] = num ++;</span><br><span class="line">            &#125; left ++;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; n*n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>547.省份数量</title>
    <url>/2022/10/08/547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h3 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></h3><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/08/547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/graph1.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：isConnected = <span class="string">[[1,1,0],[1,1,0],[0,0,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/08/547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/graph2.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：isConnected = <span class="string">[[1,0,0],[0,1,0],[0,0,1]]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>n == isConnected.length</code></li>
<li><code>n == isConnected[i].length</code></li>
<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>
<li><code>isConnected[i][i] == 1</code></li>
<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited; <span class="comment">// 0未访问 1已访问</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    edges.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.<span class="built_in">resize</span>(n); <span class="comment">//不然的话 visited长度为0, 输出恒为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; visited.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : edges)&#123;</span><br><span class="line">          	<span class="comment">//无向图,要考虑两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(e[<span class="number">0</span>] == i &amp;&amp; visited[e[<span class="number">1</span>]] == <span class="number">0</span>) <span class="built_in">dfs</span>(e[<span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">if</span>(e[<span class="number">1</span>] == i &amp;&amp; visited[e[<span class="number">0</span>]] == <span class="number">0</span>) <span class="built_in">dfs</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>56.合并区间</title>
    <url>/2022/11/27/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="type">int</span> m = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>()); <span class="comment">// 默认排第一个元素</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们用数组 merged 存储最终的答案。</span></span><br><span class="line"><span class="comment">        首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</span></span><br><span class="line"><span class="comment">        如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</span></span><br><span class="line"><span class="comment">        否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; res.<span class="built_in">back</span>()[<span class="number">1</span>])&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>6317.统计美丽子数组数目</title>
    <url>/2023/03/12/6317-%E7%BB%9F%E8%AE%A1%E7%BE%8E%E4%B8%BD%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="6317-统计美丽子数组数目"><a href="#6317-统计美丽子数组数目" class="headerlink" title="6317. 统计美丽子数组数目"></a><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/">6317. 统计美丽子数组数目</a></h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>nums</code> 。每次操作中，你可以：</p>
<ul>
<li>选择两个满足 <code>0 &lt;= i, j &lt; nums.length</code> 的不同下标 <code>i</code> 和 <code>j</code> 。</li>
<li>选择一个非负整数 <code>k</code> ，满足 <code>nums[i]</code> 和 <code>nums[j]</code> 在二进制下的第 <code>k</code> 位（下标编号从 <strong>0</strong> 开始）是 <code>1</code> 。</li>
<li>将 <code>nums[i]</code> 和 <code>nums[j]</code> 都减去 <code>2k</code> 。</li>
</ul>
<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code> 的数组，那么我们称它是一个 <strong>美丽</strong> 的子数组。</p>
<p>请你返回数组 <code>nums</code> 中 <strong>美丽子数组</strong> 的数目。</p>
<p>子数组是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,3,1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：nums 中有<span class="number"> 2 </span>个美丽子数组：[4,3,1,2,4] 和 [4,3,1,2,4] 。</span><br><span class="line">- 按照下述步骤，我们可以将子数组 [3,1,2] 中所有元素变成<span class="number"> 0 </span>：</span><br><span class="line">  - 选择 [3, 1, 2] 和 k =<span class="number"> 1 </span>。将<span class="number"> 2 </span>个数字都减去<span class="number"> 21 </span>，子数组变成 [1, 1, 0] 。</span><br><span class="line">  - 选择 [1, 1, 0] 和 k =<span class="number"> 0 </span>。将<span class="number"> 2 </span>个数字都减去<span class="number"> 20 </span>，子数组变成 [0, 0, 0] 。</span><br><span class="line">- 按照下述步骤，我们可以将子数组 [4,3,1,2,4] 中所有元素变成<span class="number"> 0 </span>：</span><br><span class="line">  - 选择 [4, 3, 1, 2, 4] 和 k =<span class="number"> 2 </span>。将<span class="number"> 2 </span>个数字都减去<span class="number"> 22 </span>，子数组变成 [0, 3, 1, 2, 0] 。</span><br><span class="line">  - 选择 [0, 3, 1, 2, 0] 和 k =<span class="number"> 0 </span>。将<span class="number"> 2 </span>个数字都减去<span class="number"> 20 </span>，子数组变成 [0, 2, 0, 2, 0] 。</span><br><span class="line">  - 选择 [0, 2, 0, 2, 0] 和 k =<span class="number"> 1 </span>。将<span class="number"> 2 </span>个数字都减去<span class="number"> 21 </span>，子数组变成 [0, 0, 0, 0, 0] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,10,4]</span></span><br><span class="line"><span class="string">输出：0</span></span><br><span class="line"><span class="string">解释：nums 中没有任何美丽子数组。</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 106</code></li>
</ul>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">beautifulSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [4,3,1,2,4]  s = [0 4 7 6 4 0]</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : s)</span><br><span class="line">            <span class="comment">// 先计入答案再统计个数，如果反过来的话，就相当于把空子数组也计入答案了</span></span><br><span class="line">            res += cnt[x]++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>662.二叉树最大宽度</title>
    <url>/2022/11/03/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h3><p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> 。</p>
<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> 。</p>
<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度。</p>
<p>题目数据保证答案将会在 <strong>32 位</strong> 带符号整数范围内。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/03/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/width1-tree.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最大宽度出现在树的第 <span class="number">3</span> 层，宽度为 <span class="number">4</span> (<span class="number">5</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">9</span>) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/03/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/maximum-width-of-binary-tree-v3.jpg" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：最大宽度出现在树的第 <span class="number">4</span> 层，宽度为 <span class="number">7</span> (<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="/2022/11/03/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/width3-tree.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,2,5]</span><br><span class="line">输出：2</span><br><span class="line">解释：最大宽度出现在树的第<span class="number"> 2 </span>层，宽度为<span class="number"> 2 </span>(3,2) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[1, 3000]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left; <span class="comment">// 存放每层最左边不为空的节点index</span></span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">1</span>, <span class="number">1</span>, left);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> lvl, <span class="type">unsigned</span> <span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt;&amp; left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(lvl &gt; left.<span class="built_in">size</span>()) left.<span class="built_in">push_back</span>(index);  <span class="comment">// 如果lvl &gt; left.size()说明当前节点就是新的一层的最左节点</span></span><br><span class="line">        res = res &gt; index - left[lvl - <span class="number">1</span>] + <span class="number">1</span> ? res : index - left[lvl - <span class="number">1</span>] + <span class="number">1</span> ;  </span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, lvl + <span class="number">1</span>, index * <span class="number">2</span>, left);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, lvl + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">1</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>698.划分为k个相等的子集</title>
    <url>/2022/12/11/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h3 id="698-划分为k个相等的子集"><a href="#698-划分为k个相等的子集" class="headerlink" title="698. 划分为k个相等的子集"></a><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h3><p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入： nums = <span class="string">[4, 3, 2, 3, 5, 2, 1]</span>, k = <span class="number">4</span></span><br><span class="line">输出： True</span><br><span class="line">说明： 有可能将其分成 <span class="number">4</span> 个子集（<span class="number">5</span>），（<span class="number">1</span>,<span class="number">4</span>），（<span class="number">2</span>,<span class="number">3</span>），（<span class="number">2</span>,<span class="number">3</span>）等于总和。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,3,4], k = 3</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li>
<li><code>0 &lt; nums[i] &lt; 10000</code></li>
<li>每个元素的频率在 <code>[1,4]</code> 范围内</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t: nums) sum += t;</span><br><span class="line">        <span class="keyword">if</span>(sum % k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> s = sum / k; <span class="comment">// 每个子集要等于的和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, s)</span></span>; <span class="comment">// k个桶每个桶可以容纳s的数</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">rbegin</span>(), nums.<span class="built_in">rend</span>()); <span class="comment">// 倒序存放nums 方便回溯里判断是否桶溢出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(nums, buckets, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt; buckets, <span class="type">int</span> k, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 把nums数组分完了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123; <span class="comment">// 每个桶都试一遍</span></span><br><span class="line">            <span class="keyword">if</span>(nums[idx] &gt; buckets[i]) <span class="keyword">continue</span>; <span class="comment">// 这个桶溢出了，下一个</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buckets[i] == buckets[i <span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            buckets[i] -= nums[idx];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">backtracking</span>(nums, buckets, k, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 本次idx放入了一个桶中，idx+1 </span></span><br><span class="line">            buckets[i] += nums[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="473-火柴拼正方形"><a href="#473-火柴拼正方形" class="headerlink" title="473. 火柴拼正方形"></a><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></h3><p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code> 个火柴棒的长度。你要用 <strong>所有的火柴棍</strong> 拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p>
<p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/12/11/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/matchsticks1-grid.jpg" alt="img"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: matchsticks = [1,1,2,2,2]</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 能拼成一个边长为2的正方形，每边两根火柴。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: matchsticks = [3,3,3,3,4]</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: 不能用所有火柴拼成一个正方形。</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>
<li><code>1 &lt;= matchsticks[i] &lt;= 108</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : matchsticks) sum += e;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">sort</span>(matchsticks.<span class="built_in">rbegin</span>(), matchsticks.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">4</span>, target)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(matchsticks, buckets, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks, vector&lt;<span class="type">int</span>&gt; buckets, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= matchsticks.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i] &lt; matchsticks[idx]) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buckets[i] == buckets[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            buckets[i] -= matchsticks[idx];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">backtracking</span>(matchsticks, buckets, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            buckets[i] += matchsticks[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>72.编辑距离</title>
    <url>/2022/11/01/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">intention</span> -&gt;</span> inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">inention</span> -&gt;</span> enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">enention</span> -&gt;</span> exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exention</span> -&gt;</span> exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exection</span> -&gt;</span> execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：如果 word1[0..i-1] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要几步呢？</span></span><br><span class="line"><span class="comment">// 答：先使用 k 步，把 word1[0..i-1] 变换到 word2[0..j-1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题2：如果 word1[0..i-1] 到 word2[0..j] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</span></span><br><span class="line"><span class="comment">// 答：先经过 k 步，把 word1[0..i-1] 变换到 word2[0..j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0..i] 就完全变成了 word2[0..j] 了。一共 k + 1 步。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题3：如果 word1[0..i] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</span></span><br><span class="line"><span class="comment">// 答：先经过 k 步，把 word1[0..i] 变换成 word2[0..j-1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0..i] 就完全变成了 word2[0..j] 了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">              	<span class="comment">// word数组从0开始</span></span><br><span class="line">                <span class="type">int</span> temp = word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(temp, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>), dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>79.单词搜索</title>
    <url>/2022/11/25/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/25/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word2.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;ABCCED&quot;</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/25/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word-1.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;SEE&quot;</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="/2022/11/25/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word3.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;ABCB&quot;</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n = board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 6</code></li>
<li><code>1 &lt;= word.length &lt;= 15</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> tag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">used</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n , <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">               <span class="built_in">backtracking</span>(board, word, <span class="number">0</span>, i, j, used);</span><br><span class="line">               <span class="keyword">if</span>(tag) <span class="keyword">return</span> tag;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传引用直接在原始位置操作，不需要进行新建变量与赋值，节省了代码运行的空间与时间开销</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> idx, <span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; used)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= board.<span class="built_in">size</span>() || c &lt; <span class="number">0</span> || c &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() </span><br><span class="line">        || used[r][c] == <span class="literal">true</span> || board[r][c] != word[idx]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(idx == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            tag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        used[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(board, word, idx + <span class="number">1</span>, r + <span class="number">1</span>, c, used);</span><br><span class="line">        <span class="built_in">backtracking</span>(board, word, idx + <span class="number">1</span>, r, c + <span class="number">1</span>, used);</span><br><span class="line">        <span class="built_in">backtracking</span>(board, word, idx + <span class="number">1</span>, r - <span class="number">1</span>, c, used);</span><br><span class="line">        <span class="built_in">backtracking</span>(board, word, idx + <span class="number">1</span>, r, c - <span class="number">1</span>, used);</span><br><span class="line">        used[r][c] = <span class="literal">false</span>; <span class="comment">// 回撤是因为这样就不用在main函数里每次循环new一个全0的used数组出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>797.所有可能的路径</title>
    <url>/2022/11/04/797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h3><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/04/797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/all_1.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：graph = <span class="string">[[1,2],[3],[3],[]]</span></span><br><span class="line">输出：<span class="string">[[0,1,3],[0,2,3]]</span></span><br><span class="line">解释：有两条路径 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> 和 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/04/797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/all_2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[4,3,1]</span>,<span class="comment">[3,2,4]</span>,<span class="comment">[3]</span>,<span class="comment">[4]</span>,<span class="comment">[]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[0,4]</span>,<span class="comment">[0,3,4]</span>,<span class="comment">[0,1,3,4]</span>,<span class="comment">[0,1,2,3,4]</span>,<span class="comment">[0,1,4]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == graph.length</code></li>
<li><code>2 &lt;= n &lt;= 15</code></li>
<li><code>0 &lt;= graph[i][j] &lt; n</code></li>
<li><code>graph[i][j] != i</code>（即不存在自环）</li>
<li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>
<li>保证输入为 <strong>有向无环图（DAG）</strong></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, graph.<span class="built_in">size</span>() - <span class="number">1</span>, path, graph);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(end);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(graph[start].<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : graph[start])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(elem, end, path, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>91.解码方法</title>
    <url>/2022/10/22/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h3><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&quot;2&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;26&quot;</span></span><br></pre></td></tr></table></figure>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;12&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：它可以解码为 <span class="string">&quot;AB&quot;</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">&quot;L&quot;</span>（<span class="number">12</span>）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;226&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">&quot;BZ&quot;</span> <span class="comment">(2 26)</span>, <span class="string">&quot;VF&quot;</span> <span class="comment">(22 6)</span>, 或者 <span class="string">&quot;BBF&quot;</span> <span class="comment">(2 2 6)</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符映射到以 <span class="number">0</span> 开头的数字。</span><br><span class="line">含有 <span class="number">0</span> 的有效映射是 <span class="string">&#x27;J&#x27;</span> -&gt; <span class="string">&quot;10&quot;</span> 和 <span class="string">&#x27;T&#x27;</span>-&gt; <span class="string">&quot;20&quot;</span> 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>状态表示：f[i]表示前i个数字一共有多少种解码方式，那么，f[n]就表示前n个数字一共有多少种不同的解码方式，即为答案。</p>
<p>状态计算：</p>
<p>设定字符串数组为s[]，考虑最后一次解码方式，因此对于第i - 1和第i 个数字，分为两种决策：</p>
<p>1、如果s[i]不为0，则可以单独解码s[i]，由于求的是方案数，如果确定了第i个数字的翻译方式，那么解码前i个数字和解码前i - 1个数的方案数就是相同的，即f[i] &#x3D; f[i - 1]。(s[]数组下标从1开始)</p>
<p>2、将s[i]和s[i - 1]组合起来解码（ 组合的数字范围在10 ~ 26之间 ）。如果确定了第i个数和第i - 1个数的解码方式，那么解码前i个数字和解码前i - 2个数的方案数就是相同的，即f[i] &#x3D; f[i - 2]。(s[]数组下标从1开始)</p>
<p>最后将两种决策的方案数加起来，因此，状态转移方程为： f[i] &#x3D; f[i - 1] + f[i - 2]。</p>
<p>边界条件：</p>
<p>f[0] &#x3D; 1，解码前0个数的方案数为1。</p>
<p>为什么解码前0个数的方案数是1？</p>
<p>f[0]代表前0个数字的方案数，这样的状态定义其实是没有实际意义的，但是f[0]的值需要保证边界是对的，即f[1]和f[2]是对的。比如说，第一个数不为0，那么解码前1个数只有一种方法，将其单独解码，即f[1] &#x3D; f[1 - 1] &#x3D; 1。解码前两个数，如果第1个数和第2个数可以组合起来解码，那么f[2] &#x3D; f[1] + f[0] &#x3D; 2 ，否则只能单独解码第2个数，即f[2] &#x3D; f[1] &#x3D; 1。因此，在任何情况下f[0]取1都可以保证f[1]和f[2]是正确的，所以f[0]应该取1。</p>
<p>实现细节:</p>
<p>在推导状态转移方程时，我们假设的s[]数组下标是从1开始的，而实际中的s[]数组下标是从0开始的，为了一 一对应，我们需要将所有字符串的下标减去 1。比如在取组合数字的值时，要取s[i - 2]和s[i - 1]，即组合值t &#x3D; (s[i - 2] - ‘0’) * 10 + s[i - 1] - ‘0’。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> temp = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= <span class="number">26</span> &amp;&amp; temp &gt;= <span class="number">10</span>) dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树 95.不同的二叉搜索树II</title>
    <url>/2022/10/22/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/22/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/uniquebstn3.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/10/22/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20221022155720080.png" alt="image-20221022155720080"></p>
<p><img src="/2022/10/22/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20221022155737712.png" alt="image-20221022155737712"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h3><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/22/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/uniquebstn3-20221022174206641.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>DFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">dfs</span>(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">dfs</span>(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTrees) &#123;</span><br><span class="line">                    TreeNode* currTree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    currTree-&gt;left = left;</span><br><span class="line">                    currTree-&gt;right = right;</span><br><span class="line">                    allTrees.<span class="built_in">push_back</span>(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>动态规划</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>中序遍历模板 98.验证BST 99.恢复二叉树 230.BST中第K小的元素 538.把BST转化为累加树</title>
    <url>/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/</url>
    <content><![CDATA[<h3 id="中序遍历模板"><a href="#中序遍历模板" class="headerlink" title="中序遍历模板"></a>中序遍历模板</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = [] <span class="comment"># 函数内部的函数一律不加self,函数内部的变量一律加self</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            self.res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>



<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/tree1.jpg" alt="img"></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">输入<span class="built_in">：root</span> = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出<span class="built_in">：true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/tree2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：根节点的值是 <span class="number">5</span> ，但是右子节点的值是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> pre = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>( root-&gt;val &lt;=pre ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.pre = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="comment"># 最小浮点值</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> check(root.left): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> root.val &lt;= self.pre : <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                self.pre = root.val</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> check(root.right): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> check(root)</span><br></pre></td></tr></table></figure>





<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode.cn/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h3><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/recover1.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是<span class="number"> 1 </span>的左孩子，因为<span class="number"> 3 </span>&gt;<span class="number"> 1 </span>。交换<span class="number"> 1 </span>和<span class="number"> 3 </span>使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/recover2.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,null,2]</span><br><span class="line">输出：[2,1,4,null,null,3]</span><br><span class="line">解释：2 不能在<span class="number"> 3 </span>的右子树中，因为<span class="number"> 2 </span>&lt;<span class="number"> 3 </span>。交换<span class="number"> 2 </span>和<span class="number"> 3 </span>使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* left,* right, * pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="type">int</span> temp = left-&gt;val;</span><br><span class="line">        left-&gt;val = right-&gt;val;</span><br><span class="line">        right-&gt;val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) left = pre;</span><br><span class="line">                right = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recoverTree</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>): <span class="comment"># 函数内部的函数一律不加self,函数内部的变量一律加self</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span>;</span><br><span class="line">            inorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> self.pre:</span><br><span class="line">                <span class="keyword">if</span> self.pre.val &gt; root.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.left: self.left = self.pre</span><br><span class="line">                    self.right = root</span><br><span class="line">            self.pre = root</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        temp = self.left.val</span><br><span class="line">        self.left.val = self.right.val</span><br><span class="line">        self.right.val = temp</span><br></pre></td></tr></table></figure>



<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/kthtree1.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/kthtree2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="type">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,k);</span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>) res = root-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2022/09/30/98-%E9%AA%8C%E8%AF%81BST/tree.png" alt="img"></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">30</span>,<span class="number">36</span>,<span class="number">21</span>,<span class="number">36</span>,<span class="number">35</span>,<span class="number">26</span>,<span class="number">15</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">33</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">0</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[1,0,2]</span></span><br><span class="line">输出：<span class="comment">[3,3,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">3,2,4,1</span>]</span><br><span class="line">输出：[<span class="number">7,9,4,10</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>
<li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>
<li>树中的所有值 <strong>互不相同</strong> 。</li>
<li>给定的树为二叉搜索树。</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> accumulation = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">iinorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">iinorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">iinorder</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> temp = root-&gt;val;</span><br><span class="line">        root-&gt;val += accumulation;</span><br><span class="line">        accumulation += temp;</span><br><span class="line">        <span class="built_in">iinorder</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>994.腐烂的橘子</title>
    <url>/2023/02/19/994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2023/02/19/994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/oranges.png" alt="img"></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[2,1,1],[1,1,0],[0,1,1]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[2,1,1],[0,1,1],[1,0,1]]</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：左下角的橘子（第 <span class="number">2</span> 行， 第 <span class="number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="number">4</span> 个正向上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,2]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：因为 <span class="number">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) </span><br><span class="line">                    <span class="comment">// 周围的1会被更新为3</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j, <span class="number">2</span>); <span class="comment">// 每次更新橘子腐烂时间是直接覆盖grid,而grid中已经有2了,所以从2开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                maxTime = <span class="built_in">max</span>(maxTime, grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxTime == <span class="number">0</span> ? <span class="number">0</span> : maxTime - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span> &amp;&amp; grid[r][c] &lt; cnt) <span class="keyword">return</span>; </span><br><span class="line">        grid[r][c] = cnt;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c, cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c, cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2022/08/25/Ajax/</url>
    <content><![CDATA[<h3 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h3><h4 id="前后端如何交互"><a href="#前后端如何交互" class="headerlink" title="前后端如何交互"></a>前后端如何交互</h4><p>前后端交互一般就是两种:</p>
<ol>
<li>是通过表单的提交，表单提交：通过前端设计表单而后端通过get或post获取信息，这是前端传数据给后端。</li>
<li>Ajax技术。所以Ajax是用于前后端交互的一门技术。Ajax是异步的JavaScript和XML，前端通过ajax给服务器发送请求，并获取服务器的响应数据。</li>
</ol>
<blockquote>
<p>后端可以通过表单获取前端数据，但是后端却没办法将数据返回给html，所以有了jsp，但是jsp复杂而且无法实现前后端分离，前端不清楚后端代码，所以jsp代码也要交给后端，那不就向全栈靠拢了。而Ajax的出现则实现了前后端的分离。</p>
</blockquote>
<h4 id="Ajax与Json"><a href="#Ajax与Json" class="headerlink" title="Ajax与Json"></a>Ajax与Json</h4><ul>
<li><p>Ajax的异步可以在不重新加载页面的情况下与服务器实现交互并更新部分网页，比如在百度的输入框输入“老坛酸菜”，下面立马能够联想出“老坛酸菜怎么了”“315”等等，这就是异步。<br>有了Ajax，那么就可以实现 html + Ajax + 后端的结构，一般Ajax交由前端工程师，后端只需简单获取数据并返回数据就可以了。</p>
</li>
<li><p>那么json是什么呢？json是JavaScript的对象表示法，是一种数据的载体。比如前端通过Ajax发送数据，或者后端返回数据给前端，那双方各玩各的怎么行呢（也不是各玩各的，人家是使用xml为载体传输，但是json比较优秀，语法简单，可读性强，能减少传输时占用的宽带，现在json几乎已经成了主流），所以统一数据的格式，一起使用json，前端用json的规范来写JavaScript，后端也将返回的数据转化成json的格式，那不就皆大欢喜了。</p>
</li>
<li><p>总之ajax和json两者不是同一个层面的东西，没法比较，只能说清二者是不同的技术。json跟xml才有可比性。最后，要是有哪里讲错了也希望大家能在评论区指出。</p>
</li>
</ul>
<h3 id="Ajax请求"><a href="#Ajax请求" class="headerlink" title="Ajax请求"></a>Ajax请求</h3><p>浏览器向网站发送请求时：URL 和 表单的形式提交。</p>
<ul>
<li>GET</li>
<li>POST</li>
</ul>
<p>特点：页面刷新。</p>
<p>除此之外，也可以基于Ajax向后台发送请求（偷偷的发送请求）。</p>
<ul>
<li><p>依赖<code>jQuery</code> 【不依赖也行,但依赖了操作就非常简单】</p>
</li>
<li><p>编写ajax代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;发送的地址&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;get&quot;</span>, </span><br><span class="line">    <span class="attr">data</span>:&#123;  <span class="comment">//要传递的数据</span></span><br><span class="line">        <span class="attr">n1</span>:<span class="number">123</span>,</span><br><span class="line">        <span class="attr">n2</span>:<span class="number">456</span></span><br><span class="line">    &#125;,<span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Ajax发送GET请求"><a href="#Ajax发送GET请求" class="headerlink" title="Ajax发送GET请求"></a>Ajax发送GET请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% block js %&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    url: <span class="string">&#x27;/task/ajax/&#x27;</span>,</span></span><br><span class="line"><span class="params">    type: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="params">    data: &#123;</span></span><br><span class="line"><span class="params">        n1: <span class="number">123</span>,</span></span><br><span class="line"><span class="params">        n2: <span class="number">456</span></span></span><br><span class="line"><span class="params">    &#125;,</span></span><br><span class="line"><span class="params">    success: <span class="keyword">function</span> (res) &#123;</span></span><br><span class="line"><span class="params">        <span class="variable language_">console</span>.log(res);</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br><span class="line"> </span><br><span class="line">&#123;% end block %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_ajax</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(request.GET)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;成功了&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Ajax发送POST请求"><a href="#Ajax发送POST请求" class="headerlink" title="Ajax发送POST请求"></a>Ajax发送POST请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% block js %&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    url: <span class="string">&#x27;/task/ajax/&#x27;</span>,</span></span><br><span class="line"><span class="params">    type: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">    data: &#123;</span></span><br><span class="line"><span class="params">        n1: $(<span class="string">&quot;#btn1&quot;</span>).val(),</span></span><br><span class="line"><span class="params">        n2: $(<span class="string">&quot;#form3&quot;</span>).serialize() //适用于 form3标签内的属性很多的情况,效果同多个 $(<span class="string">&quot;#btn1&quot;</span>).val()</span></span><br><span class="line"><span class="params">    &#125;,</span></span><br><span class="line"><span class="params">    success: <span class="keyword">function</span> (res) &#123;</span></span><br><span class="line"><span class="params">        <span class="variable language_">console</span>.log(res);</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br><span class="line"> </span><br><span class="line">&#123;% end block %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_ajax</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(request.POST)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;成功了&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Ajax绑定事件"><a href="#Ajax绑定事件" class="headerlink" title="Ajax绑定事件"></a>Ajax绑定事件</h4><ul>
<li>基于J Q u e r y</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>任务管理<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>示例1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 页面框架加载完成之后代码自动执行</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">bindBtn1Event</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">bindBtn1Event</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;/task/ajax/&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">n1</span>: $(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">n2</span>: <span class="number">456</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据交换格式-JSON"><a href="#数据交换格式-JSON" class="headerlink" title="数据交换格式 JSON"></a>数据交换格式 JSON</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import json</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 任务列表 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;task_list.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_ajax</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(request.GET)</span><br><span class="line">    <span class="built_in">print</span>(request.POST)</span><br><span class="line"></span><br><span class="line">    data_dict = &#123;<span class="string">&quot;status&quot;</span>: <span class="literal">True</span>, <span class="string">&#x27;data&#x27;</span>: [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]&#125;</span><br><span class="line">    <span class="comment"># return HttpResponse(json.dumps(data_dict))</span></span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data_dict)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;layout.html&#x27;</span> %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;任务管理&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h3&gt;示例<span class="number">1</span>&lt;/h3&gt;</span><br><span class="line">        &lt;<span class="built_in">input</span> <span class="built_in">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> value=<span class="string">&quot;点击&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            // 页面框架加载完成之后代码自动执行</span><br><span class="line">            bindBtn1Event();</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        function bindBtn1Event() &#123;</span><br><span class="line">            $(<span class="string">&quot;#btn1&quot;</span>).click(function () &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">&#x27;/task/ajax/&#x27;</span>,</span><br><span class="line">                    <span class="built_in">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        n1: $(<span class="string">&quot;#btn1&quot;</span>).val(),</span><br><span class="line">                        n2: <span class="number">456</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    dataType: <span class="string">&quot;JSON&quot;</span></span><br><span class="line">                    success: function (res) &#123;</span><br><span class="line">                        console.log(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>



<h4 id="案例-任务管理"><a href="#案例-任务管理" class="headerlink" title="案例: 任务管理"></a>案例: 任务管理</h4><ul>
<li><code>html页面</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%  <span class="keyword">extends</span> <span class="string">&#x27;layout.html&#x27;</span> %&#125;</span><br><span class="line">&#123;%  block style %&#125;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&#123;%  endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">form</span>  <span class="attr">id</span>=<span class="string">&quot;formAdd&quot;</span> <span class="attr">novalidate</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;% for field in form %&#125;</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-6&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: relative&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 15px&quot;</span>&gt;</span>&#123;&#123; field.label &#125;&#125;:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                &#123;&#123; field &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;error-msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red; position: absolute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;% endfor %&#125;</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-12&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 15px&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnAdd&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-primary&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 10px &quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// 页面框架加载完成后代码自动执行</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_">bindBtnAddEvent</span>();</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">bindBtnAddEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">            $(<span class="string">&quot;#btnAdd&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                $(<span class="string">&quot;.error-msg&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line">                $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">&#x27;/task/add/&#x27;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">                    <span class="attr">data</span>: $(<span class="string">&quot;#formAdd&quot;</span>).<span class="title function_">serialize</span>(),</span><br><span class="line">                    <span class="attr">dataType</span>: <span class="string">&quot;JSON&quot;</span>,</span><br><span class="line">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res.<span class="property">status</span>) &#123;</span><br><span class="line">                            <span class="title function_">alert</span>(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">                            <span class="comment">// 用JS实现页面的刷新</span></span><br><span class="line">                            location.<span class="title function_">reload</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            $.<span class="title function_">each</span>(res.<span class="property">error</span>, <span class="keyword">function</span> (<span class="params">name, data</span>) &#123;</span><br><span class="line">                                <span class="comment">// console.log(name,data);</span></span><br><span class="line">                                $(<span class="string">&quot;#id_&quot;</span> + name).<span class="title function_">next</span>().<span class="title function_">text</span>(data[<span class="number">0</span>]);</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>task.py</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01.utils.form <span class="keyword">import</span> TaskModelForm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 任务列表 &quot;&quot;&quot;</span></span><br><span class="line">    form = TaskModelForm()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;task_list.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># &#123;&#x27;level&#x27;: [&#x27;1&#x27;], &#x27;title&#x27;: [&#x27;sdfsdfsdfsd&#x27;], &#x27;detail&#x27;: [&#x27;111&#x27;], &#x27;user&#x27;: [&#x27;8&#x27;]&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.POST)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.用户发送过来的数据进行校验（ModelForm进行校验）</span></span><br><span class="line">    form = TaskModelForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        data_dict = &#123;<span class="string">&quot;status&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(data_dict))</span><br><span class="line"></span><br><span class="line">    data_dict = &#123;<span class="string">&quot;status&quot;</span>: <span class="literal">False</span>, <span class="string">&#x27;error&#x27;</span>: form.errors&#125;  <span class="comment"># data_dict 即是前端页面的 res</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(json.dumps(data_dict))</span><br></pre></td></tr></table></figure>



<h4 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h4><p>需要使用第三方插件,两种:</p>
<ul>
<li>highchart</li>
<li>echarts, 百度开源 <a href="https://echarts.apache.org/">https://echarts.apache.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>BM20 数组中的逆序对</title>
    <url>/2023/03/09/BM20-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [7,5,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 数组长度 &lt;= <span class="number">50000</span></span><br></pre></td></tr></table></figure>





<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_cnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; data, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">merge_cnt</span>(data, l, mid); </span><br><span class="line">        <span class="built_in">merge_cnt</span>(data, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &lt;= data[j]) t.<span class="built_in">push_back</span>(data[i ++]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(data[j ++]);</span><br><span class="line">                <span class="comment">// 逆序对的个数为    左子数组的终点- 当前左子数组的当前指针</span></span><br><span class="line">                cnt += mid + <span class="number">1</span> - i;</span><br><span class="line">                cnt %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) t.<span class="built_in">push_back</span>(data[i ++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) t.<span class="built_in">push_back</span>(data[j ++]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); i ++, j ++) data[i] = t[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">merge_cnt</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS之二叉树的属性合集</title>
    <url>/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span>     </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>    </span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxHeight</span>(root -&gt; left), <span class="built_in">maxHeight</span>(root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">        res = <span class="built_in">max</span>((<span class="built_in">maxHeight</span>(root -&gt; left) + <span class="built_in">maxHeight</span>(root -&gt; right) ), res);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/ex_depth.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root -&gt; left) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root -&gt; right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root -&gt; right) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root -&gt; left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root -&gt; left), <span class="built_in">minDepth</span>(root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root -&gt; left), <span class="built_in">maxDepth</span>(root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>
<p>如果二叉树的两个节点深度相同，但 <strong>父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>
<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>
<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>
<p><strong>示例 1：<br><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/q1248-01.png" alt="img"></strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：root <span class="operator">=</span> [<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span>]<span class="punctuation">,</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：<br><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/q1248-02.png" alt="img"></strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：root <span class="operator">=</span> [<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="keyword">null</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="keyword">null</span><span class="punctuation">,</span><span class="number">5</span>]<span class="punctuation">,</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/q1248-03.png" alt="img"></strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：root <span class="operator">=</span> [<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="keyword">null</span><span class="punctuation">,</span><span class="number">4</span>]<span class="punctuation">,</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>
<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, x, y, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x_depth == y_depth)&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">isBrother</span>(root, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> depth)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val == x) x_depth = depth;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val == y) y_depth = depth;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, x, y, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, x, y, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBrother</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( root -&gt; left &amp;&amp; root -&gt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left -&gt; val == x &amp;&amp; root -&gt; right -&gt; val == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left -&gt; val == y &amp;&amp; root -&gt; right -&gt; val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBrother</span>(root -&gt; left, x, y) || <span class="built_in">isBrother</span>(root -&gt; right, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a><a href="https://leetcode.cn/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，计算并返回 <strong>整个树</strong> 的坡度 。</p>
<p>一个树的 <strong>节点的坡度</strong> 定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值</strong> 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>
<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/tilt1.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">节点<span class="number"> 2 </span>的坡度：|0-0| = 0（没有子节点）</span><br><span class="line">节点<span class="number"> 3 </span>的坡度：|0-0| = 0（没有子节点）</span><br><span class="line">节点<span class="number"> 1 </span>的坡度：|2-3| = 1（左子树就是左子节点，所以和是<span class="number"> 2 </span>；右子树就是右子节点，所以和是<span class="number"> 3 </span>）</span><br><span class="line">坡度总和：0 +<span class="number"> 0 </span>+<span class="number"> 1 </span>= 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/tilt2.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,9,3,5,null,7]</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">节点<span class="number"> 3 </span>的坡度：|0-0| = 0（没有子节点）</span><br><span class="line">节点<span class="number"> 5 </span>的坡度：|0-0| = 0（没有子节点）</span><br><span class="line">节点<span class="number"> 7 </span>的坡度：|0-0| = 0（没有子节点）</span><br><span class="line">节点<span class="number"> 2 </span>的坡度：|3-5| = 2（左子树就是左子节点，所以和是<span class="number"> 3 </span>；右子树就是右子节点，所以和是<span class="number"> 5 </span>）</span><br><span class="line">节点<span class="number"> 9 </span>的坡度：|0-7| = 7（没有左子树，所以和是<span class="number"> 0 </span>；右子树正好是右子节点，所以和是<span class="number"> 7 </span>）</span><br><span class="line">节点<span class="number"> 4 </span>的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和<span class="number"> 2 </span>，和是<span class="number"> 10 </span>；右子树值为<span class="number"> 9 </span>和<span class="number"> 7 </span>，和是<span class="number"> 16 </span>）</span><br><span class="line">坡度总和：0 +<span class="number"> 0 </span>+<span class="number"> 0 </span>+<span class="number"> 2 </span>+<span class="number"> 7 </span>+<span class="number"> 6 </span>= 15</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/tilt3.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">21,7,14,1</span>,<span class="number">1,2,2,3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目的范围在 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123; <span class="comment">// 计算以root为根的树结点之和</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root -&gt; left); <span class="comment">// 左子树之和</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root -&gt; right); <span class="comment">// 右子树之和</span></span><br><span class="line">        res += <span class="built_in">abs</span>(l -r);</span><br><span class="line">        <span class="keyword">return</span> root -&gt; val + l + r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> lh = <span class="built_in">height</span>(root -&gt; left);</span><br><span class="line">        <span class="type">int</span> rh = <span class="built_in">height</span>(root -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(lh - rh) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root -&gt; left) &amp;&amp; <span class="built_in">isBalanced</span>(root -&gt; right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root -&gt; left), <span class="built_in">height</span>(root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/merge.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root1</span> = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>], <span class="attr">root2</span> = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root1 = <span class="comment">[1]</span>, root2 = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;<span class="comment">// root1空 root2不空</span></span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1 -&gt; val + root2 -&gt; val); </span><br><span class="line">        root -&gt; left = <span class="built_in">mergeTrees</span>(root1 -&gt; left, root2 -&gt; left);</span><br><span class="line">        root -&gt; right = <span class="built_in">mergeTrees</span>(root1 -&gt; right, root2 -&gt; right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || (!root -&gt; left &amp;&amp; !root -&gt; right)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* temp = root -&gt;left;</span><br><span class="line">            root -&gt;left = root -&gt; right;</span><br><span class="line">            root -&gt; right = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/subtree1-tree.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[3,4,5,1,2]</span>, subRoot = <span class="comment">[4,1,2]</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/12/DFS%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%88%E9%9B%86/subtree2-tree.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">0</span>], <span class="attr">subRoot</span> = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>
<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>
<li><code>-104 &lt;= root.val &lt;= 104</code></li>
<li><code>-104 &lt;= subRoot.val &lt;= 104</code></li>
</ul>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> tag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, subRoot);</span><br><span class="line">        <span class="keyword">return</span> tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSametree</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((!root1 &amp;&amp; root2) || (root1 &amp;&amp; !root2) || root1 -&gt; val != root2 -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSametree</span>(root1 -&gt; left, root2 -&gt; left) &amp;&amp; <span class="built_in">isSametree</span>(root1 -&gt; right, root2 -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val == subRoot -&gt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">            tag = <span class="built_in">isSametree</span>(root -&gt; left, subRoot -&gt; left) &amp;&amp; <span class="built_in">isSametree</span>(root -&gt; right, subRoot -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; left, subRoot);</span><br><span class="line">        <span class="built_in">dfs</span>(root -&gt; right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>DP&amp;DFS之跳跃游戏合集</title>
    <url>/2022/10/20/DP&amp;DFS%E4%B9%8B%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳<span class="number"> 1 </span>步，从下标<span class="number"> 0 </span>到达下标 1, 然后再从下标<span class="number"> 1 </span>跳<span class="number"> 3 </span>步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为<span class="number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="number"> 0 </span>， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp 通过全部用例 超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++)&#123;</span><br><span class="line">                dp[i + j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AC</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 能达到的下标</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; res) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 到了达不到的下标,不能再继续下去</span></span><br><span class="line">            res = <span class="built_in">max</span>(nums[i] + i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路一 : 动态规划</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// dp[i] 为到达 i 下标所需的最少跳跃次数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> m = INT_MAX; <span class="comment">// 在 j &lt; i中找到 j + nums[j] &gt;= i 且 最小的dp[j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &lt; m &amp;&amp; j + nums[j] &gt;= i)&#123;</span><br><span class="line">                    m = dp[j];</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行用时：1916 ms, 在所有 C++ 提交中击败了5.01%的用户</span></span><br><span class="line"><span class="comment">//内存消耗：16.8 MB, 在所有 C++ 提交中击败了5.18%的用户</span></span><br></pre></td></tr></table></figure>



<ul>
<li>思路二 :</li>
</ul>
<ol>
<li><p>如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。</p>
</li>
<li><p>如果从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。</p>
</li>
<li><p>所以，当一次 跳跃 结束时，从下一个格子开始，到现在 能跳到最远的距离，都 是下一次 跳跃 的 起跳点。</p>
<p>对每一次 跳跃 用 for 循环来模拟。</p>
<p>跳完一次之后，更新下一次 起跳点 的范围。</p>
<p>在新的范围内跳，更新 能跳到最远的距离。记录 跳跃 次数，如果跳到了终点，就得到了结果。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 到达nums[n - 1]的最少步数</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">1</span>; <span class="comment">// end 是 该轮最末尾的位置</span></span><br><span class="line">        <span class="keyword">while</span>(end &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = begin; i &lt; end; i ++)&#123; <span class="comment">// 如果将end初始化为0的话,第一轮不会展开,出现runtime error</span></span><br><span class="line">               maxReach = <span class="built_in">max</span>(nums[i] + i, maxReach);</span><br><span class="line">            &#125;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = maxReach + <span class="number">1</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行用时：12 ms, 在所有 C++ 提交中击败了76.15%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：16 MB, 在所有 C++ 提交中击败了96.52%的用户</span></span><br></pre></td></tr></table></figure>



<h3 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a><a href="https://leetcode.cn/problems/jump-game-iii/">1306. 跳跃游戏 III</a></h3><p>这里有一个非负整数数组 <code>arr</code>，你最开始位于该数组的起始下标 <code>start</code> 处。当你位于下标 <code>i</code> 处时，你可以跳到 <code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p>
<p>请你判断自己是否能够跳到对应元素值为 0 的 <strong>任一</strong> 下标处。</p>
<p>注意，不管是什么情况下，你都无法跳到数组之外。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,2,3,0,3,1,2], start = 5</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">到达值为<span class="number"> 0 </span>的下标<span class="number"> 3 </span>有以下可能方案： </span><br><span class="line">下标<span class="number"> 5 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标<span class="number"> 3 </span></span><br><span class="line">下标<span class="number"> 5 </span>-&gt; 下标<span class="number"> 6 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标<span class="number"> 3 </span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,2,3,0,3,1,2], start = 0</span><br><span class="line">输出：true </span><br><span class="line">解释：</span><br><span class="line">到达值为<span class="number"> 0 </span>的下标<span class="number"> 3 </span>有以下可能方案： </span><br><span class="line">下标<span class="number"> 0 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="literal">start</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法到达值为 <span class="number">0</span> 的下标 <span class="number">1</span> 处。 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>0 &lt;= arr[i] &lt; arr.length</code></li>
<li><code>0 &lt;= start &lt; arr.length</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canReach</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, start);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; n - <span class="number">1</span> || start &lt; <span class="number">0</span> || arr[start] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[start] == <span class="number">0</span>)&#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> step = arr[start];</span><br><span class="line">        arr[start] = <span class="number">-1</span>; <span class="comment">// -1代表已经访问过</span></span><br><span class="line">        <span class="built_in">dfs</span>(arr, start + step);</span><br><span class="line">        <span class="built_in">dfs</span>(arr, start - step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1345-跳跃游戏-IV"><a href="#1345-跳跃游戏-IV" class="headerlink" title="1345. 跳跃游戏 IV"></a><a href="https://leetcode.cn/problems/jump-game-iv/">1345. 跳跃游戏 IV</a></h3><p>给你一个整数数组 <code>arr</code> ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 <code>i</code> 跳到下标 <code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>
<ul>
<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>
<li><code>i - 1</code> 需满足：<code>i - 1 &gt;= 0</code></li>
<li><code>j</code> 需满足：<code>arr[i] == arr[j]</code> 且 <code>i != j</code></li>
</ul>
<p>请你返回到达数组最后一个元素的下标处所需的 <strong>最少操作次数</strong> 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：arr = [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">输出：3</span><br><span class="line">解释：那你需要跳跃<span class="number"> 3 </span>次，下标依次为<span class="number"> 0 </span>--&gt;<span class="number"> 4 </span>--&gt;<span class="number"> 3 </span>--&gt;<span class="number"> 9 </span>。下标<span class="number"> 9 </span>为数组的最后一个元素的下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：arr <span class="operator">=</span> [<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：一开始就在最后一个元素处，所以你不需要跳跃。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">7,6,9,6</span>,<span class="number">9,6,9,7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以直接从下标 <span class="number">0</span> 处跳到下标 <span class="number">7</span> 处，也就是数组的最后一个元素处。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 104</code></li>
<li><code>-108 &lt;= arr[i] &lt;= 108</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误版本, 这样会向右一步一步的走,最后 res 返回的是串长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> idx, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt; arr.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[idx] == <span class="number">-1</span> || idx == arr.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 已被访问过</span></span><br><span class="line">        arr[idx] = <span class="number">-1</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, idx + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(arr, idx - <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == idx || arr[j] != arr[idx] || arr[j] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(arr, j, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之0-1背包合集</title>
    <url>/2022/12/11/DP%E4%B9%8B0-1%E8%83%8C%E5%8C%85%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="0-1背包模板"><a href="#0-1背包模板" class="headerlink" title="0-1背包模板"></a>0-1背包模板</h3><p>背包最大重量为4。</p>
<table>
<thead>
<tr>
<th align="left">有三个物品</th>
<th align="left">重量</th>
<th align="left">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">物品0</td>
<td align="left">1</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">物品1</td>
<td align="left">3</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">物品2</td>
<td align="left">4</td>
<td align="left">30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h4 id="二维数组版"><a href="#二维数组版" class="headerlink" title="二维数组版"></a>二维数组版</h4><p><code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 倒叙遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = bagWeight; j &gt;= weight[<span class="number">0</span>]; j--) &#123; <span class="comment">// j从最大容量开始，直到j不小于下标为i的物品的容量</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>]; <span class="comment">// 初始化i为0时候的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果一旦正序遍历了，那么物品0就会被重复加入多次！例如代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例如dp[0][1] 是15，到了dp[0][2] = dp[0][2 - 1] + 15; 也就是dp[0][2] = 30 了，那么就是物品0被重复放入了。</span></span><br></pre></td></tr></table></figure>

<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagWeight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = bagWeight; j &gt;= weight[<span class="number">0</span>]; j--) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagWeight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 包里容量不够了</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>()][bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一维数组版"><a href="#一维数组版" class="headerlink" title="一维数组版"></a>一维数组版</h4><p>在使用二维数组时:<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p>
<p><strong>可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p>
<p>dp[j]可以通过dp[j - weight[j]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>



<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果题目给的价值都是正整数那么非0下标都初始化为0就可以了</span></span><br><span class="line"><span class="comment">// 如果题目给的价值有负数，那么非0下标就要初始化为负无穷</span></span><br></pre></td></tr></table></figure>

<h5 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h5><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品,每遍历到一个新元素,就更新dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  若正序遍历背包容量:</p>
<p>  物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>  dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>  dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>  此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
</blockquote>
<blockquote>
<p>  为什么倒叙遍历，就可以保证物品只放入一次呢？</p>
<p>  倒叙就是先算dp[2]</p>
<p>  dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15  （dp数组已经都初始化为0）</p>
<p>  dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>  所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</p>
</blockquote>
<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,5,11,5]</span></span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 <span class="comment">[1, 5, 5]</span> 和 <span class="comment">[11]</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// d(i, s) : 是否存在：nums区间[0, i] 中取一些元素，使其和为s</span></span><br><span class="line"><span class="comment">// d(i, s) = d(i-1, s)【 不取nums[i]】 || d(i-1, s-nums[i])【 取nums[i]】</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem: nums) sum+= elem;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> halfSum = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(nums, halfSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span></span>&#123; <span class="comment">// 判断数组nums是否有和为k的子集</span></span><br><span class="line">        <span class="comment">// dp[i][k - 1]表示是否在 nums下标的0-i里存在和为k的子集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span> (nums.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(k, <span class="literal">false</span>)); </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= k) dp[<span class="number">0</span>][nums[<span class="number">0</span>] - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们求dp第i行的时候dp[i][?]，我们只需要知道dp的i-1行即可dp[i-1][?];</span></span><br><span class="line">        <span class="comment">// 也就是说，按照这个依赖关系，一直往下递推，只要得到第0行即可。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++)&#123;</span><br><span class="line">                <span class="comment">//  不取nums[i] || 取nums[i]</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || ((j - nums[i] &gt;=<span class="number">0</span>) ? dp[i - <span class="number">1</span>][j - nums[i]] : <span class="literal">false</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>][k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><a href="https://leetcode.cn/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h3><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输入：<span class="selector-attr">[2,7,4,1,8,1]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">先选出 <span class="number">7</span> 和 <span class="number">8</span>，得到 <span class="number">1</span>，所以数组转换为 <span class="selector-attr">[2,4,1,1,1]</span>，</span><br><span class="line">再选出 <span class="number">2</span> 和 <span class="number">4</span>，得到 <span class="number">2</span>，所以数组转换为 <span class="selector-attr">[2,1,1,1]</span>，</span><br><span class="line">接着是 <span class="number">2</span> 和 <span class="number">1</span>，得到 <span class="number">1</span>，所以数组转换为 <span class="selector-attr">[1,1,1]</span>，</span><br><span class="line">最后选出 <span class="number">1</span> 和 <span class="number">1</span>，得到 <span class="number">0</span>，最终数组转换为 <span class="selector-attr">[1]</span>，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>优先队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s: stones) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(a - b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">0</span> : q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="comment">[2,7,4,1,8,1]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 <span class="comment">[2,7,1,8,1]</span>，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 <span class="comment">[2,1,1,1]</span>，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 <span class="comment">[1,1,1]</span>，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 <span class="comment">[1]</span>，这就是最优值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="string">[31,26,33,21,40]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/12/11/DP%E4%B9%8B0-1%E8%83%8C%E5%8C%85%E5%90%88%E9%9B%86/image-20221211233140517.png" alt="image-20221211233140517"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1背包问题</span></span><br><span class="line"><span class="comment">问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值</span></span><br><span class="line"><span class="comment">进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2</span></span><br><span class="line"><span class="comment">进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t : stones) sum += t;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>; <span class="comment">// 背包容量：target 求放进去的物品的最大重量MaxWeight</span></span><br><span class="line">        <span class="comment">// dp[i][j]含义:从前i块石头中选取，选取值之和小于等于目标值j的最大值</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target + <span class="number">1</span> ,<span class="number">0</span>)); </span><br><span class="line">        <span class="comment">// 每次石头有两种可能，加入 或者 不加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j - stones[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) <span class="comment">// 加入的话要确保背包的容量够大</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>] );</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - <span class="number">2</span> * dp[n][target]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t : stones) sum += t;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>; <span class="comment">// 背包容量：target 求放进去的物品的最大重量MaxWeight</span></span><br><span class="line">        <span class="comment">// dp[i][j]含义:从前i块石头中选取，选取值之和小于等于目标值j的最大值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span> ,<span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="comment">// 每次石头有两种可能，加入 或者 不加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: stones) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= e; j --) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - e] + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - <span class="number">2</span> * dp[target]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有<span class="number"> 5 </span>种方法让最终目标和为<span class="number"> 3 </span>。</span><br><span class="line">-1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 -<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>-<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>-<span class="number"> 1 </span>+<span class="number"> 1 </span>= 3</span><br><span class="line">+1 +<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>-<span class="number"> 1 </span>= 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/12/11/DP%E4%B9%8B0-1%E8%83%8C%E5%8C%85%E5%90%88%E9%9B%86/image-20221212114117764.png" alt="image-20221212114117764"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span>(target + sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bagSize = (target + sum) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize + <span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">// dp[bagSize]：让背包容量恰好为bagSize的方法数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = bagSize; j &gt;= e; j --) &#123;</span><br><span class="line">                dp[j] += dp[j - e];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>], m = <span class="number">5</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最多有 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 的最大子集是 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="number">4</span> 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>&#125; 和 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; 。&#123;<span class="string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="number">4</span> 个 <span class="number">1</span> ，大于 <span class="built_in">n</span> 的值 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">strs</span> = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>], m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最大的子集是 &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125; ，所以答案是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 600</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成</li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[m][n] 代表1总量不超过m,0数量不超过n的最大子集数 相当于容量有两个维度的一维数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">for</span>(string s: strs)&#123;</span><br><span class="line">            <span class="type">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--) &#123; <span class="comment">// 遍历背包容量且从后向前遍历！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之买卖股票合集</title>
    <url>/2022/10/12/DP%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="number"> 5 </span>。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> min_val = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) min_val = prices[<span class="number">0</span>];</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - min_val);</span><br><span class="line">            min_val = <span class="built_in">min</span>(prices[i], min_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>=<span class="number"> 4 </span>。</span><br><span class="line">     随后，在第<span class="number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 6 </span>-<span class="number"> 3 </span>=<span class="number"> 3 </span>。</span><br><span class="line">     总利润为<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第<span class="number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>=<span class="number"> 4 </span>。</span><br><span class="line">     总利润为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n ,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]); <span class="comment">// dp[i][0]表示当天手里没股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]); <span class="comment">// dp[i - 1][1]表示昨天的还没卖呢,没套现,手里钱为昨天的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第<span class="number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="number"> 3 </span>。</span><br><span class="line">     随后，在第<span class="number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第<span class="number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="number"> 4 </span>。   </span><br><span class="line">     注意你不能在第<span class="number"> 1 </span>天和第<span class="number"> 2 </span>天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span> </span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：prices <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 105</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 因为一次没买的话利润必然为 0, 所以不做考虑,仅在最后将利润与0比较,返回较大的那个</span></span><br><span class="line">        <span class="comment">//dp[i][0]表示买了一次没卖 dp[i][1]买卖完一次 dp[i][2]买了第二次了 dp[i][3]完成了两次购买 </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天买,再卖, 再在第一天买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">// 第一天买,再卖, 再在第一天买入,再在第一天卖出</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">3</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第<span class="number"> 1 </span>天 (股票价格 = 2) 的时候买入，在第<span class="number"> 2 </span>天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 =<span class="number"> 2 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第<span class="number"> 2 </span>天 (股票价格 = 2) 的时候买入，在第<span class="number"> 3 </span>天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 =<span class="number"> 4 </span>。</span><br><span class="line">     随后，在第<span class="number"> 5 </span>天 (股票价格 = 0) 的时候买入，在第<span class="number"> 6 </span>天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 =<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= 100</code></li>
<li><code>0 &lt;= prices.length &lt;= 1000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], -prices[i]); <span class="comment">// 第i天,第1次交易没套现</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + prices[i]); <span class="comment">// 第i天,第1次交易已经套现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j ++)&#123;</span><br><span class="line">                <span class="comment">// dp[i][j][0] 表示第i天,第j次交易还没套现 </span></span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]); </span><br><span class="line">                <span class="comment">// dp[i][j][1] 表示第i天,第j次交易已经套现</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>,dp[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行用时：56 ms, 在所有 C++ 提交中击败了5.28%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：27.6 MB, 在所有 C++ 提交中击败了5.00%的用户</span></span><br></pre></td></tr></table></figure>



<h4 id="C-优化版"><a href="#C-优化版" class="headerlink" title="C++优化版"></a>C++优化版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k, INT_MIN)</span></span>;  <span class="comment">// buy[i] 表示交易第i次时没套现</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sell</span><span class="params">(k, <span class="number">0</span>)</span></span>; <span class="comment">// sell[0] 表示交易第i次时已套现</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123; <span class="comment">// 天数</span></span><br><span class="line">            <span class="comment">// 要先将这两个弄完,因为下面j从1开始</span></span><br><span class="line">            sell[<span class="number">0</span>] = <span class="built_in">max</span>(buy[<span class="number">0</span>] + prices[i], sell[<span class="number">0</span>]); </span><br><span class="line">            buy[<span class="number">0</span>] = <span class="built_in">max</span>(buy[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j ++)&#123; <span class="comment">// 交易数</span></span><br><span class="line">                buy[j] = <span class="built_in">max</span>(buy[j], sell[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j] + prices[i]); <span class="comment">//已套现 = max(已套现:天数增加交易数不变,未套现:交易数不变)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sell[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行用时：4 ms, 在所有 C++ 提交中击败了96.13%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：10.6 MB, 在所有 C++ 提交中击败了74.91%的用户</span></span><br></pre></td></tr></table></figure>



<h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h3><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: prices = [1,2,3,0,2]</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: prices = [1]</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 已经买入</span></span><br><span class="line">        <span class="comment">// dp[0][1] = 0; // 已经卖出,且过了冷冻期</span></span><br><span class="line">        <span class="comment">// dp[0][2] = 0; // 今天卖出</span></span><br><span class="line">        <span class="comment">// dp[0][3] = 0; // 今天为冷冻期</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="comment">// 前一天为冷冻期或者前一天就过了冷冻期都能买</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]), dp[i - <span class="number">1</span>][<span class="number">0</span>]);  </span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">0</span>, dp[n - <span class="number">1</span>][<span class="number">3</span>]), <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices<span class="comment">[0]</span> = 1</span><br><span class="line">在此处卖出 prices<span class="comment">[3]</span> = 8</span><br><span class="line">在此处买入 prices<span class="comment">[4]</span> = 4</span><br><span class="line">在此处卖出 prices<span class="comment">[5]</span> = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[1,3,7,5,10,3]</span>, fee = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li>
<li><code>0 &lt;= fee &lt; 5 * 104</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// dp[0][0]: 第一天结时手里没股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之回文串合集</title>
    <url>/2022/10/16/DP%E4%B9%8B%E5%9B%9E%E6%96%87%E4%B8%B2%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode.cn/problems/palindrome-number/">9. 回文数</a></h3><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">121</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">-121</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：从左向右读<span class="punctuation">,</span> 为 <span class="number">-121</span> 。 从右向左读<span class="punctuation">,</span> 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：从右向左读<span class="punctuation">,</span> 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串</a></h3><p>给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回 <em>通过这些字母构造成的 <strong>最长的回文串</strong></em> 。</p>
<p>在构造过程中，请注意 <strong>区分大小写</strong> 。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入:s = &quot;abccccdd&quot;</span></span><br><span class="line"><span class="section">输出:7</span></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">&quot;dccaccd&quot;</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">输入<span class="symbol">:s</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">输入<span class="symbol">:</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 只由小写 <strong>和&#x2F;或</strong> 大写英文字母组成</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s)&#123;</span><br><span class="line">            mp[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)&#123;</span><br><span class="line">            <span class="type">int</span> o = i.second;</span><br><span class="line">            res += o/<span class="number">2</span> * <span class="number">2</span>; <span class="comment">// res 一加都加的是偶数</span></span><br><span class="line">            <span class="keyword">if</span>(res % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; o % <span class="number">2</span> == <span class="number">1</span>)&#123; <span class="comment">// 当有出现次数为单数的, res变为奇数下次再遇见出现次数为单数的,res不增加</span></span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="string">&quot;amanaplanacanalpanama&quot;</span> 是回文串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;race a car&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">&quot;raceacar&quot;</span> 不是回文串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot; &quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：在移除非字母数字字符之后，s 是一个空字符串 <span class="string">&quot;&quot;</span> 。</span><br><span class="line">由于空字符串正着反着读都一样，所以是回文串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 105</code></li>
<li><code>s</code> 仅由可打印的 ASCII 字符组成</li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">// 判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。</span></span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="680-验证回文串-II"><a href="#680-验证回文串-II" class="headerlink" title="680. 验证回文串 II"></a><a href="https://leetcode.cn/problems/valid-palindrome-ii/">680. 验证回文串 II</a></h3><p>给你一个字符串 <code>s</code>，<strong>最多</strong> 可以从中删除一个字符。</p>
<p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abca&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你可以删除字符 <span class="string">&#x27;c&#x27;</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r )&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isValid</span>(s, l + <span class="number">1</span>, r) || <span class="built_in">isValid</span>(s, l, r - <span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            l ++;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l ++;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; res &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[l + <span class="number">1</span>] == s[r]) &#123; <span class="comment">//错在不能第一种情况符合就不执行第二种</span></span><br><span class="line">                    l ++;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[l] == s[r - <span class="number">1</span>])&#123;</span><br><span class="line">                    r --;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            l ++;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;= <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i &lt; <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span>) dp[i][j] = s[i] == s[j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 如果没有else 那么当i = n - 1时, i + 1 越界</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：三个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">6</span>个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i &lt; <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span>) dp[i][j] = s[i] == s[j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="literal">true</span>) res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：[[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">[[&quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, vector&lt;string&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">// path.clear();</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string pre = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(pre)) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(i), path);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l ++;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只需一次分割就可将 s 分割成 [<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><img src="/2022/10/16/DP%E4%B9%8B%E5%9B%9E%E6%96%87%E4%B8%B2%E5%90%88%E9%9B%86/image-20221018175222811.png" alt="image-20221018175222811" style="zoom: 67%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; res = <span class="built_in">isPalindrome</span>(s);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">2</span>; r &lt; n; r ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt;= r; l ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[l][r])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(l &gt; <span class="number">0</span>) dp[r] = <span class="built_in">min</span>(dp[r], dp[l - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[r] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//用双指针判断会超时</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(string s) &#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i &lt; <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span>) dp[i][j] = s[i] == s[j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bbbb&quot;</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bb&quot;</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><img src="/2022/10/16/DP%E4%B9%8B%E5%9B%9E%E6%96%87%E4%B8%B2%E5%90%88%E9%9B%86/image-20221018221305687.png" alt="image-20221018221305687" style="zoom: 50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i &lt; <span class="number">1</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span>) dp[i][j] = s[i] == s[j] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == s[j]) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之子序列合集</title>
    <url>/2022/12/13/DP%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10,9,2,5</span>,<span class="number">3,7,101,18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2,3,7,101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[0,1,0,3,2,3]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,7,7,7,7,7,7]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,3,5,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[1,3,5]</span>, 长度为3。</span><br><span class="line">尽管 <span class="comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,2,2,2,2]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[2]</span>, 长度为1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i - <span class="number">1</span>] &gt; nums[i  - <span class="number">2</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,3,2,1]</span>, nums2 = <span class="comment">[3,2,1,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 <span class="comment">[3,2,1]</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[0,0,0,0,0]</span>, nums2 = <span class="string">[0,0,0,0,0]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]</span></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m ; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abcde&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line"><span class="comment">如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不用返回dp数组里的最大元素.因为dp[i][j]表示子数组一定取到i-1，j-1的元素， dp[i][j]表示子序列不一定取到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// text1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0;</span></span><br><span class="line">        <span class="comment">// 同理dp[0][j]也是0</span></span><br><span class="line">        <span class="comment">// 其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m +<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>; j &lt;=n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j- <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h3><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/13/DP%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E5%90%88%E9%9B%86/142.png" alt="img"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 <span class="symbol">nums1</span>[<span class="number">1</span>]=<span class="number">4</span> 到 <span class="symbol">nums2</span>[<span class="number">2</span>]=<span class="number">4</span> 的直线将与从 <span class="symbol">nums1</span>[<span class="number">2</span>]=<span class="number">2</span> 到 <span class="symbol">nums2</span>[<span class="number">1</span>]=<span class="number">2</span> 的直线相交。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[2,5,1,2,5]</span>, nums2 = <span class="string">[10,5,2,1,5,2]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[1,3,7,1,7,5]</span>, nums2 = <span class="string">[1,9,2,5,1]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/12/13/DP%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E5%90%88%E9%9B%86/image-20221213183653080.png" alt="image-20221213183653080"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i <span class="number">-1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1e8</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i - <span class="number">1</span>], dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h3><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路1: 同 1143.最长公共子序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n +<span class="number">1</span> , <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(&#123;dp[i - <span class="number">1</span>][j],dp[i][j- <span class="number">1</span>], dp[i][j]&#125;);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m] == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>思路2:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(&#123;dp[i - <span class="number">1</span>][j],dp[i][j- <span class="number">1</span>], dp[i][j]&#125;);</span><br><span class="line"><span class="comment">//换成 else dp[i][j] = dp[i - 1][j]; 表示跳过 t的这一项，等于前面一项</span></span><br></pre></td></tr></table></figure>



<h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h3><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">word1</span> = <span class="string">&quot;sea&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;eat&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 第一步将 <span class="string">&quot;sea&quot;</span> 变为 <span class="string">&quot;ea&quot;</span> ，第二步将 <span class="string">&quot;eat &quot;</span>变为 <span class="string">&quot;ea&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例  2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;etco&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路，找出最长公共子序列， 操作数即为两个字符串的长度之和 - 两倍的最长公共子序列长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n +<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>( word1[i - <span class="number">1</span>] == word2[ j - <span class="number">1</span>]) </span><br><span class="line">                    dp[i][j] = <span class="number">1</span> +dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> (m + n - <span class="number">2</span> * dp[m][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之完全背包合集</title>
    <url>/2022/12/12/DP%E4%B9%8B%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>背包最大重量为4。</p>
<table>
<thead>
<tr>
<th align="left">物品列表</th>
<th align="left">重量</th>
<th align="left">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">物品0</td>
<td align="left">1</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">物品1</td>
<td align="left">3</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">物品2</td>
<td align="left">4</td>
<td align="left">30</td>
</tr>
</tbody></table>
<p><strong>每件商品都有无限个！</strong>问背包能背的物品最大价值是多少？</p>
<p>首先回顾一下01背包的核心代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">for(int i = <span class="number">0</span><span class="comment">; i &lt; weight.size(); i++) &#123; // 遍历物品</span></span><br><span class="line">    for(int <span class="keyword">j </span>= <span class="keyword">bagWeight; </span><span class="keyword">j </span>&gt;= weight[i]<span class="comment">; j--) &#123; // 遍历背包容量</span></span><br><span class="line">        dp[<span class="keyword">j] </span>= max(dp[<span class="keyword">j], </span>dp[<span class="keyword">j </span>- weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="keyword">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt; bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="keyword">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>⭐️如果求组合数就是外层for循环遍历物品，内层for遍历背包。 </p>
<p>⭐️如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">target</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>], <span class="keyword">target</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为要求的是排列数，所以外层背包, 内层物品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;    </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// dp[target]表示 总和为target的组合个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i ++) &#123; <span class="comment">// 外层背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> e: nums) &#123;  <span class="comment">// 内层物品</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= e &amp;&amp; (dp[i - e] &lt; INT_MAX - dp[i]))</span><br><span class="line">                    dp[i] += dp[i - e];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 =<span class="number"> 5 </span>+<span class="number"> 5 </span>+ 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：coins </span>=<span class="string"> [2], amount = 3</span></span><br><span class="line"><span class="string">输出：-1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：coins </span>=<span class="string"> [1], amount = 0</span></span><br><span class="line"><span class="string">输出：0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">1e8</span>)</span></span>; <span class="comment">// dp[i]表示 兑换i块钱所需的最少硬币个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = e; j &lt;= amount; j ++)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - e] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">1e8</span>? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2<span class="string">+2</span><span class="string">+1</span></span><br><span class="line">5=2<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br><span class="line">5=1<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额<span class="number"> 2 </span>的硬币不能凑成总金额<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：amount </span>=<span class="string"> 10, coins = [10] </span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// dp[i]表示 兑换i块钱所需的最少硬币个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: coins)&#123; <span class="comment">// 组合数：外层物品，内层背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = e; j &lt;= amount; j ++)&#123;</span><br><span class="line">                dp[j] += dp[j - e];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 =<span class="number"> 4 </span>+<span class="number"> 4 </span>+ 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">13</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1e8</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = e; j &lt;= n; j ++)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - e] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以由 <span class="string">&quot;leet&quot;</span> 和 <span class="string">&quot;code&quot;</span> 拼接成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;applepenapple&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;applepenapple&quot;</span> 可以由 <span class="string">&quot;apple&quot;</span> <span class="string">&quot;pen&quot;</span> <span class="string">&quot;apple&quot;</span> 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;catsandog&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;cats&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">而本题其实我们求的是排列数，为什么呢。 拿 s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;] 举例。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;apple&quot;, &quot;pen&quot; 是物品，那么我们要求 物品的组合一定是 &quot;apple&quot; + &quot;pen&quot; + &quot;apple&quot; 才能组成 &quot;applepenapple&quot;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;apple&quot; + &quot;apple&quot; + &quot;pen&quot; 或者 &quot;pen&quot; + &quot;apple&quot; + &quot;apple&quot; 是不可以的，那么我们就是强调物品之间顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">// 遍历背包 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之打家劫舍合集</title>
    <url>/2022/10/14/DP%E4%B9%8B%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃<span class="number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="number"> 3 </span>号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 1 </span>+<span class="number"> 3 </span>=<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃<span class="number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="number"> 5 </span>号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 2 </span>+<span class="number"> 9 </span>+<span class="number"> 1 </span>=<span class="number"> 12 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//不偷这家</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>]; <span class="comment">// 偷这家</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);  <span class="comment">// 不太明白，记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃<span class="number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃<span class="number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="number"> 3 </span>号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 1 </span>+<span class="number"> 3 </span>=<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,3]</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>分成两个数组 0～n-2 和 1～n-1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i ++)&#123; </span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);  <span class="comment">// 不太明白，记</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = dp[ n - <span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);  <span class="comment">// 不太明白，记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, dp[n - <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/10/14/DP%E4%B9%8B%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/rob1-tree.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出:<span class="number"> 7 </span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额<span class="number"> 3 </span>+<span class="number"> 3 </span>+<span class="number"> 1 </span>= 7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="/2022/10/14/DP%E4%B9%8B%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/rob2-tree.jpg" alt="img"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: root = [3,4,5,1,3,null,1]</span></span><br><span class="line"><span class="section">输出: 9</span></span><br><span class="line"><span class="section">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树的节点数在 <code>[1, 104]</code> 范围内</li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/10/14/DP%E4%B9%8B%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/image-20221015221538145.png" alt="image-20221015221538145"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;TreeNode*, <span class="type">int</span>&gt; yes, no;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">postorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(yes[root], no[root]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postorder</span>(root -&gt; left);</span><br><span class="line">        <span class="built_in">postorder</span>(root -&gt; right);</span><br><span class="line">        yes[root] = no[root -&gt; left] + no[root -&gt; right] + root -&gt;val;</span><br><span class="line">        no[root] = <span class="built_in">max</span>(no[root -&gt; left],yes[root -&gt; left]) + <span class="built_in">max</span>(no[root -&gt; right],yes[root -&gt; right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Django项目-管理系统</title>
    <url>/2022/08/20/Django%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>新建项目 <code>/django01</code></p>
</li>
<li><p>删除templates以及<code>settings.py</code>中<code>DIRS</code>字段的值</p>
</li>
<li><p><code>python3.9 manage.py startapp app01  </code></p>
</li>
<li><p>去<code>settings.py</code>中注册<code>app01</code></p>
</li>
<li><p>在<code>app01</code>目录中新建<code>templates</code>目录以及<code>static</code>目录（<code>static</code>包含<code>css、img、js、plugins</code>目录）</p>
</li>
<li><p>在<code>settings.py</code>中进行数据库连接</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;数据库名&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;00000000&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: 3306,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># python manage.py makemigrations</span></span><br><span class="line"><span class="comment"># python manage.py migrate</span></span><br></pre></td></tr></table></figure>



<h3 id="设计数据库表结构"><a href="#设计数据库表结构" class="headerlink" title="设计数据库表结构"></a>设计数据库表结构</h3><h3 id="写页面"><a href="#写页面" class="headerlink" title="写页面"></a>写页面</h3><ul>
<li>注意点1</li>
</ul>
<p><img src="/2022/08/20/Django%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220820151146120.png" alt="image-20220820151146120"></p>
<p><img src="/2022/08/20/Django%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220820152335461.png" alt="image-20220820152335461"></p>
<p>如图中那样引用静态文件预览正常，项目运行后不正常，需如下操作:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% load <span class="keyword">static</span> %&#125;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1-dist/css/bootstrap.css&#x27; %&#125; &quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jquery-3.6.0.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1-dist/js/bootstrap.js&#x27;%&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>注意点2</li>
</ul>
<p><img src="/2022/08/20/Django%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220820173233427.png" alt="image-20220820173233427"></p>
<ul>
<li>注意点3</li>
</ul>
<p>若请求形式为<code>post</code>，则不能再出现<code>request.GET</code></p>
<p>解决方法： <code>path(&#39;department/&lt;int:nid&gt;/edit/&#39;,views.depart_edit),</code></p>
<p><img src="/2022/08/20/Django%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220821015541847.png" alt="image-20220821015541847"></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>DP之简单题合集</title>
    <url>/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1.<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶</span><br><span class="line">2.<span class="number"> 2 </span>阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1.<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶</span><br><span class="line">2.<span class="number"> 1 </span>阶 +<span class="number"> 2 </span>阶</span><br><span class="line">3.<span class="number"> 2 </span>阶 +<span class="number"> 1 </span>阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]  + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为<span class="number"> 1 </span>的台阶开始。</span><br><span class="line">- 支付<span class="number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为<span class="number"> 15 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为<span class="number"> 0 </span>的台阶开始。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 2 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 4 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 6 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬一个台阶，到达下标为<span class="number"> 7 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 9 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为<span class="number"> 6 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= cost.length &lt;= 1000</code></li>
<li><code>0 &lt;= cost[i] &lt;= 999</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul>
<li>假设数组cost 的长度为 n，则 n 个阶梯分别对应下标 0 到 n−1，楼层顶部对应下标 n，问题等价于计算达到下标 n 的最小花费。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123; <span class="comment">// cost长度 &gt;= 2 下标0,1,...</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// dp[i] 代表爬到i层以上上所需的最低花费</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(cost[i - <span class="number">2</span>] + dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/robot_maze.png" alt="img"></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">7</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt; n; j ++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS : 超时</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int cnt = 0;</span></span><br><span class="line"><span class="comment">//     int uniquePaths(int m, int n) &#123;</span></span><br><span class="line"><span class="comment">//         // vector&lt;vector&lt;int&gt;&gt; visited = (m, vector&lt;int&gt;(n, 0));</span></span><br><span class="line"><span class="comment">//         dfs(m, n, 0, 0);</span></span><br><span class="line"><span class="comment">//         return cnt;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void dfs(int m, int n, int r, int c)&#123;</span></span><br><span class="line"><span class="comment">//         if(r &lt; 0 || r &gt; m - 1 || c &lt; 0 || c &gt; n - 1) return;</span></span><br><span class="line"><span class="comment">//         if( r == m - 1 &amp;&amp; c == n - 1) cnt ++;</span></span><br><span class="line"><span class="comment">//         dfs(m, n, r + 1, c);</span></span><br><span class="line"><span class="comment">//         dfs(m, n, r, c + 1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>



<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/robot1.jpg" alt="img"></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/robot2.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == obstacleGrid.length</code></li>
<li><code>n == obstacleGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i ++) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 一遇到 obstacleGrid[i][0] = 1 就停下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j ++) dp[<span class="number">0</span>][j] = <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp [m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h3><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 1</span><br><span class="line">解释:<span class="number"> 2 </span>=<span class="number"> 1 </span>+ 1,<span class="number"> 1 </span>×<span class="number"> 1 </span>= 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 36</span><br><span class="line">解释:<span class="number"> 10 </span>=<span class="number"> 3 </span>+<span class="number"> 3 </span>+ 4,<span class="number"> 3 </span>×<span class="number"> 3 </span>×<span class="number"> 4 </span>= 36。</span><br></pre></td></tr></table></figure>



<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n ; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(&#123;dp[i], dp[i - j]* j, j*(i-j)&#125;); <span class="comment">// dp[2] = 1, 但2 &gt; dp[2]</span></span><br><span class="line">                <span class="comment">// 所以3=2+1: max(1*1,2*1);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/08/09/DP%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/uniquebstn3.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设n个节点存在二叉排序树的个数是G(n)</span></span><br><span class="line"><span class="comment">分别是1为根节点，2为根节点，...，n为根节点，</span></span><br><span class="line"><span class="comment">当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n +<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 方便 G(0)*G(n-1)</span></span><br><span class="line">        dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask快速建站</title>
    <url>/2022/08/15/Flask%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<h3 id="Flask为何物"><a href="#Flask为何物" class="headerlink" title="Flask为何物"></a>Flask为何物</h3><p>Falsk是由python开发的轻量的web框架，小巧，灵活，一个脚本就可以启动一个web项目， 开发的难度比较大，flask好多的模块是按照django的思路开发的。和flask类似的框架还有web.py</p>
<h4 id="flask和django的区别"><a href="#flask和django的区别" class="headerlink" title="flask和django的区别"></a>flask和django的区别</h4><ul>
<li>Django: 大而全，有一套完整的框架，但是耦合性高。Auth，Permission，admin基本没用开发快，符合MVC模式</li>
<li>Flask： 微框架，很小巧。一个脚本就可以启动一个web项目，需要哪些功能，自己装。需要熟悉MVC模式</li>
</ul>
<h3 id="Flask建站"><a href="#Flask建站" class="headerlink" title="Flask建站"></a>Flask建站</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure>

<img src="/2022/08/15/Flask%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/image-20220816001615926.png" alt="image-20220816001615926" style="zoom: 50%;">

<p>在web1项目根目录中新建web001.py文件,其中⬇️</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__) <span class="comment">#Flask是一个类 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了网址 /show/info 和 函数index 的对应关系</span></span><br><span class="line"><span class="comment"># 以后用户在浏览器上访问 /show/info，网站自动执行 index</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/show/info&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;中国联通&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/15/Flask%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/image-20220816003732254.png" alt="image-20220816003732254"></p>
<p>此时访问 <a href="http://127.0.0.1:5000/show/info">http://127.0.0.1:5000/show/info</a> 即出现 中国联通</p>
<p>咱们网站与别人的不一样：</p>
<ul>
<li>Flask框架为了让咱们写标签方便，支持将字符串写入到文件里。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/show/info&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># Flask内部会自动打开这个文件，并读取内容，将内容给用户返回。</span></span><br><span class="line">    <span class="comment"># 默认：去当前项目目录的templates文件夹中找。</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>此时的目录结构：</p>
<img src="/2022/08/15/Flask%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/image-20220816205452931.png" alt="image-20220816205452931" style="zoom: 67%;">



<h3 id="知识点回顾和补充"><a href="#知识点回顾和补充" class="headerlink" title="知识点回顾和补充"></a>知识点回顾和补充</h3><ol>
<li><p>网站请求的流程<br><img src="/2022/08/15/Flask%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/image-20211119140524753.png" alt="image-20211119140524753"></p>
</li>
<li><p>一大堆的标签</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">h<span class="regexp">/div/</span>span<span class="regexp">/a/img</span><span class="regexp">/ul/</span>li<span class="regexp">/table/i</span>nput<span class="regexp">/textarea/</span>select</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络请求</p>
<ul>
<li><p>在浏览器的URL中写入地址，点击回车，访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">浏览器会发送数据过去，本质上发送的是字符串：</span><br><span class="line"><span class="string">&quot;GET /explore http1.1<span class="subst">\r</span><span class="subst">\n</span>host:...<span class="subst">\r</span><span class="subst">\n</span>user-agent<span class="subst">\r</span><span class="subst">\n</span>..<span class="subst">\r</span><span class="subst">\n</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span></span><br><span class="line"></span><br><span class="line">浏览器会发送数据过去，本质上发送的是字符串：</span><br><span class="line"><span class="string">&quot;POST /explore http1.1<span class="subst">\r</span><span class="subst">\n</span>host:...<span class="subst">\r</span><span class="subst">\n</span>user-agent<span class="subst">\r</span><span class="subst">\n</span>..<span class="subst">\r</span><span class="subst">\n</span><span class="subst">\r</span><span class="subst">\n</span>数据库&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器向后端发送请求时</p>
<ul>
<li><p>GET请求【URL方法 &#x2F; 表单提交】</p>
<ul>
<li><p>现象：GET请求、跳转、向后台传入数据数据会拼接在URL上。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.sogou.com/web?query=安卓&amp;age=<span class="number">19</span>&amp;name=xx</span><br></pre></td></tr></table></figure>

<p>注意：GET请求数据会在URL中体现。</p>
</li>
</ul>
</li>
<li><p>POST请求【表单提交】</p>
<ul>
<li>现象：提交数据不在URL中而是在请求体中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>创建&#x2F;Users&#x2F;jiangangkong&#x2F;workSpace&#x2F;pycharmWorkSpace&#x2F;example1</p>
<p>在其根目录中创建app.py、templates目录&#x2F;register.html、static目录</p>
<ul>
<li><p>app.py中代码</p>
<ol>
<li>后台接受用户通过GET形式发送过来的数据 <code>request.args</code></li>
<li>后台接受用户通过POST形式发送过来的数据<code>request.form</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/register&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;register.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        user = request.form.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        pwd = request.form.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">        gender = request.form.get(<span class="string">&quot;gender&quot;</span>)</span><br><span class="line">        hobby_list = request.form.getlist(<span class="string">&quot;hobby&quot;</span>)</span><br><span class="line">        city = request.form.get(<span class="string">&quot;city&quot;</span>)</span><br><span class="line">        skill_list = request.form.getlist(<span class="string">&quot;skill&quot;</span>)</span><br><span class="line">        more = request.form.get(<span class="string">&quot;more&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(user, pwd, gender, hobby_list, city, skill_list, more)</span><br><span class="line">        <span class="comment"># 将用户信息写入文件中实现注册、写入到excel中实现注册、写入数据库中实现注册</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.给用户再返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;注册成功&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>register.html中代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        爱好：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span>篮球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span>足球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>&gt;</span>乒乓球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40&quot;</span>&gt;</span>棒球</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        城市：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;bj&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;sh&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;sz&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        擅长领域：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;101&quot;</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;102&quot;</span>&gt;</span>打球<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        备注：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;more&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>IOS开发</title>
    <url>/2022/10/16/IOS%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="创建IOS项目工程"><a href="#创建IOS项目工程" class="headerlink" title="创建IOS项目工程"></a>创建IOS项目工程</h3><img src="/2022/10/16/IOS%E5%BC%80%E5%8F%91/image-20221016133636928.png" alt="image-20221016133636928" style="zoom: 50%;">

<ul>
<li>团队名可不写，这里<code>Interface</code>先选<code>Storyboard</code></li>
</ul>
<img src="/2022/10/16/IOS%E5%BC%80%E5%8F%91/image-20221016133819051.png" alt="image-20221016133819051" style="zoom:50%;">

<ul>
<li>源代码文件(三个)</li>
</ul>
<blockquote>
<p><code>AppDelegate.swift</code>是应用程序的入口</p>
<p><code>SceneDelegate.swift</code>用来进行多场景应用的管理</p>
<p><code>ViewController</code>是模版默认创建的一个视图控制器文件，运行工程时，该控制器中内容将展现在模拟器屏幕上</p>
</blockquote>
<ul>
<li>除此之外</li>
</ul>
<blockquote>
<p><code>Main</code>是可视化的界面开发文件</p>
<p><code>Assets</code>用于存放项目中需要的图片素材</p>
<p><code>LaunchScreen</code>是应用的启动界面</p>
<p><code>Info</code>是项目的配置文件</p>
</blockquote>
<h3 id="运行IOS程序"><a href="#运行IOS程序" class="headerlink" title="运行IOS程序"></a>运行IOS程序</h3><ul>
<li>在<code>Main</code>中进行图形化操作</li>
<li>运行、视图层级、添加组件</li>
</ul>
<img src="/2022/10/16/IOS%E5%BC%80%E5%8F%91/image-20221016140313113.png" alt="image-20221016140313113" style="zoom:50%;">

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Self Attention</title>
    <url>/2022/07/31/Self-Attention/</url>
    <content><![CDATA[<h3 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/881659278403_.pic.jpg" alt="881659278403_.pic"></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30866925-c326e92942025a3a6c6b1e8b96ccc0ce.png" alt="30866925-c326e92942025a3a6c6b1e8b96ccc0ce"></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><img src="/2022/07/31/Self-Attention/30867091-d28fe5868178a62d9faab212486b474b.png" alt="30867091-d28fe5868178a62d9faab212486b474b"></p>
<h3 id="Muiltihead-Self-Attention"><a href="#Muiltihead-Self-Attention" class="headerlink" title="Muiltihead Self Attention"></a>Muiltihead Self Attention</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p><img src="/2022/07/31/Self-Attention/image-20220801014946983.png" alt="image-20220801014946983"></p>
<h4 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h4><p><img src="/2022/07/31/Self-Attention/30867156-2219b84d50e04f41dd60cbe13b2994ac.png" alt="30867156-2219b84d50e04f41dd60cbe13b2994ac"></p>
<ul>
<li>这里的 a i 和 a j 是同一个输入(可以理解为下图的X)</li>
</ul>
<h4 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h4><p><img src="/2022/07/31/Self-Attention/QQ20220801-015325.png" alt="QQ20220801-015325"></p>
<p><img src="/2022/07/31/Self-Attention/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjE0NjM2,size_16,color_FFFFFF,t_70-20220801020808429.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>八个头相当于八个不同的表征子空间，类似于apple拥有水果的含义，同时也有商标的含义，不同的含义由不同的表征子空间学习。</p>
</li>
<li><p>让其他词的Q来和apple这个词不同组的K-V进行attention。</p>
</li>
<li><p>再把所有的attention结果拼接起来，通过一个全连接层（矩阵变换）得到最终结果。</p>
</li>
<li><p>X是一开始经过Embedding的词向量矩阵，R为之前层输出的，他俩都可以进行Multihead Self Attention</p>
</li>
</ul>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>blog</title>
    <url>/2022/07/29/blog/</url>
    <content><![CDATA[<h3 id="Markdown基本操作"><a href="#Markdown基本操作" class="headerlink" title="Markdown基本操作"></a>Markdown基本操作</h3><ul>
<li>标题</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># A (一级标题)</span></span><br><span class="line"><span class="section">## A</span></span><br><span class="line"><span class="section">### A</span></span><br><span class="line"><span class="section">#### A</span></span><br><span class="line"><span class="section">##### A</span></span><br><span class="line"><span class="section">###### A （六级标题）</span></span><br></pre></td></tr></table></figure>



<ul>
<li>字体</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜粗体*</span>**</span></span><br></pre></td></tr></table></figure>



<ul>
<li>分割线、下划线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>脚注</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^鼠标移到我身上]：会弹出我！</span><br></pre></td></tr></table></figure>



<ul>
<li>列表</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项		</span><br><span class="line"><span class="bullet">*</span> 第二项		</span><br><span class="line"><span class="bullet">*</span> 第三项   </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项		</span><br><span class="line"><span class="bullet">-</span> 第二项		</span><br><span class="line"><span class="bullet">-</span> 第三项  </span><br></pre></td></tr></table></figure>



<ul>
<li>最左边的竖线</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; </span></span><br></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`print()`</span> </span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>



<ul>
<li>链接</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>图片</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 代替文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>表格</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line"></span><br><span class="line">我们可以设置表格的对齐方式：</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>



<h3 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a>Hexo基本操作</h3><ul>
<li>发布文章</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure>

<p>去&#x2F;Users&#x2F;jiangangkong&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;文章名.md 下写文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li>每篇文章下最大的标题为三级标题</li>
<li>并列关系用 * </li>
<li>顺序关系用1. 2. </li>
<li>文章开头的信息里（tags，categories，descriptions后面要加‘空格）否则会报错</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/08/22/git/</url>
    <content><![CDATA[<h3 id="将项目上传至github"><a href="#将项目上传至github" class="headerlink" title="将项目上传至github"></a>将项目上传至github</h3><h4 id="查看本地是否存在SSH密钥"><a href="#查看本地是否存在SSH密钥" class="headerlink" title="查看本地是否存在SSH密钥"></a>查看本地是否存在SSH密钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al ~/.ssh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>私钥 <code>id_rsa</code> 		公钥 <code>id_rsa.pub</code>即是github中配置的SSH</p>
</blockquote>
<h4 id="测试是否成功配置github"><a href="#测试是否成功配置github" class="headerlink" title="测试是否成功配置github"></a>测试是否成功配置github</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/22/git/image-20220822132233415.png" alt="image-20220822132233415"></p>
<h4 id="在github上新建repository"><a href="#在github上新建repository" class="headerlink" title="在github上新建repository"></a>在github上新建repository</h4><p><img src="/2022/08/22/git/image-20220822133050067.png" alt="image-20220822133050067"></p>
<h4 id="进入到项目目录，输入init命令"><a href="#进入到项目目录，输入init命令" class="headerlink" title="进入到项目目录，输入init命令"></a>进入到项目目录，输入init命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/jiangangkong/workSpace/pycharmWorkSpace/django01</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/22/git/image-20220822133634551.png" alt="image-20220822133634551"></p>
<h4 id="在该项目根目录中add并且commit"><a href="#在该项目根目录中add并且commit" class="headerlink" title="在该项目根目录中add并且commit"></a>在该项目根目录中add并且commit</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/22/git/image-20220822134151019.png" alt="image-20220822134151019"></p>
<h4 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:kjgggggg/django01.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/22/git/image-20220822134347195.png" alt="image-20220822134347195"></p>
<h3 id="从github上拉取项目"><a href="#从github上拉取项目" class="headerlink" title="从github上拉取项目"></a>从github上拉取项目</h3><h4 id="在本机上创建文件夹"><a href="#在本机上创建文件夹" class="headerlink" title="在本机上创建文件夹"></a>在本机上创建文件夹</h4><img src="/2022/08/22/git/image-20221130152726194.png" alt="image-20221130152726194" style="zoom: 33%;">

<h4 id="在此目录下clone"><a href="#在此目录下clone" class="headerlink" title="在此目录下clone"></a>在此目录下clone</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> CMU-15445</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cmu-db/bustub.git</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算合集</title>
    <url>/2023/02/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p> <strong>示例  ：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</span></span><br><span class="line"><span class="comment">// 任何数与0异或不变 0 ^ n =&gt; n</span></span><br><span class="line"><span class="comment">// 相同的数异或为0 n ^ n =&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var a = [2,3,2,4,4]</span></span><br><span class="line"><span class="comment">// 2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 =&gt; 0 ^ 0 ^3 =&gt; 3</span></span><br></pre></td></tr></table></figure>



<h3 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字</a></h3><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,0,1]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 <span class="comment">[0,3]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[0,1]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 <span class="comment">[0,2]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">9,6,4,2</span>,<span class="number">3,5,7,0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：n = <span class="number">9</span>，因为有 <span class="number">9</span> 个数字，所以所有的数字都在范围 [<span class="number">0</span>,<span class="number">9</span>] 内。<span class="number">8</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[0]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 <span class="comment">[0,1]</span> 内。1 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>
</ul>
<p> <strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p>
<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
<p><strong>示例 ：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>



<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><p><img src="/2023/02/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86/image-20230207185015323.png" alt="image-20230207185015323"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></h3><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> <span class="comment">--&gt; 0</span></span><br><span class="line"><span class="number">1</span> <span class="comment">--&gt; 1</span></span><br><span class="line"><span class="number">2</span> <span class="comment">--&gt; 10</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> <span class="comment">--&gt; 0</span></span><br><span class="line"><span class="number">1</span> <span class="comment">--&gt; 1</span></span><br><span class="line"><span class="number">2</span> <span class="comment">--&gt; 10</span></span><br><span class="line"><span class="number">3</span> <span class="comment">--&gt; 11</span></span><br><span class="line"><span class="number">4</span> <span class="comment">--&gt; 100</span></span><br><span class="line"><span class="number">5</span> <span class="comment">--&gt; 101</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li>
<li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><h5 id="法一（去的不一定是0）"><a href="#法一（去的不一定是0）" class="headerlink" title="法一（去的不一定是0）"></a>法一（去的不一定是0）</h5><p>i &gt;&gt; 1会把最低位去掉</p>
<p><strong>n&amp;1</strong><br>n为奇数时，n&amp;1的结果就是1	二进制n的最低位为1<br>n为偶数时，n&amp;1的结果就是0	二进制n的最低位为0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">            res[i] = res[i &gt;&gt; <span class="number">1</span>] + (<span class="number">1</span> &amp; i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="法二（去的肯定是0）"><a href="#法二（去的肯定是0）" class="headerlink" title="法二（去的肯定是0）"></a>法二（去的肯定是0）</h5><p><img src="/2023/02/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86/image-20230207185015323.png" alt="image-20230207185015323"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">            res[i] = res[i &amp;(i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数据库合集</title>
    <url>/2023/02/07/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="595-大的国家"><a href="#595-大的国家" class="headerlink" title="595. 大的国家"></a><a href="https://leetcode.cn/problems/big-countries/">595. 大的国家</a></h3><p><code>World</code> 表：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line"><span class="section">| Column Name | Type    |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">| name        | varchar |</span><br><span class="line">| continent   | varchar |</span><br><span class="line">| area        | int     |</span><br><span class="line">| population  | int     |</span><br><span class="line"><span class="section">| gdp         | int     |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">name 是这张表的主键。</span><br><span class="line">这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。</span><br></pre></td></tr></table></figure>

<p>如果一个国家满足下述两个条件之一，则认为该国是 <strong>大国</strong> ：</p>
<ul>
<li>面积至少为 300 万平方公里（即，<code>3000000 km2</code>），或者</li>
<li>人口至少为 2500 万（即 <code>25000000</code>）</li>
</ul>
<p>编写一个 SQL 查询以报告 <strong>大国</strong> 的国家名称、人口和面积。</p>
<p>按 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="section">World 表：</span></span><br><span class="line"><span class="section">+-------------+-----------+---------+------------+--------------+</span></span><br><span class="line"><span class="section">| name        | continent | area    | population | gdp          |</span></span><br><span class="line"><span class="section">+-------------+-----------+---------+------------+--------------+</span></span><br><span class="line">| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |</span><br><span class="line">| Albania     | Europe    | 28748   | 2831741    | 12960000000  |</span><br><span class="line">| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |</span><br><span class="line">| Andorra     | Europe    | 468     | 78115      | 3712000000   |</span><br><span class="line"><span class="section">| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |</span></span><br><span class="line"><span class="section">+-------------+-----------+---------+------------+--------------+</span></span><br><span class="line"><span class="section">输出：</span></span><br><span class="line"><span class="section">+-------------+------------+---------+</span></span><br><span class="line"><span class="section">| name        | population | area    |</span></span><br><span class="line"><span class="section">+-------------+------------+---------+</span></span><br><span class="line">| Afghanistan | 25500100   | 652230  |</span><br><span class="line"><span class="section">| Algeria     | 37100000   | 2381741 |</span></span><br><span class="line"><span class="section">+-------------+------------+---------+</span></span><br></pre></td></tr></table></figure>



<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select name, population, area from World where area &gt;= 3000000 or population &gt;= 25000000;</span><br></pre></td></tr></table></figure>



<h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode.cn/problems/combine-two-tables/">175. 组合两个表</a></h3><p>表: <code>Person</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line"><span class="section">| 列名         | 类型     |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line"><span class="section">| LastName    | varchar |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">personId 是该表的主键列。</span><br><span class="line">该表包含一些人的 ID 和他们的姓和名的信息。</span><br></pre></td></tr></table></figure>

<p>表: <code>Address</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line"><span class="section">| 列名         | 类型    |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line"><span class="section">| State       | varchar |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">addressId 是该表的主键列。</span><br><span class="line">该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。</span><br></pre></td></tr></table></figure>

<p>编写一个SQL查询来报告 <code>Person</code> 表中每个人的姓、名、城市和州。如 <code>personId</code> 的地址不在 <code>Address</code> 表中，则报告为空  <code>null</code> 。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"><span class="section">Person表:</span></span><br><span class="line"><span class="section">+----------+----------+-----------+</span></span><br><span class="line"><span class="section">| personId | lastName | firstName |</span></span><br><span class="line"><span class="section">+----------+----------+-----------+</span></span><br><span class="line">| 1        | Wang     | Allen     |</span><br><span class="line"><span class="section">| 2        | Alice    | Bob       |</span></span><br><span class="line"><span class="section">+----------+----------+-----------+</span></span><br><span class="line"><span class="section">Address表:</span></span><br><span class="line"><span class="section">+-----------+----------+---------------+------------+</span></span><br><span class="line"><span class="section">| addressId | personId | city          | state      |</span></span><br><span class="line"><span class="section">+-----------+----------+---------------+------------+</span></span><br><span class="line">| 1         | 2        | New York City | New York   |</span><br><span class="line"><span class="section">| 2         | 3        | Leetcode      | California |</span></span><br><span class="line"><span class="section">+-----------+----------+---------------+------------+</span></span><br><span class="line"><span class="section">输出: </span></span><br><span class="line"><span class="section">+-----------+----------+---------------+----------+</span></span><br><span class="line"><span class="section">| firstName | lastName | city          | state    |</span></span><br><span class="line"><span class="section">+-----------+----------+---------------+----------+</span></span><br><span class="line">| Allen     | Wang     | Null          | Null     |</span><br><span class="line"><span class="section">| Bob       | Alice    | New York City | New York |</span></span><br><span class="line"><span class="section">+-----------+----------+---------------+----------+</span></span><br><span class="line">解释: </span><br><span class="line">地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。</span><br><span class="line">addressId = 1 包含了 personId = 2 的地址信息。</span><br></pre></td></tr></table></figure>



<h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select Person.firstName, Person.lastName, Address.city, Address.state </span><br><span class="line">from Person left join Address </span><br><span class="line">on Person.personId = Address.personId;</span><br></pre></td></tr></table></figure>





<h3 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode.cn/problems/customers-who-never-order/">183. 从不订购的客户</a></h3><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>-------+</span><br><span class="line"><span class="section">| Id | Name  |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line"><span class="section">| 4  | Max   |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br></pre></td></tr></table></figure>

<p><code>Orders</code> 表：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>------------+</span><br><span class="line"><span class="section">| Id | CustomerId |</span></span><br><span class="line"><span class="section">+----+------------+</span></span><br><span class="line">| 1  | 3          |</span><br><span class="line"><span class="section">| 2  | 1          |</span></span><br><span class="line"><span class="section">+----+------------+</span></span><br></pre></td></tr></table></figure>

<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-----------+</span></span><br><span class="line"><span class="section">| Customers |</span></span><br><span class="line"><span class="section">+-----------+</span></span><br><span class="line">| Henry     |</span><br><span class="line"><span class="section">| Max       |</span></span><br><span class="line"><span class="section">+-----------+</span></span><br></pre></td></tr></table></figure>



<h4 id="MySQL-2"><a href="#MySQL-2" class="headerlink" title="MySQL"></a>MySQL</h4><p><code>Customers as A left join Orders as B </code></p>
<img src="/2023/02/07/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E9%9B%86/image-20230207162541722.png" alt="image-20230207162541722" style="zoom: 33%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select A.Name as Customers </span><br><span class="line">from Customers as A left join Orders as B </span><br><span class="line">on A.Id = B.CustomerId </span><br><span class="line">where B.Id is null;</span><br></pre></td></tr></table></figure>





<h3 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h3><p>表: <code>Person</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line"><span class="section">| Column Name | Type    |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">| id          | int     |</span><br><span class="line"><span class="section">| email       | varchar |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">id是该表的主键列。</span><br><span class="line">该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL <strong>删除语句</strong>来 <strong>删除</strong> 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。 （<strong>注意</strong>： 仅需要写删除语句，将自动对剩余结果进行查询）</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"><span class="section">Person 表:</span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line"><span class="section">| id | email            |</span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line"><span class="section">| 3  | john@example.com |</span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line"><span class="section">输出: </span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line"><span class="section">| id | email            |</span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line">| 1  | john@example.com |</span><br><span class="line"><span class="section">| 2  | bob@example.com  |</span></span><br><span class="line"><span class="section">+----+------------------+</span></span><br><span class="line">解释: john@example.com重复两次。我们保留最小的Id = 1。</span><br></pre></td></tr></table></figure>



<h4 id="MySQL-3"><a href="#MySQL-3" class="headerlink" title="MySQL"></a>MySQL</h4><img src="/2023/02/07/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E9%9B%86/image-20230207164801646.png" alt="image-20230207164801646" style="zoom:50%;">

<p>自连接,就是做笛卡尔积</p>
<img src="/2023/02/07/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E9%9B%86/image-20230207164841000.png" alt="image-20230207164841000" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Please write a DELETE statement and DO NOT write a SELECT statement.</span><br><span class="line"># Write your MySQL query statement below</span><br><span class="line">delete P1 </span><br><span class="line">from Person as P1, Person as P2 </span><br><span class="line">where P1.email = P2.email and P1.id &gt; P2.id;</span><br></pre></td></tr></table></figure>





<h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode.cn/problems/second-highest-salary/">176. 第二高的薪水</a></h3><p><code>Employee</code> 表：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>------+</span><br><span class="line"><span class="section">| Column Name | Type |</span></span><br><span class="line"><span class="section">+-------------+------+</span></span><br><span class="line">| id          | int  |</span><br><span class="line"><span class="section">| salary      | int  |</span></span><br><span class="line"><span class="section">+-------------+------+</span></span><br><span class="line">id 是这个表的主键。</span><br><span class="line">表的每一行包含员工的工资信息。</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，获取并返回 <code>Employee</code> 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 <code>null</code> 。</p>
<p>查询结果如下例所示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="section">Employee 表：</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line"><span class="section">| id | salary |</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line"><span class="section">| 3  | 300    |</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line"><span class="section">输出：</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br><span class="line"><span class="section">| SecondHighestSalary |</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br><span class="line"><span class="section">| 200                 |</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="section">Employee 表：</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line"><span class="section">| id | salary |</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line"><span class="section">| 1  | 100    |</span></span><br><span class="line"><span class="section">+----+--------+</span></span><br><span class="line"><span class="section">输出：</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br><span class="line"><span class="section">| SecondHighestSalary |</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br><span class="line"><span class="section">| null                |</span></span><br><span class="line"><span class="section">+---------------------+</span></span><br></pre></td></tr></table></figure>



<h4 id="MySQL-4"><a href="#MySQL-4" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"># select() 是为了防止出现没有第二条数据的情况</span><br><span class="line">select </span><br><span class="line">(select distinct A.salary </span><br><span class="line">from Employee A </span><br><span class="line">order by salary desc </span><br><span class="line">limit 1 offset 1) as SecondHighestSalary ;</span><br></pre></td></tr></table></figure>





<h3 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode.cn/problems/rank-scores/">178. 分数排名</a></h3><p>表: <code>Scores</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line"><span class="section">| Column Name | Type    |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">| id          | int     |</span><br><span class="line"><span class="section">| score       | decimal |</span></span><br><span class="line"><span class="section">+-------------+---------+</span></span><br><span class="line">Id是该表的主键。</span><br><span class="line">该表的每一行都包含了一场比赛的分数。Score是一个有两位小数点的浮点值。</span><br></pre></td></tr></table></figure>

<p>编写 SQL 查询对分数进行排序。排名按以下规则计算:</p>
<ul>
<li>分数应按从高到低排列。</li>
<li>如果两个分数相等，那么两个分数的排名应该相同。</li>
<li>在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。</li>
</ul>
<p>按 <code>score</code> 降序返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"><span class="section">Scores 表:</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br><span class="line"><span class="section">| id | score |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line"><span class="section">| 6  | 3.65  |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br><span class="line"><span class="section">输出: </span></span><br><span class="line"><span class="section">+-------+------+</span></span><br><span class="line"><span class="section">| score | rank |</span></span><br><span class="line"><span class="section">+-------+------+</span></span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line"><span class="section">| 3.50  | 4    |</span></span><br><span class="line"><span class="section">+-------+------+</span></span><br></pre></td></tr></table></figure>



<h4 id="MySQL-5"><a href="#MySQL-5" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select A.score as score, </span><br><span class="line">(select count(distinct B.score) from Scores B where B.score &gt;= A.score) as &quot;rank&quot; # rank 是mysql关键字</span><br><span class="line">from Scores A </span><br><span class="line">order by A.score desc;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣第319场周赛</title>
    <url>/2022/12/10/%E5%8A%9B%E6%89%A3%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="2470-最小公倍数为-K-的子数组数目"><a href="#2470-最小公倍数为-K-的子数组数目" class="headerlink" title="2470. 最小公倍数为 K 的子数组数目"></a><a href="https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/">2470. 最小公倍数为 K 的子数组数目</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code></em> 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>
<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[3,6,2,7,1]</span>, k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：以 <span class="number">6</span> 为最小公倍数的子数组是：</span><br><span class="line">- <span class="string">[3,6,2,7,1]</span></span><br><span class="line">- <span class="string">[3,6,2,7,1]</span></span><br><span class="line">- <span class="string">[3,6,2,7,1]</span></span><br><span class="line">- <span class="string">[3,6,2,7,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [3], k = 2</span></span><br><span class="line"><span class="string">输出：0</span></span><br><span class="line"><span class="string">解释：不存在以 2 为最小公倍数的子数组。</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="最大公约数模板"><a href="#最大公约数模板" class="headerlink" title="最大公约数模板"></a>最大公约数模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b? <span class="built_in">gcd</span>(b, a% b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b? <span class="built_in">gcd</span>(b, a% b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarrayLCM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[i]; <span class="comment">// 最小公倍数， 一开始是自己</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                tmp = tmp * nums[j]/ <span class="built_in">gcd</span>(tmp, nums[j]); <span class="comment">// 最小公倍数 [a,b] =  a * b / (a,b) 最大公约数</span></span><br><span class="line">                <span class="keyword">if</span>(tmp == k) res ++;</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; k) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2471-逐层排序二叉树所需的最少操作数目"><a href="#2471-逐层排序二叉树所需的最少操作数目" class="headerlink" title="2471. 逐层排序二叉树所需的最少操作数目"></a><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/">2471. 逐层排序二叉树所需的最少操作数目</a></h3><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>
<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>
<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>
<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>
<p><strong>示例 1 ：</strong></p>
<p><img src="/2022/12/10/%E5%8A%9B%E6%89%A3%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20220918174006-2.png" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换<span class="number"> 4 </span>和<span class="number"> 3 </span>。第<span class="number"> 2 </span>层变为 [3,4] 。</span><br><span class="line">- 交换<span class="number"> 7 </span>和<span class="number"> 5 </span>。第<span class="number"> 3 </span>层变为 [5,6,8,7] 。</span><br><span class="line">- 交换<span class="number"> 8 </span>和<span class="number"> 7 </span>。第<span class="number"> 3 </span>层变为 [5,6,7,8] 。</span><br><span class="line">共计用了<span class="number"> 3 </span>步操作，所以返回<span class="number"> 3 </span>。</span><br><span class="line">可以证明<span class="number"> 3 </span>是需要的最少操作数目。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 105]</code> 。</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li>树中的所有值 <strong>互不相同</strong> 。</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><p>置换环：现在是两个环，若想要把原数组变成升序，则最少需要交换 （数组长度 - 环数） 次</p>
<p><img src="/2022/12/10/%E5%8A%9B%E6%89%A3%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20221210214414515.png" alt="image-20221210214414515"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x]!= x) v[x] = <span class="built_in">find</span>(v[x]);</span><br><span class="line">        <span class="keyword">return</span> v[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodes,ls; <span class="comment">// nodes存放所有层结点值, ls存放每层的节点数</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            ls.<span class="built_in">push_back</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i ++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                nodes.<span class="built_in">push_back</span>(t -&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t -&gt; left) q.<span class="built_in">push</span>(t -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt; right) q.<span class="built_in">push</span>(t -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos; <span class="comment">// pos[i]为 i 在每层未排序之前的的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            pos[nodes[i]] = i;</span><br><span class="line">            v.<span class="built_in">push_back</span>(i); <span class="comment">// 初始化并查集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> begin = nodes.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ls.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(begin, begin + ls[i]);</span><br><span class="line">            begin = begin + ls[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = nodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="comment">// 排序前[1, 4,3, 7,6,8,5, 9,10]  pos[4] = 1  v[1] = 1 </span></span><br><span class="line">            <span class="comment">// 排序后[1, 3,4, 5,6,7,8, 9,10]  </span></span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(i), b = <span class="built_in">find</span>(pos[nodes[i]]);  <span class="comment">// i是排序完的位置, pos[nodes[i]]是未排序的位置</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">                v[a] = b;</span><br><span class="line">                cnt -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes.<span class="built_in">size</span>() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2472-不重叠回文子字符串的最大数目"><a href="#2472-不重叠回文子字符串的最大数目" class="headerlink" title="2472. 不重叠回文子字符串的最大数目"></a><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">2472. 不重叠回文子字符串的最大数目</a></h3><p>给你一个字符串 <code>s</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>
<p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p>
<ul>
<li>每个子字符串的长度 <strong>至少</strong> 为 <code>k</code> 。</li>
<li>每个子字符串是一个 <strong>回文串</strong> 。</li>
</ul>
<p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p>
<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abaccdbbd&quot;</span>, <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以选择 <span class="attr">s</span> = <span class="string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="string">&quot;aba&quot;</span> 和 <span class="string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="attr">k</span> = <span class="number">3</span> 。</span><br><span class="line">可以证明，无法选出两个以上的有效子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;adbcda&quot;</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串中不存在长度至少为 <span class="number">2</span> 的回文子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPalindromes</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ ) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == s[j - <span class="number">1</span>] &amp;&amp; (len &lt;= <span class="number">2</span> || g[i + <span class="number">1</span>][j - <span class="number">1</span>]))</span><br><span class="line">                    g[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// g[i][j] = true 表示的是原数组第i个到第j个字符组成回文子串;  区别于下标i,j</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - k; j &gt;= <span class="number">0</span>; j -- ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[j + <span class="number">1</span>][i]) &#123;</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣第322场周赛</title>
    <url>/2022/12/09/%E5%8A%9B%E6%89%A3%E7%AC%AC322%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="2490-回环句"><a href="#2490-回环句" class="headerlink" title="2490. 回环句"></a><a href="https://leetcode.cn/problems/circular-sentence/">2490. 回环句</a></h3><p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>
<ul>
<li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code>、<code>&quot;hello world hello world&quot;</code> 都是符合要求的句子。</li>
</ul>
<p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>
<p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p>
<ul>
<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>
<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>
</ul>
<p>例如，<code>&quot;leetcode exercises sound delightful&quot;</code>、<code>&quot;eetcode&quot;</code>、<code>&quot;leetcode eats soul&quot;</code> 都是回环句。然而，<code>&quot;Leetcode is cool&quot;</code>、<code>&quot;happy Leetcode&quot;</code>、<code>&quot;Leetcode&quot;</code> 和 <code>&quot;I like Leetcode&quot;</code> 都 <strong>不</strong> 是回环句。</p>
<p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">&quot;leetcode exercises sound delightful&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：句子中的单词是 [<span class="string">&quot;leetcode&quot;</span>, <span class="string">&quot;exercises&quot;</span>, <span class="string">&quot;sound&quot;</span>, <span class="string">&quot;delightful&quot;</span>] 。</span><br><span class="line">- leetcode 的最后一个字符和 exercises 的第一个字符相等。</span><br><span class="line">- exercises 的最后一个字符和 sound 的第一个字符相等。</span><br><span class="line">- sound 的最后一个字符和 delightful 的第一个字符相等。</span><br><span class="line">- delightful 的最后一个字符和 leetcode 的第一个字符相等。</span><br><span class="line">这个句子是回环句。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">&quot;eetcode&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：句子中的单词是 [<span class="string">&quot;eetcode&quot;</span>] 。</span><br><span class="line">- eetcode 的最后一个字符和 eetcode 的第一个字符相等。</span><br><span class="line">这个句子是回环句。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= sentence.length &lt;= 500</code></li>
<li><code>sentence</code> 仅由大小写英文字母和空格组成</li>
<li><code>sentence</code> 中的单词由单个空格进行分隔</li>
<li>不含任何前导或尾随空格</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCircularSentence</span><span class="params">(string sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(sentence)</span></span>; <span class="comment">// 记住 stringstream ssin(sentence);</span></span><br><span class="line">        string str;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        <span class="keyword">while</span>(ssin &gt;&gt; str) strs.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].<span class="built_in">back</span>() != strs[(i + <span class="number">1</span>)%strs.<span class="built_in">size</span>()][<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2491-划分技能点相等的团队"><a href="#2491-划分技能点相等的团队" class="headerlink" title="2491. 划分技能点相等的团队"></a><a href="https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/">2491. 划分技能点相等的团队</a></h3><p>给你一个正整数数组 <code>skill</code> ，数组长度为 <strong>偶数</strong> <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 <strong>相等</strong> 。</p>
<p>团队的 <strong>化学反应</strong> 等于团队中玩家的技能点 <strong>乘积</strong> 。</p>
<p>返回所有团队的 <strong>化学反应</strong> 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：skill = [3,2,5,1,3,4]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">将玩家分成<span class="number"> 3 </span>个团队 (1, 5), (2, 4), (3, 3) ，每个团队的技能点之和都是<span class="number"> 6 </span>。</span><br><span class="line">所有团队的化学反应之和是<span class="number"> 1 </span>*<span class="number"> 5 </span>+<span class="number"> 2 </span>*<span class="number"> 4 </span>+<span class="number"> 3 </span>*<span class="number"> 3 </span>=<span class="number"> 5 </span>+<span class="number"> 8 </span>+<span class="number"> 9 </span>=<span class="number"> 22 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：skill = [3,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">两个玩家形成一个团队，技能点之和是<span class="number"> 7 </span>。</span><br><span class="line">团队的化学反应是<span class="number"> 3 </span>*<span class="number"> 4 </span>=<span class="number"> 12 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：skill = [<span class="number">1,1,2,3</span>]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">无法将玩家分成每个团队技能点都相等的若干个 <span class="number">2</span> 人团队。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= skill.length &lt;= 105</code></li>
<li><code>skill.length</code> 是偶数</li>
<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dividePlayers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; skill)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> elem: skill) Sum += elem;</span><br><span class="line">        <span class="type">int</span> teamNum = skill.<span class="built_in">size</span>()/ <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(Sum % teamNum) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> sum = Sum/ teamNum;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> elem: skill)&#123;</span><br><span class="line">            <span class="type">int</span> temp = sum - elem;</span><br><span class="line">            <span class="keyword">if</span>(mp[temp])&#123;</span><br><span class="line">                res += temp* elem;</span><br><span class="line">                mp[temp] --;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> mp[elem] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem: mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(elem.second) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2492-两个城市间路径的最小分数"><a href="#2492-两个城市间路径的最小分数" class="headerlink" title="2492. 两个城市间路径的最小分数"></a><a href="https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/">2492. 两个城市间路径的最小分数</a></h3><p>给你一个正整数 <code>n</code> ，表示总共有 <code>n</code> 个城市，城市从 <code>1</code> 到 <code>n</code> 编号。给你一个二维数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi, distancei]</code> 表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>双向</strong> 道路，道路距离为 <code>distancei</code> 。城市构成的图不一定是连通的。</p>
<p>两个城市之间一条路径的 <strong>分数</strong> 定义为这条路径中道路的 <strong>最小</strong> 距离。</p>
<p>城市 <code>1</code> 和城市 <code>n</code> 之间的所有路径的 <strong>最小</strong> 分数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一条路径指的是两个城市之间的道路序列。</li>
<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code> 和城市 <code>n</code> 。</li>
<li>测试数据保证城市 <code>1</code> 和城市<code>n</code> 之间 <strong>至少</strong> 有一条路径。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/09/%E5%8A%9B%E6%89%A3%E7%AC%AC322%E5%9C%BA%E5%91%A8%E8%B5%9B/graph11.png" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, roads = <span class="string">[[1,2,9],[2,3,6],[2,4,5],[1,4,7]]</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：城市 <span class="number">1</span> 到城市 <span class="number">4</span> 的路径中，分数最小的一条为：<span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> 。这条路径的分数是 <span class="built_in">min</span>(<span class="number">9</span>,<span class="number">5</span>) = <span class="number">5</span> 。</span><br><span class="line">不存在分数更小的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/12/09/%E5%8A%9B%E6%89%A3%E7%AC%AC322%E5%9C%BA%E5%91%A8%E8%B5%9B/graph22.png" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]</span><br><span class="line">输出：2</span><br><span class="line">解释：城市<span class="number"> 1 </span>到城市<span class="number"> 4 </span>分数最小的路径是：1 -&gt;<span class="number"> 2 </span>-&gt;<span class="number"> 1 </span>-&gt;<span class="number"> 3 </span>-&gt;<span class="number"> 4 </span>。这条路径的分数是 min(2,2,4,7) =<span class="number"> 2 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= roads.length &lt;= 105</code></li>
<li><code>roads[i].length == 3</code></li>
<li><code>1 &lt;= ai, bi &lt;= n</code></li>
<li><code>ai != bi</code></li>
<li><code>1 &lt;= distancei &lt;= 104</code></li>
<li>不会有重复的边。</li>
<li>城市 <code>1</code> 和城市 <code>n</code> 之间至少有一条路径。</li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++<img src="/2022/12/09/%E5%8A%9B%E6%89%A3%E7%AC%AC322%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20221209171206770.png" alt="image-20221209171206770"></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="comment">// merge合并两个集合；(“并”）</span></span><br><span class="line"><span class="comment">// find判断两个元素是否属于同一个集合．（“查”）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//查看x的根节点 -&gt; x所属集合</span></span><br><span class="line">        <span class="keyword">if</span> (v[x] != x) v[x] = <span class="built_in">find</span>(v[x]);</span><br><span class="line">        <span class="keyword">return</span> v[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScore</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>, <span class="number">1e8</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) v[i] = i; <span class="comment">// 初始化并查集，每个节点的根结点都是自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: roads) &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(edge[<span class="number">0</span>]), b = <span class="built_in">find</span>(edge[<span class="number">1</span>]), c = edge[<span class="number">2</span>];<span class="comment">// a为边起始点的根节点 b为边结束点的根节点 c为权值</span></span><br><span class="line">            w[a] = <span class="built_in">min</span>(&#123;w[a], w[b], c&#125;);</span><br><span class="line">            v[b] = a; <span class="comment">// 并</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w[<span class="built_in">find</span>(<span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣第92场双周赛</title>
    <url>/2022/12/10/%E5%8A%9B%E6%89%A3%E7%AC%AC92%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="2482-行和列中一和零的差值"><a href="#2482-行和列中一和零的差值" class="headerlink" title="2482. 行和列中一和零的差值"></a><a href="https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/">2482. 行和列中一和零的差值</a></h3><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 二进制矩阵 <code>grid</code> 。</p>
<p>我们按照如下过程，定义一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 差值矩阵 <code>diff</code> ：</p>
<ul>
<li>令第 <code>i</code> 行一的数目为 <code>onesRowi</code> 。</li>
<li>令第 <code>j</code> 列一的数目为 <code>onesColj</code> 。</li>
<li>令第 <code>i</code> 行零的数目为 <code>zerosRowi</code> 。</li>
<li>令第 <code>j</code> 列零的数目为 <code>zerosColj</code> 。</li>
<li><code>diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj</code></li>
</ul>
<p>请你返回差值矩阵 <code>diff</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/10/%E5%8A%9B%E6%89%A3%E7%AC%AC92%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/image-20221106171747-6.png" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,1],[1,1,1]]</span><br><span class="line">输出：[[5,5,5],[5,5,5]]</span><br><span class="line">解释：</span><br><span class="line">- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br><span class="line">- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br><span class="line">- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br><span class="line">- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br><span class="line">- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br><span class="line">- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 =<span class="number"> 3 </span>+<span class="number"> 2 </span>-<span class="number"> 0 </span>-<span class="number"> 0 </span>= 5</span><br></pre></td></tr></table></figure>

<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">onesMinusZeros</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r1</span><span class="params">(m)</span>, <span class="title">r0</span><span class="params">(m)</span>, <span class="title">c0</span><span class="params">(n)</span>, <span class="title">c1</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]) &#123;</span><br><span class="line">                    r1[i] ++;</span><br><span class="line">                    c1[j] ++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    r0[i] ++;</span><br><span class="line">                    c0[j] ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = grid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                res[i][j] = r1[i] + c1[j] - r0[i] - c0[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2483-商店的最少代价"><a href="#2483-商店的最少代价" class="headerlink" title="2483. 商店的最少代价"></a><a href="https://leetcode.cn/problems/minimum-penalty-for-a-shop/">2483. 商店的最少代价</a></h3><p>给你一个顾客访问商店的日志，用一个下标从 <strong>0</strong> 开始且只包含字符 <code>&#39;N&#39;</code> 和 <code>&#39;Y&#39;</code> 的字符串 <code>customers</code> 表示：</p>
<ul>
<li>如果第 <code>i</code> 个字符是 <code>&#39;Y&#39;</code> ，它表示第 <code>i</code> 小时有顾客到达。</li>
<li>如果第 <code>i</code> 个字符是 <code>&#39;N&#39;</code> ，它表示第 <code>i</code> 小时没有顾客到达。</li>
</ul>
<p>如果商店在第 <code>j</code> 小时关门（<code>0 &lt;= j &lt;= n</code>），代价按如下方式计算：</p>
<ul>
<li>在开门期间，如果某一个小时没有顾客到达，代价增加 <code>1</code> 。</li>
<li>在关门期间，如果某一个小时有顾客到达，代价增加 <code>1</code> 。</li>
</ul>
<p>请你返回在确保代价 <strong>最小</strong> 的前提下，商店的 <strong>最早</strong> 关门时间。</p>
<p>注意，商店在第 <code>j</code> 小时关门表示在第 <code>j</code> 小时以及之后商店处于关门状态。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：customers = &quot;YYNY&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第 0 小时关门，总共 1<span class="string">+1</span><span class="string">+0</span><span class="string">+1</span> = 3 代价。</span><br><span class="line">- 第 1 小时关门，总共 0<span class="string">+1</span><span class="string">+0</span><span class="string">+1</span> = 2 代价。</span><br><span class="line">- 第 2 小时关门，总共 0<span class="string">+0</span><span class="string">+0</span><span class="string">+1</span> = 1 代价。</span><br><span class="line">- 第 3 小时关门，总共 0<span class="string">+0</span><span class="string">+1</span><span class="string">+1</span> = 2 代价。</span><br><span class="line">- 第 4 小时关门，总共 0<span class="string">+0</span><span class="string">+1</span><span class="string">+0</span> = 1 代价。</span><br><span class="line">在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：customers <span class="operator">=</span> <span class="string">&quot;NNNNN&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优关门时间是 <span class="number">0</span> ，因为自始至终没有顾客到达。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：customers <span class="operator">=</span> <span class="string">&quot;YYYY&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最优关门时间是 <span class="number">4</span> ，因为每一小时均有顾客到达。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= customers.length &lt;= 105</code></li>
<li><code>customers</code> 只包含字符 <code>&#39;Y&#39;</code> 和 <code>&#39;N&#39;</code> 。</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也就是计算：前(包括自己)0 + 后1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bestClosingTime</span><span class="params">(string customers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// v[i] 表示第i个小时前（包括这个小时）1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(customers[i - <span class="number">1</span>] == <span class="string">&#x27;Y&#x27;</span>) v[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cost = <span class="number">1e8</span>; <span class="comment">// 代价</span></span><br><span class="line">        <span class="type">int</span> res; <span class="comment">// 返回的时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = i - v[i] + v[n] - v[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= cost)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                cost = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针合集</title>
    <url>/2023/02/15/%E5%8F%8C%E6%8C%87%E9%92%88%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1,0,3,10</span>]</span><br><span class="line">输出：[<span class="number">0,1,9,16</span>,<span class="number">100</span>]</span><br><span class="line">解释：平方后，数组变为 [<span class="number">16,1,0,9</span>,<span class="number">100</span>]</span><br><span class="line">排序后，数组变为 [<span class="number">0,1,9,16</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">7</span>,-<span class="number">3,2,3,11</span>]</span><br><span class="line">输出：[<span class="number">4,9,9,49</span>,<span class="number">121</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, idx = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[l])&gt; <span class="built_in">abs</span>(nums[r])) res[idx--] = nums[l] * nums[l ++];</span><br><span class="line">            <span class="keyword">else</span> res[idx--] = nums[r] * nums[r --];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右两个指针l和r，起始位置分别在0和n - 1</span></span><br><span class="line"><span class="comment">如果nums[l] * nums[l] &gt; nums[r] * nums[r], 则左指针向右移动</span></span><br><span class="line"><span class="comment">否则，右指针向左移动</span></span><br><span class="line"><span class="comment">左右指针谁移动，就把谁的平方的结果从右向左放入res数组中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯之组合总和合集</title>
    <url>/2022/11/22/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="递归、回溯、DFS的区别"><a href="#递归、回溯、DFS的区别" class="headerlink" title="递归、回溯、DFS的区别"></a>递归、回溯、DFS的区别</h3><p>递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想</p>
<ol>
<li><p>在函数中调用函数本身来解决子问题以达到解决原问题的方法就叫递归</p>
<blockquote>
<p>  对于一个可以分解的问题，子问题与原问题处理过程完全相同，区别只在于数据规模，可以用递归来解</p>
</blockquote>
</li>
<li><p>回溯就是通过不同的尝试来搜索问题的解</p>
<blockquote>
<p>  有点类似于穷举（搜索全部解空间），但是和穷举不同的是回溯会“剪枝”，对已经知道错误的结果没必要再枚举接下来的答案了</p>
</blockquote>
</li>
<li><p>回溯搜索是深度优先搜索（DFS）的一种情况</p>
<blockquote>
<p>  对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构（剪枝），而深度优先搜索则记下完整的搜索树</p>
<p>  在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了</p>
</blockquote>
</li>
</ol>
<h3 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        收集结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (该节点的所有子节点)&#123;</span><br><span class="line">        处理结点;</span><br><span class="line">        递归函数;</span><br><span class="line">        回溯操作（比如 收集结果<span class="number">12</span> 撤销<span class="number">2</span>,收集结果<span class="number">13</span> 撤销<span class="number">3</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和<span class="number"> 3 </span>可以形成一组候选，2 +<span class="number"> 2 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。注意<span class="number"> 2 </span>可以使用多次。</span><br><span class="line">7 也是一个候选，<span class="number"> 7 </span>=<span class="number"> 7 </span>。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,3,5]</span>, target = 8</span><br><span class="line">输出: <span class="comment">[<span class="comment">[2,2,2,2]</span>,<span class="comment">[2,3,3]</span>,<span class="comment">[3,5]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2]</span>, target = 1</span><br><span class="line">输出: <span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>回溯无剪枝</li>
</ul>
<img src="/2022/11/22/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%90%88%E9%9B%86/image-20221124221507614.png" alt="image-20221124221507614" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i); <span class="comment">// 不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯有剪枝</li>
</ul>
<p>上面的版本一的代码可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p>
<p>其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。</p>
<p>那么可以在for循环的搜索范围上做做文章了。</p>
<p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<img src="/2022/11/22/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%90%88%E9%9B%86/image-20221124221531136.png" alt="image-20221124221531136" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他思路</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路二：正确, 每个idx都有选或者不选两种情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, candidates, target, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx,vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.<span class="built_in">size</span>() || target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>, candidates, target, path); <span class="comment">// 要在前, 因为跳过的话, target不能减少</span></span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">        <span class="built_in">dfs</span>(idx, candidates, target - candidates[idx], path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误版本:把它想成了根节点为0的四叉树</span></span><br><span class="line"><span class="comment">// 输入 [2,3,6,7] 7</span></span><br><span class="line"><span class="comment">// 输出 [[0,2,2,3],[0,2,3,2],[0,3,2,2],[0,7]]</span></span><br><span class="line"><span class="comment">// 预期结果 [[2,2,3],[7]]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, candidates, target, path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : st)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) st.<span class="built_in">insert</span>(path);</span><br><span class="line">        target = target - cur;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : candidates)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(elem, candidates, target, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h3><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,1,6]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,5]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,7]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[2,6]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,5,2,1,2]</span>, target = 5,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">避免重复思想：</span><br><span class="line">这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即</span><br><span class="line">                  1</span><br><span class="line">                 / \</span><br><span class="line">               <span class="number"> 2 </span> <span class="number"> 2 </span> 这种情况不会发生 但是却允许了不同层级之间的重复即：</span><br><span class="line">               /     \</span><br><span class="line">             <span class="number"> 5 </span>      5</span><br><span class="line">                例2</span><br><span class="line">                  1</span><br><span class="line">                 /</span><br><span class="line">               <span class="number"> 2 </span>     这种情况确是允许的</span><br><span class="line">               /</span><br><span class="line">             <span class="number"> 2 </span> </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i <span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 见上图</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,4]</span>,</span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIdx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIdx; i &lt;= n; i ++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[]</span>,<span class="comment">[1]</span>,<span class="comment">[2]</span>,<span class="comment">[1,2]</span>,<span class="comment">[3]</span>,<span class="comment">[1,3]</span>,<span class="comment">[2,3]</span>,<span class="comment">[1,2,3]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path = &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); i ++)&#123; <span class="comment">// 分别将长度为0， 1， 2，... 的子集求出</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIdx, <span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == cnt)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIdx; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);    </span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, cnt);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,2]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[]</span>,<span class="comment">[1]</span>,<span class="comment">[1,2]</span>,<span class="comment">[1,2,2]</span>,<span class="comment">[2]</span>,<span class="comment">[2,2]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path = &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 必须要排序，不然 nums[i] == nums[i - 1] 不起效果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIdx, <span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == cnt)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIdx; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIdx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);    </span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, cnt);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h3><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p>
<p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a1b2&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;a1b2&quot;</span>, <span class="string">&quot;a1B2&quot;</span>, <span class="string">&quot;A1b2&quot;</span>, <span class="string">&quot;A1B2&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;3z4&quot;</span></span><br><span class="line">输出: [<span class="string">&quot;3z4&quot;</span>,<span class="string">&quot;3Z4&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 12</code></li>
<li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[i] = s[i] ^ <span class="number">32</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(s,i+<span class="number">1</span>);</span><br><span class="line">                s[i] = s[i] ^ <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂&amp;快速乘合集</title>
    <url>/2022/12/04/%E5%BF%AB%E9%80%9F%E5%B9%82&amp;%E5%BF%AB%E9%80%9F%E4%B9%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1024.00000</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">2.10000</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9.26100</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = -<span class="number">2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：<span class="number">2</span>-<span class="number">2</span> = <span class="number">1</span><span class="regexp">/22 = 1/</span><span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/12/04/%E5%BF%AB%E9%80%9F%E5%B9%82&%E5%BF%AB%E9%80%9F%E4%B9%98%E5%90%88%E9%9B%86/image-20221204164815393.png" alt="image-20221204164815393"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  n &lt; <span class="number">0</span> ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a href="https://leetcode.cn/problems/divide-two-integers/">29. 两数相除</a></h3><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: dividend = 10, divisor = 3</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入: dividend = 7, divisor = <span class="string">-3</span></span><br><span class="line">输出: <span class="string">-2</span></span><br><span class="line">解释: 7/<span class="string">-3</span> = truncate(<span class="string">-2</span>.33333..) = <span class="string">-2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> a = <span class="built_in">abs</span>(dividend);</span><br><span class="line">        <span class="type">long</span> b = <span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &gt;= b)&#123;</span><br><span class="line">            <span class="type">long</span> step = <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> temp = b;</span><br><span class="line">            <span class="keyword">while</span>(a &gt;= temp)&#123; </span><br><span class="line">                a -= temp;</span><br><span class="line">                res += step;</span><br><span class="line">                temp = temp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                step = step &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) || (divisor &lt; <span class="number">0</span> &amp;&amp; dividend &gt; <span class="number">0</span>)) <span class="keyword">return</span> (<span class="number">0</span> - res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(res) &gt; INT_MAX ? INT_MAX : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>括号合集</title>
    <url>/2022/10/09/%E6%8B%AC%E5%8F%B7%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><a href="https://leetcode.cn/problems/score-of-parentheses/">856. 括号的分数</a></h3><p>给定一个平衡括号字符串 <code>S</code>，按下述规则计算该字符串的分数：</p>
<ul>
<li><code>()</code> 得 1 分。</li>
<li><code>AB</code> 得 <code>A + B</code> 分，其中 A 和 B 是平衡括号字符串。</li>
<li><code>(A)</code> 得 <code>2 * A</code> 分，其中 A 是平衡括号字符串。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">&quot;()&quot;</span></span><br><span class="line">输出： <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">&quot;(())&quot;</span></span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">输入： &quot;()()&quot;</span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">输入： &quot;(()(()))&quot;</span><br><span class="line">输出： <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>S</code> 是平衡括号字符串，且只含有 <code>(</code> 和 <code>)</code> 。</li>
<li><code>2 &lt;= S.length &lt;= 50</code></li>
</ol>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>DFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// int res = 0; 要将res 写在函数内部，因为每次从‘（’开始这轮迭代时，内层结果都从0开始累加</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[++i] == <span class="string">&#x27;)&#x27;</span>) res += <span class="number">1</span>;  <span class="comment">// ++i 跳过当前 ‘（’</span></span><br><span class="line">            <span class="keyword">else</span> res += <span class="number">2</span> * <span class="built_in">dfs</span>(s);</span><br><span class="line">            ++i; <span class="comment">// ++i 跳过当前 ’）‘或 ’（‘</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>只找最里层的（）</li>
</ul>
<p>我们通过观察发现，() 是唯一贡献分数的结构，外括号只是为该结构添加了一些乘数。所以我们只需要关心 ()。</p>
<p>我们用 dd 维护当前括号的深度，对于每个 (，我们将深度加一，对于每个 )，我们将深度减一。当我们遇到 () 时，我们将 <code>2^d</code>加到答案中。</p>
<p>我们举个实际的例子，以 (()(())) 为例，我们首先找到内部两个闭合括号 ()，然后将分数加上对应的 <code>2^d</code>。实际上，我们是在计算 (()) + ((())) 的分数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">( ( ) ( ( ) ) )</span><br><span class="line">  ^ ^   ^ ^</span><br><span class="line"></span><br><span class="line">( ( ) ) + ( ( ( ) ) )</span><br><span class="line">  ^ ^         ^ ^ </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --d;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    ans += <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：lcbin</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/score-of-parentheses/solution/by-lcbin-b9st/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>





<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;()&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(res, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; res, string path,<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> n)</span></span>&#123; <span class="comment">// l为左括号数， r为右括号数</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; r  || l &gt; n || r &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == n) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">dfs</span>(res, path + <span class="string">&#x27;(&#x27;</span>, l + <span class="number">1</span>, r ,n); <span class="comment">// 试试（</span></span><br><span class="line">        <span class="built_in">dfs</span>(res, path + <span class="string">&#x27;)&#x27;</span>, l, r + <span class="number">1</span>, n); <span class="comment">// 试试 ）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;(()&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;)()())&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有效的括号满足 1. 开头是左括号 &amp;&amp; 左括号数 &gt;= 右括号数  2.当左括号数 == 右括号数时,统计长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">1</span>; L &lt; n - i; L ++)&#123;</span><br><span class="line">                s[i + L] == <span class="string">&#x27;(&#x27;</span> ? l ++ : r ++;</span><br><span class="line">                <span class="keyword">if</span>(l &lt; r) <span class="keyword">break</span>; <span class="comment">// break语句只能跳出当前所在的最内层循环</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l == r) res = <span class="built_in">max</span>(res, L + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>数学题合集</title>
    <url>/2022/11/22/%E6%95%B0%E5%AD%A6%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode.cn/problems/zigzag-conversion/">6. Z 字形变换</a></h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">P</span>   <span class="selector-tag">A</span>   H   N</span><br><span class="line"><span class="selector-tag">A</span> <span class="selector-tag">P</span> L S <span class="selector-tag">I</span> <span class="selector-tag">I</span> G</span><br><span class="line">Y   <span class="selector-tag">I</span>   R</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">int</span> numRows</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;PAYPALISHIRING&quot;</span>, <span class="attr">numRows</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="string">&quot;PAHNAPLSIIGYIR&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">输入：<span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;PAYPALISHIRING&quot;</span><span class="operator">,</span> <span class="variable">numRows</span> <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">解释：</span><br><span class="line"><span class="variable">P</span>     <span class="built_in">I</span>    <span class="built_in">N</span></span><br><span class="line"><span class="variable">A</span>   <span class="variable">L</span> <span class="variable">S</span>  <span class="built_in">I</span> <span class="variable">G</span></span><br><span class="line"><span class="variable">Y</span> <span class="variable">A</span>   <span class="variable">H</span> <span class="variable">R</span></span><br><span class="line"><span class="variable">P</span>     <span class="built_in">I</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;A&quot;</span>, <span class="attr">numRows</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
<li><code>1 &lt;= numRows &lt;= 1000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找规律</span></span><br><span class="line"><span class="comment">4行的:</span></span><br><span class="line"><span class="comment">0     6      12        18</span></span><br><span class="line"><span class="comment">1   5 7   11 13    17</span></span><br><span class="line"><span class="comment">2 4   8 10   14 16</span></span><br><span class="line"><span class="comment">3     9      15</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于n行的, s中的第i个字符,对余数进行判断:</span></span><br><span class="line"><span class="comment">i%(2n-2) == 0 ----&gt; row0</span></span><br><span class="line"><span class="comment">i%(2n-2) == 1 or 2n-2-1 ----&gt; row1</span></span><br><span class="line"><span class="comment">i%(2n-2) == 2 or 2n-2-2 ----&gt; row2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">i%(2n-2) == n-1 ----&gt; row(n-1)</span></span><br><span class="line"><span class="comment">==&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对 k = i%(2n-2)进行判断:</span></span><br><span class="line"><span class="comment">k&lt;=n-1时候，s[i]就属于第k行</span></span><br><span class="line"><span class="comment">k&gt;n-1时候，s[i]就属于2n-2-k行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后将rows拼接起来就行了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> k = i%(<span class="number">2</span>*numRows - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= numRows - <span class="number">1</span>)&#123;</span><br><span class="line">                rows[k] += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> rows[<span class="number">2</span>*numRows - <span class="number">2</span>- k] += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : rows)&#123;</span><br><span class="line">            res += elem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转</a></h3><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：x <span class="operator">=</span> <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="string">-123</span></span><br><span class="line">输出：<span class="string">-321</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：x <span class="operator">=</span> <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：x <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) res += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp = x % <span class="number">10</span>;</span><br><span class="line">            res += <span class="built_in">to_string</span>(<span class="built_in">abs</span>(temp));</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stol</span>(res) &gt; INT_MAX || <span class="built_in">stol</span>(res) &lt;INT_MIN ? <span class="number">0</span> : <span class="built_in">stol</span>(res); <span class="comment">// string -&gt; long</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/22/%E6%95%B0%E5%AD%A6%E9%A2%98%E5%90%88%E9%9B%86/question_11.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><ul>
<li>我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, (r - l) * <span class="built_in">min</span>(height[l], height[r]));</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt;= height[r]) l ++;</span><br><span class="line">            <span class="keyword">else</span> r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出: [<span class="number">24,12,8,6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[-1,1,0,-3,3]</span></span><br><span class="line">输出: <span class="comment">[0,0,9,0,0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;     <span class="comment">//left：左边累乘积，right：右边累乘积</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)    <span class="comment">//最终每个元素其左右乘积进行相乘得出结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[i] *= left;       <span class="comment">//乘以其左边的乘积</span></span><br><span class="line">            left *= nums[i];</span><br><span class="line">            </span><br><span class="line">            res[n - <span class="number">1</span> - i] *= right;  <span class="comment">//乘以其右边的乘积 取n - 1, n - 2, ..., 2, 1, 0</span></span><br><span class="line">            right *= nums[n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 单行注释</span><br><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">/*多行注释*/</span></span><br></pre></td></tr></table></figure>



<h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><ul>
<li><p>查看已有的数据库（文件夹）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库（文件夹）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database gx_day14 <span class="keyword">DEFAULT</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库（文件夹）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database gx_day14;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入数据库（进入文件夹）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use gx_day14;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件夹下所有的数据表（文件）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据表的管理"><a href="#数据表的管理" class="headerlink" title="数据表的管理"></a>数据表的管理</h4><ul>
<li><p>进入数据库（进入文件夹）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use gx_day14;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前数据库下的所有 表（文件）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表（文件文件）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	列名称 类型,</span><br><span class="line">    列名称 类型,</span><br><span class="line">    列名称 类型</span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20211123140828409.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span>, </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span>, </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span>,   <span class="comment">-- 不允许为空</span></span><br><span class="line">    age <span class="type">int</span> <span class="keyword">null</span>                 <span class="comment">-- 允许为空（默认）</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span>, </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">default</span> <span class="number">3</span>        <span class="comment">-- 插入数据时，age列的值默认3</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,     <span class="comment">-- 主键（不允许为空，不允许重复）</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>主键一般用于表示当前行的数据的编号（类似于人的身份证）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key, <span class="comment">-- 内部维护，自增</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>一般情况下，我们再创建表时都会这样来写：【标准】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb1(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> tb1;</span><br><span class="line"># <span class="keyword">desc</span> <span class="operator">+</span>表名用来显示表的状态，包括列名（<span class="keyword">column</span> name），</span><br><span class="line"># 各个列的类型（Type），各个列的值类型，主外键（Key），默认值，其他；示例如下：</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">16</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h5><ul>
<li><p>tinyint</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">有符号，取值范围：<span class="number">-128</span> ～ <span class="number">127</span> (有正有负)【默认】</span><br><span class="line">无符号，取值范围：<span class="number">0</span> ～ <span class="number">255</span>（只有正）</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb2(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    age tinyint   <span class="comment">-- 有符号：取值范围：-128 ～ 127</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb3(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    age tinyint unsigned <span class="comment">-- 无符号：取值范围：0 ～ 255</span></span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>int</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>				表示有符号，取值范围：<span class="number">-2147483648</span> ～ <span class="number">2147483647</span></span><br><span class="line"><span class="type">int</span> unsigned	表示无符号，取值范围：<span class="number">0</span> ～ <span class="number">4294967295</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bigint</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">有符号，取值范围：<span class="number">-9223372036854775808</span> ～ <span class="number">9223372036854775807</span></span><br><span class="line">无符号，取值范围：<span class="number">0</span>  ～  <span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure>

<p>练习题：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb2(</span><br><span class="line">    id <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    salary <span class="type">int</span>,</span><br><span class="line">    age tinyint</span><br><span class="line">) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">10000</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">20000</span>,<span class="number">28</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">30000</span>,<span class="number">38</span>),(<span class="number">40000</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"># 查看表中的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb2;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_gx_day14 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> tb1                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> tb2(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     id <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     salary <span class="type">int</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     age tinyint</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_gx_day14 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> tb1                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb2                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">10000</span>,<span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">20000</span>,<span class="number">28</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb2(salary,age) <span class="keyword">values</span>(<span class="number">30000</span>,<span class="number">38</span>),(<span class="number">40000</span>,<span class="number">40</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> salary <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="number">10000</span> <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>  <span class="number">20000</span> <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>  <span class="number">30000</span> <span class="operator">|</span>   <span class="number">38</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>  <span class="number">40000</span> <span class="operator">|</span>   <span class="number">40</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>float</p>
</li>
<li><p>double</p>
</li>
<li><p>decimal</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为<span class="number">65</span>，d最大值为<span class="number">30</span>。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb3(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	salary <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb3(salary) <span class="keyword">values</span>(<span class="number">1.28</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb3(salary) <span class="keyword">values</span>(<span class="number">5.289</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb3(salary) <span class="keyword">values</span>(<span class="number">5.282</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb3(salary) <span class="keyword">values</span>(<span class="number">122115.11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>char(m)，速度快。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">定长字符串，m代表字符串的长度，最多可容纳<span class="number">255</span>个字符。</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">11</span>)，固定用<span class="number">11</span>个字符串进行存储，哪怕真是没有<span class="number">11</span>个字符，也会按照<span class="number">11</span>存储。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb4(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	mobile <span class="type">char</span>(<span class="number">11</span>)</span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb4(mobile) <span class="keyword">values</span>(&quot;151&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb4(mobile) <span class="keyword">values</span>(&quot;15131255555&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>varchar(m)，节省空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">变长字符串，m代表字符的长度。   最大<span class="number">65535</span>字节<span class="operator">/</span><span class="number">3</span> <span class="operator">=</span> 最大的m</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">11</span>)，真实数据有多少长久按照多长存储。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb5(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	mobile <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb5(mobile) <span class="keyword">values</span>(&quot;151&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb5(mobile) <span class="keyword">values</span>(&quot;15131255555&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>text</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">text数据类型用于保存变长的大字符串，可以组多到<span class="number">65535</span> (<span class="number">2</span><span class="operator">*</span><span class="operator">*</span><span class="number">16</span> − <span class="number">1</span>)个字符。</span><br><span class="line"></span><br><span class="line">一般情况下，长文本会用text类型。例如：文章、新闻等。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb6(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  title <span class="type">varchar</span>(<span class="number">128</span>),</span><br><span class="line">	content text</span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mediumtext</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A TEXT <span class="keyword">column</span> <span class="keyword">with</span> a maximum length <span class="keyword">of</span> <span class="number">16</span>,<span class="number">777</span>,<span class="number">215</span> (<span class="number">2</span><span class="operator">*</span><span class="operator">*</span><span class="number">24</span> − <span class="number">1</span>) characters.</span><br></pre></td></tr></table></figure>
</li>
<li><p>longtext</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A TEXT <span class="keyword">column</span> <span class="keyword">with</span> a maximum length <span class="keyword">of</span> <span class="number">4</span>,<span class="number">294</span>,<span class="number">967</span>,<span class="number">295</span> <span class="keyword">or</span> <span class="number">4</span>GB (<span class="number">2</span><span class="operator">*</span><span class="operator">*</span><span class="number">32</span> − <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD HH:MM:SS（<span class="number">1000</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span><span class="operator">/</span><span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>）</span><br></pre></td></tr></table></figure>
</li>
<li><p>date</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD（<span class="number">1000</span><span class="number">-01</span><span class="number">-01</span><span class="operator">/</span><span class="number">9999</span><span class="number">-12</span><span class="number">-31</span>）</span><br></pre></td></tr></table></figure></li>
</ul>
<p>MySQL还有很多其他的数据类型，例如：<em>set、enum、TinyBlob、Blob、MediumBlob、LongBlob 等</em>，详细见官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/data-types.html">https://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></p>
<h4 id="数据行操作"><a href="#数据行操作" class="headerlink" title="数据行操作"></a>数据行操作</h4><h5 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名,列名) <span class="keyword">values</span>(值,值);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名,列名) <span class="keyword">values</span>(值,值),(值,值),(值,值),(值,值);</span><br></pre></td></tr></table></figure>



<h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span> <span class="keyword">and</span> name<span class="operator">=</span>&quot;谢涛&quot;;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span> <span class="keyword">or</span> name<span class="operator">=</span>&quot;谢涛&quot;;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">!=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="operator">=</span>值,列<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="operator">=</span>值 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb7 <span class="keyword">set</span> password<span class="operator">=</span>&quot;哈哈哈&quot;;</span><br><span class="line"><span class="keyword">update</span> tb7 <span class="keyword">set</span> email<span class="operator">=</span>&quot;哈哈哈&quot; <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">update</span> tb7 <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">10</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名称;</span><br><span class="line"><span class="keyword">select</span> 列名称,列名称 <span class="keyword">from</span> 表名称;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 列名称,列名称 <span class="keyword">from</span> 表名称 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb7;</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> tb7;</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> tb7 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> tb7 <span class="keyword">where</span> name<span class="operator">=</span>&quot;xx&quot; <span class="keyword">and</span> password<span class="operator">=</span>&quot;xx&quot;;</span><br></pre></td></tr></table></figure>



<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><ul>
<li>内连接</li>
</ul>
<blockquote>
<p> 与等值连接在效果上完全一致。但是开发中建议使用内连接，因为等值连接在查询的时候会将2个表会先进行笛卡尔乘积运算，生成一个新表格，占据在电脑内存里，当表的数据量很大时，很耗内存，这种方法效率比较低；内连接查询时会将2个表根据共同ID进行逐条匹配，不会出现笛卡尔乘积的现象，效率比较高。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">=</span> B.c3;</span><br><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">=</span> B.c3; # <span class="keyword">join</span> 是 <span class="keyword">inner</span> <span class="keyword">join</span> 的简写，效果一样 </span><br></pre></td></tr></table></figure>



<ul>
<li>自然连接</li>
</ul>
<blockquote>
<p>是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p>
</blockquote>
<ul>
<li>左外连接</li>
</ul>
<blockquote>
<p> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）以及右边表中全部匹配的行</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">=</span> B.c3;</span><br></pre></td></tr></table></figure>



<ul>
<li>右外连接</li>
</ul>
<blockquote>
<p>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）以及左边表中全部匹配的行</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">=</span> B.c3;</span><br></pre></td></tr></table></figure>



<ul>
<li>全外连接</li>
</ul>
<blockquote>
<p> 包含左、右两个表的全部行，不管在另一边的表中是否存在与它们匹配的行</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">full</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">=</span> B.c3;</span><br></pre></td></tr></table></figure>



<ul>
<li>（theta）连接</li>
</ul>
<blockquote>
<p> 使用等值以外的条件来匹配左、右两个表中的行</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A <span class="keyword">join</span> B <span class="keyword">on</span> A.c3 <span class="operator">!=</span> B.c3;</span><br></pre></td></tr></table></figure>



<ul>
<li>交叉连接</li>
<li>自连接（自己和自己做笛卡尔积）</li>
</ul>
<blockquote>
<p> 生成笛卡尔积——它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行一一匹配</p>
<p>通俗的说就是查询所得的结果行数是两张表行数的乘积。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.c1,B.c2 <span class="keyword">from</span> A,B;</span><br></pre></td></tr></table></figure>



<h4 id="聚合函数、GROUP-BY、HAVING"><a href="#聚合函数、GROUP-BY、HAVING" class="headerlink" title="聚合函数、GROUP BY、HAVING"></a>聚合函数、GROUP BY、HAVING</h4><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>计数（Count）、求和（SUM）、求平均数（AVG）、最大值（MAX）、最小值（MIN）</p>
<h5 id="GROUP-BY、HAVING"><a href="#GROUP-BY、HAVING" class="headerlink" title="GROUP BY、HAVING"></a>GROUP BY、HAVING</h5><p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/52b444ad8acd4e4da81a88d29e46a27d.png" alt="img"></p>
<ol>
<li>想知道每门学科的最高分</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course ,<span class="built_in">Max</span>(score) <span class="keyword">AS</span> 最高分数 <span class="keyword">FROM</span> `t_user` t <span class="keyword">GROUP</span> <span class="keyword">BY</span> course</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/102cce8b375b42a1a6a4c2c8c2cb61c8.png" alt="img"></p>
<ol start="2">
<li>想知道考试时间在2022-09-07号之前每门学科的最高分</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course ,<span class="built_in">MAX</span>(score) <span class="keyword">AS</span> 最高分数 <span class="keyword">FROM</span> `t_user` t <span class="keyword">WHERE</span> t.create_time <span class="operator">&gt;</span> <span class="string">&#x27;2022-09-07&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> course</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/bc88340022b949f085c3cb777b8544b1.png" alt="img"></p>
<ol start="3">
<li>想知道考试时间在2022-09-07号之前每门学科最高分数在70以上有多少人</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course ,<span class="built_in">MAX</span>(score) <span class="keyword">AS</span> 最高分数 <span class="keyword">FROM</span> `t_user` t <span class="keyword">WHERE</span> t.create_time <span class="operator">&gt;</span> <span class="string">&#x27;2022-09-07&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> course <span class="keyword">HAVING</span>(最高分数) <span class="operator">&gt;</span> <span class="number">70</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/3652288d186f44ac885435272e12340a.png" alt="img"></p>
<p>可以发现 我们用了having，对分组之后的结果进行了一个筛选。</p>
<h4 id="关键字顺序-SD-FJ-OW-GWHOL"><a href="#关键字顺序-SD-FJ-OW-GWHOL" class="headerlink" title="关键字顺序 SD FJ OW GWHOL"></a>关键字顺序 SD FJ OW GWHOL</h4><p>时代峰峻 欧文 管委会OL</p>
<ul>
<li><strong>SELECT</strong> </li>
<li><strong>DISTINCT</strong><code>&lt;select_list&gt;</code></li>
<li><strong>FROM</strong> <code>&lt;left_table&gt;</code></li>
<li><code>&lt;join_type&gt;</code> <strong>JOIN</strong> <code>&lt;right_table&gt;</code></li>
<li><strong>ON</strong> <code>&lt;join_condition&gt;</code></li>
<li><strong>WHERE</strong> <code>&lt;where_condition&gt;</code></li>
<li><strong>GROUP BY</strong> <code>&lt;group_by_list&gt;</code></li>
<li><strong>WITH</strong> <code>&#123;CUBE|ROLLUP&#125;</code></li>
<li><strong>HAVING</strong> <code>&lt;having_condition&gt;</code></li>
<li><strong>ORDER BY</strong> <code>&lt;order_by_condition&gt;</code></li>
<li><strong>LIMIT</strong> <code>&lt;limit_number&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>查找&amp;排序合集</title>
    <url>/2022/11/27/%E6%9F%A5%E6%89%BE&amp;%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">Random_Partition</span>(nums, left, right);</span><br><span class="line">            <span class="built_in">QuickSort</span>(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">QuickSort</span>(nums, pos + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= temp) right --;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= temp) left ++;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更快版本的Partition</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Partition2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; x) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优化，随机取 temp</span></span><br><span class="line">    <span class="comment">//int Random_Partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span></span><br><span class="line">    <span class="comment">//    int i = rand() % (right - left + 1) + left; // 随机选一个作为我们的主元</span></span><br><span class="line">    <span class="comment">//    swap(nums[left], nums[i]);</span></span><br><span class="line">    <span class="comment">//    return Partition(nums, left, right);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//从中间截开</span></span><br><span class="line">		<span class="built_in">merge_sort</span>(a, l, mid);<span class="comment">//把左边沿中间截开</span></span><br><span class="line">		<span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, r);<span class="comment">//把右边沿中间截开</span></span><br><span class="line">		<span class="built_in">merge</span>(a, l, r, mid);<span class="comment">//合并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">()</span></span>;<span class="comment">//一个新数组用来存储排序好的数组</span></span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>;<span class="comment">//两个变量分别指向左边和右边两组数的第一个数</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) s.<span class="built_in">push_back</span>(a[i++]);</span><br><span class="line">		<span class="keyword">else</span> s.<span class="built_in">push_back</span>(a[j++]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) s.<span class="built_in">push_back</span>(a[i++]);<span class="comment">//当一组数已经全部排进去之后，再将另外一组数的全部数字都排进去</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r)  s.<span class="built_in">push_back</span>(a[j++]);</span><br><span class="line">	a.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><ul>
<li>while(l &lt; r)</li>
<li>if &lt;, l &#x3D; mid + 1; else r &#x3D; mid;</li>
<li>return l</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[5,7,7,8,8,10]</span>, target = 8</span><br><span class="line">输出：<span class="comment">[3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[5,7,7,8,8,10]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[-1,-1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[]</span>, target = 0</span><br><span class="line">输出：<span class="comment">[-1,-1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">search</span>(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span>&#123;<span class="number">-1</span>, - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = res;</span><br><span class="line">        <span class="type">int</span> r = res;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; <span class="number">0</span> &amp;&amp; nums[l - <span class="number">1</span>] == target)    l --;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r + <span class="number">1</span>] == target)    r ++;</span><br><span class="line">        <span class="keyword">return</span>&#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[3,4,5,1,2]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 <span class="string">[1,2,3,4,5]</span> ，旋转 <span class="number">3</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 <span class="string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[11,13,15,17]</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 <span class="string">[11,13,15,17]</span> ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">左值 &lt; 中值, 中值 &lt; 右值 ：没有旋转，最小值在最左边，可以收缩右边界</span><br><span class="line">        右</span><br><span class="line">     中</span><br><span class="line"> 左</span><br><span class="line">    </span><br><span class="line">左值 &gt; 中值, 中值 &lt; 右值 ：有旋转，最小值在左半边，可以收缩右边界</span><br><span class="line"> 左       </span><br><span class="line">         右</span><br><span class="line">     中</span><br><span class="line">    </span><br><span class="line">左值 &lt; 中值, 中值 &gt; 右值 ：有旋转，最小值在右半边，可以收缩左边界</span><br><span class="line">     中  </span><br><span class="line"> 左 </span><br><span class="line">         右</span><br><span class="line">    </span><br><span class="line">左值 &gt; 中值, 中值 &gt; 右值 ：单调递减，不可能出现</span><br><span class="line"> 左</span><br><span class="line">    中</span><br><span class="line">        右</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)   <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123; <span class="comment">// 如果中间的数小于最右边的数，则右半段是有序的</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + <span class="number">1</span>; <span class="comment">// 不知道第二个条件有什么用</span></span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 若中间数大于最右边数，则左半段是有序的</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; nums[l] &lt;= target) r = mid; </span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a></h3><p>符合下列属性的数组 <code>arr</code> 称为 山脉数组 ：<br><code>arr.length &gt;= 3</code><br>存在<code> i（0 &lt; i &lt; arr.length - 1）</code>使得：<br><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code>且<code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code><br>给你由整数组成的山脉数组<code>arr</code>，返回任何满足<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>的下标 <code>i</code> </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：arr </span>=<span class="string"> [0,1,0]</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">0,2,1,0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">0,10,5,2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">3,4,5,1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">24,69,100,99</span>,<span class="number">79,78,67,36</span>,<span class="number">26</span>,<span class="number">19</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 104</code></li>
<li><code>0 &lt;= arr[i] &lt;= 106</code></li>
<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> r = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 不用判断是否越界是因为用例一定是个山脉数组，一定有山峰 不会出现像【0，1，2】或【2，1，0】的用例</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid - <span class="number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid + <span class="number">1</span>]) <span class="keyword">return</span> mid; <span class="comment">//左右都小于mid，说明mid是山峰</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid + <span class="number">1</span>] &gt; arr[mid]) l = mid; <span class="comment">//右边比左边高，说明山峰在右侧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid + <span class="number">1</span>] &lt; arr[mid]) r = mid; <span class="comment">//右边比左边低，山峰在左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">89182</span>;  <span class="comment">// 随便写，不会执行到这步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>查找&amp;排序</tag>
      </tags>
  </entry>
  <entry>
    <title>栈之括号匹配合集</title>
    <url>/2022/11/19/%E6%A0%88%E4%B9%8B%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) stk.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) stk.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) stk.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 情况1：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 情况2：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> stk.<span class="built_in">pop</span>(); <span class="comment">// stk.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况3：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉系统软件包配置迁移测试</title>
    <url>/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="第一轮测试"><a href="#第一轮测试" class="headerlink" title="第一轮测试"></a>第一轮测试</h3><h4 id="1-mac进入root状态"><a href="#1-mac进入root状态" class="headerlink" title="1.mac进入root状态"></a>1.mac进入root状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开终端</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="comment"># 然后输入本机账号的密码0000</span></span><br></pre></td></tr></table></figure>

<h4 id="2-mac连接远程服务器"><a href="#2-mac连接远程服务器" class="headerlink" title="2.mac连接远程服务器"></a>2.mac连接远程服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进入root状态</span></span><br><span class="line">ssh 服务器用户名@ip <span class="comment"># ssh rpmtest@172.29.7.204</span></span><br><span class="line"><span class="comment"># 输入服务器连接密码</span></span><br></pre></td></tr></table></figure>

<h4 id="查看已安装rpm包-若没有-则安装"><a href="#查看已安装rpm包-若没有-则安装" class="headerlink" title="*查看已安装rpm包 若没有 则安装"></a>*查看已安装rpm包 若没有 则安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qi 包名</span><br><span class="line">yum list installed|grep dbus <span class="comment">#模糊查询</span></span><br><span class="line">sudo yum install dconf-editor-3.28.0-1.el7 <span class="comment">#安装</span></span><br></pre></td></tr></table></figure>

<h4 id="3-在centos服务器上的test文件夹下运行test-py生成迁移脚本"><a href="#3-在centos服务器上的test文件夹下运行test-py生成迁移脚本" class="headerlink" title="3.在centos服务器上的test文件夹下运行test.py生成迁移脚本"></a>3.在centos服务器上的test文件夹下运行test.py生成迁移脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#查看文件列表</span></span><br><span class="line">python3 test.py dbus-1.10.24-12.el7.x86_64.rpm x86_64</span><br><span class="line"><span class="comment"># 生成对应的.sh和.json文件</span></span><br></pre></td></tr></table></figure>

<h4 id="4-将-sh发送到欧拉服务器上的test文件夹下"><a href="#4-将-sh发送到欧拉服务器上的test文件夹下" class="headerlink" title="4.将.sh发送到欧拉服务器上的test文件夹下"></a>4.将.sh发送到欧拉服务器上的test文件夹下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp dbus-1.10.24-12.el7.x86_64.rpm.sh 172.29.7.209:~/test</span><br><span class="line"><span class="comment"># 输入ls 查看有无backup 和 configfile 文件夹</span></span><br></pre></td></tr></table></figure>

<h4 id="5-在centos服务器上查看对应的-json文件"><a href="#5-在centos服务器上查看对应的-json文件" class="headerlink" title="5.在centos服务器上查看对应的.json文件"></a>5.在centos服务器上查看对应的.json文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim dbus-1.10.24-12.el7.x86_64.rpm x86_64.json</span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># %! python3 -m json.tool 后输入该条指令将该json文件夹格式化方便查看</span></span><br></pre></td></tr></table></figure>

<h4 id="6-比对"><a href="#6-比对" class="headerlink" title="6.比对"></a>6.比对</h4><p>查看configfile文件夹中修改后的系统配置文件并与backup文件夹中的原文件进行比较，查看修改部分是否同之前的json文件中的内容保持一致(修改后配置项的值应为src_current_value)，也可以与对应sh脚本中echo和sed内容进行对比是否一致，若不一致，需记录。</p>
<h3 id="第二轮测试"><a href="#第二轮测试" class="headerlink" title="第二轮测试"></a>第二轮测试</h3><h4 id="1-mac进入root状态-1"><a href="#1-mac进入root状态-1" class="headerlink" title="1.mac进入root状态"></a>1.mac进入root状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开终端</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="comment"># 然后输入本机账号的密码0000</span></span><br></pre></td></tr></table></figure>

<h4 id="2-mac连接远程服务器-1"><a href="#2-mac连接远程服务器-1" class="headerlink" title="2.mac连接远程服务器"></a>2.mac连接远程服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进入root状态</span></span><br><span class="line">ssh 服务器用户名@ip <span class="comment"># ssh rpmtest@172.29.7.221</span></span><br><span class="line"><span class="comment"># 输入服务器连接密码</span></span><br></pre></td></tr></table></figure>

<h4 id="3-进入linux的-etc-x2F-yum-repos-d-目录"><a href="#3-进入linux的-etc-x2F-yum-repos-d-目录" class="headerlink" title="3.进入linux的 etc&#x2F;yum.repos.d 目录"></a>3.进入linux的 etc&#x2F;yum.repos.d 目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd ~    回到根目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br></pre></td></tr></table></figure>

<h4 id="4-查看所有可用软件包"><a href="#4-查看所有可用软件包" class="headerlink" title="4.查看所有可用软件包"></a>4.查看所有可用软件包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要测试 clamav-milter-0.103.5-1.el7.x86_64.rpm 包</span></span><br><span class="line">yum --disablerepo=<span class="string">&#x27;*&#x27;</span> --enablerepo=<span class="string">&#x27;huawei-*&#x27;</span> list clamav-milter --showduplicate</span><br><span class="line"><span class="comment"># 结果如下图 说明要降级软件包</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811163753844.png" alt="image-20220811163753844" style="zoom:67%;">

<h4 id="5-升级-x2F-降级软件包"><a href="#5-升级-x2F-降级软件包" class="headerlink" title="5.升级&#x2F;降级软件包"></a>5.升级&#x2F;降级软件包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级</span></span><br><span class="line">sudo yum upgrade clamav-milter-0.103.5-1.el7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降级</span></span><br><span class="line">sudo yum downgrade clamav-milter-0.103.5-1.el7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提示信息同时升级/降级软件包依赖(大文件放最后)</span></span><br><span class="line">sudo yum downgrade python-firewall-0.5.3-5.el7 firewalld-filesystem-0.5.3-5.el7 firewalld-0.5.3-5.el7</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811174709752.png" alt="image-20220811174709752" style="zoom:50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有其他的包依赖需要降级的这个包，因此两个需要一起downgrade就可以了</span></span><br><span class="line">sudo yum downgrade cronie-anacron-1.4.11-19.el7 cronie-1.4.11-19.el7</span><br></pre></td></tr></table></figure>

<h4 id="6-备份配置文件"><a href="#6-备份配置文件" class="headerlink" title="6.备份配置文件"></a>6.备份配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/test</span><br><span class="line">python3 test.py cronie-1.4.11-19.el7.x86_64.rpm x86_64</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811181850807.png" alt="image-20220811181850807"></p>
<ul>
<li>第一个是CentOS当前配置文件路径</li>
<li>第二个是CentOS默认配置文件路径</li>
<li>第三个是OpenEuler默认配置文件路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先以root权限备份CentOS当前配置文件和OpenEuler默认配置文件到backup文件夹对应的子文件夹下。backup文件夹分别有两个子文件夹centos_default\openeuler。backup文件夹分别有两个子文件夹centos_current 、openeuler。</span></span><br><span class="line"><span class="built_in">cp</span> -p /usr/lib/systemd/system/crond.service backup/centos_current/</span><br><span class="line"><span class="built_in">cp</span> -p database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/crond.service backup/openeuler/</span><br><span class="line"><span class="comment"># 此时~/test/backup/centos_current/crond.service 和~/test/backup/openeuler/crond.service已经建立</span></span><br></pre></td></tr></table></figure>

<h4 id="7-修改配置项"><a href="#7-修改配置项" class="headerlink" title="7.修改配置项"></a>7.修改配置项</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/crond.service</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811184451341.png" alt="image-20220811184451341" style="zoom:50%;">

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811193700367.png" alt="image-20220811193700367" style="zoom:50%;">



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim  database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/crond.service</span><br></pre></td></tr></table></figure>

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811193525150.png" alt="image-20220811193525150" style="zoom:50%;">

<h4 id="8-在centos服务器上的test文件夹下运行test-py生成迁移脚本"><a href="#8-在centos服务器上的test文件夹下运行test-py生成迁移脚本" class="headerlink" title="8.在centos服务器上的test文件夹下运行test.py生成迁移脚本"></a>8.在centos服务器上的test文件夹下运行test.py生成迁移脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#查看文件列表</span></span><br><span class="line">python3 test.py cronie-1.4.11-19.el7.x86_64.rpm x86_64</span><br><span class="line"><span class="comment"># 生成对应的.sh和.json文件</span></span><br></pre></td></tr></table></figure>

<h4 id="9-将-sh发送到欧拉服务器上的test文件夹下"><a href="#9-将-sh发送到欧拉服务器上的test文件夹下" class="headerlink" title="9.将.sh发送到欧拉服务器上的test文件夹下"></a>9.将.sh发送到欧拉服务器上的test文件夹下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp cronie-1.4.11-19.el7.x86_64.rpm.sh 172.29.7.209:~/test</span><br><span class="line"><span class="comment"># 输入ls 查看有无backup 和 configfile 文件夹</span></span><br></pre></td></tr></table></figure>

<h4 id="10-在centos服务器上查看对应的-json文件"><a href="#10-在centos服务器上查看对应的-json文件" class="headerlink" title="10.在centos服务器上查看对应的.json文件"></a>10.在centos服务器上查看对应的.json文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim dbus-1.10.24-12.el7.x86_64.rpm x86_64.json</span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># %! python3 -m json.tool 后输入该条指令将该json文件夹格式化方便查看</span></span><br></pre></td></tr></table></figure>

<h4 id="11-比对"><a href="#11-比对" class="headerlink" title="11.比对"></a>11.比对</h4><p>检查OpenEuler服务器上是否有对应版本的rpm包，若没有，则安装。若存在，则复制脚本到OpenEuler服务器，以root权限运行该脚本。脚本会备份要修改的配置文件到同目录下backup文件夹，修改后的配置文件到同目录下configfile文件夹。若有错误日志输出，需记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum list clamav-milter --showduplicate</span></span><br><span class="line"><span class="comment"># sudo yum install XXX</span></span><br><span class="line"></span><br><span class="line">sudo ./cronie-1.4.11-19.el7.x86_64.rpm.sh</span><br><span class="line"></span><br><span class="line">vim backup/crond.service</span><br></pre></td></tr></table></figure>

<p>对比openeuler服务器上backup和configfile目录下配置项的值，是否符合json文件中is_sync为true的配置项</p>
<p>backup为修改前默认配置文件，值是json文件中的openeuler_default_value</p>
<p>configfile为后修改后的配置文件，值是json文件中src_current_value</p>
<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811205126703.png" alt="image-20220811205126703" style="zoom:50%;">

<img src="/2022/08/08/%E6%AC%A7%E6%8B%89%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8C%85%E9%85%8D%E7%BD%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/image-20220811205336588.png" alt="image-20220811205336588" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src_current_value的值为当前centos环境的配置项值,从环境中查询</span></span><br><span class="line"><span class="comment">// src_default_value的值为centos的rpm包的配置项默认值，从数据库中查询</span></span><br><span class="line"><span class="comment">// openEuler_default_value的值为对应openEuler上rpm包的配置项默认值，从数据库中查询</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;crond.service&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;rpm_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cronie-1.4.11-19.el7.x86_64.rpm&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;filename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;crond.service&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;src_os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;centos&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;target_os &quot;</span><span class="punctuation">:</span> <span class="string">&quot;openeuler&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;arch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command Scheduler&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command Scheduler&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;After&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auditd.service systemd-user-sessions.service time-sync.target&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auditd.service nss-user-lookup.target systemd-user-sessions.service time-sync.target ypbind.service autofs.service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unit&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;insert &quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;insert1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;changed&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;alter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; /etc/sysconfig/crond &quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;alter1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;src_current_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS item1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /usr/sbin/crond -n $CRONDARGS item2&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;src_default_value&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;openEuler_default_value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                   <span class="string">&quot; /etc/sysconfig/crond item1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot; /etc/sysconfig/crond item2&quot;</span></span><br><span class="line">               <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_default_diff&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_customer_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;section&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Service&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;is_sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h4 id="12-在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径"><a href="#12-在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径" class="headerlink" title="12.在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径"></a>12.在完成脚本迁移后，将所有cento中备份的文件恢复到原文件路径</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -p backup/centos_current/crond.service /usr/lib/systemd/system/</span><br><span class="line">sudo <span class="built_in">cp</span> -p backup/openeuler/crond.service  database/service_and_socket_data/openEuler20.03-SP1/x86_64/everything/service/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>润</title>
    <url>/2022/11/09/%E6%B6%A6/</url>
    <content><![CDATA[<h3 id="考研英语"><a href="#考研英语" class="headerlink" title="考研英语"></a>考研英语</h3><h4 id="小作文"><a href="#小作文" class="headerlink" title="小作文"></a>小作文</h4><h5 id="申请信"><a href="#申请信" class="headerlink" title="申请信"></a>申请信</h5><p><em>Dear Mr.A</em>（后省略此处）</p>
<p><em><strong>I am writing to apply for the position</strong></em> as the personal secretary to the general manager. (the opportunity for further study in your university).</p>
<p><em><strong>I am fully confident that I am the right candidate</strong></em>. To begin with, I major in secretary and will graduate from Peking University. I have a good academic performance in school and have been the top five students for four years in my grade. In addition, I am an open-minded, cooperative and ready-to-help girl.</p>
<p><em><strong>Enclosed is my resume to provide additional information. Thank you for your time and consideration. I am looking forward to your reply at your earliest convenience.</strong></em></p>
<p><em>Sincerely, Li Ming</em>（后省略此处）</p>
<h5 id="投诉信"><a href="#投诉信" class="headerlink" title="投诉信"></a>投诉信</h5><p><em><strong>I am deeply dissatisfied with my recent shopping experience</strong></em> in one of your retail stores, and ask you to step in and resolve the matter.</p>
<p>On the afternoon of 5 December, 2022, I visited your retail store at IFS mall, looking for a ___. <em><strong>A staff member recommended your latest model and assured me that</strong></em> its battery capacity was much larger than that of most products on the market. <em><strong>I was very impressed by this feature and bought it without hesitation.</strong></em> But as soon as I tested it out at home, I found out that the battery life actually showed no significant improvement. <em><strong>The next day, I brought the product back to the store and asked for a full refund. To my shock, that same staff member flatly denied that he made the false claim.</strong></em> And the store manager sided with him and rejected my refund request.</p>
<p><em><strong>I will highly appreciate if you can take care of this dispute and get back to me as soon as possible.</strong></em></p>
<h5 id="建议信"><a href="#建议信" class="headerlink" title="建议信"></a>建议信</h5><p><em><strong>I am writing the letter in purpose of drawing your attention to the fact that</strong></em> some people stiluse plastic bags in spite of restrictions on the use of them. <em><strong>and I will try to make some conducive recommendations concerning</strong></em> the write pollution.</p>
<p><em><strong>In my humble opinion</strong></em>, to eradicate the phenomenon of widespread write pollution, it would be wise to take the following actions. Above all, the public should keep in mind to foster consciousness of the negative influence of frequent use plastic bags. Besides, there is no doubt that the authorities should strengthen the enforcement of the laws to completely ban the improper use of plastic bags.</p>
<p><em><strong>I hope you will find these proposals useful, and I would be ready to discuss this matter with you to further details. Your prompt attention to my recommendations will be highly appreciated.</strong></em></p>
<h5 id="邀请信"><a href="#邀请信" class="headerlink" title="邀请信"></a>邀请信</h5><p><em><strong>I am writing on behalf of the</strong></em> English Department <em><strong>to invite you to</strong></em> give a lecture in our college.</p>
<p>We know that you are an expert on American literature. As English majors, our students would like to know something about American literature. <em><strong>We would be very grateful if you could</strong></em> give a talk on “Contemporary American Literature” to students of the English Department on Saturday, June 4. If this subject does not suit you, any other similar topic would be welcomed as well.</p>
<p>We have already had several very interesting talks from some distinguished visitors from various countries and <em><strong>we look</strong></em><br><em><strong>forward early to the opportunity to benefit from your experience and wisdom.</strong></em></p>
<h5 id="通知信"><a href="#通知信" class="headerlink" title="通知信"></a>通知信</h5><p>The first year in Foreign Languages School is drawing to a close. So far, we have been focusing on learning the skills in English listening and speaking. <em><strong>In order to</strong></em> further test your competence in spoken English, <em><strong>we beg to notify you that</strong></em> our school decides to organize an English Speech Contest.</p>
<p><em><strong>The English Speech Contest is scheduled to be held at 2 p.m. on May 25 in the Lecture Hall of our school.</strong></em> The speech will be centered on the theme of language learning and culture. All the students are welcome to participate in the contest. The two foreign teachers, Professor Smith and Professor Johnson will be invited as the judges and the winners will be awarded an Oxford English Dictionary. </p>
<p><em><strong>If you are interested in this activity, please feel free to contact us via <a href="mailto:&#120;&#x78;&#x78;&#120;&#120;&#120;&#x78;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;">&#120;&#x78;&#x78;&#120;&#120;&#120;&#x78;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;</a>. The deadline is  ___. Come and join us now!</strong></em></p>
<h4 id="大作文"><a href="#大作文" class="headerlink" title="大作文"></a>大作文</h4><h5 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h5><ol>
<li><p>漫画</p>
<p><em><strong>The cartoon depicts … Although he…, he …</strong></em></p>
<blockquote>
<p>  The cartoon depicts a young athlete on a running track. Although he has just crossed the finishing line, he immediately starts his next round without stopping to catch his breath</p>
</blockquote>
</li>
<li><p>对比图</p>
<p><em><strong>In the upper picture, we learn that ….   On the contrary, in the lower picture, ….</strong></em></p>
<p><em><strong>The first picture show us .On the contrary, according to the second picture, we learn that…</strong></em></p>
</li>
<li><p>表格类：(表格数据多，点到为止，只点首尾，中间的非典型数据不用提及)</p>
<p><em><strong>The table clearly reflects &#x2F; reveals</strong> …. <strong>According to the data given above, we can conclude that</strong>…. <strong>is highest</strong>… <strong>In contrast,</strong> …. <strong>is the lowest</strong> …</em></p>
</li>
<li><p>曲线图：(曲线图的数据及术语要根据情况表达到位)</p>
<p><em><strong>The line chart &#x2F; line graph clearly illustrates that the number of … increased &#x2F; jumped from 时间 to 时间…</strong></em></p>
</li>
<li><p>柱状图：(纵坐标一般为数据，横坐标一般是年代及主体，注意抓住不同主体描述)</p>
<p><em><strong>According to the above bar chart &#x2F; column chart, the number &#x2F; percentage of … from 时间 to 时间…</strong></em></p>
</li>
<li><p>饼状图：(饼状图是所有图表中相对最简单的一种，只需要掌握占比多少的表达，描述清楚即可)</p>
<p><em><strong>The pie chart above clearly reveals the…in a certain city &#x2F; university &#x2F;… Among all the categories, the percentage of … is&#x2F;are the highest，accounting for… On the contrary, the statistics of … take up merely.., the lowest…</strong></em></p>
</li>
</ol>
<h5 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h5><ol>
<li><p><em><strong>I think there are two main reasons for such a great contrast. First of all, … For example, … Secondly, … As a result, …</strong></em><br>我认为造成这种巨大的对比有两个主要原因。首先,…	例如,…	其次,… 	因此,…</p>
</li>
<li><p><em><strong>It’s not difficult for us to come up with some possible reasons accounting for this trend. At the top of the list, with rapid development of our economy and society, more and more people prefer … In addition, … Last but not least, the fact cannot be ignored that…</strong></em><br>我们不难发现导致这种趋势的一些可能的原因。首先，随着我国经济和社会的迅速发展，越来越多的人更喜欢… 此外,… 最后但同样重要的一个点,不容忽视的是….</p>
</li>
<li><p><em><strong>The major determinant lies in … On the one hand, … On the other hand, …</strong></em><br>主要的决定因素在于…一方面，…另一方面,…</p>
</li>
<li><p><em><strong>From my perspective, the tendency in the bar chart above can be traced back to three major contributors. First and foremost, … In addition, … Most importantly, …</strong></em><br>在我看来，以上柱状图的中的趋势是由三个主要原因造成。首先且最重要的是，…其次，…最为重要的是，…</p>
</li>
<li><p><em><strong>Several factors that account for the above-mentioned phenomenon could be summarized as follows. To start with, the main reason  is…  Furthermore, ..</strong></em><br>造成上述现象的一些因素可以概括如下。首先的主要原因在于，其次…</p>
</li>
</ol>
<h5 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h5><ol>
<li><p><em><strong>For these reasons, it is critical to … Only in this way can we…</strong></em></p>
</li>
<li><p><em><strong>To conclude, we should…</strong></em></p>
</li>
<li><p><em><strong>In summary, the cartoon makes a strong case for … By doing…, we can…</strong></em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>润</category>
      </categories>
      <tags>
        <tag>润</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口合集</title>
    <url>/2023/02/14/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, windSize = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(r &lt; n)&#123;</span><br><span class="line">    sum += nums[r ++];</span><br><span class="line">    <span class="keyword">while</span>(sum &gt; target &amp;&amp; l &lt; n) sum -= nums[l ++];</span><br><span class="line">    <span class="keyword">if</span>(sum == target) windSize = <span class="built_in">max</span>(windSize, r - l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658. 将 x 减到 0 的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p>
<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span>]<span class="punctuation">,</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最佳解决方案是移除后两个元素，将 <span class="keyword">x</span> 减到 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[5,6,7,8,9]</span>, x = <span class="number">4</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span>]<span class="punctuation">,</span> <span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最佳解决方案是移除后三个元素和前两个元素（总共 <span class="number">5</span> 次操作），将 <span class="keyword">x</span> 减到 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= x &lt;= 109</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> SUM = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(SUM &lt; x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target = SUM - x;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, windSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            sum += nums[r ++];</span><br><span class="line">            <span class="comment">// while(sum &lt; target &amp;&amp; r &lt; nums.size()) sum += nums[r ++];</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt; target &amp;&amp; l &lt; nums.<span class="built_in">size</span>()) sum -= nums[l ++];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) windSize = <span class="built_in">max</span>(windSize, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> windSize == <span class="number">-1</span> ? <span class="number">-1</span>: nums.<span class="built_in">size</span>() - windSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2516-每种字符至少取-K-个"><a href="#2516-每种字符至少取-K-个" class="headerlink" title="2516. 每种字符至少取 K 个"></a><a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/">2516. 每种字符至少取 K 个</a></h3><p>给你一个由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>
<p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aabaaaacaabc&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line">从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。</span><br><span class="line">从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。</span><br><span class="line">共需要 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span> 分钟。</span><br><span class="line">可以证明需要的最少分钟数是 <span class="number">8</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, k = <span class="number">1</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -<span class="number">1</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 仅由字母 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成</li>
<li><code>0 &lt;= k &lt;= s.length</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeCharacters</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求 满足 cnt[0] &gt;= k &amp;&amp; cnt[1] &gt;= k &amp;&amp; cnt[2] &gt;= k 的最大窗口;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: s)</span><br><span class="line">            cnt[e -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, windSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)&#123;</span><br><span class="line">            cnt[s[r ++]-<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; n &amp;&amp; cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k) cnt[s[l ++] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">0</span>] &gt;= k &amp;&amp; cnt[<span class="number">1</span>] &gt;= k &amp;&amp; cnt[<span class="number">2</span>] &gt;= k) windSize = <span class="built_in">max</span>(windSize, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windSize == <span class="number">-1</span> ? <span class="number">-1</span> : n - windSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：fruits </span>=<span class="string"> [1,2,1]</span></span><br><span class="line"><span class="string">输出：3</span></span><br><span class="line"><span class="string">解释：可以采摘全部 3 棵树。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[0,1,2,2]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 <span class="comment">[1,2,2]</span> 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[0,1]</span> 这两棵树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[1,2,3,2,2]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 <span class="comment">[2,3,2,2]</span> 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[1,2]</span> 这两棵树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：fruits = [<span class="number">3,3,3,1</span>,<span class="number">2,1,1,2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以采摘 [<span class="number">1,2,1,1</span>,<span class="number">2</span>] 这五棵树。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= fruits.length &lt;= 105</code></li>
<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 种类 &lt;= 2 的最大窗口</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, windSize = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            mp[fruits[r ++]] ++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; fruits.<span class="built_in">size</span>() &amp;&amp; mp.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>( -- mp[fruits[l]] == <span class="number">0</span>) mp.<span class="built_in">erase</span>(fruits[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            windSize = <span class="built_in">max</span>(windSize, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h3><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">&quot;ab&quot;</span> <span class="built_in">s2</span> = <span class="string">&quot;eidbaooo&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="built_in">s2</span> 包含 <span class="built_in">s1</span> 的排列之一 (<span class="string">&quot;ba&quot;</span>).</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s1<span class="operator">=</span> <span class="string">&quot;ab&quot;</span> s2 <span class="operator">=</span> <span class="string">&quot;eidboaoo&quot;</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li>
<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>)</span>,<span class="title">cnt2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : s1)</span><br><span class="line">            cnt1[e - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r =<span class="number">0</span> ,windSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cnt2[s2[r ++] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; s2.<span class="built_in">size</span>() &amp;&amp; cnt1[s2[l] - <span class="string">&#x27;a&#x27;</span>] &lt;  cnt2[s2[l] - <span class="string">&#x27;a&#x27;</span>]) cnt2[s2[l ++] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(cnt1 == cnt2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159. 至多包含两个不同字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a></h3><p>给你一个字符串 <code>s</code> ，请你找出 <strong>至多</strong> 包含 <strong>两个不同字符</strong> 的最长子串，并返回该子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;eceba&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：满足题目要求的子串是 <span class="string">&quot;ece&quot;</span> ，长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;ccaabbb&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：满足题目要求的子串是 <span class="string">&quot;aabbb&quot;</span> ，长度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由英文字母组成</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r =<span class="number">0</span> ,windSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)&#123;</span><br><span class="line">            mp[s[r++]] ++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; n &amp;&amp; mp.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(-- mp[s[l]] == <span class="number">0</span>) mp.<span class="built_in">erase</span>(s[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            windSize = <span class="built_in">max</span>(windSize , r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></h3><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], <span class="attr">k</span> = <span class="number">3</span>, <span class="attr">t</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], <span class="attr">k</span> = <span class="number">1</span>, <span class="attr">t</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], <span class="attr">k</span> = <span class="number">2</span>, <span class="attr">t</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 104</code></li>
<li><code>0 &lt;= t &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> indexDiff, <span class="type">int</span> valueDiff)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt; n)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(nums[r] - valueDiff); <span class="comment">// 找到第一个 &gt;= nums[r]-valueDiff 的迭代器</span></span><br><span class="line">            <span class="keyword">if</span>(it != st.<span class="built_in">end</span>() &amp;&amp; *it &lt;= nums[r] + valueDiff) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.<span class="built_in">insert</span>(nums[r ++]);</span><br><span class="line">            <span class="keyword">while</span>(r - l &gt; indexDiff) st.<span class="built_in">erase</span>(nums[l ++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法之中等题合集</title>
    <url>/2022/12/14/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%AD%E7%AD%89%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="string">-3</span>, 5, <span class="string">-7</span>, 3) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="string">-7</span>, 3, <span class="string">-3</span>, 6, <span class="string">-8</span>) 。</span><br></pre></td></tr></table></figure>



<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>动态规划</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// up[i] 表示以下标0 - i元素中的某一个为结尾的最长的「上升摆动序列」的长度。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">down</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// down[i] 表示以下标0 - i元素中的某一个为结尾的最长的「下降摆动序列」的长度。</span></span><br><span class="line">        up[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">1</span>] - nums[<span class="number">0</span>] &gt; <span class="number">0</span> ) up[<span class="number">1</span>] = <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] - nums[<span class="number">1</span>] &gt; <span class="number">0</span>) down[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> up[<span class="number">1</span>] = down[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]- nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) </span><br><span class="line">                up[i] = <span class="built_in">max</span>(down[i - <span class="number">1</span>] + <span class="number">1</span>, up[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]- nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) </span><br><span class="line">                down[i] = <span class="built_in">max</span>(up[i - <span class="number">1</span>] + <span class="number">1</span>, down[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                down[i] = down[i <span class="number">-1</span>];</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>贪心</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> prevdiff = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ret = prevdiff != <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((diff &gt; <span class="number">0</span> &amp;&amp; prevdiff &lt;= <span class="number">0</span>) || (diff &lt; <span class="number">0</span> &amp;&amp; prevdiff &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">                prevdiff = diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h3><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 10</span></span><br><span class="line"><span class="section">输出: 9</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 1234</span></span><br><span class="line"><span class="section">输出: 1234</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 332</span></span><br><span class="line"><span class="section">输出: 299</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 109</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;<span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i - <span class="number">1</span>] &gt; str[i]) &#123;</span><br><span class="line">                str[i - <span class="number">1</span>] --;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; len; j ++) &#123;</span><br><span class="line">                    str[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h3><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,0,2]</span></span><br><span class="line"><span class="string">输出：5</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,2,2]</span></span><br><span class="line"><span class="string">输出：4</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span></span><br><span class="line"><span class="string">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == ratings.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i ++)&#123; <span class="comment">// 正向遍历一遍</span></span><br><span class="line">            <span class="keyword">if</span>((ratings[i] &gt; ratings[i - <span class="number">1</span>]) &amp;&amp; (res[i] &lt;= res[i - <span class="number">1</span>])) </span><br><span class="line">                res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((ratings[i - <span class="number">1</span>] &gt; ratings[i]) &amp;&amp; (res[i <span class="number">-1</span>] &lt;= res[i])) </span><br><span class="line">                res[i - <span class="number">1</span>] = res[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>;i --)&#123; <span class="comment">// 反向遍历一遍</span></span><br><span class="line">            <span class="keyword">if</span>((ratings[i] &gt; ratings[i - <span class="number">1</span>]) &amp;&amp; (res[i] &lt;= res[i - <span class="number">1</span>])) </span><br><span class="line">                res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((ratings[i - <span class="number">1</span>] &gt; ratings[i]) &amp;&amp; (res[i <span class="number">-1</span>] &lt;= res[i])) </span><br><span class="line">                res[i - <span class="number">1</span>] = res[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: res) sum += e;</span><br><span class="line">        <span class="keyword">return</span> sum + n ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：people = <span class="comment">[<span class="comment">[7,0]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>,<span class="comment">[5,0]</span>,<span class="comment">[6,1]</span>,<span class="comment">[5,2]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[5,0]</span>,<span class="comment">[7,0]</span>,<span class="comment">[5,2]</span>,<span class="comment">[6,1]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>]</span></span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 <span class="comment">[<span class="comment">[5,0]</span>,<span class="comment">[7,0]</span>,<span class="comment">[5,2]</span>,<span class="comment">[6,1]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>]</span> 是重新构造后的队列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：people = <span class="comment">[<span class="comment">[6,0]</span>,<span class="comment">[5,0]</span>,<span class="comment">[4,0]</span>,<span class="comment">[3,2]</span>,<span class="comment">[2,2]</span>,<span class="comment">[1,4]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[4,0]</span>,<span class="comment">[5,0]</span>,<span class="comment">[2,2]</span>,<span class="comment">[3,2]</span>,<span class="comment">[1,4]</span>,<span class="comment">[6,0]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= people.length &lt;= 2000</code></li>
<li><code>0 &lt;= hi &lt;= 106</code></li>
<li><code>0 &lt;= ki &lt; people.length</code></li>
<li>题目数据确保队列可以被重建</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><ul>
<li>思路：经验之谈 ( 感觉 )</li>
</ul>
<p>先对 [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 进行排序： </p>
<p>第一维度高的在前，第二维度低的在前，每次插入到第二维度下标所在处：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</p>
<p>插入的过程：</p>
<blockquote>
<p>  插入[7,0]：[[7,0]]</p>
<p>  插入[7,1]：[[7,0],[7,1]]</p>
<p>  插入[6,1]：[[7,0],[6,1],[7,1]]</p>
<p>  插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</p>
<p>  插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</p>
<p>  插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// sort(people.rbegin(), people.rend());</span></span><br><span class="line">        <span class="comment">// &#123;&#123;7,1&#125;, &#123;7,0&#125;, &#123;6,1&#125;, &#123;5,2&#125;, &#123;5,0&#125;, &#123;4,4&#125;&#125;</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: people) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>() + e[<span class="number">1</span>], e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法之区间问题合集</title>
    <url>/2022/12/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳<span class="number"> 1 </span>步，从下标<span class="number"> 0 </span>到达下标 1, 然后再从下标<span class="number"> 1 </span>跳<span class="number"> 3 </span>步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为<span class="number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="number"> 0 </span>， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; res) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = begin; i &lt; end; i ++)&#123; <span class="comment">// 如果将end初始化为0的话,第一轮不会展开,出现runtime error</span></span><br><span class="line">               maxReach = <span class="built_in">max</span>(nums[i] + i, maxReach);</span><br><span class="line">            &#125;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = maxReach + <span class="number">1</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[10,16]</span>,<span class="comment">[2,8]</span>,<span class="comment">[1,6]</span>,<span class="comment">[7,12]</span>]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球<span class="comment">[2,8]</span>和<span class="comment">[1,6]</span>。</span><br><span class="line">-在x = 11处发射箭，击破气球<span class="comment">[10,16]</span>和<span class="comment">[7,12]</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[3,4]</span>,<span class="comment">[5,6]</span>,<span class="comment">[7,8]</span>]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[2,3]</span>,<span class="comment">[3,4]</span>,<span class="comment">[4,5]</span>]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球<span class="comment">[1,2]</span>和<span class="comment">[2,3]</span>。</span><br><span class="line">- 在x = 4处射出箭，击破气球<span class="comment">[3,4]</span>和<span class="comment">[4,5]</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 105</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算区间之间相交的区间数量</span></span><br><span class="line"><span class="comment">// 如[[10,16],[2,8],[1,6],[7,12]] 合并为[[2,6],[10,12]]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: points) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) res.<span class="built_in">push_back</span>(e);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e[<span class="number">0</span>] &gt; res.<span class="built_in">back</span>()[<span class="number">1</span>]) res.<span class="built_in">push_back</span>(e);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">back</span>() = &#123;<span class="built_in">max</span>(e[<span class="number">0</span>],res.<span class="built_in">back</span>()[<span class="number">0</span>]), <span class="built_in">min</span>(e[<span class="number">1</span>],res.<span class="built_in">back</span>()[<span class="number">1</span>])&#125;;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[2,3]</span>,<span class="comment">[3,4]</span>,<span class="comment">[1,3]</span>]</span></span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 <span class="comment">[1,3]</span> 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[ <span class="comment">[1,2]</span>, <span class="comment">[1,2]</span>, <span class="comment">[1,2]</span> ]</span></span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 <span class="comment">[1,2]</span> 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[ <span class="comment">[1,2]</span>, <span class="comment">[2,3]</span> ]</span></span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 105</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与452相比，就是每个相交的区间只保留一个（注意这题里端点不算相交）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.<span class="built_in">size</span>() == <span class="number">0</span>) tmp.<span class="built_in">push_back</span>(e);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[<span class="number">0</span>] &gt;= tmp.<span class="built_in">back</span>()[<span class="number">1</span>]) tmp.<span class="built_in">push_back</span>(e);</span><br><span class="line">                <span class="keyword">else</span> tmp.<span class="built_in">back</span>()= &#123;<span class="built_in">max</span>(e[<span class="number">0</span>],tmp.<span class="built_in">back</span>()[<span class="number">0</span>]), <span class="built_in">min</span>(e[<span class="number">1</span>],tmp.<span class="built_in">back</span>()[<span class="number">1</span>])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - tmp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h3><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>、<span class="string">&quot;defegde&quot;</span>、<span class="string">&quot;hijhklij&quot;</span> 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            end = <span class="built_in">max</span>(end, mp[s[i]]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) res.<span class="built_in">push_back</span>(e);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e[<span class="number">0</span>]&gt; res.<span class="built_in">back</span>()[<span class="number">1</span>]) res.<span class="built_in">push_back</span>(e);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(e[<span class="number">1</span>], res.<span class="built_in">back</span>()[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法之提高题合集</title>
    <url>/2022/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%90%E9%AB%98%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h3><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从<span class="number"> 3 </span>号加油站(索引为<span class="number"> 3 </span>处)出发，可获得<span class="number"> 4 </span>升汽油。此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 4 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 1 </span>+<span class="number"> 5 </span>=<span class="number"> 8 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 8 </span>-<span class="number"> 2 </span>+<span class="number"> 1 </span>=<span class="number"> 7 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 7 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 6 </span>升汽油</span><br><span class="line">开往<span class="number"> 2 </span>号加油站，此时油箱有<span class="number"> 6 </span>-<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 5 </span>升汽油</span><br><span class="line">开往<span class="number"> 3 </span>号加油站，你需要消耗<span class="number"> 5 </span>升汽油，正好足够你返回到<span class="number"> 3 </span>号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从<span class="number"> 0 </span>号或<span class="number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从<span class="number"> 2 </span>号加油站出发，可以获得<span class="number"> 4 </span>升汽油。 此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 3 </span>-<span class="number"> 3 </span>+<span class="number"> 3 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">你无法返回<span class="number"> 2 </span>号加油站，因为返程需要消耗<span class="number"> 4 </span>升汽油，但是你的油箱只有<span class="number"> 3 </span>升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><img src="/2022/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%90%E9%AB%98%E9%A2%98%E5%90%88%E9%9B%86/image-20221216203824063.png" alt="image-20221216203824063" style="zoom: 25%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rest</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            rest[i] = gas[i] - cost[i];</span><br><span class="line">            sum += rest[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 一定跑不完一圈</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            curSum += rest[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                res = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a></h3><p>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%90%E9%AB%98%E9%A2%98%E5%90%88%E9%9B%86/bst_cameras_01.png" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">0</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%90%E9%AB%98%E9%A2%98%E5%90%88%E9%9B%86/bst_cameras_02.png" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">0</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>
<li>每个节点的值都是 0。</li>
</ol>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(root) == <span class="number">2</span>) res ++; <span class="comment">// root不可观， 要在root上装一个</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> || right == <span class="number">2</span>)&#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这点装了监视器</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法之简单题合集</title>
    <url>/2022/12/14/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 是g数组的下标，也是最终返回值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; g.<span class="built_in">size</span>() &amp;&amp; g[res] &lt;= s[i]) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,2,3]</span>, k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 <span class="comment">[4,-2,3]</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,-1,0,2]</span>, k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 <span class="comment">[3,1,0,2]</span> 。</span><br></pre></td></tr></table></figure>



<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>( k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            *nums.<span class="built_in">begin</span>() = - *nums.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums) res += e;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h3><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> <strong>示例 ：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前<span class="number"> 2 </span>位顾客那里，我们按顺序收取<span class="number"> 2 </span>张<span class="number"> 5 </span>美元的钞票。</span><br><span class="line">对于接下来的<span class="number"> 2 </span>位顾客，我们收取一张<span class="number"> 10 </span>美元的钞票，然后返还<span class="number"> 5 </span>美元。</span><br><span class="line">对于最后一位顾客，我们无法退回<span class="number"> 15 </span>美元，因为我们现在只有两张<span class="number"> 10 </span>美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= bills.length &lt;= 105</code></li>
<li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">changes</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 代表5块，10块个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">10</span>)&#123;</span><br><span class="line">                changes[<span class="number">1</span>] ++;</span><br><span class="line">                changes[<span class="number">0</span>] --;</span><br><span class="line">                <span class="keyword">if</span>(changes[<span class="number">0</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(changes[<span class="number">1</span>] &amp;&amp; changes[<span class="number">0</span>])&#123; <span class="comment">// 贪心体现在这，因为10块除了找付款20的零钱没有用，所以我们优先用它</span></span><br><span class="line">                    changes[<span class="number">1</span>] --;</span><br><span class="line">                    changes[<span class="number">0</span>] --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(changes[<span class="number">0</span>] &gt;= <span class="number">3</span>) changes[<span class="number">0</span>] -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> changes[<span class="number">0</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表之合并有序链表合集</title>
    <url>/2022/08/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1, list2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">if</span> list1.val&lt;=list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>



<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><h5 id="顺序合并"><a href="#顺序合并" class="headerlink" title="顺序合并"></a>顺序合并</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个变量 ans 来维护以及合并的链表，第 i次循环把第 i 个链表和 ans 合并，答案保存到 ans 中。</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* ans=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>;i&lt;lists.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans = <span class="built_in">mergeTwoLists</span>(ans,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="分治合并"><a href="#分治合并" class="headerlink" title="分治合并"></a>分治合并</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid =(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists,l,mid),<span class="built_in">merge</span>(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span> &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1 &amp;&amp; list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 &amp;&amp; list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">//上面三行等价于 if(!list1 || !list2) return l1?l1:l2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,lists, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left&gt;right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> left == right:    <span class="keyword">return</span> lists[left]</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        l1 = self.merge(lists, left, mid)</span><br><span class="line">        l2 = self.merge(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(l1, l2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1, list2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">if</span> list1.val&lt;=list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>链表之新颖题合集</title>
    <url>/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/e1.png" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[<span class="comment">[7,null]</span>,<span class="comment">[13,0]</span>,<span class="comment">[11,4]</span>,<span class="comment">[10,2]</span>,<span class="comment">[1,0]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[7,null]</span>,<span class="comment">[13,0]</span>,<span class="comment">[11,4]</span>,<span class="comment">[10,2]</span>,<span class="comment">[1,0]</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/e2.png" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[[1,1],[2,1]]</span></span><br><span class="line">输出：<span class="string">[[1,1],[2,1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/e3.png" alt="img"></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[[3,null],[3,0],[3,null]]</span></span><br><span class="line">输出：<span class="string">[[3,null],[3,0],[3,null]]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;Node*, Node*&gt; mp;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(head)) &#123; <span class="comment">// head 没出现过</span></span><br><span class="line">            Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(head -&gt; val);</span><br><span class="line">            mp[head] = headNew;</span><br><span class="line">            headNew -&gt; next = <span class="built_in">copyRandomList</span>(head -&gt; next);</span><br><span class="line">            headNew -&gt; random = <span class="built_in">copyRandomList</span>(head -&gt; random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p><img src="/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/bstdlloriginalbst.png" alt="img"></p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p><img src="/2022/11/17/%E9%93%BE%E8%A1%A8%E4%B9%8B%E6%96%B0%E9%A2%96%E9%A2%98%E5%90%88%E9%9B%86/bstdllreturndll.png" alt="img"></p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        head -&gt; left = tail;</span><br><span class="line">        tail -&gt; right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* tail = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root -&gt; left);</span><br><span class="line"></span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(root -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(!head) head = newNode;</span><br><span class="line">        <span class="keyword">if</span>(pre) pre -&gt; right = newNode;</span><br><span class="line">        newNode -&gt; left = pre;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        pre = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表之链表排序合集</title>
    <url>/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><a href="https://leetcode.cn/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h3><p>给定单个链表的头 <code>head</code> ，使用 <strong>插入排序</strong> 对链表进行排序，并返回 <em>排序后链表的头</em> 。</p>
<p><strong>插入排序</strong> 算法的步骤:</p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<p>下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。</p>
<p>对链表进行插入排序。</p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/Insertion-sort-example-300px.gif" alt="img"></p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/sort1linked-list.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4,2,1,3</span>]</span><br><span class="line">输出: [<span class="number">1,2,3,4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/sort2linked-list.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: head = [-<span class="number">1,5,3,4</span>,<span class="number">0</span>]</span><br><span class="line">输出: [-<span class="number">1,0,3,4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数在 <code>[1, 5000]</code>范围内</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            ListNode* pre = dummyHead;</span><br><span class="line">            <span class="keyword">while</span>(pre -&gt; next &amp;&amp; pre -&gt; next -&gt; val &lt; head -&gt; val) pre = pre -&gt; next;</span><br><span class="line">            ListNode* h = head;</span><br><span class="line">            head = head -&gt; next; <span class="comment">// 已排好序的节点下一个原来指向head， head = head -&gt; next 后就指向head -&gt; next</span></span><br><span class="line">            h -&gt; next = pre -&gt; next;</span><br><span class="line">            pre -&gt; next = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/sort_list_1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">4,2,1,3</span>]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/sort_list_2.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [-<span class="number">1,5,3,4</span>,<span class="number">0</span>]</span><br><span class="line">输出：[-<span class="number">1,0,3,4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode * p = dummy;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(head -&gt; val);</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stable_sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem: temp)&#123;</span><br><span class="line">            p -&gt; next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(elem, <span class="literal">nullptr</span>);</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h3><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="symbol">L0</span> → <span class="symbol">L1</span> → … → <span class="built_in">Ln</span> - <span class="number">1</span> → <span class="built_in">Ln</span></span><br></pre></td></tr></table></figure>

<p>请将其重新排列后变为：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="symbol">L0</span> → <span class="built_in">Ln</span> → <span class="symbol">L1</span> → <span class="built_in">Ln</span> - <span class="number">1</span> → <span class="symbol">L2</span> → <span class="built_in">Ln</span> - <span class="number">2</span> → …</span><br></pre></td></tr></table></figure>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/1626420311-PkUiGI-image.png" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">1,4,2,3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/07/%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/1626420320-YUiulT-image.png" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[1,5,2,4,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为 <code>[1, 5 * 104]</code></li>
<li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><ul>
<li>先将表节点依次入数组，再利用数组下标找到相应元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; temp;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(p);</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = temp.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            temp[i] -&gt; next = temp[j];</span><br><span class="line">            i ++;</span><br><span class="line">            temp[j] -&gt; next = temp[i];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        temp[i] -&gt; next = <span class="literal">nullptr</span>;  <span class="comment">// 最后一个总是 i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表逆置合集</title>
    <url>/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/rev1ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/rev1ex2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head -&gt; next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* res = <span class="built_in">reverseList</span>(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        <span class="comment">// 用例：1-&gt;2-&gt;3</span></span><br><span class="line">        <span class="comment">// 返回3</span></span><br><span class="line">        <span class="comment">// 3-&gt;2-&gt;null</span></span><br><span class="line">        <span class="comment">// 3-&gt;2-&gt;1-&gt;null</span></span><br><span class="line">        head -&gt; next = <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,3,2]</span></span><br><span class="line">输出：<span class="comment">[2,3,1]</span></span><br></pre></td></tr></table></figure>



<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">reversePrint</span>(head -&gt; next);</span><br><span class="line">        res.<span class="built_in">push_back</span>(head -&gt; val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/rev2ex2.jpg" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="selector-attr">[1,2,3,4,5]</span>, <span class="attribute">left</span> = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：<span class="selector-attr">[1,4,3,2,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="selector-attr">[5]</span>, <span class="attribute">left</span> = <span class="number">1</span>, right = <span class="number">1</span></span><br><span class="line">输出：<span class="selector-attr">[5]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/image-20221107183715429.png" alt="image-20221107183715429"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 头插法， 每次将遍历到的节点插入到 left节点左侧</span></span><br><span class="line">    <span class="comment">// 1-&gt; 2 -&gt;3-&gt;4-&gt;5  翻转2-4</span></span><br><span class="line">    <span class="comment">// 1-&gt; 3 -&gt;2-&gt;4-&gt;5</span></span><br><span class="line">    <span class="comment">// 1-&gt; 4 -&gt;3-&gt;2-&gt;5</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// dummyHead 是为了让 pre 不为空</span></span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        ListNode* pre = dummyHead;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* nxt = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 left处的节点，即为cur， pre一直是left前不用换的那个节点， nxt是cur后的节点， cur和nxt会不停变换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; left; i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            nxt = cur -&gt; next; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次把 nxt 头插进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i ++)&#123;</span><br><span class="line">            cur -&gt; next = nxt -&gt; next;</span><br><span class="line">            nxt -&gt; next = pre -&gt; next;</span><br><span class="line">            pre -&gt; next = nxt;</span><br><span class="line">            nxt = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/swap_ex1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">2,1,4,3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">迭代：</span></span><br><span class="line"><span class="comment">创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">temp.next = node2</span></span><br><span class="line"><span class="comment">node1.next = node2.next</span></span><br><span class="line"><span class="comment">node2.next = node1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp = node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(temp -&gt; next &amp;&amp; temp -&gt; next -&gt; next)&#123;</span><br><span class="line">            ListNode* a = temp -&gt; next;</span><br><span class="line">            ListNode* b = temp -&gt; next -&gt; next;</span><br><span class="line">            a -&gt; next = b -&gt; next;</span><br><span class="line">            b -&gt; next = a;</span><br><span class="line">            temp -&gt; next = b;</span><br><span class="line">            temp = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>递归</li>
</ul>
<img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/image-20221105224311896.png" alt="image-20221105224311896" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* a = head -&gt; next;</span><br><span class="line">        ListNode* b = head -&gt; next -&gt; next;</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="built_in">swapPairs</span>(b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/reverse_ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%E5%90%88%E9%9B%86/reverse_ex2.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中的节点数目为 <code>n</code></li>
<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* prev = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            len ++;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; len / k; i ++)&#123;</span><br><span class="line">            pair&lt;ListNode*,ListNode*&gt; p = <span class="built_in">reverse</span>(curr, k);</span><br><span class="line">            prev -&gt; next = p.first;</span><br><span class="line">            curr -&gt; next = p.second;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ListNode*,ListNode*&gt; <span class="title">reverse</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span>&#123; <span class="comment">//返回翻转后的 &lt;新头节点，原来尾部下一个节点&gt; </span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> &#123;head, head -&gt; next&#125;;</span><br><span class="line">        pair&lt;ListNode*,ListNode*&gt; res = <span class="built_in">reverse</span>(head -&gt; next, --k);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445</title>
    <url>/2022/10/21/CMU-15-445/</url>
    <content><![CDATA[<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p><img src="/2022/10/21/CMU-15-445/image-20221129144502012.png" alt="image-20221129144502012"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/01-introduction.pdf">01-introduction.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">88K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/02-advancedsql.pdf">02-advancedsql.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">107K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/03-storage1.pdf">03-storage1.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">68K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/04-storage2.pdf">04-storage2.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">290K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/05-bufferpool.pdf">05-bufferpool.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">256K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/06-hashtables.pdf">06-hashtables.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">76K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/07-trees.pdf">07-trees.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">255K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/08-indexconcurrency.pdf">08-indexconcurrency.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">77K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/09-sorting.pdf">09-sorting.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">118K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/10-joins.pdf">10-joins.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">163K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/11-queryexecution1.pdf">11-queryexecution1.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">770K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/12-queryexecution2.pdf">12-queryexecution2.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">677K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/13-optimization1.pdf">13-optimization1.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">628K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/14-optimization2.pdf">14-optimization2.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">839K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/15-concurrencycontrol.pdf">15-concurrencycontrol.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">89K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/16-twophaselocking.pdf">16-twophaselocking.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">89K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/17-timestampordering.pdf">17-timestampordering.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">86K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/18-multiversioning.pdf">18-multiversioning.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">59K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/19-logging.pdf">19-logging.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">284K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/20-recovery.pdf">20-recovery.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">451K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/21-distributed.pdf">21-distributed.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">454K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/22-distributedoltp.pdf">22-distributedoltp.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">67K</td>
</tr>
<tr>
<td><img src="https://15445.courses.cs.cmu.edu/icons/layout.gif" alt="[   ]"></td>
<td><a href="https://15445.courses.cs.cmu.edu/fall2021/notes/23-distributedolap.pdf">23-distributedolap.pdf</a></td>
<td>2022-01-07 10:55</td>
<td align="left">268K</td>
</tr>
</tbody></table>
<h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><h4 id="01-introduction"><a href="#01-introduction" class="headerlink" title="01 - introduction"></a>01 - introduction</h4><h5 id="1-Databases"><a href="#1-Databases" class="headerlink" title="1 Databases"></a>1 Databases</h5><p>数据库是一个可以模拟真实世界的某些方面的有组织的, 相互关联的数据的集合</p>
<p>数据库与数据库管理系统(DBMS, 如MySQL, Oracle, MongoDB)不同.   DBMS是管理数据库的软件</p>
<h5 id="2-Flat-File-Strawman"><a href="#2-Flat-File-Strawman" class="headerlink" title="2 Flat File Strawman"></a>2 Flat File Strawman</h5><p>没有数据库之前,我们用简单的文件存储数据,有几个问题 (用开发音乐软件举例) :</p>
<ul>
<li>Data Integrity 数据完整性</li>
</ul>
<blockquote>
<p> – How do we ensure that the artist is the same for each album entry? </p>
<p>– What if somebody overwrites the album year with an invalid string? </p>
<p>– How do we treat multiple artists on one album? </p>
<p>– What happens when we delete an artist with an album? </p>
</blockquote>
<ul>
<li>Implementation 实现</li>
</ul>
<blockquote>
<p>– How do we find a particular record? </p>
<p>– What if we now want to create a new application that uses the same database? </p>
<p>– What if two threads try to write to the same file at the same time? </p>
</blockquote>
<ul>
<li>Durability 持久性</li>
</ul>
<blockquote>
<p>– What if the machine crashes while our program is updating a record? </p>
<p>– What if we want to replicate the database on multiple machines for high availability?</p>
</blockquote>
<h5 id="3-DBMS"><a href="#3-DBMS" class="headerlink" title="3 DBMS"></a>3 DBMS</h5><p>DBMS用于定义、创建、查询、更新和管理数据库</p>
<p>DBMS很难构建和维护，因为逻辑层和物理层之间存在紧密耦合。</p>
<p>逻辑层描述数据库具有哪些实体和属性，而物理层是那些实体和属性被存储的方式。在早期，物理层被定义在应用软件中，如果我们想</p>
<p>更改应用程序正在使用的物理层，我们必须更改所有代码以匹配新的物理层。</p>
<h5 id="4-Relational-Model-关系模型"><a href="#4-Relational-Model-关系模型" class="headerlink" title="4 Relational Model 关系模型"></a>4 Relational Model 关系模型</h5><p>Ted Codd注意到，每当人们想要更改物理层时，他们都会重写DBMS，因此在1970年，他提出了关系模型来避免这种情况。</p>
<p>这个关系模型有三个关键点:</p>
<ul>
<li><p>将数据库存储在简单的数据结构(关系)中。</p>
</li>
<li><p>通过高级语言访问数据。</p>
</li>
<li><p>待实现的物理存储。</p>
</li>
</ul>
<blockquote>
<p><em>数据模型(Data Model)</em>	是用于描述数据库中数据的概念的集合。关系模型是一个数据模型的示例。</p>
<p><em>架构(Schema)</em>	给定数据模型下对特定的数据集的描述</p>
</blockquote>
<p>关系数据模型定义了三个概念:</p>
<ul>
<li><p>结构:关系及其内容的定义。</p>
</li>
<li><p>完整性:确保数据库的内容满足约束。一个约束的例子是year属性的任何值都必须是一个数字。</p>
</li>
<li><p>操作:如何访问和修改数据库的内容。</p>
</li>
</ul>
<blockquote>
<p> <em>关系</em>	是包含表示实体的属性关系的无序集。关系是无序的，DBMS可以以任何它想要的方式存储它们，允许优化。</p>
<p> <em>元组(Tuple)</em>	是关系中的一组属性值(也称为它的域)。每个属性都可以是特殊的value, NULL，这意味着对于给定的元组，属性是未定义的。</p>
<p> <em>n-ary关系</em>	具有n个属性的关系称为n-ary关系。</p>
<p> <em>主键</em>	关系的主键唯一标识单个元组。一些dbms自动创建一个内部主键如果你没定义的话</p>
<p> <em>外键</em>	指定一个关系中的属性必须映射到另一个关系中的元组（若不想加一列外键，可以使用中间表使两表关联）</p>
<p> <img src="/2022/10/21/CMU-15-445/image-20221126150705702.png" alt="image-20221126150705702"></p>
</blockquote>
<h5 id="5-数据操作语言-DML"><a href="#5-数据操作语言-DML" class="headerlink" title="5 数据操作语言(DML)"></a>5 数据操作语言(DML)</h5><p>DML增删改查</p>
<p>从数据库中存储和检索信息的语言。有两类:</p>
<ul>
<li>过程性(Procedural)	查询指定了DBMS应该使用的(高级)策略来查找所需的数据结果。</li>
<li>非过程性(Non-Procedural)	查询只指定需要什么数据，而不指定如何查找它</li>
</ul>
<h5 id="6-Relational-Algebra"><a href="#6-Relational-Algebra" class="headerlink" title="6 Relational Algebra"></a>6 Relational Algebra</h5><p>关系代数是一组用于检索和操作关系中的元组的基本操作。</p>
<p>每一个运算符接受一个或多个关系作为输入，并输出一个新的关系。</p>
<p>Relational algebra is a procedural language because it defines the high level-steps of how to compute a query.</p>
<p>关系代数属于过程性DMLs</p>
<h6 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126152217857.png" alt="image-20221126152217857"></p>
<h6 id="Projection-投影"><a href="#Projection-投影" class="headerlink" title="Projection 投影"></a>Projection 投影</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126152432928.png" alt="image-20221126152432928"></p>
<h6 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h6><p>SQL中UNION ALL是不去重的， UNION是去重的</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126152821267.png" alt="image-20221126152821267"></p>
<h6 id="Intersection"><a href="#Intersection" class="headerlink" title="Intersection"></a>Intersection</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126154835998.png" alt="image-20221126154835998"></p>
<h6 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126153116649.png" alt="image-20221126153116649"></p>
<h6 id="Product-笛卡尔积"><a href="#Product-笛卡尔积" class="headerlink" title="Product 笛卡尔积"></a>Product 笛卡尔积</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126153619080.png" alt="image-20221126153619080"></p>
<h6 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126154721724.png" alt="image-20221126154721724"></p>
<h5 id="相关词汇"><a href="#相关词汇" class="headerlink" title="* 相关词汇"></a>* 相关词汇</h5><p>plagiarize   [ˈpleɪdʒəraɪz]	v.剽窃,抄袭</p>
<p>manipulate	v.操作</p>
<p>coordinate 	v. 协调,配合</p>
<p>formula	n.公式</p>
<p>fledged	adj.成熟的</p>
<p>redundant	adj.多余的</p>
<p>internal	n.内部结构</p>
<p>inter-related 	adj.相互关联的</p>
<p>coupling	n.耦合</p>
<p>procedural	adj.程序上的,过程上的</p>
<p>algebra	n.代数</p>
<h4 id="02-Advanced-SQL"><a href="#02-Advanced-SQL" class="headerlink" title="02 - Advanced SQL"></a>02 - Advanced SQL</h4><h5 id="1-关系语言"><a href="#1-关系语言" class="headerlink" title="1 关系语言"></a>1 关系语言</h5><p>SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。</p>
<p>SQL 是关系型数据库的标准语言，所有的关系型数据库管理系统（RDBMS），比如 MySQL、Oracle、SQL Server、MS Access、Sybase、Informix、Postgres 等，都将 SQL 作为其标准处理语言。</p>
<blockquote>
<p>  此外，SQL 也有一些变种，就像中文有很多方言，比如：</p>
<ul>
<li><p>微软的 SQL Server 使用 T-SQL；</p>
</li>
<li><p>Oracle 使用 PL&#x2F;SQL；</p>
</li>
<li><p>微软 Access 版本的 SQL 被称为 JET SQL（本地格式）。</p>
</li>
</ul>
</blockquote>
<p>关系代数基于集合(无序的，无重复的)。SQL基于包(无序的，有重复)。</p>
<h5 id="2-SQL-History"><a href="#2-SQL-History" class="headerlink" title="2 SQL History"></a>2 SQL History</h5><p>SQL是关系数据库的声明式查询语言。它最初是在20世纪70年代作为IBM系统R项目。IBM最初将其称为“SEQUEL”(结构化英语查询语言)</p>
<p>在20世纪80年代被改为“SQL”(结构化查询语言)。</p>
<p>该语言由不同的命令类组成:</p>
<ol>
<li><p>数据操作语言(DML): SELECT、INSERT、UPDATE和DELETE语句。</p>
</li>
<li><p>数据定义语言(DDL):表、索引、视图和其他对象的模式定义。</p>
</li>
<li><p>数据控制语言(DCL):安全、访问控制。</p>
</li>
</ol>
<h5 id="EXAMPLE-DATABASE"><a href="#EXAMPLE-DATABASE" class="headerlink" title="*EXAMPLE DATABASE"></a>*EXAMPLE DATABASE</h5><p><img src="/2022/10/21/CMU-15-445/image-20221126165715230.png" alt="image-20221126165715230"></p>
<h5 id="3-Joins"><a href="#3-Joins" class="headerlink" title="3 Joins"></a>3 Joins</h5><p>略</p>
<h5 id="4-Aggregates"><a href="#4-Aggregates" class="headerlink" title="4 Aggregates"></a>4 Aggregates</h5><p><img src="/2022/10/21/CMU-15-445/image-20221126170427679.png" alt="image-20221126170427679"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126171336292.png" alt="image-20221126171336292"></p>
<p>这里三种方式都可以 		</p>
<p>count(login) : 数一下login列不为NULL的个数</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126171811548.png" alt="image-20221126171811548"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126171853396.png" alt="image-20221126171853396"></p>
<h6 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126172953811.png" alt="image-20221126172953811"></p>
<h6 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126173321903.png" alt="image-20221126173321903"></p>
<h5 id="5-String-Operations"><a href="#5-String-Operations" class="headerlink" title="5 String Operations"></a>5 String Operations</h5><h6 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126183425213.png" alt="image-20221126183425213"></p>
<h6 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126183445170.png" alt="image-20221126183445170"></p>
<h6 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126183638923.png" alt="image-20221126183638923"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126183903013.png" alt="image-20221126183903013"></p>
<h5 id="6-Date-and-Time"><a href="#6-Date-and-Time" class="headerlink" title="6 Date and Time"></a>6 Date and Time</h5><p>略</p>
<h5 id="7-Output-Redirection"><a href="#7-Output-Redirection" class="headerlink" title="7 Output Redirection"></a>7 Output Redirection</h5><p>使用输出建表</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126184914697.png" alt="image-20221126184914697"></p>
<h5 id="8-Output-Control"><a href="#8-Output-Control" class="headerlink" title="8 Output Control"></a>8 Output Control</h5><h6 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h6><p><img src="/2022/10/21/CMU-15-445/image-20221126195301643.png" alt="image-20221126195301643"></p>
<h6 id="LIMIT-OFFSET"><a href="#LIMIT-OFFSET" class="headerlink" title="LIMIT[OFFSET]"></a>LIMIT[OFFSET]</h6><p>控制输出的行数[从第几行开始] <img src="/2022/10/21/CMU-15-445/image-20221126200016823.png" alt="image-20221126200016823"></p>
<h5 id="9-Nested-Queries-子查询"><a href="#9-Nested-Queries-子查询" class="headerlink" title="9 Nested Queries 子查询"></a>9 Nested Queries 子查询</h5><p><img src="/2022/10/21/CMU-15-445/image-20221126200751882.png" alt="image-20221126200751882"></p>
<p>完整语句</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126201853412.png" alt="image-20221126201853412"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126201829520.png" alt="image-20221126201829520"></p>
<p>子查询与AGGREGATION</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126203129067.png" alt="image-20221126203129067"></p>
<p>Example：</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126204106867.png" alt="image-20221126204106867"></p>
<h5 id="10-Window-Functions-窗口函数"><a href="#10-Window-Functions-窗口函数" class="headerlink" title="10 Window Functions 窗口函数"></a>10 Window Functions 窗口函数</h5><p><img src="/2022/10/21/CMU-15-445/image-20221126204610372.png" alt="image-20221126204610372"></p>
<p>FUNC()可以是聚合函数或ROW_NUMBER()或RANK()</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126205134154.png" alt="image-20221126205134154"></p>
<p>OVER()内可以用PARTITION BY 或者 ORDER BY</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126205922481.png" alt="image-20221126205922481"></p>
<p>Example:</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126211552775.png" alt="image-20221126211552775"></p>
<h5 id="11-Common-Table-Expressions"><a href="#11-Common-Table-Expressions" class="headerlink" title="11 Common Table Expressions"></a>11 Common Table Expressions</h5><p>视图，也相当于临时表</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126212830492.png" alt="image-20221126212830492"></p>
<p>Example1：临时创建一个cteSource表, 有一列maxId, maxId是已经注册的最大的学号。然后内连接（等值连接）两表【笛卡尔积】…</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126213326265.png" alt="image-20221126213326265"></p>
<p>Example2:</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221126214852172.png" alt="image-20221126214852172"></p>
<h5 id="相关词汇-1"><a href="#相关词汇-1" class="headerlink" title="* 相关词汇"></a>* 相关词汇</h5><p>无</p>
<h4 id="03-Database-Storage-Part-I"><a href="#03-Database-Storage-Part-I" class="headerlink" title="03 - Database Storage (Part I)"></a>03 - Database Storage (Part I)</h4><h5 id="1-Storage"><a href="#1-Storage" class="headerlink" title="1 Storage"></a>1 Storage</h5><p>数据库组成部分由上而下：</p>
<blockquote>
<p>  Query Planning 查询规划<br>  Operator Execution 操作执行<br>  Access Methods 存取方法<br>  Buffer Pool Manager 缓冲池管理器<br>  <strong>Disk Manager 磁盘管理</strong> </p>
</blockquote>
<p>DBMS假定主存储数据库位于非易失性磁盘上, 但一切操作性的行为都发生在内存中</p>
<blockquote>
<p>  存储等级（速度由慢到快，容量由大到小）：</p>
<p>  <em><strong>非易失性：Network Storage -&gt; HDD(本地机械磁盘) -&gt; SSD(固态硬盘)</strong></em> -&gt; </p>
<p>  易失性，但支持随机访问：DRAM(内存) -&gt; CPU Caches(CPU高速缓存) -&gt; CPU寄存器</p>
<p>  <img src="/2022/10/21/CMU-15-445/image-20221127152344622.png" alt="image-20221127152344622"></p>
</blockquote>
<h6 id="一个好的DBMS要实现的目标"><a href="#一个好的DBMS要实现的目标" class="headerlink" title="一个好的DBMS要实现的目标"></a>一个好的DBMS要实现的目标</h6><p>允许DBMS管理超过可用的内存量。</p>
<p>读&#x2F;写磁盘是昂贵的，所以必须如此小心地避开大型存储和性能下降。</p>
<p>对磁盘的随机访问通常要比顺序访问慢得多，所以DBMS想要最大化顺序访问</p>
<h5 id="2-Disk-Oriented-DBMS-Overview"><a href="#2-Disk-Oriented-DBMS-Overview" class="headerlink" title="2 Disk-Oriented DBMS Overview"></a>2 Disk-Oriented DBMS Overview</h5><p>Disk-Oriented DBMS  即面向硬盘的数据库管理系统，数据最后都是要存到硬盘里的</p>
<blockquote>
<p>  Memory-Oriented DBMS 存在内存里比如Redis，断电就没了</p>
</blockquote>
<p><img src="/2022/10/21/CMU-15-445/image-20221127155442235.png" alt="image-20221127155442235"></p>
<p>内存只给该DBMS分配那么多空间，但数据库文件在磁盘中很大</p>
<h5 id="3-DBMS-vs-OS"><a href="#3-DBMS-vs-OS" class="headerlink" title="3 DBMS vs. OS"></a>3 DBMS vs. OS</h5><p>为什么不使用mmap方法？</p>
<p>因为一旦内存满了，OS不知道该替换哪一页了</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127155956397.png" alt="image-20221127155956397"></p>
<h6 id="不要将任何事交给OS！"><a href="#不要将任何事交给OS！" class="headerlink" title="不要将任何事交给OS！"></a>不要将任何事交给OS！</h6><p><img src="/2022/10/21/CMU-15-445/image-20221127160329549.png" alt="image-20221127160329549"></p>
<h5 id="4-数据库存储两大问题"><a href="#4-数据库存储两大问题" class="headerlink" title="4 数据库存储两大问题"></a>4 数据库存储两大问题</h5><ol>
<li><p>DBMS怎么将数据库表达成在磁盘上的文件的格式？</p>
</li>
<li><p>DBMS如何管理内存并将数据写回磁盘？</p>
</li>
</ol>
<h5 id="5-解决第一个问题"><a href="#5-解决第一个问题" class="headerlink" title="5 解决第一个问题"></a>5 解决第一个问题</h5><ol>
<li><p>File Storage</p>
<p>DBMS将数据库存储为一个或多个文件在磁盘上，通常以专有格式的内容，操作系统不知道这些文件</p>
<ul>
<li><p>Database Pages</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127164010365.png" alt="image-20221127164010365"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127163343193.png" alt="image-20221127163343193"></p>
</li>
<li><p>Database Heap</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127164550741.png" alt="image-20221127164550741"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127165147686.png" alt="image-20221127165147686"></p>
<p>Heap File 的两种实现方案</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127165644342.png" alt="image-20221127165644342"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127165908044.png" alt="image-20221127165908044"></p>
</li>
</ul>
</li>
<li><p>Page Layout</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127170233806.png" alt="image-20221127170233806"></p>
<p>Page中Data的组织架构</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127171023844.png" alt="image-20221127171023844"></p>
<p>Tuple-oriented：slot相当于索引，slot有序，后面Tuple可以是乱的；Record id就等于pageid + slot</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127171501966.png" alt="image-20221127171501966"></p>
<p>Log-Structered: 会定时压缩，方便更新，不方便读</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127184815211.png" alt="image-20221127184815211"></p>
</li>
<li><p>Tuple Layout</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127172453560.png" alt="image-20221127172453560"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127172609365.png" alt="image-20221127172609365"></p>
</li>
</ol>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h5><p>Database is organized in pages.</p>
<p>Different ways to track pages.（链表&#x2F; 目录）</p>
<p>Different ways to store pages.（<strong>Tuple形式【Slotted】</strong>&#x2F; Log形式【记录每次修改的信息】）</p>
<p>Different ways to store tuples.（就说了一种，见Tuple Layout）</p>
<h4 id="04-Database-Storage-Part-II"><a href="#04-Database-Storage-Part-II" class="headerlink" title="04 - Database Storage (Part II)"></a>04 - Database Storage (Part II)</h4><h5 id="1-Data-Representation"><a href="#1-Data-Representation" class="headerlink" title="1 Data Representation"></a>1 Data Representation</h5><p><img src="/2022/10/21/CMU-15-445/image-20221127190733089.png" alt="image-20221127190733089"></p>
<p>系统目录：数据库的元数据都是一张张存在INFORMATION_SCHEMA中的表</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221127195124897.png" alt="image-20221127195124897"></p>
<h5 id="2-Workloads"><a href="#2-Workloads" class="headerlink" title="2 Workloads"></a>2 Workloads</h5><p><img src="/2022/10/21/CMU-15-445/image-20221127195805260.png" alt="image-20221127195805260"></p>
<p>OLTP专注于写， OLAP专注于读</p>
<img src="/2022/10/21/CMU-15-445/image-20221127201203980.png" alt="image-20221127201203980" style="zoom: 150%;">

<p><img src="/2022/10/21/CMU-15-445/image-20221127203047508.png" alt="image-20221127203047508"></p>
<h5 id="3-Storage-Models"><a href="#3-Storage-Models" class="headerlink" title="3 Storage Models"></a>3 Storage Models</h5><h6 id="N-Ary-Storage-Model-NSM"><a href="#N-Ary-Storage-Model-NSM" class="headerlink" title="N-Ary Storage Model (NSM)"></a>N-Ary Storage Model (NSM)</h6><p>在n元存储模型中，DBMS将单个元组的所有属性连续地存储在单个页面中，因此NSM也被称为“行存储”。</p>
<p>这种方法非常适合OLTP工作负载，其中请求插入量大，事务往往只操作单个实体。它是理想的，因为它只需要一次获取就可以获得单个元组的所有属性。</p>
<p>优点：</p>
<ul>
<li><p>快速插入、更新和删除</p>
</li>
<li><p>适合需要整个元组的查询。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适合扫描表的大部分（比如我们仅需要ID，却要一行行的扫描）或属性的子集。这是因为它会获取处理查询不需要的数据</li>
</ul>
<p><img src="/2022/10/21/CMU-15-445/image-20221127204852016.png" alt="image-20221127204852016"></p>
<h6 id="Decomposition-Storage-Model-DSM"><a href="#Decomposition-Storage-Model-DSM" class="headerlink" title="Decomposition Storage Model (DSM)"></a>Decomposition Storage Model (DSM)</h6><p><strong>不同的页，存不同的列。</strong>因此，它也被称为“列存储”。</p>
<p>此模型非常适合OLAP工作负载许多只读查询在表的属性子集上执行大型扫描。</p>
<p>优点:</p>
<ul>
<li><p>减少查询执行过程中浪费的工作量，因为DBMS只读取数据查询所需的。</p>
</li>
<li><p>支持更好的压缩，因为相同属性的所有值都是连续存储的。</p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>由于元组分裂&#x2F;拼接，点查询、插入、更新和删除速度较慢。</li>
</ul>
<p><img src="/2022/10/21/CMU-15-445/image-20221127205756775.png" alt="image-20221127205756775"></p>
<h4 id="05-Buffer-Pools"><a href="#05-Buffer-Pools" class="headerlink" title="05 - Buffer Pools"></a>05 - Buffer Pools</h4><p>解决第二个问题：DBMS如何管理内存并将数据写回磁盘？</p>
<p>答：使用缓存池，读时要将附近的数据缓存下来，要写时写入缓存池，一定数量后统一写入磁盘</p>
<h5 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h5><p><img src="/2022/10/21/CMU-15-445/image-20221128151409816.png" alt="image-20221128151409816"></p>
<p>页表记录着该页是否被修改，引用数量</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221128153339671.png" alt="image-20221128153339671"></p>
<h5 id="2-Locks-vs-Latches"><a href="#2-Locks-vs-Latches" class="headerlink" title="2 Locks vs. Latches"></a>2 Locks vs. Latches</h5><p>锁:锁是一种高级的逻辑原语，它保护数据库的内容(例如，元组、表、数据库)来自其他事务。事务将在其整个持续时间内持有一个锁。数据库系统可以向用户公开运行查询时持有哪些锁。锁需要能够回滚更改。</p>
<p>插销(Mutex):DBMS用于内部数据关键部分的低级保护原语结构(例如，哈希表，内存区域)。插销只在操作期间保持。插销不需要回滚</p>
<h5 id="3-Page-Directory-vs-Page-Table"><a href="#3-Page-Directory-vs-Page-Table" class="headerlink" title="3 Page Directory vs. Page Table"></a>3 Page Directory vs. Page Table</h5><p>Page Directory 是disk中记录DB File索引的， Page Table是内存中记录页表索引的</p>
<h5 id="4-Buffer-Pool"><a href="#4-Buffer-Pool" class="headerlink" title="4 Buffer Pool"></a>4 Buffer Pool</h5><p>见上</p>
<h5 id="5-Buffer-Pool-Optimizations"><a href="#5-Buffer-Pool-Optimizations" class="headerlink" title="5 Buffer Pool Optimizations"></a>5 Buffer Pool Optimizations</h5><h6 id="Multiple-Buffer-Pools"><a href="#Multiple-Buffer-Pools" class="headerlink" title="Multiple Buffer Pools"></a>Multiple Buffer Pools</h6><p><img src="/2022/10/21/CMU-15-445/image-20221128161910488.png" alt="image-20221128161910488"></p>
<p><img src="/2022/10/21/CMU-15-445/image-20221128162031675.png" alt="image-20221128162031675"></p>
<h6 id="Pre-fetching"><a href="#Pre-fetching" class="headerlink" title="Pre-fetching"></a>Pre-fetching</h6><p>DBMS还可以根据查询计划预取页面进行优化。然后，当第一组页面是在处理过程中，第二个可以预取到缓冲池中。这种方法通常被DBMS使用按顺序访问多个页面。</p>
<h6 id="Scan-Sharing"><a href="#Scan-Sharing" class="headerlink" title="Scan Sharing"></a>Scan Sharing</h6><p>共享扫描，可能出错</p>
<h6 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h6><p>旁路缓存池：数据不进内存池，直接进内存，用完直接释放资源</p>
<h5 id="6-OS-Page-Cache"><a href="#6-OS-Page-Cache" class="headerlink" title="6 OS Page Cache"></a>6 OS Page Cache</h5><p>不仅我们的数据库对文件有缓存，操作系统对于文件也有缓存。我们要绕过OS替我们操作的缓存。</p>
<h5 id="7-Buffer-Replacement-Policies"><a href="#7-Buffer-Replacement-Policies" class="headerlink" title="7 Buffer Replacement Policies"></a>7 Buffer Replacement Policies</h5><p>当DBMS需要释放一个帧来为新页腾出空间时，它必须决定从缓冲池释放一个frame</p>
<p>替换策略的实现目标是改进正确性、准确性、速度和元数据开销</p>
<h6 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h6><h6 id="CLOCK算法"><a href="#CLOCK算法" class="headerlink" title="CLOCK算法"></a>CLOCK算法</h6><p>假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串：1,3,4,2,5,6,3,4,7                                   </p>
<p>第一步：刚开始先将前五个页面装入五个物理块，这时五个页面均已被访问过，所以访问位置为1</p>
<p><img src="/2022/10/21/CMU-15-445/image-20221128165844020.png" alt="image-20221128165844020">                       </p>
<p>第二步：访问到6号页，需要换出一个页面。开始进行扫描，扫描一圈后，物理块中的五个页面的访问位全都置0<img src="/2022/10/21/CMU-15-445/image-20221128165908751.png" alt="image-20221128165908751"></p>
<p> 第三步：再进行第二轮扫描，1号页（0）淘汰，6号页进来并且将6号页访问位置为1，扫描页指针指向下一位</p>
<p> <img src="/2022/10/21/CMU-15-445/image-20221128165927882.png" alt="image-20221128165927882"></p>
<p>第四步：按照访问顺序，该访问3号页和4号页，所以将3号页和4号页的访问位置为1，扫描页指针不动（因为没有淘汰）<img src="/2022/10/21/CMU-15-445/image-20221128165959830.png" alt="image-20221128165959830"></p>
<p>第五步：按照访问顺序，该访问7号页，7号页没有在物理块中，所以需要淘汰一个页面。扫描页指针从3号页开始扫描，3号页和4号页的访问位都是1，所以继续检查且将3号页和4号页的访问位置为0。2号页的访问位是0，淘汰。7号页进入物理块置为1，指针移动到5号页<img src="/2022/10/21/CMU-15-445/image-20221128170100161.png" alt="image-20221128170100161"></p>
<h6 id="对LRU和CLOCK的改进"><a href="#对LRU和CLOCK的改进" class="headerlink" title="对LRU和CLOCK的改进"></a>对LRU和CLOCK的改进</h6><p>如果纯纯的顺序读写，那么LRU和CLOCK都多此一举并且每次还要检查最近未被使用的，耗时大</p>
<p>解决方法：</p>
<ul>
<li><p>LRU-K：统计最近K次的LRU替换时间，及时调整替换策略</p>
</li>
<li><p>LOCALIZATION：若两条SQL语句都执行了，第二条执行时发现缓存池里#1他俩都要用，#2#3只有自己用，那么替换时就优先替换掉#1</p>
</li>
<li><p>PRIORITY HINTS：执行器采用一些机器学习&#x2F;深度学习算法告知Buffer Pool Manager 某个帧的重要程度，让它不要轻易替换</p>
</li>
</ul>
<h6 id="Dirty-Pages算法"><a href="#Dirty-Pages算法" class="headerlink" title="Dirty Pages算法"></a>Dirty Pages算法</h6><p>若该页没脏（没被修改），则按正常替换策略替换。</p>
<p>若用户修改了该frame，则系统要维护一个修改日志，以防断电。等修改了一定次数后，统一写回内存。写回内存后要设置脏位为非脏</p>
<h5 id="8-Other-Memory-Pools"><a href="#8-Other-Memory-Pools" class="headerlink" title="8 Other Memory Pools"></a>8 Other Memory Pools</h5><p>The DBMS needs memory for things other than just tuples and indexes. These other memory pools may not always backed by disk depending on implementation.</p>
<ul>
<li>Sorting + Join Buffers </li>
<li>Query Caches</li>
<li>Maintenance Buffers</li>
<li>Log Buffers </li>
<li>Dictionary Caches</li>
</ul>
<h4 id="06-Hash-Tables"><a href="#06-Hash-Tables" class="headerlink" title="06 - Hash Tables"></a>06 - Hash Tables</h4><p><img src="/2022/10/21/CMU-15-445/image-20221129144632748.png" alt="image-20221129144632748"></p>
<h5 id="1-Data-Structures"><a href="#1-Data-Structures" class="headerlink" title="1 Data Structures"></a>1 Data Structures</h5><p>DBMS对系统内部的许多不同部分使用不同的数据结构。包括:</p>
<ul>
<li><p>内部元数据: 这是跟踪关于数据库和系统的信息的数据状态。例如:页表，页目录</p>
</li>
<li><p>核心数据存储: 数据结构被用作数据库元组的基础存储。比如Redis是KV类型的数据库,核心类型就是哈希表</p>
</li>
<li><p>临时数据结构:DBMS可以在处理数据时动态地构建数据结构查询以加速执行(例如，连接的哈希表)。</p>
</li>
<li><p>表索引: 辅助数据结构可以用来更容易地查找特定的元组。（使用哈希表&#x2F;B+树）</p>
</li>
</ul>
<p>在为DBMS实现数据结构时，有两个主要的设计决策需要考虑:</p>
<ol>
<li><p>数据组织: 我们需要弄清楚如何布局内存以及在里面存储什么信息数据结构以支持高效的访问</p>
</li>
<li><p>并发性: 我们还需要考虑如何使多个线程能够访问数据结构不会造成任何问题</p>
</li>
</ol>
<h5 id="2-Hash-Table"><a href="#2-Hash-Table" class="headerlink" title="2 Hash Table"></a>2 Hash Table</h5><p><img src="/2022/10/21/CMU-15-445/image-20221129145943417.png" alt="image-20221129145943417"></p>
<p>A hash table implementation is comprised of two parts:  哈希函数、哈希冲突</p>
<h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>（1）闭散列（开放地址法）：【线性探测法、二次探测法】<br>当我们遇到哈希冲突的时候，从当前位置的下一个开始找空位，碰到空位存进去。这种方法好存放但是难查找更加难删除</p>
<p><img src="/2022/10/21/CMU-15-445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2MjczNQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>（2）开散列：【拉链法】<br>当我们遇到哈希冲突的时候，将当前位置的元素变成一个链表或者树<br>哈希冲突较严重时<br>（1）拓容：将原来的数组拓容为更大的数组，再将元素重新取模放入新的数组中<br>（2）当链表长度到达6的时候，将链表变成树</p>
<h4 id="07-Tree-Indexes"><a href="#07-Tree-Indexes" class="headerlink" title="07 - Tree Indexes"></a>07 - Tree Indexes</h4><h5 id="1-B-Tree-famliy"><a href="#1-B-Tree-famliy" class="headerlink" title="1 B-Tree famliy"></a>1 B-Tree famliy</h5><p><img src="/2022/10/21/CMU-15-445/image-20221129162236510.png" alt="image-20221129162236510"></p>
<h5 id="2-B-Tree"><a href="#2-B-Tree" class="headerlink" title="2 B-Tree"></a>2 B-Tree</h5><ul>
<li><p>这里的 B 是 Balance（平衡）的缩写。它是一种多路的平衡搜索树。</p>
</li>
<li><p>它跟普通的平衡二叉树的不同是，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。</p>
</li>
<li><p>B树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是O(1)。</p>
</li>
<li><p>一般一棵 B 树的高度在 3 层左右，3 层就可满足百万级别的数据量</p>
</li>
</ul>
<p><img src="/2022/10/21/CMU-15-445/3b0f06b8e96a4c2d99efd59e8586f70e.png" alt="img"></p>
<ul>
<li>B树 每个节点都存储了一定的范围区间，区间更多的情况下，搜索也就更快。比如普通的二叉树对于 1~ 100 的索引值，首先分为 1~ 50 和51~ 100 两部分。而 B树可以分为四个区间 1~ 25, 26~ 50, 51~ 75, 76~ 100 。甚至可以划分为更多区间，这样一次就能排除四分之三的数据</li>
</ul>
<h5 id="3-B-Tree"><a href="#3-B-Tree" class="headerlink" title="3 B+Tree"></a>3 B+Tree</h5><p>B+树是B树的一种变种，它与 B树 的 区别 是：</p>
<ul>
<li><p>叶子节点保存了完整的索引和数据，而非叶子节点只保存索引值，因此它的查询时间固定为 log(n).</p>
</li>
<li><p>叶子节点中有指向下一个叶子节点的指针，叶子节点类似于一个单链表</p>
</li>
<li><p>正因为叶子节点保存了完整的数据以及有指针作为连接，B+树可以增加了区间访问性，提高了范围查询，而B树的范围查询相对较差</p>
</li>
<li><p>B+树更适合外部存储。因为它的非叶子节点不存储数据，只保存索引。</p>
</li>
</ul>
<p><img src="/2022/10/21/CMU-15-445/ae4649c6bbac43e9b2583ca08508a0a0.png" alt="img"></p>
<blockquote>
<p>  <strong>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n; 而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)</strong></p>
</blockquote>
<h5 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4 红黑树"></a>4 红黑树</h5><p>对于二叉搜索树，如果插入的数据是随机的，那么它就是接近平衡的二叉树，平衡的二叉树，它的操作效率（查询，插入，删除）效率较高，时间复杂度是O（logN）。但是可能会出现一种极端的情况，那就是插入的数据是有序的（递增或者递减），那么所有的节点都会在根节点的右侧或左侧，此时，二叉搜索树就变为了一个链表，它的操作效率就降低了，时间复杂度为O(N)，所以可以认为二叉搜索树的时间复杂度介于O（logN）和O(N)之间，视情况而定。</p>
<p><strong>那么为了应对这种极端情况，红黑树就出现了，它是具备了某些特性的二叉搜索树，能解决非平衡树问题，红黑树是一种接近平衡的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡）</strong></p>
<h6 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h6><p>首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>⭐️叶节点(null节点) 都是黑色，null节点的父节点在红黑树里不将其看作叶子节点</li>
<li>红色节点的子节点和父节点都是黑色，且从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点</li>
<li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>判断题：</p>
<p><img src="/2022/10/21/CMU-15-445/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5LiDbW9k,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>上面这棵树首先很容易就能知道是满足性质1-4条的，关键在于第5条性质，可能乍一看好像也是符合第5条的，但实际就会陷入一个误区，直接将图上的最后一层的节点看作叶子节点，这样看的话每一条从根节点到叶子结点的路径确实都经过了3个黑节点。</p>
<p>但实际上，在红黑树中真正被定义为叶子结点的，是那些空节点，如下：</p>
<p><img src="/2022/10/21/CMU-15-445/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5LiDbW9k,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>这样一来，路径1有4个黑色节点（算上空节点)，路径2只有3个黑色节点，这样性质5就不满足了，所以不是红黑树</p>
<h6 id="红黑树效率"><a href="#红黑树效率" class="headerlink" title="红黑树效率"></a>红黑树效率</h6><p>红黑树的查找，插入和删除操作，时间复杂度都是O(logN)</p>
<p>查找操作时，它和普通的相对平衡的二叉搜索树的效率相同，都是通过相同的方式来查找的，没有用到红黑树特有的特性。</p>
<p>**但若插入的是有序数据，那么红黑树的查询效率就比二叉搜索树要高了，因为此时二叉搜索树不是平衡树，它的时间复杂度O(N)**。</p>
<p>插入和删除操作时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉搜索树效率要低一点，不过时间复杂度仍然是O(logN)。总之，红黑树的优点就是对有序数据的查询操作不会慢到O(logN)的时间复杂度。</p>
<h6 id="红黑树与AVL树相比较"><a href="#红黑树与AVL树相比较" class="headerlink" title="红黑树与AVL树相比较"></a>红黑树与AVL树相比较</h6><ol>
<li>AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异</li>
<li>红黑树的插入删除比AVL树更便于控制操作</li>
<li>红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）</li>
</ol>
<p>08 - Index Concurrency Control</p>
<p>对索引的并发控制问题【表项索引: 使用辅助数据结构（哈希表&#x2F;B+树）可以用来更容易地查找特定的元组】</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter</title>
    <url>/2022/08/26/flutter/</url>
    <content><![CDATA[<h3 id="写flutter程序"><a href="#写flutter程序" class="headerlink" title="写flutter程序"></a>写flutter程序</h3><h4 id="Android-Studio-版本"><a href="#Android-Studio-版本" class="headerlink" title="Android Studio 版本"></a>Android Studio 版本</h4><ol>
<li>打开Android Studio 新建 Flutter 项目</li>
<li>项目放在 WorkSpace&#x2F;flutterWorkSpace&#x2F;项目名 </li>
<li>选择 Open iOS Simulator</li>
<li>debug模式运行 , 修改后代码后点击闪电图标热加载</li>
</ol>
<h3 id="编写第一个flutter程序"><a href="#编写第一个flutter程序" class="headerlink" title="编写第一个flutter程序"></a>编写第一个flutter程序</h3><ol>
<li>打开Android Studio 新建 Flutter 项目</li>
<li>pubspec文件管理Flutter应用程序的assets(资源，如图片、package等)。 在pubspec.yaml中，将english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cupertino_icons:</span> <span class="string">^0.1.0</span></span><br><span class="line">  <span class="attr">english_words:</span> <span class="string">^3.1.0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>单击右上角的 <strong>Pub get</strong>，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/jiangangkong/flutter/bin/flutter --no-color pub get</span><br><span class="line">Running <span class="string">&quot;flutter pub get&quot;</span> <span class="keyword">in</span> startup_01...                          8.0s</span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如遇到Error: Cannot run with sound null safety, because the following dependencies don’t support null safety: 则在该项目根目录终端上输入:<code>flutter run --no-sound-null-safety</code> 或者  我们可以在运行的时候添加<code>--no-sound-null-safety</code>。打开Android Studio，然后依次选择【Run】 –&gt;【 Edit Configurations】 –&gt; 【Add Additional Run args 】–&gt; 【–no-sound-null-safety】，如下图。<img src="/2022/08/26/flutter/image-20220901215621643.png" alt="image-20220901215621643"></li>
</ol>
<h3 id="设置lcon和启动画面"><a href="#设置lcon和启动画面" class="headerlink" title="设置lcon和启动画面"></a>设置lcon和启动画面</h3><p>ios:</p>
<p>在<code>ios/Runner/Assets.xcassets/AppIcon.appiconset</code>中设置lcon图片, 并修改<code>Contents.json</code></p>
<p>在<code>ios/Runner/Assets.xcassets/LaunchImage.imageset</code>中设置启动图片，并在同级别的<code>Contents.json</code>文件中配置。</p>
<h3 id="路由管理-fluro"><a href="#路由管理-fluro" class="headerlink" title="路由管理 fluro"></a>路由管理 fluro</h3><ul>
<li><code>main.dart</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;routers/routes.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;routers/application.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:fluro/fluro.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;pages/first_page.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  FluroRouter  router = FluroRouter();</span><br><span class="line">  Application.router = router; <span class="comment">//一定要先写这行</span></span><br><span class="line">  Routes.configureRoutes(router);</span><br><span class="line"></span><br><span class="line">  runApp(<span class="keyword">const</span> MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: FirstPage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>routers/application.dart</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:fluro/fluro.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">late</span> <span class="keyword">final</span> FluroRouter router;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>routers/router_handler.dart</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:fluro/fluro.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/second_page.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/first_page.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/third_page.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/fourth_page.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/fifth_page.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/error_page.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FirstPage</span></span><br><span class="line"><span class="keyword">var</span> firstPageHandler = <span class="keyword">new</span> Handler(</span><br><span class="line">    handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params)  &#123;</span><br><span class="line">      <span class="keyword">return</span> FirstPage();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecondPage</span></span><br><span class="line"><span class="keyword">var</span> secondPageHandler = <span class="keyword">new</span> Handler(</span><br><span class="line">    handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params) &#123;</span><br><span class="line">      <span class="keyword">return</span> SecondPage();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thirdPageHandler = <span class="keyword">new</span> Handler(</span><br><span class="line">    handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params)  &#123;</span><br><span class="line">      <span class="keyword">return</span> ThirdPage();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fourthPageHandler = <span class="keyword">new</span> Handler(</span><br><span class="line">    handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params) &#123;</span><br><span class="line">      <span class="keyword">return</span> FourthPage();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fifthPageHandler = <span class="keyword">new</span> Handler(</span><br><span class="line">    handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params) &#123;</span><br><span class="line">      <span class="keyword">return</span> FifthPage();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<ul>
<li><code>routers/routes.dart</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 定义请求路径以及定义路径对应的Handler</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:fluro/fluro.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;router_handler.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../pages/error_page.dart&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> page1 = <span class="string">&quot;/1&quot;</span>;  <span class="comment">//定义路由</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> page2 = <span class="string">&quot;/2&quot;</span>;  <span class="comment">//定义路由</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> page3 = <span class="string">&quot;/3&quot;</span>;  <span class="comment">//定义路由</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> page4 = <span class="string">&quot;/4&quot;</span>;  <span class="comment">//定义路由</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> page5 = <span class="string">&quot;/5&quot;</span>;  <span class="comment">//定义路由</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> configureRoutes(FluroRouter router) &#123; <span class="comment">//处理未匹配到路由时展示的页面</span></span><br><span class="line">    router.notFoundHandler = Handler(</span><br><span class="line">        handlerFunc: (BuildContext? context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; params) &#123;</span><br><span class="line">          <span class="keyword">return</span> ErrorPage();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//注册路由并指向所对应的handler(Handler对应的是界面)</span></span><br><span class="line">    router.define(page1, handler: firstPageHandler);</span><br><span class="line">    router.define(page2, handler: secondPageHandler);</span><br><span class="line">    router.define(page3, handler: thirdPageHandler);</span><br><span class="line">    router.define(page4, handler: fourthPageHandler);</span><br><span class="line">    router.define(page5, handler: fifthPageHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>pages/first_page.dart</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:fluro/fluro.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../routers/application.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FirstPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;FirstPage&gt; createState() =&gt; _FirstPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirstPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FirstPage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前选中底部导航的索引</span></span><br><span class="line">  <span class="built_in">int</span> _selectedIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    onGenerateRoute: Application.router.generator ;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 顶部应用按钮</span></span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">&#x27;第一页&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 中部内容区</span></span><br><span class="line">      <span class="comment">// body: Center(</span></span><br><span class="line">      <span class="comment">//   child:</span></span><br><span class="line">      <span class="comment">// ),</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 底部导航</span></span><br><span class="line">      bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">        items: [</span><br><span class="line">          BottomNavigationBarItem(icon: Icon(Icons.account_tree_rounded), label:<span class="string">&#x27;UPCOMING&#x27;</span>),</span><br><span class="line">          BottomNavigationBarItem(icon: Icon(Icons.add_chart_outlined), label:<span class="string">&#x27;RESULTS&#x27;</span>),</span><br><span class="line">          BottomNavigationBarItem(icon: Icon(Icons.add_box_sharp), label:<span class="string">&#x27;FIGHT PASS&#x27;</span>),</span><br><span class="line">          BottomNavigationBarItem(icon: Icon(Icons.abc_sharp), label:<span class="string">&#x27;NEWS&#x27;</span>),</span><br><span class="line">          BottomNavigationBarItem(icon: Icon(Icons.accessibility_outlined), label:<span class="string">&#x27;ATHLETES&#x27;</span>),</span><br><span class="line">        ],</span><br><span class="line">        type: BottomNavigationBarType.fixed, <span class="comment">// 页面超过三个要加这句话, 不然除了正在访问的页面,其他页面导航栏全白</span></span><br><span class="line">        unselectedFontSize: <span class="number">12</span>,</span><br><span class="line">        selectedFontSize: <span class="number">12</span>,</span><br><span class="line">        iconSize: <span class="number">28</span>,</span><br><span class="line">        currentIndex: _selectedIndex,</span><br><span class="line">        fixedColor: Color.fromRGBO(<span class="number">221</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        onTap: _onItemTapped,</span><br><span class="line">        unselectedItemColor: Colors.white,</span><br><span class="line">        backgroundColor: Colors.black87</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onItemTapped(<span class="built_in">int</span> index)&#123;</span><br><span class="line">    Application.router.navigateTo(</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">&quot;/<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>&quot;</span>,</span><br><span class="line">        transition: TransitionType.fadeIn <span class="comment">// 动画</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="状态管理-provider"><a href="#状态管理-provider" class="headerlink" title="状态管理 provider"></a>状态管理 provider</h3><h4 id="短时状态-与-应用状态"><a href="#短时状态-与-应用状态" class="headerlink" title="短时状态 与 应用状态"></a>短时状态 与 应用状态</h4><p>短时状态（有时也称 <strong>用户界面 (UI) 状态</strong> 或者 <strong>局部状态</strong>）是你可以完全包含在一个独立 widget 中的状态。</p>
<p>这是一个有点儿模糊的定义，这里有几个例子。</p>
<ul>
<li>一个 <a href="https://api.flutter-io.cn/flutter/widgets/PageView-class.html"><code>PageView</code></a> 组件中的当前页面</li>
<li>一个复杂动画中当前进度</li>
<li>一个 <code>BottomNavigationBar</code> 中当前被选中的 tab</li>
</ul>
<p>widget 树中其他部分不需要访问这种状态。不需要去序列化这种状态，这种状态也不会以复杂的方式改变。换句话说，不需要使用状态管理架构（例如 ScopedModel, Redux）去管理这种状态。你需要用的只是一个 <code>StatefulWidget</code>。</p>
<p>如果你想在你的应用中的多个部分之间共享一个非短时的状态，并且在用户会话期间保留这个状态，我们称之为应用状态（有时也称共享状态）。</p>
<p>应用状态的一些例子：</p>
<ul>
<li>用户选项</li>
<li>登录信息</li>
<li>一个社交应用中的通知</li>
<li>一个电商应用中的购物车</li>
<li>一个新闻应用中的文章已读&#x2F;未读状态</li>
</ul>
<h4 id="provider使用"><a href="#provider使用" class="headerlink" title="provider使用"></a>provider使用</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  provider: ^<span class="number">6.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h4><ul>
<li>ChangeNotifier【发送通知的人】</li>
</ul>
<blockquote>
<p><code>ChangeNotifier</code> 是 Flutter SDK 中的一个简单的类。它用于向监听器发送通知。换言之，如果被定义为 <code>ChangeNotifier</code>，你可以订阅它的状态变化。（这和大家所熟悉的观察者模式相类似）。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowAthletes</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> showAthletesService() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> options = BaseOptions(</span><br><span class="line">      <span class="comment">// method: &quot;POST&quot;,</span></span><br><span class="line">      baseUrl: <span class="string">&quot;http://127.0.0.1:8000/api&quot;</span>,</span><br><span class="line">      connectTimeout: <span class="number">5000</span>,</span><br><span class="line">      receiveTimeout: <span class="number">3000</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Dio dio = Dio(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formData = FormData.fromMap(&#123;<span class="string">&#x27;level&#x27;</span>: currentIndex&#125;);</span><br><span class="line"></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/showAthletes&quot;</span>, data: formData);</span><br><span class="line">    currentLen = response.data[<span class="string">&quot;len&quot;</span>];</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ChangeNotifierProvider 【在mian中注册该ChangeNotifier】</li>
</ul>
<blockquote>
<p><code>ChangeNotifierProvider</code> widget 可以向其子孙节点暴露一个 <code>ChangeNotifier</code> 实例。它属于 <code>provider</code> package。</p>
<p>我们已经知道了该把 <code>ChangeNotifierProvider</code> 放在什么位置：在需要访问它的 widget 之上。在 <code>CartModel</code> 里，也就意味着将它置于 <code>MyCart</code> 和 <code>MyCatalog</code> 之上。</p>
<p>你肯定不愿意把 <code>ChangeNotifierProvider</code> 放的级别太高（因为你不希望破坏整个结构）。但是在我们这里的例子中，<code>MyCart</code> 和 <code>MyCatalog</code> 之上只有 <code>MyApp</code>。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  FluroRouter  router = FluroRouter();</span><br><span class="line">  Application.router = router; <span class="comment">//一定要先写这行</span></span><br><span class="line">  Routes.configureRoutes(router);</span><br><span class="line">  Provider.debugCheckInvalidValueType = <span class="keyword">null</span>;</span><br><span class="line">  runApp(</span><br><span class="line">      MultiProvider(</span><br><span class="line">        providers: [</span><br><span class="line">          ChangeNotifierProvider(create: (_) =&gt; ShowAthletes()),</span><br><span class="line">        ],</span><br><span class="line">        child: MyApp(),</span><br><span class="line">      )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Consumer【变化的主体】</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget buildAthleteList()&#123;</span><br><span class="line">  <span class="keyword">return</span> Consumer&lt;ShowAthletes&gt;(</span><br><span class="line">    builder: (context,sa,child)&#123;</span><br><span class="line">      <span class="keyword">return</span> Expanded(</span><br><span class="line">        child: ListView.builder(</span><br><span class="line">          itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">return</span>  ListTile(</span><br><span class="line">              leading: Icon(Icons.settings,color: Colors.blue,),</span><br><span class="line">              title: Text(<span class="string">&quot;师傅麻烦你把我送到解放碑&quot;</span>,style: TextStyle(color: Colors.white24),),</span><br><span class="line">              subtitle: Text(<span class="string">&quot;和他挥手拜拜有缘再会&quot;</span>,style: TextStyle(color: Colors.white24),),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">          itemCount: currentLen,</span><br><span class="line">        ) ,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们必须指定要访问的模型类型。在这个示例中，我们要访问 <code>CartModel</code> 那么就写上 <code>Consumer&lt;CartModel&gt;</code>。</p>
<p><code>Consumer</code> widget 唯一必须的参数就是 builder。当 <code>ChangeNotifier</code> 发生变化的时候会调用 builder 这个函数。（换言之，当你在模型中调用 <code>notifyListeners()</code> 时，所有相关的 <code>Consumer</code> widget 的 builder 方法都会被调用。）</p>
<p>builder 在被调用的时候会用到三个参数。第一个是 <code>context</code>。在每个 build 方法中都能找到这个参数。</p>
<p>builder 函数的第二个参数是 <code>ChangeNotifier</code> 的实例。它是我们最开始就能得到的实例。你可以通过该实例定义 UI 的内容。</p>
<p>第三个参数是 <code>child</code>，用于优化目的。如果 <code>Consumer</code> 下面有一个庞大的子树，当模型发生改变的时候，该子树 <strong>并不会</strong> 改变，那么你就可以仅仅创建它一次，然后通过 builder 获得该实例。</p>
</blockquote>
<blockquote>
<p>最好能把 <code>Consumer</code> 放在 widget 树尽量低的位置上。你总不希望 UI 上任何一点小变化就全盘重新构建 widget 吧。</p>
</blockquote>
<ul>
<li>Provider.of 【点击时触发的方法】</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _swt = !_swt;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">int?</span> selectedIndex =</span><br><span class="line">    <span class="keyword">await</span> _showCustomModalBottomSheet(</span><br><span class="line">    context, _options);</span><br><span class="line">  <span class="keyword">if</span> (selectedIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _swt = !_swt;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> sa = ShowAthletes();</span><br><span class="line">  Provider.of&lt;ShowAthletes&gt;(context,listen:<span class="keyword">false</span>).showAthletesService();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;自定义底部弹层：选中了第<span class="subst">$selectedIndex</span>个选项&quot;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有的时候你不需要模型中的 <strong>数据</strong> 来改变 UI，但是你可能还是需要访问该数据。比如，<code>ClearCart</code> 按钮能够清空购物车的所有商品。它不需要显示购物车里的内容，只需要调用 <code>clear()</code> 方法。</p>
<p>我们可以使用 <code>Consumer&lt;CartModel&gt;</code> 来实现这个效果，不过这么实现有点浪费。因为我们让整体框架重构了一个无需重构的 widget。</p>
<p>所以这里我们可以使用 <code>Provider.of</code>，并且将 <code>listen</code> 设置为 <code>false</code>。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Provider.of&lt;CartModel&gt;(context, listen: <span class="keyword">false</span>).removeAll();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 build 方法中使用上面的代码，当 <code>notifyListeners</code> 被调用的时候，并不会使 widget 被重构。</p>
</blockquote>
<h3 id="视频播放插件"><a href="#视频播放插件" class="headerlink" title="视频播放插件"></a>视频播放插件</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p><img src="/2022/08/26/flutter/image-20220917144002341.png" alt="image-20220917144002341"></p>
<h3 id="flutter-django-前后端分离"><a href="#flutter-django-前后端分离" class="headerlink" title="flutter+django 前后端分离"></a>flutter+django 前后端分离</h3><p>在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。</p>
<h4 id="什么是RESTful-API？"><a href="#什么是RESTful-API？" class="headerlink" title="什么是RESTful API？"></a>什么是RESTful API？</h4><p>要弄清楚什么是RESTful API,首先要弄清楚什么是REST。REST – REpresentational State Transfer，英语的直译就是“表现层状态转移”。如果看这个概念，估计没几个人能明白是什么意思。那下面就让我来用一句人话解释一下什么是RESTful:URL定位资源，用HTTP动词（GET,POST,PUT,DELETE)描述操作。RESTful 是典型的基于HTTP的协议。</p>
<p><code>Resource：</code>资源，即数据。<br><code>Representational：</code>某种表现形式，比如用JSON，XML，JPEG等；<br><code>State Transfer：</code>状态变化。通过HTTP动词实现。</p>
<p>所以RESTful API就是REST风格的API。 那么在什么场景下使用RESTful API呢？在当今的互联网应用的前端展示媒介很丰富。有手机、有平板电脑还有PC以及其他的展示媒介。那么这些前端接收到的用户请求统一由一个后台来处理并返回给不同的前端肯定是最科学和最经济的方式，RESTful API就是一套协议来规范多种形式的前端和同一个后台的交互方式。</p>
<p>RESTful API由后台也就是SERVER来提供前端来调用。前端调用API向后台发起HTTP请求，后台响应请求将处理结果反馈给前端。也就是说RESTful 是典型的基于HTTP的协议。那么RESTful API有哪些设计原则和规范呢？</p>
<p>资源。首先是弄清楚资源的概念。资源就是网络上的一个实体，一段文本，一张图片或者一首歌曲。资源总是要通过一种载体来反应它的内容。文本可以用TXT，也可以用HTML或者XML、图片可以用JPG格式或者PNG格式，JSON是现在最常用的资源表现形式。</p>
<p>统一接口。RESTful风格的数据元操CRUD（create,read,update,delete）分别对应HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口。</p>
<p>URI。可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个URI与之对应，最典型的URI就是URL。</p>
<p>无状态。所谓无状态即所有的资源都可以URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。有状态和无状态的区别，举个例子说明一下，例如要查询员工工资的步骤为第一步：登录系统。第二步：进入查询工资的页面。第三步：搜索该员工。第四步：点击姓名查看工资。这样的操作流程就是有状态的，查询工资的每一个步骤都依赖于前一个步骤，只要前置操作不成功，后续操作就无法执行。如果输入一个URL就可以得到指定员工的工资，则这种情况就是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个URL与之对应可以通过HTTP中的GET方法得到资源，这就是典型的RESTful风格。</p>
<p>说了这么多，到底RESTful长什么样子的呢？<br><code>GET:http://www.xxx.com/source/id 获取指定ID的某一类资源。例如GET:http://www.xxx.com/friends/123表示获取ID为123的会员的好友列表。如果不加id就表示获取所有会员的好友列表。</code></p>
<p><code>POST:http://www.xxx.com/friends/123表示为指定ID为123的会员新增好友。其他的操作类似就不举例了。</code></p>
<h4 id="RESTful-API设计准则"><a href="#RESTful-API设计准则" class="headerlink" title="RESTful API设计准则"></a>RESTful API设计准则</h4><p>应该尽量将API部署在专用域名之下 <code>https://example.org/api/</code><br>应该将API的版本号放入URL <code>https://example.org/app/1.0/foo</code>， 但这个是不强制的<br>路径又被称为终点，表示API的具体地址，每个地址代表一种资源。资源只能是名词不能是动词，而且名词往往和数据库的表名相对应。同时，利用HTTP方法（post, get, put, delete)可以分离网址中资源名称的操作。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET /products    <span class="comment">#返回所有的产品清单</span></span><br><span class="line">POST /products   <span class="comment">#将产品新建到集合</span></span><br><span class="line">GET <span class="regexp">/products/</span><span class="number">4</span>  <span class="comment">#将获取产品4</span></span><br><span class="line">PATCH <span class="regexp">/products/</span><span class="number">4</span> <span class="comment">#更新产品4（客户端提供改变后的完整资源）</span></span><br><span class="line">PUT <span class="regexp">/products/</span><span class="number">4</span>  <span class="comment">#更新产品4（客户端提高改变的额属性）</span></span><br><span class="line">DELETE <span class="regexp">/products/</span><span class="number">4</span> <span class="comment">#删除产品4</span></span><br><span class="line">HEAD   <span class="comment">#获取资源的元数据</span></span><br><span class="line">OPTIONS  <span class="comment">#获取信息</span></span><br></pre></td></tr></table></figure>

<p>API中的名词应该使用复数，无论是子资源或者所有资源</p>
<p>过滤信息；如果记录数量很多，服务器不可能都将它们全部返回。API需要提供参数，过滤返回结果</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">?l</span>imit=<span class="number">10</span>  <span class="comment">#指定返回记录的数量</span></span><br><span class="line"><span class="string">?o</span>ffset=<span class="number">10</span> <span class="comment">#指定返回记录的开始位置</span></span><br><span class="line"><span class="string">?p</span>age=<span class="number">2</span>&amp;per_page=<span class="number">100</span> <span class="comment">#指定第几页，以及每页的记录数</span></span><br><span class="line"><span class="string">?s</span>hortby=name&amp;order=asc <span class="comment">#指定返回结果按照哪个属性排序以及排序顺序</span></span><br><span class="line"><span class="string">?a</span>nimal_type_id=<span class="number">1</span> <span class="comment">#指定筛选条件</span></span><br></pre></td></tr></table></figure>

<p>RESTful API最好做到Hypermedia（即返回结果中提供链接，连向其它API方法）</p>
<p>服务器返回的数据格式，应该尽量采用json格式，避免使用XML</p>
<h4 id="后端开发（REST接口开发）的核心任务"><a href="#后端开发（REST接口开发）的核心任务" class="headerlink" title="后端开发（REST接口开发）的核心任务"></a>后端开发（REST接口开发）的核心任务</h4><p>后端只负责返回前端需要的数据，不再渲染HTML页面，不再控制前端的效果。无论哪种前端，所需的数据基本相同，所以后端只需要开发一套逻辑对外提供数据就可以了。</p>
<p>在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。</p>
<p>将请求的数据（如json格式的数据）转换成模型类对象操作数据库, 将模型类对象转换成响应的数据，比如Json格式<br>因此：数据类型的转换就涉及到序列化和反序列化：</p>
<p>在开发REST API 接口时，视图中要频繁地进行序列化和反序列化的编写。</p>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>序列化：将程序中的一个数据结构类型转换为其它格式（字典，json, xml等），比如将<a href="https://so.csdn.net/so/search?q=django&spm=1001.2101.3001.7020">django</a>中的模型类对象转换为json字符串，这个转换过程我们成为序列化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books_all=Books.objects.<span class="built_in">all</span>()</span><br><span class="line">book_list=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#序列化</span></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books_all:</span><br><span class="line">	book_list.append(&#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:book.<span class="built_in">id</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>:book.title,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>:book.author,</span><br><span class="line">        <span class="string">&#x27;publish_time&#x27;</span>:book.publish_time</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> JsonResponse(book_list, safe=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>反序列化：将其它格式（json,字典，XML等）转换成程序中的数据。例如将Json字符串转换成Django中的模型类对象。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">json_bytes</span>=request.body</span><br><span class="line"><span class="attribute">json_str</span>=json_bytes.decode()</span><br><span class="line"></span><br><span class="line"><span class="comment">#反序列化</span></span><br><span class="line"><span class="attribute">book_dict</span>=json.loads(json_str)</span><br><span class="line">book = Books.objects.create(</span><br><span class="line">	<span class="attribute">title</span>=book_dict.get(&#x27;title&#x27;),</span><br><span class="line">	<span class="attribute">publish_time</span>=datetime.striptime(book_dict.get(&#x27;publish_time&#x27;), <span class="string">&#x27;%Y-%m-%d&#x27;</span>).date()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/26/flutter/91f29e7b7b8b4587acb025ee1504583e.png" alt="在这里插入图片描述"></p>
<h4 id="前后端分离实际操作"><a href="#前后端分离实际操作" class="headerlink" title="前后端分离实际操作"></a>前后端分离实际操作</h4><ul>
<li>django中安装并在settings.py中注册</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install djangorestframework  <span class="comment"># 它是基于Django的，帮助我们快速开发符合restful规范的接口框架,它主要适用于前后端分离项目。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install django-cors-headers  <span class="comment"># django-cors-headers处理跨域请求，一个为响应添加跨源资源共享(CORS)头的Django应用。这允许从其他源向Django应用程序发出浏览器内请求。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;apps.user&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">] <span class="comment"># 在settings.py中注册</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户表 &quot;&quot;&quot;</span></span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">&quot;用户&quot;</span>, max_length=<span class="number">20</span>, null=<span class="literal">False</span>)</span><br><span class="line">    password = models.CharField(verbose_name=<span class="string">&quot;密码&quot;</span>, max_length=<span class="number">16</span>, null=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在user根目录添加serializers.py文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> apps.user.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> apps.user <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSerializer</span>(serializers.HyperlinkedModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.User</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/26/flutter/image-20220911014713905.png" alt="image-20220911014713905"></p>
<ul>
<li>生成模型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate </span><br></pre></td></tr></table></figure>



<h3 id="实际开发注意事项"><a href="#实际开发注意事项" class="headerlink" title="实际开发注意事项"></a>实际开发注意事项</h3><ul>
<li>拆分appbar进components一定要实现<code>PreferredSizeWidget</code>借口</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppBar</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> <span class="keyword">implements</span> <span class="title">PreferredSizeWidget</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyAppBar(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Size <span class="keyword">get</span> preferredSize =&gt; <span class="keyword">const</span> Size.fromHeight(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;MyAppBar&gt; createState() =&gt; _MyAppBarState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyAppBar</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> AppBar(</span><br><span class="line">      title: <span class="keyword">const</span> Text(<span class="string">&quot;UFC&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>appBar中的actions组件设置高度要用UnconstrainedBox包裹去除父样式</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">actions: [</span><br><span class="line">  UnconstrainedBox(</span><br><span class="line">    child :SizedBox(</span><br><span class="line">      height: <span class="number">27</span>,</span><br><span class="line">      width: <span class="number">70</span>,</span><br><span class="line">      child: ElevatedButton(</span><br><span class="line">        child: Text(<span class="string">&quot;live now&quot;</span>),</span><br><span class="line">        style: ElevatedButton.styleFrom(</span><br><span class="line">          primary: Color.fromRGBO(<span class="number">254</span>, <span class="number">46</span>, <span class="number">36</span>, <span class="number">1</span>),</span><br><span class="line">          padding: <span class="keyword">new</span> EdgeInsets.only(bottom: <span class="number">3</span>),</span><br><span class="line">          minimumSize: <span class="keyword">const</span> Size(<span class="number">90</span>, <span class="number">20</span>),</span><br><span class="line">          maximumSize: <span class="keyword">const</span> Size(<span class="number">90</span>, <span class="number">20</span>),</span><br><span class="line">          shape: RoundedRectangleBorder(</span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">5</span>))),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<ul>
<li>运行项目后若出现<code>The sandbox is not in sync with the Podfile.lock. Run &#39;pod install&#39; or update your CocoaPods installation.</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目根目录/ios</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure>

<ul>
<li>前端传”type”:2 后端要用”2”接收; 并且多个数据要用formData传</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = FormData.fromMap(&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: usernameController.text,</span><br><span class="line">  <span class="string">&#x27;password&#x27;</span>: passwordController.text,</span><br><span class="line">  <span class="string">&#x27;type&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line">Response response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/login&quot;</span>, data: formData);</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loginOrRegister = request.POST.get(<span class="string">&quot;type&quot;</span>)  </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loginOrRegister == <span class="string">&quot;2&quot;</span>:</span><br></pre></td></tr></table></figure>

<ul>
<li>form.is_valid()总是返回false</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决方法:前端提交的字段名要与数据库中字段名一致</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TabController 不能为null</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决方法:TabController? tabController;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Scaffold.of() called with a context that does not contain a Scaffold. 比如:Drawer点不出</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法: 在应用Scaffold.of(context).openDrawer();的外层套一个Builder</span></span><br><span class="line">leading: Builder(builder: (BuildContext context)&#123;</span><br><span class="line">          <span class="keyword">return</span> IconButton(</span><br><span class="line">            icon: Icon(Icons.menu),</span><br><span class="line">            tooltip: <span class="string">&quot;Search&quot;</span>,</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Scaffold.of(context).openDrawer();</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;),</span><br></pre></td></tr></table></figure>

<ul>
<li>Scaffold下body中有多个组件,其中之一为列表时,要用Expanded包裹</li>
</ul>
<p><img src="/2022/08/26/flutter/image-20220923201358714.png" alt="image-20220923201358714"></p>
<ul>
<li>flutter 前后端序列化操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回运动员的信息</span></span><br><span class="line">level = request.POST.get(<span class="string">&quot;level&quot;</span>)</span><br><span class="line">athletes = models.Athlete.objects.<span class="built_in">filter</span>(level=level)</span><br><span class="line">num = models.Athlete.objects.<span class="built_in">filter</span>(level=level).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化为Json对象</span></span><br><span class="line">result = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, athletes)</span><br><span class="line">res = &#123;</span><br><span class="line">  <span class="string">&#x27;len&#x27;</span>: num,</span><br><span class="line">  <span class="string">&#x27;data&#x27;</span>: result,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HttpResponse(json.dumps(res), content_type=<span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前端</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowAthletes</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> showAthletesService() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> options = BaseOptions(</span><br><span class="line">      <span class="comment">// method: &quot;POST&quot;,</span></span><br><span class="line">      baseUrl: <span class="string">&quot;http://127.0.0.1:8000/api&quot;</span>,</span><br><span class="line">      connectTimeout: <span class="number">5000</span>,</span><br><span class="line">      receiveTimeout: <span class="number">3000</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Dio dio = Dio(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formData = FormData.fromMap(&#123;<span class="string">&#x27;level&#x27;</span>: currentIndex&#125;);</span><br><span class="line"></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/showAthletes&quot;</span>, data: formData);</span><br><span class="line">    currentLen = response.data[<span class="string">&quot;len&quot;</span>];</span><br><span class="line">    notifyListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化后访问后端传来的数据</span></span><br><span class="line">    list = jsonDecode(response.data[<span class="string">&quot;data&quot;</span>]);</span><br><span class="line">    <span class="keyword">if</span>(list.isNotEmpty)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt; list.length;i++)&#123;</span><br><span class="line">        <span class="built_in">print</span>(list[i][<span class="string">&quot;fields&quot;</span>][<span class="string">&quot;chineseName&quot;</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="flutter持久化-实际开发一般都是前后端分离"><a href="#flutter持久化-实际开发一般都是前后端分离" class="headerlink" title="*flutter持久化 [实际开发一般都是前后端分离]"></a>*flutter持久化 [实际开发一般都是前后端分离]</h3><h4 id="sqlite和mysql"><a href="#sqlite和mysql" class="headerlink" title="sqlite和mysql"></a>sqlite和mysql</h4><ol>
<li><p><strong>和MySQL相比，SQLite支持的数据类型较少。</strong></p>
</li>
<li><p><strong>SQLite的可移植性较好，而MySQL较差。</strong>SQLite库大小约为250 KB，而MySQL服务器大约为600 MB。SQLite直接将信息存储在单个文件中，使其易于复制。不需要任何配置，并且可以使用最少的支持来完成该过程。</p>
</li>
<li><p><strong>MySQL有构造良好的用户管理系统，而SQLite没有。</strong>SQLite没有任何特定的用户管理功能，因此不适合多用户访问。MySQL有一个构造良好的用户管理系统，可以处理多个用户并授予不同级别的权限。SQLite适用于较小的数据库，随着数据库的增长，使用SQLite时内存需求也会变大。使用SQLite时，性能优化更加困难。相反，MySQL易于扩展，可以轻松处理更大的数据库。</p>
</li>
<li><p><strong>SQLite没有内置的身份验证机制，而MySQL有，其安全性较高。</strong></p>
</li>
</ol>
<h5 id="优点和缺点-–-sqlite与mysql"><a href="#优点和缺点-–-sqlite与mysql" class="headerlink" title="优点和缺点 – sqlite与mysql"></a>优点和缺点 – sqlite与mysql</h5><p><strong>sqlite的优点</strong>：</p>
<ul>
<li>基于文件，易于设置和使用</li>
<li>适合基础开发和测试</li>
<li>轻松携带</li>
<li>使用标准SQL语法进行微小更改</li>
<li>使用方便</li>
</ul>
<p><strong>SQLite的缺点</strong>：</p>
<ul>
<li>缺乏用户管理和安全功能</li>
<li>不容易扩展</li>
<li>不适合大数据库</li>
<li>无法定制</li>
</ul>
<p><strong>MySQL的优点</strong>：</p>
<ul>
<li>使用方便</li>
<li>提供了许多与数据库相关的功能</li>
<li>良好的安全功能</li>
<li>易于扩展，适用于大型数据库</li>
<li>提供良好的速度和性能</li>
<li>提供良好的用户管理和多种访问控制</li>
</ul>
<p><strong>MySQL的缺点</strong>：</p>
<ul>
<li>需要一些技术专业知识来设置</li>
<li>与传统SQL相比，语法略有不同</li>
</ul>
<h4 id="sqflite"><a href="#sqflite" class="headerlink" title="sqflite"></a>sqflite</h4><p>sqflite是一款轻量级的关系型数据库，类似SQLite。在Flutter平台我们使用sqflite库来同时支持Android 和iOS。数据种类:</p>
<p>INTEGER :	Dart type: <code>int</code></p>
<p>REAL :	Dart type: <code>num</code></p>
<p>TEXT :	Dart type: <code>String</code></p>
<p>BLOB :	Dart type: <code>Uint8List</code></p>
<h4 id="flutter使用sqflite"><a href="#flutter使用sqflite" class="headerlink" title="flutter使用sqflite"></a>flutter使用sqflite</h4><ul>
<li>准备工作</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  fluro: ^<span class="number">2.0</span><span class="number">.3</span></span><br><span class="line">  dio: ^<span class="number">4.0</span><span class="number">.6</span></span><br><span class="line">  # The following adds the Cupertino Icons font to your application.</span><br><span class="line">  # Use <span class="keyword">with</span> the CupertinoIcons <span class="class"><span class="keyword">class</span> <span class="title">for</span> <span class="title">iOS</span> <span class="title">style</span> <span class="title">icons</span>.</span></span><br><span class="line"><span class="class">  <span class="title">cupertino_icons</span>: ^1.0.2</span></span><br><span class="line"><span class="class">  <span class="title">sqflite</span>: ^2.0.3+1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:sqflite/sqflite.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开数据库</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">await</span> openDatabase(<span class="string">&#x27;my_db.db&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭数据库</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> db.close();</span><br></pre></td></tr></table></figure>



<h6 id="sqflite原生操作"><a href="#sqflite原生操作" class="headerlink" title="sqflite原生操作"></a>sqflite原生操作</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用getDatabasesPath获取位置</span><br><span class="line">var databasesPath = await getDatabasesPath();</span><br><span class="line">String path = join(databasesPath, &#x27;demo.db&#x27;);</span><br><span class="line"></span><br><span class="line">// 删除数据库</span><br><span class="line">await deleteDatabase(path);</span><br><span class="line"></span><br><span class="line">// 打开数据库</span><br><span class="line">Database database = await openDatabase(path, version: 1,</span><br><span class="line">    onCreate: (Database db, int version) async &#123;</span><br><span class="line">  // When creating the db, create the table</span><br><span class="line">  await db.execute(</span><br><span class="line">      &#x27;CREATE TABLE Test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER, num REAL)&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在事务中插入一些记录</span><br><span class="line">await database.transaction((txn) async &#123;</span><br><span class="line">  int id1 = await txn.rawInsert(</span><br><span class="line">      &#x27;INSERT INTO Test(name, value, num) VALUES(&quot;some name&quot;, 1234, 456.789)&#x27;);</span><br><span class="line">  print(&#x27;inserted1: $id1&#x27;);</span><br><span class="line">  int id2 = await txn.rawInsert(</span><br><span class="line">      &#x27;INSERT INTO Test(name, value, num) VALUES(?, ?, ?)&#x27;,</span><br><span class="line">      [&#x27;another name&#x27;, 12345678, 3.1416]);</span><br><span class="line">  print(&#x27;inserted2: $id2&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 更新记录</span><br><span class="line">int count = await database.rawUpdate(</span><br><span class="line">    &#x27;UPDATE Test SET name = ?, value = ? WHERE name = ?&#x27;,</span><br><span class="line">    [&#x27;updated name&#x27;, &#x27;9876&#x27;, &#x27;some name&#x27;]);</span><br><span class="line">print(&#x27;updated: $count&#x27;);</span><br><span class="line"></span><br><span class="line">// 查找全部</span><br><span class="line">List&lt;Map&gt; list = await database.rawQuery(&#x27;SELECT * FROM Test&#x27;);</span><br><span class="line">List&lt;Map&gt; expectedList = [</span><br><span class="line">  &#123;&#x27;name&#x27;: &#x27;updated name&#x27;, &#x27;id&#x27;: 1, &#x27;value&#x27;: 9876, &#x27;num&#x27;: 456.789&#125;,</span><br><span class="line">  &#123;&#x27;name&#x27;: &#x27;another name&#x27;, &#x27;id&#x27;: 2, &#x27;value&#x27;: 12345678, &#x27;num&#x27;: 3.1416&#125;</span><br><span class="line">];</span><br><span class="line">print(list);</span><br><span class="line">print(expectedList);</span><br><span class="line">assert(const DeepCollectionEquality().equals(list, expectedList));</span><br><span class="line"></span><br><span class="line">// 记录条数</span><br><span class="line">count = Sqflite</span><br><span class="line">    .firstIntValue(await database.rawQuery(&#x27;SELECT COUNT(*) FROM Test&#x27;));</span><br><span class="line">assert(count == 2);</span><br><span class="line"></span><br><span class="line">// 删除记录</span><br><span class="line">count = await database</span><br><span class="line">    .rawDelete(&#x27;DELETE FROM Test WHERE name = ?&#x27;, [&#x27;another name&#x27;]);</span><br><span class="line">assert(count == 1);</span><br><span class="line"></span><br><span class="line">// 关闭数据库</span><br><span class="line">await database.close();</span><br></pre></td></tr></table></figure>

<h6 id="SQL-helpers操作"><a href="#SQL-helpers操作" class="headerlink" title="SQL helpers操作"></a>SQL helpers操作</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final String tableTodo = &#x27;todo&#x27;;</span><br><span class="line">final String columnId = &#x27;_id&#x27;;</span><br><span class="line">final String columnTitle = &#x27;title&#x27;;</span><br><span class="line">final String columnDone = &#x27;done&#x27;;</span><br><span class="line"></span><br><span class="line">// 实体类</span><br><span class="line">class Todo &#123;</span><br><span class="line">  int id;</span><br><span class="line">  String title;</span><br><span class="line">  bool done;</span><br><span class="line">  </span><br><span class="line">  Map&lt;String, Object?&gt; toMap() &#123;</span><br><span class="line">    var map = &lt;String, Object?&gt;&#123;</span><br><span class="line">      columnTitle: title,</span><br><span class="line">      columnDone: done == true ? 1 : 0</span><br><span class="line">    &#125;;</span><br><span class="line">    if (id != null) &#123;</span><br><span class="line">      map[columnId] = id;</span><br><span class="line">    &#125;</span><br><span class="line">    return map;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Todo();</span><br><span class="line">  </span><br><span class="line">  Todo.fromMap(Map&lt;String, Object?&gt; map) &#123;</span><br><span class="line">    id = map[columnId];</span><br><span class="line">    title = map[columnTitle];</span><br><span class="line">    done = map[columnDone] == 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TodoProvider &#123;</span><br><span class="line">  Database db;</span><br><span class="line">	</span><br><span class="line">	// 打开数据库并创建表</span><br><span class="line">  Future open(String path) async &#123;</span><br><span class="line">    db = await openDatabase(path, version: 1,</span><br><span class="line">        onCreate: (Database db, int version) async &#123;</span><br><span class="line">      await db.execute(&#x27;&#x27;&#x27;</span><br><span class="line">create table $tableTodo ( </span><br><span class="line">  $columnId integer primary key autoincrement, </span><br><span class="line">  $columnTitle text not null,</span><br><span class="line">  $columnDone integer not null)</span><br><span class="line">&#x27;&#x27;&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	// 插入记录</span><br><span class="line">  Future&lt;Todo&gt; insert(Todo todo) async &#123;</span><br><span class="line">    todo.id = await db.insert(tableTodo, todo.toMap());</span><br><span class="line">    return todo;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	// 根据id查询记录</span><br><span class="line">  Future&lt;Todo&gt; getTodo(int id) async &#123;</span><br><span class="line">    List&lt;Map&gt; maps = await db.query(tableTodo,</span><br><span class="line">        columns: [columnId, columnDone, columnTitle],</span><br><span class="line">        where: &#x27;$columnId = ?&#x27;,</span><br><span class="line">        whereArgs: [id]);</span><br><span class="line">    if (maps.length &gt; 0) &#123;</span><br><span class="line">      return Todo.fromMap(maps.first);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	// 根据id删除记录</span><br><span class="line">  Future&lt;int&gt; delete(int id) async &#123;</span><br><span class="line">    return await db.delete(tableTodo, where: &#x27;$columnId = ?&#x27;, whereArgs: [id]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	// 给一个实体类,根据它的id更新记录</span><br><span class="line">  Future&lt;int&gt; update(Todo todo) async &#123;</span><br><span class="line">    return await db.update(tableTodo, todo.toMap(),</span><br><span class="line">        where: &#x27;$columnId = ?&#x27;, whereArgs: [todo.id]);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	// 关闭数据库</span><br><span class="line">  Future close() async =&gt; db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h6><p>不要使用数据库，而只使用事务中的Transaction对象来访问数据库</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> database.transaction((txn) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Ok</span></span><br><span class="line">  <span class="keyword">await</span> txn.execute(<span class="string">&#x27;CREATE TABLE Test1 (id INTEGER PRIMARY KEY)&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// DON&#x27;T  use the database object in a transaction</span></span><br><span class="line">  <span class="comment">// this will deadlock!</span></span><br><span class="line">  <span class="keyword">await</span> database.execute(<span class="string">&#x27;CREATE TABLE Test2 (id INTEGER PRIMARY KEY)&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">batch = db.batch();</span><br><span class="line">batch.insert(<span class="string">&#x27;Test&#x27;</span>, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;);</span><br><span class="line">batch.update(<span class="string">&#x27;Test&#x27;</span>, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;new_item&#x27;</span>&#125;, where: <span class="string">&#x27;name = ?&#x27;</span>, whereArgs: [<span class="string">&#x27;item&#x27;</span>]);</span><br><span class="line">batch.delete(<span class="string">&#x27;Test&#x27;</span>, where: <span class="string">&#x27;name = ?&#x27;</span>, whereArgs: [<span class="string">&#x27;item&#x27;</span>]);</span><br><span class="line">results = <span class="keyword">await</span> batch.commit();</span><br></pre></td></tr></table></figure>

<p>警告，在事务期间，批处理在事务提交之前不会被提交</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> database.transaction((txn) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> batch = txn.batch();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// commit but the actual commit will happen when the transaction is committed</span></span><br><span class="line">  <span class="comment">// however the data is available in this transaction</span></span><br><span class="line">  <span class="keyword">await</span> batch.commit();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>默认情况下，批处理一旦遇到错误就会停止(通常会恢复未提交的更改)。你可以忽略错误，这样即使有一个操作失败，每个成功的操作都会运行并提交:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function">await batch.<span class="title">commit</span><span class="params">(continueOnError: <span class="keyword">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2022/08/02/python/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&quot;Zhihu&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取第二位</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1:-2]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>result：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]:  Runoob</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>]:  [<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第三个元素为 :  <span class="number">1997</span></span><br><span class="line">更新后的第三个元素为 :  <span class="number">2001</span></span><br><span class="line">更新后的列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="append与extend的区别"><a href="#append与extend的区别" class="headerlink" title="append与extend的区别"></a>append与extend的区别</h4><ul>
<li>ist.append(object) 向列表中添加一个对象object</li>
<li>list.extend(sequence) 把一个序列seq的内容添加到列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista = [<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listb = [<span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista.extend(listb)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lista</span><br><span class="line">[<span class="string">&#x27;compact disc&#x27;</span>, <span class="string">&#x27;8-track tape&#x27;</span>, <span class="string">&#x27;long playing record&#x27;</span>, <span class="string">&#x27;DVD Audio disc&#x27;</span>, <span class="string">&#x27;Super Audio CD&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.pop();</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;原始列表 : &quot;</span>, <span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原始列表 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">删除第三个元素 :  [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure>



<h4 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h4><table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print(x, end&#x3D;” “)</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h4 id="列表截取与拼接"><a href="#列表截取与拼接" class="headerlink" title="列表截取与拼接"></a>列表截取与拼接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">输出从第二个元素开始后的所有元素</td>
</tr>
</tbody></table>
<h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="列表比较"><a href="#列表比较" class="headerlink" title="列表比较"></a>列表比较</h4><p>列表比较需要引入 <strong>operator</strong> 模块的 <strong>eq</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 operator 模块</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">c = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(a,b): &quot;</span>, operator.eq(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;operator.eq(c,b): &quot;</span>, operator.eq(c,b))</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">operator.eq(a,b):  <span class="literal">False</span></span><br><span class="line">operator.eq(c,b):  <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h4><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td>
</tr>
</tbody></table>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典是另一种可变容器模型，且可存储任意类型对象。</span></span><br><span class="line"><span class="comment"># 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 &#123;&#125; 中 ,格式如下所示：</span></span><br><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 键必须是唯一的，但值则不必。</span></span><br><span class="line"><span class="comment"># 值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的字典实例：</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可如此创建字典：</span></span><br><span class="line">tinydict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">tinydict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h4 id="访问具体的值"><a href="#访问具体的值" class="headerlink" title="访问具体的值"></a>访问具体的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="comment"># tinydict[&#x27;Age&#x27;]:  7</span></span><br></pre></td></tr></table></figure>

<h4 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h4><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># tinydict[&#x27;Name&#x27;]:  小菜鸟</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(dict) 计算字典元素个数，即键的总数。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">str(dict) 输出字典，可以打印的字符串表示。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">pop(key[,default])</a> 删除字典 key（键）所对应的值，返回被删除的值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody></table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><code>set</code>是一个无序的不重复元素序列。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 这里演示的是去重功能</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 快速判断元素是否在集合内</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</span></span><br><span class="line">s.add( x )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</span></span><br><span class="line">s.update( x )</span><br></pre></td></tr></table></figure>

<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</span></span><br><span class="line">s.remove( x ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</span></span><br><span class="line">s.discard( x )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以设置随机删除集合中的一个元素，语法格式如下：</span></span><br><span class="line">s.pop()</span><br></pre></td></tr></table></figure>

<h4 id="计算元素个数"><a href="#计算元素个数" class="headerlink" title="计算元素个数"></a>计算元素个数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>

<h4 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>

<h4 id="集合内置函数-amp-方法"><a href="#集合内置函数-amp-方法" class="headerlink" title="集合内置函数&amp;方法"></a>集合内置函数&amp;方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td>
<td align="left">为集合添加元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td>
<td align="left">移除集合中的所有元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td>
<td align="left">拷贝一个集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td>
<td align="left">返回多个集合的差集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td>
<td align="left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td>
<td align="left">删除集合中指定的元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td>
<td align="left">返回集合的交集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td>
<td align="left">返回集合的交集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td>
<td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td>
<td align="left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td>
<td align="left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td>
<td align="left">随机移除元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td>
<td align="left">移除指定元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td>
<td align="left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td>
<td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td>
<td align="left">返回两个集合的并集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td>
<td align="left">给集合添加元素</td>
</tr>
</tbody></table>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li><em>Numpy</em> 是 <em>Python</em> 中科学计算的核心库，<em>NumPy</em> 这个词来源于 <em>Numerical</em> 和 <em>Python</em> 两个单词。它提供了一个高性能的多维<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>对象，以及大量的库函数和操作，可以帮助程序员轻松地进行数值计算，广泛应用于机器学习模型、图像处理和计算机图形学、数学任务等领域。</li>
</ul>
<h4 id="Numpy数组：ndarray"><a href="#Numpy数组：ndarray" class="headerlink" title="Numpy数组：ndarray"></a>Numpy数组：ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型，它是描述相同类型的元素集合。ndarray 中的每个元素都是数据类型对象(dtype)的对象。ndarray 中的每个元素在内存中使用相同大小的块。</span></span><br><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>object	任何暴露数组接口方法的对象</p>
</li>
<li><p>dtype	数据类型</p>
</li>
<li><p>copy	如果为 True，则 object 对象被复制，否则，只有当array返回副本，object 是嵌套序列，或者需要副本来满足任何其他要求（dtype，order等）时，才会生成副本。</p>
</li>
<li><p>order	指定阵列的内存布局。 如果 object 不是数组，则新创建的数组将按行排列（C），如果指定了（F），则按列排列。 如果 object 是一个数组，则以下成立。C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）</p>
</li>
<li><p>subok	默认情况下，返回的数组被强制为基类数组。 如果为 True，则返回子类。</p>
</li>
<li><p>ndmin	返回数组的最小维数</p>
</li>
</ul>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="comment"># 注意：list 打印显示是 [1, 2, 3]，而 ndarray 打印显示是 [1 2 3]，当中没有逗号。</span></span><br></pre></td></tr></table></figure>



<h5 id="例2-dtype-参数用法示例"><a href="#例2-dtype-参数用法示例" class="headerlink" title="例2:dtype 参数用法示例"></a>例2:dtype 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, dtype=np.float_)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">b = np.array(a, dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">float64</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.float64&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h5 id="例3-copy-参数的用法"><a href="#例3-copy-参数的用法" class="headerlink" title="例3:copy 参数的用法"></a>例3:copy 参数的用法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">True</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 可以看到 a 和 b 的值不同，说明 b 是 a 的副本，两个是不同的对象。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array(a, copy=<span class="literal">False</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a 改变同时引起了 b 的改变，说明 a 和 b 指向的是同一个对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="例4：ndmin-参数用法示例"><a href="#例4：ndmin-参数用法示例" class="headerlink" title="例4：ndmin 参数用法示例"></a>例4：ndmin 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = np.array(a, ndmin=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>



<h5 id="例5：subok-参数用法示例"><a href="#例5：subok-参数用法示例" class="headerlink" title="例5：subok 参数用法示例"></a>例5：subok 参数用法示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.matrix(<span class="string">&#x27;1 2 7; 3 4 8; 5 6 9&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">at = np.array(a, subok=<span class="literal">True</span>)</span><br><span class="line">af = np.array(a, subok=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(at))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(af))</span><br></pre></td></tr></table></figure>

<p>Result</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">9</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.matrix&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h4><ul>
<li>ndarray.ndim	秩，即轴的数量或维度的数量</li>
<li>ndarray.shape	数组的维度，对于矩阵，n 行 m 列</li>
<li>ndarray.size	数组元素的总个数，相当于 .shape 中 n*m 的值</li>
<li>ndarray.dtype	ndarray 对象的元素类型</li>
<li>ndarray.itemsize	ndarray 对象中每个元素的大小，以字节为单位</li>
<li>ndarray.flags	ndarray 对象的内存信息</li>
<li>ndarray.real	ndarray 元素的实部（复数的实部）</li>
<li>ndarray.imag	ndarray 元素的虚部（复数的虚部）</li>
<li>ndarray.data	包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h4 id="Numpy中的常数"><a href="#Numpy中的常数" class="headerlink" title="Numpy中的常数"></a>Numpy中的常数</h4><ul>
<li>正无穷：Inf &#x3D; inf &#x3D; infty &#x3D; Infinity &#x3D; PINF</li>
<li>负无穷：NINF</li>
<li>正零：PZERO</li>
<li>负零：NZERO</li>
<li>非数值：nan &#x3D; NaN &#x3D; NAN</li>
<li>自然数e：e</li>
<li>π：pi</li>
<li>伽马：euler_gamma</li>
<li>None 的别名：newaxis</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.inf)</span><br><span class="line"><span class="built_in">print</span>(np.NINF)</span><br><span class="line"><span class="built_in">print</span>(np.PZERO)</span><br><span class="line"><span class="built_in">print</span>(np.NZERO)</span><br><span class="line"><span class="built_in">print</span>(np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.e)</span><br><span class="line"><span class="built_in">print</span>(np.pi)</span><br><span class="line"><span class="built_in">print</span>(np.euler_gamma)</span><br><span class="line"><span class="built_in">print</span>(np.newaxis)</span><br><span class="line"><span class="comment"># inf</span></span><br><span class="line"><span class="comment"># -inf</span></span><br><span class="line"><span class="comment"># 0.0</span></span><br><span class="line"><span class="comment"># -0.0</span></span><br><span class="line"><span class="comment"># nan</span></span><br><span class="line"><span class="comment"># 2.718281828459045</span></span><br><span class="line"><span class="comment"># 3.141592653589793</span></span><br><span class="line"><span class="comment"># 0.5772156649015329</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h4><h5 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方法用来创建一个指定维度（shape）、数据类型（dtype）的未初始化的数组。</span></span><br><span class="line">numpy.empty(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.empty([<span class="number">3</span>, <span class="number">2</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]</span><br><span class="line"> [         <span class="number">0</span> <span class="number">1072693248</span>]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="numpy-full"><a href="#numpy-full" class="headerlink" title="numpy.full"></a>numpy.full</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回给定维度和类型的新数组，填充 fill_value。</span></span><br><span class="line">numpy.full(shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>



<h4 id="Numpy从数值范围创建数组"><a href="#Numpy从数值范围创建数组" class="headerlink" title="Numpy从数值范围创建数组"></a>Numpy从数值范围创建数组</h4><h5 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该函数等效于 Python 内置 range 函数，但返回的是 ndarray 而不是列表。</span></span><br><span class="line">arange([start,] stop[, step,], dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个一维等差数列的数组，与 arange 函数不同，arange 是固定步长，而 linspace 则是固定元素数量。</span></span><br><span class="line">linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span>]</span><br><span class="line">[<span class="number">0.</span>         <span class="number">1.66666667</span> <span class="number">3.33333333</span> <span class="number">5.</span>        ]</span><br></pre></td></tr></table></figure>



<h5 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.logspace 函数用于创建一个等比数列。</span></span><br><span class="line">numpy.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值为：base ** start （幂运算）</li>
<li>stop	序列的终止值为：base ** stop。如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的等步长的样本数量，默认为50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>base	对数 log 的底数。</li>
<li>dtype	ndarray 的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.logspace(<span class="number">1</span>, <span class="number">4</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [   10.   100.  1000. 10000.]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-geomspace"><a href="#numpy-geomspace" class="headerlink" title="numpy.geomspace"></a>numpy.geomspace</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.geomspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start	序列的起始值</li>
<li>stop	序列的终止值，如果 endpoint 为 True，该值包含于数列中</li>
<li>num	要生成的样本数量，默认为 50</li>
<li>endpoint	该值为 Ture 时，数列中中包含 stop 值，反之不包含，默认是 True。</li>
<li>dtype	ndarray 的数据类型</li>
<li>axis	1.16.0 版本中的新功能 ，没看懂怎么用，官网上连个例子都没有，值为 0 和 -1 的时候结果相同，其他时候都报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.geomspace(<span class="number">1</span>, <span class="number">8</span>, num=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1. 2. 4. 8.]</span></span><br></pre></td></tr></table></figure>



<h4 id="Numpy从已有的数组创建数组"><a href="#Numpy从已有的数组创建数组" class="headerlink" title="Numpy从已有的数组创建数组"></a>Numpy从已有的数组创建数组</h4><h5 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.asarray 类似 numpy.array，但 numpy.asarray 的参数只有三个。</span></span><br><span class="line">numpy.asarray(a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>a</th>
<th>输入数据，可以转换为数组的任何形式。 这包括列表，元组列表，元组，元组元组，列表元组和 ndarray。</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>数据类型</td>
</tr>
<tr>
<td>order</td>
<td>在计算机内存中的存储元素的顺序，只支持 ‘C’（按行）、‘F’（按列），默认 ‘C’</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</span></span><br><span class="line">numpy.frombuffer(buffer, dtype=<span class="built_in">float</span>, count=-<span class="number">1</span>, offset=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>buffer</th>
<th>实现了 <code>__buffer__</code> 方法的对象，（绝对不是菜鸟教程上说的任意对象都可以）</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>返回数组的数据类型</td>
</tr>
<tr>
<td>count</td>
<td>读取的数据数量，默认为 -1，读取所有数据。</td>
</tr>
<tr>
<td>offset</td>
<td>读取的起始位置，默认为 0。</td>
</tr>
</tbody></table>
<p>例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</span></span><br><span class="line">a = np.frombuffer(<span class="string">b&#x27;Hello World&#x27;</span>, dtype=<span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [b&#x27;H&#x27; b&#x27;e&#x27; b&#x27;l&#x27; b&#x27;l&#x27; b&#x27;o&#x27; b&#x27; &#x27; b&#x27;W&#x27; b&#x27;o&#x27; b&#x27;r&#x27; b&#x27;l&#x27; b&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>



<p>例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">a = array.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">na = np.frombuffer(a, dtype=np.int_)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(na)</span><br><span class="line"></span><br><span class="line"><span class="comment">#array.array 创建的数组对象内存是连续的（这里不能用 list，会报：AttributeError: ‘list’ object has no attribute ‘buffer’）</span></span><br><span class="line"><span class="comment"># numpy.frombuffer 从 array.array 的内存中创建数组，从上例中可以看出，改变 array.array 的值，numpy.frombuffer 的值也会跟着改变，由此可见。</span></span><br><span class="line"><span class="comment"># array.array 数组中的值改变是可以的，但是如果是添加值，那就不行了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [1, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [1 2 3 4]</span></span><br><span class="line"><span class="comment"># array(&#x27;i&#x27;, [10, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># [10  2  3  4]</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a>numpy.fromiter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</span></span><br><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">iterable = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">a = np.fromiter(iterable, <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 0  1  4  9 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看起来有点像 numpy.array，array 方法需要传入的是一个 list，而 fromiter 可以传入可迭代对象。</span></span><br></pre></td></tr></table></figure>



<h5 id="numpy-empty-like"><a href="#numpy-empty-like" class="headerlink" title="numpy.empty_like"></a>numpy.empty_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty_like(prototype, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-zeros-like"><a href="#numpy-zeros-like" class="headerlink" title="numpy.zeros_like"></a>numpy.zeros_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-ones-like"><a href="#numpy-ones-like" class="headerlink" title="numpy.ones_like"></a>numpy.ones_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h5 id="numpy-full-like"><a href="#numpy-full-like" class="headerlink" title="numpy.full_like"></a>numpy.full_like</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.full_like(a, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣HOT100部分合集</title>
    <url>/2023/01/31/%E5%8A%9B%E6%89%A3HOT100%E9%83%A8%E5%88%86%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[2,0,2,1,1,0]</span></span><br><span class="line">输出：<span class="string">[0,0,1,1,2,2]</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>, two = n;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[zero]);</span><br><span class="line">                i ++;</span><br><span class="line">                zero ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                two --;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[two]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2023/01/31/%E5%8A%9B%E6%89%A3HOT100%E9%83%A8%E5%88%86%E5%90%88%E9%9B%86/tree.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入: preorder = <span class="string">[3,9,20,15,7]</span>, inorder = <span class="string">[9,3,15,20,7]</span></span><br><span class="line">输出: <span class="string">[3,9,20,null,null,15,7]</span></span><br></pre></td></tr></table></figure>



<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123; <span class="comment">// [左，右]</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; <span class="number">0</span> || r &gt;= inorder.<span class="built_in">size</span>() || l &gt; r || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> num = preorder.<span class="built_in">front</span>();</span><br><span class="line">        preorder.<span class="built_in">erase</span>(preorder.<span class="built_in">begin</span>());</span><br><span class="line">        TreeNode* t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == num)&#123;</span><br><span class="line">                t -&gt; left = <span class="built_in">dfs</span>(preorder, inorder, l, i - <span class="number">1</span>);</span><br><span class="line">                t -&gt; right = <span class="built_in">dfs</span>(preorder, inorder, i + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[100,4,200,1,3,2]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 <span class="string">[1, 2, 3, 4]</span>。它的长度为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,3,7,2</span>,<span class="number">5,8,4,6</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: nums)</span><br><span class="line">            st.<span class="built_in">insert</span>(e);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : st)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">count</span>(e - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="type">int</span> curNum = e;</span><br><span class="line">                <span class="type">int</span> longStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">count</span>(curNum + <span class="number">1</span>))&#123;</span><br><span class="line">                    longStreak += <span class="number">1</span>;</span><br><span class="line">                    curNum += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, longStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;apple&quot;);</span><br><span class="line">trie.<span class="keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="keyword">True</span></span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">False</span></span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 <span class="keyword">True</span></span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;app&quot;);</span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">True</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span></span>&#123; <span class="comment">// 如果存在的话，返回prefix的最后一个字符所在树节点</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: prefix)&#123;</span><br><span class="line">            <span class="type">int</span> num = ch -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; children[num] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> node = node -&gt; children[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() :<span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : word)&#123;</span><br><span class="line">            <span class="type">int</span> num = ch -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; children[num] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node -&gt; children[num] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node -&gt; children[num];</span><br><span class="line">        &#125;</span><br><span class="line">        node -&gt; isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* res = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">if</span>(res) <span class="keyword">return</span> res -&gt; isEnd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* res = <span class="built_in">searchPrefix</span>(prefix);</span><br><span class="line">        <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253. 会议室 II"></a><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></h3><p>给你一个会议时间安排的数组 <code>intervals</code> ，每个会议时间都会包括开始和结束的时间 <code>intervals[i] = [starti, endi]</code> ，返回 <em>所需会议室的最小数量</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[0,30],[5,10],[15,20]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[7,10],[2,4]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>0 &lt;= starti &lt; endi &lt;= 106</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[<span class="number">0</span>] &gt;= res[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    res[i] = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(e);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h3><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,3,4,2,2]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[3,1,3,4,2]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>; </span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="comment">// 找nums中有多少数 &lt;= mid</span></span><br><span class="line">                cnt += nums[i] &lt;= mid; </span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mid) l = mid + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span> r = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1,1,1,2,2,3]</span>, k = 2</span><br><span class="line">输出: <span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出: <span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><ul>
<li>优先队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums)</span><br><span class="line">            mp[e]++;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que; <span class="comment">// priority_queue&lt;Type, Container, Functional&gt; </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); i ++)&#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*i);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>() &gt; k)  pri_que.<span class="built_in">pop</span>();<span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;3[a2[c]]&quot;</span></span><br><span class="line">输出：<span class="string">&quot;accaccacc&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;2[abc]3[cd]ef&quot;</span></span><br><span class="line">输出：<span class="string">&quot;abcabccdcdcdef&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 30</code></li>
<li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li>
<li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li>
<li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 s[i] == &#x27;]&#x27; 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；</span></span><br><span class="line"><span class="comment">当 s[i] == &#x27;[&#x27; 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。</span></span><br><span class="line"><span class="comment">遍历完毕后返回 res。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string src; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ptr; <span class="comment">// unsigned int</span></span><br><span class="line">     </span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDigits</span><span class="params">()</span> </span>&#123; <span class="comment">// 停在数字后第一个非数字处</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; src.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(src[ptr])) </span><br><span class="line">            ret = ret * <span class="number">10</span> + src[ptr++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr == src.<span class="built_in">size</span>() || src[ptr] == <span class="string">&#x27;]&#x27;</span>)  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(src[ptr])) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">getDigits</span>(); </span><br><span class="line">            ++ ptr; <span class="comment">// 过滤左括号</span></span><br><span class="line">            string str = <span class="built_in">getString</span>(); </span><br><span class="line">            ++ ptr; <span class="comment">// 过滤右括号</span></span><br><span class="line">            <span class="keyword">while</span> (k --) ret += str; <span class="comment">// 构造字符串</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(src[ptr]))</span><br><span class="line">            ret = <span class="built_in">string</span>(<span class="number">1</span>, src[ptr++]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret + <span class="built_in">getString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,1,1], k = 2</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><ul>
<li>前缀和</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// &lt;前缀和，对应的前缀和的个数&gt;</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : nums) &#123;</span><br><span class="line">            sum += e; </span><br><span class="line">            res += mp[sum - k]; </span><br><span class="line">            mp[sum] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;cbaebabacd&quot;</span>, <span class="selector-tag">p</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出: <span class="selector-attr">[0,6]</span></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">&quot;cba&quot;</span>, 它是 <span class="string">&quot;abc&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">6</span> 的子串是 <span class="string">&quot;bac&quot;</span>, 它是 <span class="string">&quot;abc&quot;</span> 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abab&quot;</span>, <span class="selector-tag">p</span> = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出: <span class="selector-attr">[0,1,2]</span></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">&quot;ab&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">1</span> 的子串是 <span class="string">&quot;ba&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">2</span> 的子串是 <span class="string">&quot;ab&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            sCount[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            pCount[p[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sCount == pCount) res.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + pLen &lt; sLen; i ++)&#123;</span><br><span class="line">            sCount[s[i] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            sCount[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(sCount == pCount) res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></h3><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：tasks = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>], n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：A -&gt; B -&gt; <span class="function"><span class="params">(待命)</span> -&gt;</span> A -&gt; B -&gt; <span class="function"><span class="params">(待命)</span> -&gt;</span> A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n = <span class="number">2</span> 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：tasks = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>], n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：在这种情况下，任何大小为 <span class="number">6</span> 的排列都可以满足要求，因为 n = <span class="number">0</span></span><br><span class="line">[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>]</span><br><span class="line">[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>]</span><br><span class="line">[<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>]</span><br><span class="line">...</span><br><span class="line">诸如此类</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：tasks = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>], n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：一种可能的解决方案是：</span><br><span class="line">     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; <span class="function"><span class="params">(待命)</span> -&gt;</span> <span class="function"><span class="params">(待命)</span> -&gt;</span> A -&gt; <span class="function"><span class="params">(待命)</span> -&gt;</span> <span class="function"><span class="params">(待命)</span> -&gt;</span> A</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= task.length &lt;= 104</code></li>
<li><code>tasks[i]</code> 是大写英文字母</li>
<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
<h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><ul>
<li><a href="https://leetcode.cn/problems/task-scheduler/solution/tong-zi-by-popopop/">https://leetcode.cn/problems/task-scheduler/solution/tong-zi-by-popopop/</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">26</span>)</span></span>; <span class="comment">// 统计每种任务的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : tasks) vec[e - <span class="string">&#x27;A&#x27;</span>] ++;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(),vec.<span class="built_in">rend</span>()); <span class="comment">// vec[0]为最多的任务数</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 需要记录有多个任务数量都最大且相同, 用于标记最后一个桶的任务数。</span></span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[cnt] == vec[<span class="number">0</span>]) cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(len, cnt+(n+<span class="number">1</span>)*(vec[<span class="number">0</span>]<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈合集</title>
    <url>/2022/10/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><ul>
<li>单调栈分为单调递增栈和单调递减栈</li>
</ul>
<ol>
<li>单调递增栈即栈内元素保持单调递增的栈</li>
<li>同理单调递减栈即栈内元素保持单调递减的栈</li>
</ol>
<ul>
<li>操作规则（下面都以单调递增栈为例）</li>
</ul>
<ol>
<li>如果新的元素比栈顶元素大，就入栈</li>
<li>如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</li>
</ol>
<ul>
<li>加入这样一个规则之后，会有什么效果</li>
</ul>
<ol>
<li>栈内的元素是递增的</li>
<li>当元素出栈时，说明<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素</li>
<li>当元素出栈后，说明新<strong>栈顶元素</strong>是出栈元素<strong>向前</strong>找第一个比其小的元素</li>
</ol>
<ul>
<li>C++模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; nums[i])&#123;</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>].</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- <span class="number">4</span> ，用加粗斜体标识，nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]。不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br><span class="line">- <span class="number">1</span> ，用加粗斜体标识，nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]。下一个更大元素是 <span class="number">3</span> 。</span><br><span class="line">- <span class="number">2</span> ，用加粗斜体标识，nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]。不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- <span class="number">2</span> ，用加粗斜体标识，nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。下一个更大元素是 <span class="number">3</span> 。</span><br><span class="line">- <span class="number">4</span> ，用加粗斜体标识，nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// &lt;nums1中该元素值, 对应在nums2中的下一个最大元素值&gt;</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; stk.<span class="built_in">top</span>())&#123;    <span class="comment">// 栈非空</span></span><br><span class="line">                <span class="type">int</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                mp[top] = nums2[i]; </span><br><span class="line">            &#125; </span><br><span class="line">            stk.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums1[i] = mp[nums1[i]] ? mp[nums1[i]] : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p>
<p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,1]</span></span><br><span class="line"><span class="section">输出: [2,-1,2]</span></span><br><span class="line"><span class="section">解释: 第一个 1 的下一个更大的数是 2；</span></span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="string">[1,2,3,4,3]</span></span><br><span class="line">输出: <span class="string">[2,3,4,-1,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 元素下标</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// 该数组元素下标 -&gt; 对应下一个最大元素值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * nums.<span class="built_in">size</span>() - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                mp[top] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            nums[i] = mp.<span class="built_in">find</span>(i) != mp.<span class="built_in">end</span>() ? mp[i] : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [<span class="number">73,74,75,71</span>,<span class="number">69,72,76,73</span>]</span><br><span class="line">输出: [<span class="number">1,1,4,2</span>,<span class="number">1,1,0,0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [<span class="number">30,40,50,60</span>]</span><br><span class="line">输出: [<span class="number">1,1,1,0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: temperatures = <span class="comment">[30,60,90]</span></span><br><span class="line">输出: <span class="comment">[1,1,0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 下标</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// &lt;当前下标, 长度&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> L = i - stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">                mp[top] = L;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                temperatures[i] = mp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temperatures[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temperatures;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">&quot;1432219&quot;</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">&quot;1219&quot;</span></span><br><span class="line">解释：移除掉三个数字 <span class="number">4</span>, <span class="number">3</span>, 和 <span class="number">2</span> 形成一个新的最小的数字 <span class="number">1219</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">&quot;10200&quot;</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;200&quot;</span></span><br><span class="line">解释：移掉首位的 <span class="number">1</span> 剩下的数字为 <span class="number">200.</span> 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 ：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">&quot;10&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;0&quot;</span></span><br><span class="line">解释：从原数字移除所有的数字，剩余为空就是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= num.length &lt;= 105</code></li>
<li><code>num</code> 仅由若干位数字（0 - 9）组成</li>
<li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> isLeadingZero = <span class="literal">true</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk; <span class="comment">//存下标</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> k == <span class="number">1</span> ? <span class="string">&quot;0&quot;</span> : num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; num[i] - <span class="string">&#x27;0&#x27;</span> &lt; num[stk.<span class="built_in">top</span>()] - <span class="string">&#x27;0&#x27;</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                k --;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);      </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前k没用完,代表后面有多余的数 不然最后一个数没办法处理</span></span><br><span class="line">            k--;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += num[stk.<span class="built_in">top</span>()];</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(isLeadingZero &amp;&amp; res[i] == <span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">            isLeadingZero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>() ? res : <span class="string">&quot;0&quot;</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟栈 时空复杂度更小</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     string removeKdigits(string num, int k) &#123;</span></span><br><span class="line"><span class="comment">//         vector&lt;char&gt; stk;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; digit: num) &#123;</span></span><br><span class="line"><span class="comment">//             while (stk.size() &gt; 0 &amp;&amp; stk.back() &gt; digit &amp;&amp; k) &#123;</span></span><br><span class="line"><span class="comment">//                 stk.pop_back();</span></span><br><span class="line"><span class="comment">//                 k -= 1;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             stk.push_back(digit);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (; k &gt; 0; --k) &#123;</span></span><br><span class="line"><span class="comment">//             stk.pop_back();</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         string ans = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//         bool isLeadingZero = true;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; digit: stk) &#123;</span></span><br><span class="line"><span class="comment">//             if (isLeadingZero &amp;&amp; digit == &#x27;0&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//                 continue;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             isLeadingZero = false;</span></span><br><span class="line"><span class="comment">//             ans += digit;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return ans == &quot;&quot; ? &quot;0&quot; : ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>



<h3 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h3><p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 <strong>跨度</strong> 。</p>
<p>当日股票价格的 <strong>跨度</strong> 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>
<ul>
<li>例如，如果未来 7 天股票的价格是 <code>[100,80,60,70,60,75,85]</code>，那么股票跨度将是 <code>[1,1,1,2,1,4,6]</code> 。</li>
</ul>
<p>实现 <code>StockSpanner</code> 类：</p>
<ul>
<li><code>StockSpanner()</code> 初始化类对象。</li>
<li><code>int next(int price)</code> 给出今天的股价 <code>price</code> ，返回该股票当日价格的 <strong>跨度</strong> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;StockSpanner&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>]</span><br><span class="line">[[], [<span class="number">100</span>], [<span class="number">80</span>], [<span class="number">60</span>], [<span class="number">70</span>], [<span class="number">60</span>], [<span class="number">75</span>], [<span class="number">85</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockSpanner stockSpanner = new StockSpanner();</span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">100</span>); <span class="regexp">//</span> 返回 <span class="number">1</span></span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">80</span>);  <span class="regexp">//</span> 返回 <span class="number">1</span></span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">60</span>);  <span class="regexp">//</span> 返回 <span class="number">1</span></span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">70</span>);  <span class="regexp">//</span> 返回 <span class="number">2</span></span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">60</span>);  <span class="regexp">//</span> 返回 <span class="number">1</span></span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">75</span>);  <span class="regexp">//</span> 返回 <span class="number">4</span> ，因为截至今天的最后 <span class="number">4</span> 个股价 (包括今天的股价 <span class="number">75</span>) 都小于或等于今天的股价。</span><br><span class="line">stockSpanner.<span class="keyword">next</span>(<span class="number">85</span>);  <span class="regexp">//</span> 返回 <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= price &lt;= 105</code></li>
<li>最多调用 <code>next</code> 方法 <code>104</code> 次</li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; price &gt;= stk.<span class="built_in">top</span>().first)&#123; <span class="comment">// 新加入的price &gt;= 栈顶的price</span></span><br><span class="line">            res += stk.<span class="built_in">top</span>().second; </span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(price, res)); <span class="comment">// 前面没有小于等于price的 , 就只有它自己</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h3><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[2,6,4,8,10,9,15]</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：你只需要对 <span class="string">[6, 4, 8, 10, 9]</span> 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 单调栈(vector模拟)*/</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = n - <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="comment">//从左往右递增栈，找到不符合自己位置的最小元素的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; nums[stk.<span class="built_in">back</span>()] &gt; nums[i]) &#123;</span><br><span class="line">                l = <span class="built_in">min</span>(l, stk.<span class="built_in">back</span>());</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//从右往左递减栈，找到不符合自己位置的最大元素的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; nums[stk.<span class="built_in">back</span>()] &lt; nums[i]) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, stk.<span class="built_in">back</span>());</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r - l &gt; 0时所需排序长度为r - l + 1， r - l &lt;= 0时整体已经有序</span></span><br><span class="line">        <span class="keyword">return</span> r - l &gt; <span class="number">0</span> ? r - l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%90%88%E9%9B%86/rainwatertrap-8362159.png" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">0,1,0,2</span>,<span class="number">1,0,1,3</span>,<span class="number">2,1,2,1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0,1,0,2</span>,<span class="number">1,0,1,3</span>,<span class="number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：height = <span class="string">[4,2,0,3,2,5]</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>0 &lt;= height[i] &lt;= 105</code></li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><ul>
<li>单调栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们用栈保存每堵墙。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总体的原则就是，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前高度小于等于栈顶高度，入栈，指针后移。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> currHeight = <span class="built_in">min</span>(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>动态规划</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到每一列左边最高的墙和右边最高的墙</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// dp[0][0] = 0; 左边最高的墙</span></span><br><span class="line">        <span class="comment">// dp[n - 1][1] = 0; 右边最高的墙</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            dp[n - i - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[n - i][<span class="number">1</span>], height[n - i]);</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">            res += <span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]) &gt; height[i] ? <span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]) - height[i] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/10/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%90%88%E9%9B%86/histogram.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：heights = <span class="string">[2,1,5,6,2,3]</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/10/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%90%88%E9%9B%86/histogram-1.jpg" alt="img"></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入： heights </span>=<span class="string"> [2,4]</span></span><br><span class="line"><span class="string">输出： 4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;=105</code></li>
<li><code>0 &lt;= heights[i] &lt;= 104</code></li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><p><img src="/2022/10/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%90%88%E9%9B%86/7e876ae756613053b3432cebc9274e9dbdaafd2e6b8492d37fc34ee98f7655ea-%E5%9B%BE%E7%89%87.png" alt="图片.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于一个高度，如果能得到向左和向右的边界</span></span><br><span class="line"><span class="comment">// 那么就能对每个高度求一次面积</span></span><br><span class="line"><span class="comment">// 遍历所有高度，即可得出最大面积</span></span><br><span class="line"><span class="comment">// 使用单调栈，在出栈操作时得到前后边界并计算面积</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">      stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">      heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);  <span class="comment">// 若没在前加0，不能保证stack不为空，所以left的值就需要赋初始值0</span></span><br><span class="line">      heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[s.<span class="built_in">top</span>()])&#123;  <span class="comment">// 2进栈 6，5被弹出</span></span><br><span class="line">            <span class="comment">//6: cur = 4; left = 4; right = 4; (right - left + 1) = 1</span></span><br><span class="line">            <span class="comment">//5: cur = 3; left = 3; right = 4; (right - left + 1) = 2</span></span><br><span class="line">            <span class="type">int</span> cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = s.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = i - <span class="number">1</span>; </span><br><span class="line">            res = <span class="built_in">max</span>(res, (right - left + <span class="number">1</span>) * heights[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>链表之简单题合集</title>
    <url>/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">// 不能只判断 slow -&gt; next &amp;&amp; fast -&gt; next -&gt; next 因为 如果 fast -&gt; next 就为null的话，根本就没有 fast -&gt; next -&gt; next 这个东西</span></span><br><span class="line">        <span class="keyword">while</span>(slow -&gt; next &amp;&amp; fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next)&#123; </span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist-8435531.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist_test2-8435530.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/circularlinkedlist_test3-8435530.png" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        set&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(p) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(p);</span><br><span class="line">                p = p -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4,1,8,4</span>,<span class="number">5</span>], listB = [<span class="number">5,6,1,8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">8</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 <span class="keyword">A</span> 为 [<span class="number">4,1,8,4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5,6,1,8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 <span class="keyword">A</span> 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br><span class="line">— 请注意相交节点的值不为 <span class="number">1</span>，因为在链表 <span class="keyword">A</span> 和链表 B 之中值为 <span class="number">1</span> 的节点 (<span class="keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="keyword">A</span> 和链表 B 中值为 <span class="number">8</span> 的节点 (<span class="keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先统一位置，再同时往后遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p = headA;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        ListNode* q = headB;</span><br><span class="line">        <span class="type">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            lenA ++;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q)&#123;</span><br><span class="line">            lenB ++;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* temp1 = lenA &gt;= lenB ? headA : headB;</span><br><span class="line">        ListNode* temp2 = lenA &gt;= lenB ? headB : headA;</span><br><span class="line">        <span class="type">int</span> dist = <span class="built_in">abs</span>(lenA - lenB);</span><br><span class="line">        <span class="keyword">while</span>(dist--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!temp1 || !temp1 -&gt; next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            temp1 = temp1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp1 &amp;&amp; temp2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp1 == temp2) <span class="keyword">return</span> temp1;</span><br><span class="line">            temp2 = temp2 -&gt; next;</span><br><span class="line">            temp1 = temp1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h3><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/partition.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,4,3,2,5,2]</span>, x = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[1,2,2,4,3,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[2,1]</span>, x = 2</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><ul>
<li>维护两个链表，一个放小的，一个放大的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode * headSmall = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        ListNode * headLarge = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        ListNode * p = headSmall;</span><br><span class="line">        ListNode * q = headLarge;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head -&gt; val &lt; x)&#123;</span><br><span class="line">                p -&gt; next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head -&gt; val, <span class="literal">nullptr</span>);</span><br><span class="line">                p = p -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q -&gt; next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head -&gt; val, <span class="literal">nullptr</span>);</span><br><span class="line">                q = q -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = headLarge -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> headSmall -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h3><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/rotate1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[4,5,1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/roate2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[0,1,2]</span>, k = 4</span><br><span class="line">输出：<span class="comment">[2,0,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 2 * 109</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整段取下接到前面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* p = dummy -&gt; next;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            len ++;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k % len == <span class="number">0</span>) <span class="keyword">return</span> head;  <span class="comment">// 转 k 次 和转 （k % 链表长度） 次的效果一样</span></span><br><span class="line">        <span class="type">int</span> cnt = len - k % len; </span><br><span class="line">        ListNode* pre = dummy -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(--cnt &gt; <span class="number">0</span>) pre = pre -&gt; next;</span><br><span class="line">        ListNode * tail = pre -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(tail -&gt; next) tail = tail -&gt; next;</span><br><span class="line">        tail -&gt; next = dummy -&gt; next;</span><br><span class="line">        dummy -&gt; next = pre -&gt; next;</span><br><span class="line">        pre -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确但超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">while</span>(k-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode * pre = dummy;</span><br><span class="line">            <span class="keyword">while</span>(pre -&gt; next -&gt; next &amp;&amp; pre -&gt; next)&#123;</span><br><span class="line">                pre = pre -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre -&gt; next -&gt; next = dummy -&gt; next;</span><br><span class="line">            dummy -&gt; next = pre -&gt; next;</span><br><span class="line">            pre -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/remove_ex1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><ul>
<li>双指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* pre = dummy;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(n -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next)&#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            pre = pre -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre -&gt; next = pre -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       head -&gt; next = <span class="built_in">removeNthFromEnd</span>(head -&gt; next, n);</span><br><span class="line">       cur ++; <span class="comment">// 不能传参数 n-- 递归，因为是倒数统计，从最后一个节点向前return</span></span><br><span class="line">       <span class="keyword">if</span>(n == cur) <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/removelinked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>



<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; val == val) <span class="keyword">return</span> <span class="built_in">removeElements</span>(head -&gt; next, val);</span><br><span class="line">        head -&gt; next = <span class="built_in">removeElements</span>(head -&gt; next, val);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/list1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/list2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2,3,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><ul>
<li>非递归版</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-101</span>, head);</span><br><span class="line">        ListNode* pre = dummy;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; cur -&gt; val == pre -&gt; val)&#123;</span><br><span class="line">                pre -&gt; next = cur -&gt; next;</span><br><span class="line">                cur = pre -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!cur) <span class="keyword">break</span>;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            pre = pre -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归版</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">-101</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; val == pre) <span class="keyword">return</span> <span class="built_in">deleteDuplicates</span>(head -&gt; next);</span><br><span class="line">        pre = head -&gt; val;</span><br><span class="line">        head -&gt; next = <span class="built_in">deleteDuplicates</span>(head -&gt; next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/linkedlist1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2,3,3,4,4,5]</span></span><br><span class="line">输出：<span class="comment">[1,2,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/linkedlist2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,1,2,3]</span></span><br><span class="line">输出：<span class="comment">[2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><ul>
<li>非递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-101</span>, head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        ListNode* pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur -&gt; next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; next -&gt;val == cur -&gt; val)&#123;</span><br><span class="line">                <span class="type">int</span> val = cur -&gt; val;</span><br><span class="line">                <span class="keyword">while</span>(cur &amp;&amp; cur -&gt; val == val) cur = cur -&gt; next;</span><br><span class="line">                pre -&gt; next = cur;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<p>head 后面有值而且和 head 的值相等，那么就找到第一个不相等的节点为止，然后对它去递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next &amp;&amp; head -&gt; val == head -&gt; next -&gt; val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head -&gt; next &amp;&amp; head -&gt; val == head -&gt; next -&gt; val)&#123;</span><br><span class="line">                head = head -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteDuplicates</span>(head -&gt; next);</span><br><span class="line">        &#125;</span><br><span class="line">        head -&gt; next = <span class="built_in">deleteDuplicates</span>(head -&gt; next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/">328. 奇偶链表</a></h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/oddeven-linked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入: head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出: <span class="string">[1,3,5,2,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="/2022/11/10/%E9%93%BE%E8%A1%A8%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%E5%90%88%E9%9B%86/oddeven2-linked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入: head = <span class="string">[2,1,3,5,6,4,7]</span></span><br><span class="line">输出: <span class="string">[2,3,6,7,1,5,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>n == </code> 链表中的节点数</li>
<li><code>0 &lt;= n &lt;= 104</code></li>
<li><code>-106 &lt;= Node.val &lt;= 106</code></li>
</ul>
<h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* evenHead = head -&gt; next;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(even &amp;&amp; even -&gt; next)&#123;  <span class="comment">// 等价于 odd &amp;&amp; odd -&gt; next &amp;&amp; even &amp;&amp; even -&gt; next</span></span><br><span class="line">            odd -&gt; next = even -&gt; next;</span><br><span class="line">            odd = odd -&gt; next;</span><br><span class="line">            even -&gt; next = odd -&gt; next;</span><br><span class="line">            even = even -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd -&gt; next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-PROJECTS</title>
    <url>/2022/11/28/CMU-15-445-PROJECTS/</url>
    <content><![CDATA[<h3 id="PROJECT-1-BUFFER-POOL"><a href="#PROJECT-1-BUFFER-POOL" class="headerlink" title="PROJECT #1 - BUFFER POOL"></a>PROJECT #1 - BUFFER POOL</h3><h4 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h4><p>During the semester, you will be building <strong>a new disk-oriented storage manager for the <a href="https://github.com/cmu-db/bustub">BusTub</a> DBMS</strong>. Such a storage manager assumes that the primary storage location of the database is on disk.</p>
<p>The first programming project is to implement a <strong>buffer pool</strong> in your storage manager. 缓冲池负责将物理页从主存来回移动到磁盘。它让DBMS支持大于系统可用内存量的数据库</p>
<p>缓冲池的操作对系统中的其他部分是透明的。 比如，系统用<code>page_id_t</code>向缓冲池请求一个页面，它不知道该页面是否已经在内存中，也不知道系统是否必须从磁盘检索它</p>
<p><strong>Your implementation will need to be thread-safe</strong>. Multiple threads will be accessing the internal data structures at the same and thus you need to make sure that their critical sections are protected with <a href="https://stackoverflow.com/a/42464336">latches</a> (these are called “locks” in operating systems).</p>
<h4 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a>TASK #1 - LRU REPLACEMENT POLICY</h4><p>该组件负责跟踪缓冲池中的页面使用情况。You will implement a new sub-class called <code>LRUReplacer</code> in <code>src/include/buffer/lru_replacer.h</code> and its corresponding implementation file in <code>src/buffer/lru_replacer.cpp</code>. <code>LRUReplacer</code> extends the abstract <code>Replacer</code> class (<code>src/include/buffer/replacer.h</code>), which contains the function specifications.</p>
<p>The maximum number of pages for the <code>LRUReplacer</code> &#x3D; the size of the buffer pool .However, at any given moment not all the frames are considered to be in the <code>LRUReplacer</code>. The <code>LRUReplacer</code> is initialized to have no frames in it. Then, only the newly unpinned ones will be considered to be in the <code>LRUReplacer</code></p>
<p><em><strong>You will need to implement the LRU policy discussed in the class. You will need to implement the following methods:</strong></em></p>
<ul>
<li><p><em><strong><code>Victim(frame_id_t*)</code> : 与<code>Replacer</code>所跟踪的所有其他元素相比，删除最近访问次数最少的对象。将其内容存储在输出参数中并返回 <code>True</code>. If the <code>Replacer</code> is empty return <code>False</code>.</strong></em></p>
</li>
<li><p><em><strong><code>Pin(frame_id_t)</code> : This method should be called after a page is pinned to a frame in the <code>BufferPoolManager</code>. It should remove the frame containing the pinned page from the <code>LRUReplacer</code>.</strong></em></p>
</li>
<li><p><em><strong><code>Unpin(frame_id_t)</code> : This method should be called when the <code>pin_count</code> of a page becomes 0. This method should add the frame containing the unpinned page to the <code>LRUReplacer</code>.</strong></em></p>
</li>
<li><p><em><strong><code>Size()</code>:该方法返回当前在<code>LRUReplacer</code>中的帧数量</strong></em></p>
</li>
</ul>
<blockquote>
<p>  Pin —&gt; 移出LRUReplacer</p>
<p>  Unpin —&gt; pin_count – 若pin_count &#x3D;&#x3D; 0 —&gt; 进入LRUReplacer</p>
</blockquote>
<h5 id="replacer-h"><a href="#replacer-h" class="headerlink" title="replacer.h"></a>replacer.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"><span class="comment">// Replacer is an abstract class that tracks page usage.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Replacer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Replacer</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Replacer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove the victim frame as defined by the replacement policy.</span></span><br><span class="line"><span class="comment">   * @param[out] frame_id id of frame that was removed, nullptr if no victim was found</span></span><br><span class="line"><span class="comment">   * @return true if a victim frame was found, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// pin了代表我要用了，不应该成为victim，得从队列中移出</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unpin代表我要开始监视你了，放入队列头  </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @return the number of elements in the replacer that can be victimized */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h5 id="lru-replacer-h"><a href="#lru-replacer-h" class="headerlink" title="lru_replacer.h"></a>lru_replacer.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">// NOLINT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/replacer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUReplacer</span> : <span class="keyword">public</span> Replacer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// num_pages = maximum number of pages the LRUReplacer will be required to store</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LRUReplacer</span><span class="params">(<span class="type">size_t</span> num_pages)</span></span>; </span><br><span class="line">  ~<span class="built_in">LRUReplacer</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// TODO(student): implement me!</span></span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; lru_list_;                                            <span class="comment">// 双向链表，存放frame_id_t</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; lru_hash_;  <span class="comment">// 哈希表，value存储一个迭代器</span></span><br><span class="line">  <span class="type">size_t</span> max_size_;                                                           <span class="comment">// 最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h5 id="lru-replacer-cpp"><a href="#lru-replacer-cpp" class="headerlink" title="lru_replacer.cpp"></a>lru_replacer.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/lru_replacer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line">LRUReplacer::<span class="built_in">LRUReplacer</span>(<span class="type">size_t</span> num_pages) &#123; max_size_ = num_pages; &#125;</span><br><span class="line"></span><br><span class="line">LRUReplacer::~<span class="built_in">LRUReplacer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用LRU策略删除一个victim frame，这个函数能得到frame_id</span></span><br><span class="line"><span class="comment">// @param[out] *frame_id 在指针中写入被删除的id</span></span><br><span class="line"><span class="comment">// @return 如果删除成功返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;mutex_&#125;; <span class="comment">// 将多个锁（std::mutex等）包装成一种锁类型，用于线程一次性申请多个锁; 当程序出现异常，可自动析构.</span></span><br><span class="line">  <span class="keyword">if</span> (lru_list_.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双向链表不为空，取最后一个</span></span><br><span class="line">  *frame_id = lru_list_.<span class="built_in">back</span>();</span><br><span class="line">  lru_hash_.<span class="built_in">erase</span>(lru_list_.<span class="built_in">back</span>());</span><br><span class="line">  lru_list_.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定一个frame, 表明它不应该成为victim（即在replacer中移除该frame_id）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;mutex_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = lru_hash_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (iter == lru_hash_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lru_list_.<span class="built_in">erase</span>(iter-&gt;second);</span><br><span class="line">  lru_hash_.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;mutex_&#125;;</span><br><span class="line">  <span class="keyword">if</span> (lru_hash_.<span class="built_in">count</span>(frame_id) != <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 避免重复添加</span></span><br><span class="line">  <span class="keyword">if</span> (lru_list_.<span class="built_in">size</span>() &gt;= max_size_) <span class="keyword">return</span>; <span class="comment">// 超容量了</span></span><br><span class="line">  </span><br><span class="line">  lru_list_.<span class="built_in">push_front</span>(frame_id); <span class="comment">// 添加到链表头</span></span><br><span class="line">  lru_hash_[frame_id] = lru_list_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回replacer中能够victim的数量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;mutex_&#125;;</span><br><span class="line">  <span class="keyword">return</span> lru_list_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>







<h4 id="TASK-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#TASK-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="TASK #2 - BUFFER POOL MANAGER INSTANCE"></a>TASK #2 - BUFFER POOL MANAGER INSTANCE</h4><p>Next, you need to implement the buffer pool manager in your system (<code>BufferPoolManagerInstance</code>). The <em><strong><code>BufferPoolManagerInstance</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory.</strong></em> <em><strong>The <code>BufferPoolManagerInstance</code> can also write dirty pages out to disk</strong></em> when it is either ( …之一 )  explicitly instructed to do so or when it needs to evict ( 驱逐 ) a page to make space for a new page.</p>
<p>为了确保您的实现与系统的其余部分正确工作，我们将为您提供一些已经填充的函数。您也不需要实现实际向磁盘读写数据的代码(在我们的实现中称为<code>DiskManager</code>)。我们将为您提供该功能。</p>
<p>系统中所有内存中的页面都由<code>Page</code>对象表示。<code>BufferPoolManagerInstance</code>不需要理解这些页面的内容。每个<code>Page</code>对象都包含一个内存块，<code>DiskManager</code>将使用该内存块作为位置，复制它从磁盘读取的物理页面的内容。当数据来回移动到磁盘时，<code>BufferPoolManagerInstance</code>将重用相同的Page对象来存储数据。这意味着在系统的整个生命周期中，同一个<code>Page</code>对象可能包含不同的物理页面。<code>Page</code>对象的标识符(<code>page_id</code>)跟踪它所包含的物理页面;如果<code>Page</code>对象不包含物理页面，那么它的<code>page_id</code>必须设置为<code>INVALID_PAGE_ID</code></p>
<p>Each <code>Page</code> object also maintains a counter for the number of threads that have “pinned” that page. Your <code>BufferPoolManagerInstance</code> is not allowed to free a <code>Page</code> that is pinned. Each <code>Page</code> object also keeps track of whether it is dirty or not. It is your job to record whether a page was modified before it is unpinned. Your <code>BufferPoolManagerInstance</code> must write the contents of a dirty <code>Page</code> back to disk before that object can be reused.</p>
<p>Your <code>BufferPoolManagerInstance</code> implementation will use the <code>LRUReplacer</code> class ,It will use the <code>LRUReplacer</code> to keep track of when <code>Page</code> objects are accessed so that it can decide which one to evict when it must free a frame to make room for copying a new physical page from disk.</p>
<p><em><strong>You will need to implement the following functions defined in the header file (<code>src/include/buffer/buffer_pool_manager_instance.h</code>) in the source file (<code>src/buffer/buffer_pool_manager_instance.cpp</code>):</strong></em></p>
<ul>
<li><em><strong><code>FetchPgImp(page_id)</code>：you should return NULL if no page is available in the free list and all other pages are currently pinned. FlushPgImp should flush a page regardless of its pin status</strong></em></li>
<li><em><strong><code>UnpinPgImp(page_id, is_dirty)</code>：is_dirty参数跟踪页面在固定时是否被修改</strong></em></li>
<li><em><strong><code>FlushPgImp(page_id)</code></strong></em></li>
<li><em><strong><code>NewPgImp(page_id)</code></strong></em></li>
<li><em><strong><code>DeletePgImp(page_id)</code></strong></em></li>
<li><em><strong><code>FlushAllPagesImpl()</code></strong></em></li>
</ul>
<p><strong>Note:</strong> <code>Pin</code> and <code>Unpin</code> within the contexts of the <code>LRUReplacer</code> and the <code>BufferPoolManagerInstance</code> have inverse meanings.</p>
<ul>
<li><p><em><strong>Within the context of the <code>LRUReplacer</code>, pinning a page implies that we shouldn’t evict the page because it is in use.</strong></em> <em><strong>This means we should remove it from the <code>LRUReplacer</code></strong></em></p>
</li>
<li><p><em><strong>On the other hand, pinning a page in the <code>BufferPoolManagerInstance</code> implies that we want to use a page, and that it should not be removed from the buffer pool.</strong></em></p>
</li>
</ul>
<h5 id="page-h"><a href="#page-h" class="headerlink" title="page.h"></a>page.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/rwlatch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page is the basic unit of storage within the database system. Page provides a wrapper for actual data pages being</span></span><br><span class="line"><span class="comment"> * held in main memory. Page also contains book-keeping information that is used by the buffer pool manager, e.g.</span></span><br><span class="line"><span class="comment"> * pin count, dirty flag, page id, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BufferPoolManagerInstance</span>; <span class="comment">// There is book-keeping information inside the page that should only be relevant to the buffer pool manager.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Page</span>() &#123; <span class="built_in">ResetMemory</span>(); &#125; <span class="comment">// 清空页面数据</span></span><br><span class="line">  ~<span class="built_in">Page</span>() = <span class="keyword">default</span>; <span class="comment">// Default destructor.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> *<span class="title">GetData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125; <span class="comment">// return the actual data contained within this page </span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">page_id_t</span> <span class="title">GetPageId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> page_id_; &#125; <span class="comment">// return the page id of this page</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetPinCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pin_count_; &#125; <span class="comment">// return the pin count of this page</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsDirty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> is_dirty_; &#125; <span class="comment">// 是否在内存中被修改</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">WLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WLock</span>(); &#125; <span class="comment">// 锁住页，不让写</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">WUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WUnlock</span>(); &#125; <span class="comment">// 释放写锁</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RLock</span>(); &#125; <span class="comment">// 锁住页，不让读</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RUnlock</span>(); &#125; <span class="comment">// 释放读锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">lsn_t</span> <span class="title">GetLSN</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">lsn_t</span> *&gt;(<span class="built_in">GetData</span>() + OFFSET_LSN); &#125; <span class="comment">// log sequence number</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetLSN</span><span class="params">(<span class="type">lsn_t</span> lsn)</span> </span>&#123; <span class="built_in">memcpy</span>(<span class="built_in">GetData</span>() + OFFSET_LSN, &amp;lsn, <span class="built_in">sizeof</span>(<span class="type">lsn_t</span>)); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">page_id_t</span>) == <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">lsn_t</span>) == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> SIZE_PAGE_HEADER = <span class="number">8</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> OFFSET_PAGE_START = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> OFFSET_LSN = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ResetMemory</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(data_, OFFSET_PAGE_START, PAGE_SIZE); &#125; <span class="comment">// 将页面中保存的数据归零</span></span><br><span class="line">  <span class="type">char</span> data_[PAGE_SIZE]&#123;&#125;; <span class="comment">// The actual data that is stored within a page</span></span><br><span class="line">  <span class="type">page_id_t</span> page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  <span class="type">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  ReaderWriterLatch rwlatch_; <span class="comment">// Page latch</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="disk-manager-h"><a href="#disk-manager-h" class="headerlink" title="disk_manager.h"></a>disk_manager.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  <span class="comment">// NOLINT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>   <span class="comment">// NOLINT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiskManager takes care of the allocation and deallocation of pages within a database. It performs the reading and</span></span><br><span class="line"><span class="comment"> * writing of pages to and from disk, providing a logical file layer within the context of a database management system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskManager</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">DiskManager</span><span class="params">(<span class="type">const</span> std::string &amp;db_file)</span></span>; <span class="comment">// 创建写入指定数据库文件的新磁盘管理器。db_file是要写入的数据库文件的文件名</span></span><br><span class="line">  ~<span class="built_in">DiskManager</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ShutDown</span><span class="params">()</span></span>; <span class="comment">// 关闭磁盘管理器并关闭所有文件资源</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WritePage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">const</span> <span class="type">char</span> *page_data)</span></span>; <span class="comment">// 向数据库文件写入一个页面</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReadPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">char</span> *page_data)</span></span>; <span class="comment">// Read a page from the database file.  page_data是一个传出buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteLog</span><span class="params">(<span class="type">char</span> *log_data, <span class="type">int</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ReadLog</span><span class="params">(<span class="type">char</span> *log_data, <span class="type">int</span> size, <span class="type">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetNumFlushes</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回磁盘刷新次数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetFlushState</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 如果内存中的内容尚未刷新，则返回true</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetNumWrites</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回磁盘写次数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the future which is used to check for non-blocking flushes.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetFlushLogFuture</span><span class="params">(std::future&lt;<span class="type">void</span>&gt; *f)</span> </span>&#123; flush_log_f_ = f; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">HasFlushLogFuture</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> flush_log_f_ != <span class="literal">nullptr</span>; &#125; <span class="comment">// 检查是否设置了non-blocking flush future</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetFileSize</span><span class="params">(<span class="type">const</span> std::string &amp;file_name)</span></span>;</span><br><span class="line">  <span class="comment">// stream to write log file</span></span><br><span class="line">  std::fstream log_io_;</span><br><span class="line">  std::string log_name_;</span><br><span class="line">  <span class="comment">// stream to write db file</span></span><br><span class="line">  std::fstream db_io_;</span><br><span class="line">  std::string file_name_;</span><br><span class="line">  <span class="type">int</span> num_flushes_;</span><br><span class="line">  <span class="type">int</span> num_writes_;</span><br><span class="line">  <span class="type">bool</span> flush_log_;</span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; *flush_log_f_;</span><br><span class="line">  <span class="comment">// With multiple buffer pool instances, need to protect file access</span></span><br><span class="line">  std::mutex db_io_latch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h5 id="buffer-pool-manager-instance-h"><a href="#buffer-pool-manager-instance-h" class="headerlink" title="buffer_pool_manager_instance.h"></a>buffer_pool_manager_instance.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">// NOLINT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/buffer_pool_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/lru_replacer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;recovery/log_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;storage/disk/disk_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;storage/page/page.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"><span class="comment">// BufferPoolManager reads disk pages to and from its internal buffer pool.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManagerInstance</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new BufferPoolManagerInstance.</span></span><br><span class="line"><span class="comment">   * @param pool_size the size of the buffer pool</span></span><br><span class="line"><span class="comment">   * @param disk_manager the disk manager</span></span><br><span class="line"><span class="comment">   * @param log_manager the log manager (for testing only: nullptr = disable logging)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">BufferPoolManagerInstance</span>(<span class="type">size_t</span> pool_size, DiskManager *disk_manager, LogManager *log_manager = <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new BufferPoolManagerInstance.</span></span><br><span class="line"><span class="comment">   * @param pool_size the size of the buffer pool</span></span><br><span class="line"><span class="comment">   * @param num_instances total number of BPIs in parallel BPM</span></span><br><span class="line"><span class="comment">   * @param instance_index index of this BPI in the parallel BPM</span></span><br><span class="line"><span class="comment">   * @param disk_manager the disk manager</span></span><br><span class="line"><span class="comment">   * @param log_manager the log manager (for testing only: nullptr = disable logging)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">BufferPoolManagerInstance</span>(<span class="type">size_t</span> pool_size, <span class="type">uint32_t</span> num_instances, <span class="type">uint32_t</span> instance_index,</span><br><span class="line">                            DiskManager *disk_manager, LogManager *log_manager = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">BufferPoolManagerInstance</span>() <span class="keyword">override</span>; <span class="comment">// Destroys an existing BufferPoolManagerInstance.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> pool_size_; &#125; <span class="comment">// return size of the buffer pool</span></span><br><span class="line">  <span class="function">Page *<span class="title">GetPages</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pages_; &#125; <span class="comment">// return pointer to all the pages in the buffer pool</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">Page *<span class="title">FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// Fetch the requested page from the buffer pool.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> <span class="keyword">override</span></span>; <span class="comment">// BufferPool里不需要你了，走吧 Unpin the target page from the buffer pool.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return false if the page could not be found in the page table, true otherwise</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// 将目标页刷新到磁盘</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 将缓冲池中的所有页刷新到磁盘</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new page in the buffer pool.</span></span><br><span class="line"><span class="comment">   * @param[out] page_id id of created page</span></span><br><span class="line"><span class="comment">   * @return nullptr if no new pages could be created, otherwise pointer to new page</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Page *<span class="title">NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Deletes a page from the buffer pool.</span></span><br><span class="line"><span class="comment">   * @param page_id id of page to be deleted</span></span><br><span class="line"><span class="comment">   * @return false if the page exists but could not be deleted, true if the page didn&#x27;t exist or deletion succeeded</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">page_id_t</span> <span class="title">AllocatePage</span><span class="params">()</span></span>; <span class="comment">// 在磁盘上分配一个页面，返回已分配页面的id</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DeallocatePage</span><span class="params">(__attribute__((unused)) <span class="type">page_id_t</span> page_id)</span> </span>&#123; <span class="comment">// 从磁盘上释放一个页</span></span><br><span class="line">    <span class="comment">// This is a no-nop right now without a more complex data structure to track deallocated pages</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证正在使用的page_id是否可被此BPI访问， 这可以在所有函数中使用，以验证输入数据，并确保并行BPM将请求路由到正确的BPI</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ValidatePageId</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="type">const</span></span>; </span><br><span class="line">    </span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> pool_size_; <span class="comment">// Number of pages in the buffer pool</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> num_instances_ = <span class="number">1</span>; <span class="comment">// How many instances are in the parallel BPM (if present, otherwise just 1 BPI)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> instance_index_ = <span class="number">0</span>; <span class="comment">// Index of this BPI in the parallel BPM (if present, otherwise just 0)</span></span><br><span class="line">  <span class="comment">/** Each BPI maintains its own counter for page_ids to hand out, must ensure they mod back to its instance_index_ */</span></span><br><span class="line">  std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = instance_index_;</span><br><span class="line"></span><br><span class="line">  Page *pages_; <span class="comment">// Array of buffer pool pages</span></span><br><span class="line">  DiskManager *disk_manager_ __attribute__((__unused__)); <span class="comment">// 指向磁盘管理器的指针</span></span><br><span class="line">  LogManager *log_manager_ __attribute__((__unused__)); <span class="comment">// 指向日志管理器的指针</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_; <span class="comment">// 页表，用于跟踪缓冲池页</span></span><br><span class="line">  Replacer *replacer_; <span class="comment">// 替换程序来查找要替换的未固定页</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_; <span class="comment">// 空白页链表</span></span><br><span class="line">  <span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h5 id="buffer-pool-manager-instance-cpp"><a href="#buffer-pool-manager-instance-cpp" class="headerlink" title="buffer_pool_manager_instance.cpp"></a>buffer_pool_manager_instance.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/buffer_pool_manager_instance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/macros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"><span class="comment">// 构造函数1</span></span><br><span class="line">BufferPoolManagerInstance::<span class="built_in">BufferPoolManagerInstance</span>(<span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                                                     LogManager *log_manager)</span><br><span class="line">    : <span class="built_in">BufferPoolManagerInstance</span>(pool_size, <span class="number">1</span>, <span class="number">0</span>, disk_manager, log_manager) &#123;&#125;</span><br><span class="line"><span class="comment">// 构造函数2,使用函数重载</span></span><br><span class="line">BufferPoolManagerInstance::<span class="built_in">BufferPoolManagerInstance</span>(<span class="type">size_t</span> pool_size, <span class="type">uint32_t</span> num_instances, <span class="type">uint32_t</span> instance_index,</span><br><span class="line">                                                     DiskManager *disk_manager, LogManager *log_manager)</span><br><span class="line">    : <span class="built_in">pool_size_</span>(pool_size),</span><br><span class="line">      <span class="built_in">num_instances_</span>(num_instances),</span><br><span class="line">      <span class="built_in">instance_index_</span>(instance_index),</span><br><span class="line">      <span class="built_in">next_page_id_</span>(<span class="built_in">static_cast</span>&lt;<span class="type">page_id_t</span>&gt;(instance_index)),</span><br><span class="line">      <span class="built_in">disk_manager_</span>(disk_manager),</span><br><span class="line">      <span class="built_in">log_manager_</span>(log_manager) &#123;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(num_instances &gt; <span class="number">0</span>, <span class="string">&quot;If BPI is not part of a pool, then the pool size should just be 1&quot;</span>);</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(</span><br><span class="line">      instance_index &lt; num_instances,</span><br><span class="line">      <span class="string">&quot;BPI index cannot be greater than the number of BPIs in the pool. In non-parallel case, index should just be 1.&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化该BPI的页数组和替换策略</span></span><br><span class="line">  pages_ = <span class="keyword">new</span> Page[pool_size_];</span><br><span class="line">  replacer_ = <span class="keyword">new</span> <span class="built_in">LRUReplacer</span>(pool_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最初，每个页面都在空闲列表中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    free_list_.<span class="built_in">emplace_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BufferPoolManagerInstance::~<span class="built_in">BufferPoolManagerInstance</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] pages_;</span><br><span class="line">  <span class="keyword">delete</span> replacer_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新目标页到磁盘</span></span><br><span class="line"><span class="comment"> * @param page_id id of page to be flushed, cannot be INVALID_PAGE_ID</span></span><br><span class="line"><span class="comment"> * @return false if the page could not be found in the page table, true otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">if</span> (page_id == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果page不在页表中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在页表中找到frameid，然后根据他获取Page对象</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second; <span class="comment">// std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_; </span></span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;  <span class="comment">// 刷新之后重置dirty状态</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新buffer pool中的所有页到磁盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span> (iter != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> page_id = iter-&gt;first;</span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">    Page *page = &amp;pages_[frame_id];</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    iter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在缓冲池中创建一个新页面 page_id为传出参数</span></span><br><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="comment">// 优先从freelist里获取空页(内存区域)，没有就去replacer中找一个(内存区域)，如果都找不到就返回nullptr</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  Page *page = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 在页表中更新</span></span><br><span class="line">    page = &amp;pages_[frame_id]; </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id)) &#123;</span><br><span class="line">    page = &amp;pages_[frame_id];</span><br><span class="line">    <span class="comment">// 从replacer中找到的页面要从pagetable中先删除</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;<span class="built_in">GetPageId</span>(), page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">page_id_t</span> new_page_id = <span class="built_in">AllocatePage</span>(); <span class="comment">// 在磁盘上分配一个页面(磁盘区域)，返回已分配页面的id</span></span><br><span class="line">  page-&gt;page_id_ = new_page_id;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>(); <span class="comment">// 将页面中保存的数据归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加到pagetable，Pin该页面并返回数据</span></span><br><span class="line">  page_table_[new_page_id] = frame_id;</span><br><span class="line">  *page_id = new_page_id;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓冲池中获取请求的页面</span></span><br><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// 如果存在，即Page在缓冲池中</span></span><br><span class="line">  <span class="keyword">if</span> (iter != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到这个页面，Pin它并返回它</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">    Page *page = &amp;pages_[frame_id];</span><br><span class="line">    page-&gt;pin_count_++;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在，即Page在磁盘中</span></span><br><span class="line">  <span class="comment">// 优先从freelist里获取空页，没有就去replacer中找一个，如果都找不到就返回nullptr</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  Page *page = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = &amp;pages_[frame_id];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id)) &#123;</span><br><span class="line">    page = &amp;pages_[frame_id];</span><br><span class="line">    <span class="comment">// 从replacer中找到的页面要从pagetable中先删除</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;<span class="built_in">GetPageId</span>(), page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置状态</span></span><br><span class="line">  page-&gt;page_id_ = page_id;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 填充Page内容</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="comment">// 添加到pagetable，Pin该页面并返回数据</span></span><br><span class="line">  page_table_[page_id] = frame_id;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓冲池中删除一个指定的页面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// 如果不存在，即Page在磁盘中，直接返回成功</span></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// DeallocatePage(page_id);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在，即Page在缓冲池中</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// 如果PinCount不为0，则说明有人在用，返回失败</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetPinCount</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清理，更新元数据，删除pagetable，返还至freelist</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;<span class="built_in">GetPageId</span>(), page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">0</span>;</span><br><span class="line">  page-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">  <span class="comment">// DeallocatePage(page_id);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在缓冲池中Unpin一个页面</span></span><br><span class="line"><span class="comment"> * @return false if the page pin count is &lt;= 0 before this call, true otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// 如果不存在，即Page在磁盘中，直接返回true</span></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在，即Page在缓冲池中</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetPinCount</span>() &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 如果没被pin过，直接返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;pin_count_--;</span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;  <span class="comment">// 判断而非直接赋值是为了避免覆盖以前的状态</span></span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetPinCount</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">BufferPoolManagerInstance::AllocatePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">page_id_t</span> next_page_id = next_page_id_;</span><br><span class="line">  next_page_id_ += num_instances_;</span><br><span class="line">  <span class="built_in">ValidatePageId</span>(next_page_id);</span><br><span class="line">  <span class="keyword">return</span> next_page_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManagerInstance::ValidatePageId</span><span class="params">(<span class="type">const</span> <span class="type">page_id_t</span> page_id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(page_id % num_instances_ == instance_index_);  <span class="comment">// allocated pages mod back to this BPI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>



<h4 id="TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #3 - PARALLEL BUFFER POOL MANAGER"></a>TASK #3 - PARALLEL BUFFER POOL MANAGER</h4><p>As you probably noticed in the previous task, the single Buffer Pool Manager Instance needs to take latches in order to be thread safe. This can cause a lot of contention as every thread fights over a single latch when interacting with the buffer pool. One potential solution is to have multiple buffer pools in your system, each with it’s own latch.</p>
<p><code>ParallelBufferPoolManager</code> is a class that holds multiple <code>BufferPoolManagerInstance</code>s. For every operation the <code>ParallelBufferPoolManager</code> picks a single <code>BufferPoolManagerInstance</code> and delegates to that instance.</p>
<p>We use the given page id to determine which specific <code>BufferPoolManagerInstance</code> to use. If we have <code>num_instances</code> many <code>BufferPoolManagerInstance</code>s, then we need some way to map the given page id to a number in the range [0, num_instances). For this project we will be using the modulo operator, <code>page_id mod num_instances</code> will map the given page_id to the correct range.</p>
<p>When the <code>ParallelBufferPoolManager</code> is first instantiated it should have a starting index of 0. Every time you create a new page you will try every <code>BufferPoolManagerInstance</code>, starting at the starting index, until one is successful. Then increase the starting index by one.</p>
<p>Make sure that when you create the individual <code>BufferPoolManagerInstance</code>s you use the constructor that takes <code>uint32_t num_instances</code> and <code>uint32_t instance_index</code> so that page ids are created correctly.</p>
<p><strong>You will need to implement the following functions defined in the header file (<code>src/include/buffer/parallel_buffer_pool_manager.h</code>) in the source file (<code>src/buffer/parallel_buffer_pool_manager.cpp</code>):</strong></p>
<ul>
<li><em><strong><code>ParallelBufferPoolManager(num_instances, pool_size, disk_manager, log_manager)</code></strong></em></li>
<li><em><strong><code>~ParallelBufferPoolManager()</code></strong></em></li>
<li><em><strong><code>GetPoolSize()</code></strong></em></li>
<li><em><strong><code>GetBufferPoolManager(page_id)</code></strong></em></li>
<li><em><strong><code>FetchPgImp(page_id)</code></strong></em></li>
<li><em><strong><code>UnpinPgImp(page_id, is_dirty)</code></strong></em></li>
<li><em><strong><code>FlushPgImp(page_id)</code></strong></em></li>
<li><em><strong><code>NewPgImp(page_id)</code></strong></em></li>
<li><em><strong><code>DeletePgImp(page_id)</code></strong></em></li>
<li><em><strong><code>FlushAllPagesImpl()</code></strong></em></li>
</ul>
<h5 id="parallel-buffer-pool-manager-h"><a href="#parallel-buffer-pool-manager-h" class="headerlink" title="parallel_buffer_pool_manager.h"></a>parallel_buffer_pool_manager.h</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/buffer_pool_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/buffer_pool_manager_instance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;recovery/log_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;storage/disk/disk_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;storage/page/page.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelBufferPoolManager</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new ParallelBufferPoolManager.</span></span><br><span class="line"><span class="comment">   * @param the number of individual BufferPoolManagerInstances to store</span></span><br><span class="line"><span class="comment">   * @param pool_size the pool size of each BufferPoolManagerInstance</span></span><br><span class="line"><span class="comment">   * @param disk_manager the disk manager</span></span><br><span class="line"><span class="comment">   * @param log_manager the log manager (for testing only: nullptr = disable logging)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                            LogManager *log_manager = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ParallelBufferPoolManager</span>() <span class="keyword">override</span>; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// @return size of the buffer pool</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">size_t</span> num_instances_; <span class="comment">// 实例的数量</span></span><br><span class="line">  <span class="type">size_t</span> pool_size_; <span class="comment">// 每个实例的容量</span></span><br><span class="line">  <span class="type">size_t</span> next_instance_; <span class="comment">// 对每个BPI依次插入页面时，下一个要插入的位置（0，1，2..）</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">  std::vector&lt;BufferPoolManagerInstance *&gt; managers_; <span class="comment">// BPI数组</span></span><br><span class="line">  <span class="comment">// BufferPoolManager **managers_;</span></span><br><span class="line">  <span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">  <span class="comment">// DiskManager *disk_manager_ __attribute__((__unused__));</span></span><br><span class="line">  <span class="comment">/** Pointer to the log manager. */</span></span><br><span class="line">  <span class="comment">// LogManager *log_manager_ __attribute__((__unused__));</span></span><br><span class="line"></span><br><span class="line">  <span class="function">BufferPoolManager *<span class="title">GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Page *<span class="title">FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// Fetch the requested page from the buffer pool.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> <span class="keyword">override</span></span>; <span class="comment">// Unpin the target page from the buffer pool.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// 将目标页刷新到磁盘</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 将缓冲池中的所有页刷新到磁盘</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Page *<span class="title">NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// Creates a new page in the buffer pool.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>; <span class="comment">// Deletes a page from the buffer pool.</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h5 id="parallel-buffer-pool-manager-cpp"><a href="#parallel-buffer-pool-manager-cpp" class="headerlink" title="parallel_buffer_pool_manager.cpp"></a>parallel_buffer_pool_manager.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/parallel_buffer_pool_manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                                                     LogManager *log_manager) &#123;</span><br><span class="line">  <span class="comment">// Allocate and create individual BufferPoolManagerInstances</span></span><br><span class="line">  num_instances_ = num_instances;</span><br><span class="line">  pool_size_ = pool_size;</span><br><span class="line">  next_instance_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// managers_ = new BufferPoolManager *[static_cast&lt;int&gt;(num_instances)];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    managers_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances_, i, disk_manager, log_manager));</span><br><span class="line">    <span class="comment">// BufferPoolManagerInstance *manager =</span></span><br><span class="line">    <span class="comment">//     new BufferPoolManagerInstance(pool_size, num_instances, i, disk_manager, log_manager);</span></span><br><span class="line">    <span class="comment">// *(managers_ + i) = manager;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span></span><br><span class="line">ParallelBufferPoolManager::~<span class="built_in">ParallelBufferPoolManager</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span> managers_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get size of all BufferPoolManagerInstances</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ParallelBufferPoolManager::GetPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num_instances_ * pool_size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BufferPoolManager *<span class="title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span></span><br><span class="line">  <span class="keyword">return</span> managers_[page_id % num_instances_];</span><br><span class="line">  <span class="comment">// return *(managers_ + page_id % num_instances_);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Unpin page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="built_in">UnpinPage</span>(page_id, is_dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Flush page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="built_in">FlushPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// create new page. We will request page allocation in a round robin manner from the underlying</span></span><br><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    <span class="comment">// BufferPoolManager *manager = *(managers_ + next_instance_);</span></span><br><span class="line">    BufferPoolManager *manager = managers_[next_instance_];</span><br><span class="line">    Page *page = manager-&gt;<span class="built_in">NewPage</span>(page_id);</span><br><span class="line">    next_instance_ = (next_instance_ + <span class="number">1</span>) % num_instances_;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParallelBufferPoolManager::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="built_in">DeletePage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush all pages from all BufferPoolManagerInstances</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    BufferPoolManager *manager = *(managers_ + i);</span><br><span class="line">    manager-&gt;<span class="built_in">FlushAllPages</span>();</span><br><span class="line">    <span class="keyword">delete</span> managers_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2022/08/03/CPP/</url>
    <content><![CDATA[<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span> &amp;a,<span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//声明一个模板，告诉编译器后面紧跟着的代码中的T不要报错，T是一个通用数据类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//两种方式使用函数模板 1.自动类型推导：mySwap(a,b)  2.显示指定类型：mySwap&lt;int&gt;(a,b)</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt; a&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> c=<span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(c,d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span> &lt;&lt; c&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;<span class="string">&quot;d=&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数模板注意事项：</span></span><br><span class="line"><span class="comment">1.自动类型推导，必须推导出一致的数据类型T才可以使用,就是这部分所有T对应一种类型</span></span><br><span class="line"><span class="comment">2.模板必须要确定出T的数据类型才能使用。 就是函数体要有T，如果没有，要使用显示指定类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">普通函数与函数模板的区别：</span></span><br><span class="line"><span class="comment">普通函数调用时，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">int myAdd(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void test()&#123;</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    int b = 20;</span></span><br><span class="line"><span class="comment">    char c = &#x27;c&#x27;; //A-65 a-97 </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; myAdd(a,c)&lt;&lt; endl;  //隐式类型转换，将字符型变量转换成了整型变量</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">函数模板调用时，如果可以利用自动类型推导，则不会发生隐式类型转换；若使用显示指定类型，可以发生隐式类型转换。</span></span><br><span class="line"><span class="comment">可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line"><span class="comment">函数模板也可以重载,并且如果普通函数和函数模板都可以调用，优先调用普通函数</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">void A(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ab&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;AB&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3,是对2的重载</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void A(T a, T b,T c)&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;ABC&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时会调用1，但可以通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a=10,b=20;</span></span><br><span class="line"><span class="comment">    A&lt;&gt;(a,b);//通过空模板参数列表来强制调用2</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T name,U age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T name;</span><br><span class="line">        U age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、类模板和函数模板的区别：</span></span><br><span class="line"><span class="comment">//1.类模板没有自动类型推导的使用方法 2.类模板在模板参数列表中可以有默认参数 template&lt;class T, class U = int&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、类模板中成员函数创建时机：普通类中的成员函数一开始就可以创建，类模板中的成员函数在调用时才创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、类模板对象做函数参数：</span></span><br><span class="line"><span class="comment">//一共有三种传入方式：1.指定传入的类型 2.参数模板化 3.整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.指定传入的类型 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.整个类模板化，建议使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、类模板与继承:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Son:public Base&#123;&#125;;   错误，需要指定Base的T类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想灵活指定父类中T类型，子类也需要变类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">public</span> Base&lt;T1&gt;&#123;</span><br><span class="line">    T2 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、类模板成员函数类外实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person1</span>(T3 name,T4 age);</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     this-&gt;name=name;this-&gt;age=age;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        T3 name;</span><br><span class="line">        T4 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line">Person1&lt;T3,T4&gt;::<span class="built_in">Person1</span>(T3 name,T4 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="keyword">class</span> <span class="title class_">T4</span>&gt;</span><br><span class="line"><span class="type">void</span> Person1&lt;T3,T4&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sb&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  七、类模板分文件编写</span></span><br><span class="line"><span class="comment">//问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</span></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="comment">// 1.直接包含.cpp源文件:</span></span><br><span class="line"><span class="comment">//一般把类及其方法的声明放在.h文件中，把实现放在.cpp文件中。 </span></span><br><span class="line"><span class="comment">// 三个文件：person.h;person.cpp;main.cpp  在person.cpp中要写#include&quot;person.h&quot;  在main.cpp中要包含#include&quot;person.cpp&quot;</span></span><br><span class="line"><span class="comment">// 2.将声明和实现写到同一文件中，并更改后缀名为.hpp。hpp是业界约定，不是必须。 然后在main.cpp中包含#include&quot;person.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、类模板与友元</span></span><br><span class="line"><span class="comment">//掌握类模板配合友元函数的类内和类外实现</span></span><br><span class="line"><span class="comment">//全局函数类内实现：直接在类内声明友元即可   </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"><span class="comment">template&lt;class T5 , class T6&gt;</span></span><br><span class="line"><span class="comment">class Person2&#123;</span></span><br><span class="line"><span class="comment">    //全局函数 类内实现  friend关键字能访问private数据</span></span><br><span class="line"><span class="comment">    friend void printPerson(Person2&lt;T5,T6&gt; p)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot; age:&quot; &lt;&lt; p.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person2(T5 name,T6 age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    private:</span></span><br><span class="line"><span class="comment">        T5 name;</span></span><br><span class="line"><span class="comment">        T6 age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    Person2&lt;string,int&gt;p(&quot;aaa&quot;,18);</span></span><br><span class="line"><span class="comment">    printPerson(p);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//全局函数类外实现：需要提前让编译器知道全局函数的存在(较难)</span></span><br></pre></td></tr></table></figure>



<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">重载操作符的类的对象叫函数对象，重载的是()时，又叫仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、特点：</span></span><br><span class="line"><span class="comment">1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="comment">2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="comment">3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v1+v2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myadd myadd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数对象超出普通函数的概念，函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Myprint</span>()&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count; <span class="comment">//内部自己状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">myprint</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myprint调用的次数是&quot;</span> &lt;&lt; myprint.count &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(Myprint &amp;mp,string s)</span></span>&#123;</span><br><span class="line">    Myprint myprint;</span><br><span class="line">    <span class="built_in">myprint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    Myprint mp2;</span><br><span class="line">    <span class="built_in">doPrint</span>(mp2,<span class="string">&quot;cnm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、谓词</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回bool类型的仿函数称为谓词</span></span><br><span class="line"><span class="comment">如果operator接受一个参数，叫做一元谓词</span></span><br><span class="line"><span class="comment">如果operator接受两个参数，叫做二元谓词</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、内建函数对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stl内建了一些函数对象，能够拿来直接使用。这些仿函数所产生的对象，用法和一般函数完全相同。</span></span><br><span class="line"><span class="comment">使用内建函数对象需要包含#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">分类：算数，关系，逻辑仿函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.算数仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T plus&lt;T&gt;;        //加    plus&lt;int&gt; p; cout &lt;&lt; p(10,20) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T minus&lt;T&gt;;       //减</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T multiplies&lt;T&gt;;  //乘</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T divides&lt;T&gt;;     //除</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T modulus&lt;T&gt;;     //取模</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; T negate&lt;T&gt;;      //取反 negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.关系仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt;;    //   greater&lt;int&gt;() 等价于之前的自定义的 Mycompare       greater&lt;int&gt;()要加()，代表对象的创建。</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt;;    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.逻辑仿函数</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt;;      //与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt;;       //或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt;;      //非</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file readbinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief 读取二进制数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>]; </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p;<span class="comment">//接住读出的数据</span></span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));  <span class="comment">//函数原型：istream&amp; read(char * buffer,int len);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"><span class="comment">//文件类型有两种 1.文本文件：文件以文本的ASCII码形式存储在计算机中 2.二进制文件：文件以文本的二进制形式存储在计算机中，不能直接读懂</span></span><br><span class="line"><span class="comment">//操作文件的三大类  ofstream：写操作  ifstream：读操作  fstream：读写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件步骤——“包流开写闭”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #include &lt;fstream&gt;   //包含头文件</span></span><br><span class="line"><span class="comment">    ofstream ofs;      //创建流对象</span></span><br><span class="line"><span class="comment">    ofs.open(&quot;文件路径&quot;，打开方式);     //打开文件</span></span><br><span class="line"><span class="comment">    ofs &lt;&lt; &quot;写入的数据&quot;;     //写数据</span></span><br><span class="line"><span class="comment">    ofs.close();    //关闭文件</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    文件打开方式：</span></span><br><span class="line"><span class="comment">    ios::in         //为读文件而打开文件</span></span><br><span class="line"><span class="comment">    i0s::out        //为写文件而打开文件</span></span><br><span class="line"><span class="comment">    ios::ate        //初始位置：文件尾</span></span><br><span class="line"><span class="comment">    ios::app        //追加方式写文件</span></span><br><span class="line"><span class="comment">    ios::trunc      //如果文件存在，则先删除再创建</span></span><br><span class="line"><span class="comment">    ios::binary     //二进制方式</span></span><br><span class="line"><span class="comment">    ios::binary | ios::out      //用二进制方式写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test01.txt&quot;</span>,ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;name:kongjiangang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;gender:male&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file writebinaryfile.cpp</span></span><br><span class="line"><span class="comment"> * @author your name (you@domain.com)</span></span><br><span class="line"><span class="comment"> * @brief  向二进制文件写数据</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-26</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包流开操闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//函数原型： ostream&amp; write(const char * buffer,int len);</span></span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><h5 id="stl-general"><a href="#stl-general" class="headerlink" title="stl general"></a>stl general</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl:标准模板库</span></span><br><span class="line"><span class="comment">//stl从广义上分为容器,算法,迭代器。 容器和算法通过迭代器无缝衔接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl六大组件:容器,算法,迭代器,仿函数,适配器(配接器),空间配置器</span></span><br><span class="line"><span class="comment">//1.容器:分为序列式容器(强调值的排序)和关联式容器(二叉树)。各种数据结构,如vector,list,deque,set,map等，用来存放数据</span></span><br><span class="line"><span class="comment">//2.算法:分为质变算法(拷贝，置换，删除)和非质变算法(查找，计数，遍历)。常用的函数,如sort,find,copy,for_each等</span></span><br><span class="line"><span class="comment">//3.迭代器:分为(输入(对数据只读),输出(对数据只写),前向,双向,随机访问)迭代器。能按序访问某个容器内所含元素又不暴露该容器内部表示方法。</span></span><br><span class="line"><span class="comment">//4.仿函数:行为类似函数,可作为算法的某种策略</span></span><br><span class="line"><span class="comment">//5.适配器:不做要求</span></span><br><span class="line"><span class="comment">//6.空间配置器:负责空间的配置与管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、容器算法迭代器初识：vector存放内置数据类型</span></span><br><span class="line"><span class="comment">//容器：vector 算法：for_each 迭代器：vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> <span class="comment">//需要包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//同上</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器中插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>(); <span class="comment">//起始迭代器，指向容器中的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();     <span class="comment">//结束迭代器，指向容器中的最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span> (itBegin != itEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种遍历方式，利用for_each算法,回掉</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),myPrint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、vector存放自定义数据类型,同一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容器中再嵌套一个容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="comment">//创建小容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在小容器中插入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小容器插入到大容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过大容器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator iterator=v.<span class="built_in">begin</span>();iterator!=v.<span class="built_in">end</span>();iterator++)&#123;</span><br><span class="line">        <span class="comment">//(*iterator) 是一维数组</span></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit=(*iterator).<span class="built_in">begin</span>();vit!=(*iterator).<span class="built_in">end</span>();vit++)</span><br><span class="line">            cout&lt;&lt; (*vit) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector,也称单端数组</span></span><br><span class="line"><span class="comment">//vector与普通数组区别:不同之处是数组是静态空间，而vector可以动态扩展</span></span><br><span class="line"><span class="comment">//vector容器的迭代器是支持随机访问的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v;</span></span><br><span class="line"><span class="comment">vector(v.begin(),v.end());      //将v[begin(),end()]区间中的元素赋值给vector，如 vector&lt;int&gt; v2(v1.begin(),v1.end());</span></span><br><span class="line"><span class="comment">vector(n,elem);     //初始值为n个elem</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec);</span></span><br><span class="line"><span class="comment">assign(begin,end);      //v2.assign(v1.begin(),v.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);     //v3.assign(10,20);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、容量和大小</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">empty();        //判断容器是否为空</span></span><br><span class="line"><span class="comment">capicity();     //容器的容量，不是创建vector，插入10个元素容量就为10，可能为16</span></span><br><span class="line"><span class="comment">size();     //返回容器中元素数量</span></span><br><span class="line"><span class="comment">resize(int num);        //重新指定容器长度，若容器变长，则以默认值填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num,elem);       //重新指定容器长度，若容器变长，则以elem填充新位置；若容器变短，则末尾超过容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">pop_back();     //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos,elem);    </span></span><br><span class="line"><span class="comment">insert(const_iterator pos,int n,elem);       //在pos处插入n个elem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(const_iterator pos);      //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator begin,onst_iterator end);      //删除begin到end间的所有元素</span></span><br><span class="line"><span class="comment">clear();        //删除容器内所有元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、数据存取</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">at(int idx);</span></span><br><span class="line"><span class="comment">operator[];     // vector&lt;int&gt; v; cout &lt;&lt; v[n] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">front();        //返回容器内第一个元素</span></span><br><span class="line"><span class="comment">back();     //返回容器内最后一个元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、互换容器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">swap(vec);      //将vec与本身的元素进行互换 v1.swap(v2);</span></span><br><span class="line"><span class="comment">v.resize(3);vector&lt;int&gt;(v).swap(v);     //巧用swap收缩内存，vector&lt;int&gt;(v)是匿名对象，拷贝构造函数，同时匿名对象自动析构。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、预留空间</span></span><br><span class="line"><span class="comment">//减少vector在动态扩展容量时的扩展次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">reserve(int len);       //容器预留len个元素长度，但预留位置不初始化，且元素不可访问。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h6 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums)</span><br><span class="line">            mp[e]++;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que; <span class="comment">// priority_queue&lt;Type, Container, Functional&gt; </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); i ++)&#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*i);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>() &gt; k)  pri_que.<span class="built_in">pop</span>();<span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> comp = [&amp;](pii&amp; l, pii&amp; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> matrix[l.first][l.second] &gt; matrix[r.first][r.second];&#125;; <span class="comment">// 小根堆</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(comp)&gt; <span class="built_in">q</span>(comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) q.<span class="built_in">emplace</span>(i, <span class="number">0</span>); <span class="comment">// push fist colum i行0列</span></span><br><span class="line">        <span class="keyword">while</span>(--k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(j != n<span class="number">-1</span>) q.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">list(链表，stl中的链表是一个双向循环链表，每个结点都有data,prev,next域)常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">list&lt;T&gt; l;</span></span><br><span class="line"><span class="comment">list(begin,end);        //拷贝构造函数,list&lt;int&gt; l2(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">list(n,elem);       </span></span><br><span class="line"><span class="comment">list(const list &amp;l);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换：</span></span><br><span class="line"><span class="comment">assign(begin,end);      //list&lt;int&gt; l2; l2.assign(l1.begin(),l1.end());</span></span><br><span class="line"><span class="comment">assign(n,elem);</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;l);</span></span><br><span class="line"><span class="comment">swap(l)     //将l与本身的元素互换  l1.swap(l2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">resize(num);</span></span><br><span class="line"><span class="comment">resize(num,elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、插入和删除：</span></span><br><span class="line"><span class="comment">push_back(elem);</span></span><br><span class="line"><span class="comment">push_front(elem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pop_back();</span></span><br><span class="line"><span class="comment">pop_front();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insert(pos,elem);       //返回新数据的位置</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);     //无返回值</span></span><br><span class="line"><span class="comment">insert(pos,begin,end);      //无返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个数据的位置</span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个数据的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">remove(elem);       //移除所有与elem匹配的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">clear();        //移除容器中所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、数据存取</span></span><br><span class="line"><span class="comment">front();</span></span><br><span class="line"><span class="comment">back();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、反转和排序</span></span><br><span class="line"><span class="comment">reverse();</span></span><br><span class="line"><span class="comment">sort();</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">map &amp; multimap 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map基本概念：</span></span><br><span class="line"><span class="comment">1.map中的所有元素都是pair</span></span><br><span class="line"><span class="comment">2.pair中的第一个元素为key，起索引作用。第二个元素为value(实际值)</span></span><br><span class="line"><span class="comment">3.所有元素都会根据元素的键值自动排序</span></span><br><span class="line"><span class="comment">4.map &amp; multimap区别：map不允许容器中有重复key值的元素，multimap允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造与赋值</span></span><br><span class="line"><span class="comment">map&lt;T1,T2&gt; mp;</span></span><br><span class="line"><span class="comment">map(const map &amp;mp);     </span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp);      //返回值是一个map的引用变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(mp);       //mp1.swap(mp2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);       //map&lt;int,int&gt; mp1;  mp1.insert(pair&lt;int,int&gt;(1,20));</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(key);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回mp.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、排序</span></span><br><span class="line"><span class="comment">默认按key值从小到大排序，但可以通过仿函数改变</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">map&lt;int,int,MyCompare&gt; mp;      //指定排序规则</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">set &amp; multiset 容器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">set基本概念：</span></span><br><span class="line"><span class="comment">1.所有元素都会在插入时自动被排序</span></span><br><span class="line"><span class="comment">2.set/multiset是关联式容器，底层用二叉树实现</span></span><br><span class="line"><span class="comment">3.set和multiset区别：set不允许容器中有相同元素，multiset允许</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st;</span></span><br><span class="line"><span class="comment">set(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值与交换</span></span><br><span class="line"><span class="comment">list&amp; operator=(const set &amp;st);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、大小与交换</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">emtpy();</span></span><br><span class="line"><span class="comment">swap(st);       //st1.swap(st2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、插入和删除</span></span><br><span class="line"><span class="comment">insert(elem);</span></span><br><span class="line"><span class="comment">clear();    </span></span><br><span class="line"><span class="comment">erase(pos);     //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(begin,end);       //返回下一个元素的迭代器</span></span><br><span class="line"><span class="comment">erase(elem);        //删除容器中值为elem的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、查找与统计</span></span><br><span class="line"><span class="comment">find(key);      //查找key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回st.end()</span></span><br><span class="line"><span class="comment">count(key);     //统计值为key的元素个数</span></span><br><span class="line"><span class="comment">st.lower_bound(x); // 返回第一个&gt;=x的迭代器</span></span><br><span class="line"><span class="comment">st.upper_bound(x); // 返回第一个&gt;x的迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">六、set和multiset的区别</span></span><br><span class="line"><span class="comment">set插入数据时会返回是否插入成功，multiset不会</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">七、pair 对组的创建</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p(value1,value2);       //p.first和p.second分别访问不同部分</span></span><br><span class="line"><span class="comment">pair&lt;type,type&gt; p = make_pair(value1,value2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">八、set容器排序</span></span><br><span class="line"><span class="comment">学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</span></span><br><span class="line"><span class="comment">主要技术点：利用仿函数可以改变排序规则</span></span><br><span class="line"><span class="comment">1.set中存放内置数据类型</span></span><br><span class="line"><span class="comment">class MyCompare&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(int v1,int v2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return v1&gt;v2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">set&lt;int,MyCompare&gt; s2;      //指定排序规则</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.set中存放自定义数据类型</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        Person(string name,int age)&#123;</span></span><br><span class="line"><span class="comment">            this-&gt;name = name;</span></span><br><span class="line"><span class="comment">            this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        string name;</span></span><br><span class="line"><span class="comment">        int age;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">class MyCompare2&#123;</span></span><br><span class="line"><span class="comment">    public:</span></span><br><span class="line"><span class="comment">        bool operator()(const Person &amp;p1,const Person &amp;p2)&#123;     //第一个括号是要重载的符号，第二个是传入的参数</span></span><br><span class="line"><span class="comment">            return p1.age&gt;p2.age;       //按年龄降序排列</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    set&lt;Person,MyCompare2&gt; st;</span></span><br><span class="line"><span class="comment">    Person p1(&quot;lisi&quot;,19);</span></span><br><span class="line"><span class="comment">    Person p2(&quot;lisiguang&quot;,20);</span></span><br><span class="line"><span class="comment">    st.insert(p1);</span></span><br><span class="line"><span class="comment">    st.insert(p2);</span></span><br><span class="line"><span class="comment">    //迭代器输出，省略……</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>



<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stack常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; s;</span></span><br><span class="line"><span class="comment">stack(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);</span></span><br><span class="line"><span class="comment">pop();      //移除栈顶元素</span></span><br><span class="line"><span class="comment">top();      //返回栈顶元素</span></span><br><span class="line"><span class="comment">emplace();	//emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数.相当于emplace直接把原料拿进家，造了一个。而push是造好了之后，再复制到自己家里，多了复制这一步。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">queue常用接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; q;</span></span><br><span class="line"><span class="comment">queue(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、数据存取：</span></span><br><span class="line"><span class="comment">push(elem);     //往队尾加元素</span></span><br><span class="line"><span class="comment">pop();      //从队头移除一个元素</span></span><br><span class="line"><span class="comment">back();      //返回最后一个元素</span></span><br><span class="line"><span class="comment">front();        //返回第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、大小操作：</span></span><br><span class="line"><span class="comment">empty();</span></span><br><span class="line"><span class="comment">size();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h6 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一、 构造函数</span></span><br><span class="line"><span class="built_in">deque</span>();<span class="comment">// 创建一个空deque</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> nSize); <span class="comment">// 创建一个deque,元素个数为nSize</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> nSize,<span class="type">const</span> T&amp; t);<span class="comment">// 创建一个deque,元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;); <span class="comment">// 复制构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、 增加函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列头部增加一个元素X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列尾部增加一个元素x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列中某一元素前增加一个元素x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 双端队列中某一元素前增加n个相同的元素x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iterator last)</span></span>; <span class="comment">// 双端队列中某一元素前插入另一个相同类型向量的[first,last)间的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、删除函数</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>; <span class="comment">// 删除双端队列中的某一个元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>; <span class="comment">// 删除双端队列中[first,last）中的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">// 删除双端队列中最前一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">// 删除双端队列中最后一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清空双端队列中所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、遍历函数</span></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span></span>; <span class="comment">// 返回pos位置元素的引用</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span>; <span class="comment">// 返回首元素的引用</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>; <span class="comment">// 返回尾元素的引用</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>; <span class="comment">// 返回向量头指针，指向第一个元素</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>; <span class="comment">// 返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>; <span class="comment">// 反向迭代器，指向最后一个元素</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>; <span class="comment">// 反向迭代器，指向第一个元素的前一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 向量是否为空，若true,则向量中无元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 六、大小函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回向量中元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回最大可允许的双端对了元素数量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 七、其他函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(deque&amp;)</span></span>; <span class="comment">// 交换两个同类型向量的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">// 向量中第n个元素的值设置为x</span></span><br></pre></td></tr></table></figure>





<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//char*是一个指针；string是一个类，类内部封装了char*，是一个char*型的容器</span></span><br><span class="line"><span class="comment">//string类内部封装了很多成员方法，如find，copy，delete，replace，insert。 string类管理char*所分配的内存，不用担心复制越界和取值越界，由类内部负责管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、构造函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string();      //创建一个空的字符串，例如string str;</span></span><br><span class="line"><span class="comment">string(const char* s);     //使用字符串s初始化，如   char* str = &quot;hello world&quot;; string s(str);</span></span><br><span class="line"><span class="comment">string(const string&amp; str);     //使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="comment">string(int n,char c);      //使用n个字符c初始化 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char* s);       //string str = &quot;aaa&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const string&amp; s);         //string str1 =str;</span></span><br><span class="line"><span class="comment">string&amp; operator=(const char c);        //strng str = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s);      //string str2; str2.assign(&quot;aaaaa&quot;);</span></span><br><span class="line"><span class="comment">string&amp; assign(const char* s,int n);        //把字符串s的前n个字符赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(const string &amp;s);        //把字符串s赋值给当前字符串</span></span><br><span class="line"><span class="comment">string&amp; assign(int n,char c);       //用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三、拼接</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char* str);       //string str=&quot;我&quot;; str+=&quot;爱玩游戏&quot;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const char c);         //string str=&quot;我&quot;; str+=&#x27;艹&#x27;;</span></span><br><span class="line"><span class="comment">string&amp; operator+=(const &amp;string str);        //str1 += str2;</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s);      //string str=&quot;我&quot;; str.append(&quot;爱玩游戏&quot;);</span></span><br><span class="line"><span class="comment">string&amp; append(const char* s,int n);        //把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s);        //str1.append(str2);</span></span><br><span class="line"><span class="comment">string&amp; append(const string &amp;s,int pos,int n);       //把字符串s从pos开始n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、查找和替换</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int find(const string&amp; str,int pos=0) const;        //查找str第一次出现的位置，从pos开始寻找。不写pos默认为0</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos=0) const;        //查找s第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char* s,int pos,int n) const;        //查找s的前n个字符第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int find(const char c ,int pos=0) const;        //查找字符c第一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str,int pos=npos) const;        //查找str最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos=npos) const;        //查找s最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char* s,int pos,int n) const;        //查找s的前n个字符最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment">int rfind(const char c ,int pos=0) const;        //查找字符c最后一次出现的位置，从pos开始寻找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const string&amp; str);       //替换从pos开始的n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos,int n,const char* s);       //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五、比较</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串是按字符的ASCII进行比较 =返回0;&gt;返回1;&lt;返回-1</span></span><br><span class="line"><span class="comment">int compare(const string&amp; s) const;</span></span><br><span class="line"><span class="comment">int compare(const char* s) const;   </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六、获取(也可以赋值，修改)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n);        //通过[]方式获取字符 cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">char&amp; at(int n);        //通过at获取字符  cout &lt;&lt; str.at(i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//七、插入和删除</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const char* s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,const string&amp; s);      //在pos处插入s</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos,int n,char c);       //在指定pos插入n个c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string&amp; erase(int pos,int n=npos);      //删除从pos开始的n个字符 ，nopos表示不存在的位置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//八、获取子串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">string substr(int pos = 0;int n = npos) const;        //返回由pos开始n个字符组成的子串  </span></span><br><span class="line"><span class="comment">                                                      //如string str=&quot;abcdef&quot;; cout &lt;&lt; str.substr(1,3) &lt;&lt; endl;返回&quot;bcd&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="刷题输入输出"><a href="#刷题输入输出" class="headerlink" title="刷题输入输出"></a>刷题输入输出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1 最基本，也是最常用的用法</span></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;a+b&lt;&lt;endl;<span class="comment">// 输入：2[回车]3[回车]    输出：5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法2 接受一个字符串，遇	“ ”、[TAB]、[回车]都结束</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl; <span class="comment">// 输入：jkljkl jkljkl  输出：jkljkl(遇空格结束)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin.get()可以用来接收单个字符</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);	</span><br><span class="line">cout&lt;&lt;ch&lt;&lt;endl;	<span class="comment">// 输入：jljkljkl	输出：j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getchar() 接受一个字符，需包含“#include&lt;string&gt;”</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=<span class="built_in">getchar</span>();                      </span><br><span class="line">cout&lt;&lt;ch&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin.getline() 接受一个字符串，可以接收空格并输出</span></span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(m,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl; <span class="comment">// 输入：jkljkljkl  输出：jklj(\0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getline() 接受一个字符串，可以接收空格并输出，需包含“#include&lt;string&gt;”</span></span><br><span class="line">string st ;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Input st:&quot;</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin,st);</span><br><span class="line">cout&lt;&lt;st&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gets() 接受一个字符串，可以接收空格并输出，需包含“#include&lt;string&gt;”</span></span><br><span class="line"><span class="type">char</span> m[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">gets</span>(m);  <span class="comment">//不能写成m=gets();</span></span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br></pre></td></tr></table></figure>





<h4 id="刷题常用函数"><a href="#刷题常用函数" class="headerlink" title="刷题常用函数"></a>刷题常用函数</h4><h5 id="to-string-int-x"><a href="#to-string-int-x" class="headerlink" title="to_string(int x)"></a>to_string(int x)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="stoi-string-s"><a href="#stoi-string-s" class="headerlink" title="stoi(string s)"></a>stoi(string s)</h5><p>string 类型转为 int 类型</p>
<h5 id="reverse-iterator-begin-iterator-end"><a href="#reverse-iterator-begin-iterator-end" class="headerlink" title="reverse(iterator begin, iterator end)"></a>reverse(iterator begin, iterator end)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h5 id="islower-x2F-isupper-x2F-isalpha-x2F-isdigit"><a href="#islower-x2F-isupper-x2F-isalpha-x2F-isdigit" class="headerlink" title="islower&#x2F; isupper&#x2F;isalpha&#x2F;isdigit"></a>islower&#x2F; isupper&#x2F;isalpha&#x2F;isdigit</h5><h5 id="isalnum-char-ch"><a href="#isalnum-char-ch" class="headerlink" title="isalnum(char ch)"></a>isalnum(char ch)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">// 判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。</span></span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="tolower-char-ch-x2F-toupper-char-ch-x2F-tolower-string-s-x2F-toupper-string-s"><a href="#tolower-char-ch-x2F-toupper-char-ch-x2F-tolower-string-s-x2F-toupper-string-s" class="headerlink" title="tolower(char ch)&#x2F;toupper(char ch) &#x2F;tolower(string s)&#x2F;toupper(string s)"></a>tolower(char ch)&#x2F;toupper(char ch) &#x2F;tolower(string s)&#x2F;toupper(string s)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">// 判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。</span></span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="next-permutation-iterator-begin-iterator-end"><a href="#next-permutation-iterator-begin-iterator-end" class="headerlink" title="next_permutation(iterator begin, iterator end)"></a>next_permutation(iterator begin, iterator end)</h5><p>函数将按字母表顺序生成给定序列的下一个较大的排列，直到整个序列为降序为止。</p>
<h5 id="prev-permutation-iterator-begin-iterator-end"><a href="#prev-permutation-iterator-begin-iterator-end" class="headerlink" title="prev_permutation(iterator begin, iterator end)"></a>prev_permutation(iterator begin, iterator end)</h5><p>函数与之相反，是生成给定序列的上一个较小的排列。</p>
<h5 id="long-int-stol（const-string＆str"><a href="#long-int-stol（const-string＆str" class="headerlink" title="long int stol（const string＆str)"></a>long int stol（const string＆str)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next_permutation</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()) &amp;&amp; <span class="built_in">stol</span>(tmp) &lt;= INT_MAX ? <span class="built_in">stol</span>(tmp) : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此函数将在函数调用中作为参数提供的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>转换为long int。</p>
<h5 id="sort-amp-amp-stable-sort"><a href="#sort-amp-amp-stable-sort" class="headerlink" title="sort &amp;&amp; stable_sort"></a>sort &amp;&amp; stable_sort</h5><p>sort函数是algorithm库下的一个函数，sort函数是不稳定的，即大小相同的元素在排序后相对顺序可能发生改变，如果某些场景需要保持相同元素间的相对顺序，可使用<code>stable_sort</code>函数，这里不过多介绍</p>
<p>由于在排序过程中涉及到元素<em>交换</em>等操作，所以sort函数仅支持<strong>可随机访问</strong>的容器，如数组,  string, vector, deque等</p>
<p>方式一(默认)	<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()); <span class="comment">// sort函数如果不传入第三个参数，则默认是升序排列</span></span><br></pre></td></tr></table></figure>



<p>方式二(自定义)	<code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
<blockquote>
<p>  实现降序排列，需传入第三个参数–比较函数，<code>greater&lt;type&gt;()</code>，这里的元素为<code>int</code> 类型，即函数为<code> greater&lt;int&gt;()</code>;</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="lower-bound-x2F-upper-bound"><a href="#lower-bound-x2F-upper-bound" class="headerlink" title="lower_bound&#x2F; upper_bound"></a>lower_bound&#x2F; upper_bound</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个 &gt;=val 的元素的迭代器</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个	&gt;val 的元素的迭代器</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="C-Primer-Plus"><a href="#C-Primer-Plus" class="headerlink" title="C++ Primer Plus"></a>C++ Primer Plus</h4><ol>
<li><p><code>cout.put(&#39;A&#39;);</code> 与 <code>cout &lt;&lt; &#39;A&#39;;</code>区别 : 前者打印A的ASCII码,  后者打印A</p>
</li>
<li><p>const Month &#x3D; 12 这样便可以在程序中使用Month而不是12了</p>
</li>
<li><p>强制转换的语法有两种: <code>(typeName) value</code>和<code>typeName (value)</code> C++11新增:<code>static_cast&lt;typeName&gt; value</code></p>
</li>
<li><p>在初始化声明中，如果使用auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同</p>
</li>
<li><p>数组:</p>
<ol>
<li>声明 <code>typeName arrayName[arraySize];</code> 其中<code>arraySize</code>不能为变量。</li>
<li>初始化时可以 <code>int a[2]=&#123;1,2&#125; </code>也可以 <code>int a[3] =&#123;1,2&#125; </code>【长度为3，第三个元素默认为0】同样可以<code>int a[] = &#123;1,2&#125; </code>【长度为2】 </li>
<li>C++11初始化数组时可以省略 &#x3D; ；其次 <code>int a = &#123;&#125;</code>代表将a初始化为全0；最后 列表初始化禁止缩窄转换 如 不允许<code>long a[] = &#123;3, 1.2,1.3&#125;</code>。</li>
</ol>
</li>
<li><p>字符串<code>string</code>本质上是以<code>&#39;\0&#39;</code>结尾的char数组</p>
<ol>
<li><code>char a = &#39;A&#39; </code>正确 	 <code>char a = &quot;A&quot; </code>错误 因为” “是字符串 而’ ‘是字符</li>
<li>每次读取一行字符串输入: <code>cin.getline(name, 20)</code> &#x2F;&#x2F; 使用getline( )将姓名读入到一个包含20个元素的name数组中</li>
</ol>
</li>
<li><p>共用体:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共用体（union）是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">a</span>&#123;</span><br><span class="line">  <span class="type">int</span> int_val;</span><br><span class="line">  <span class="type">long</span> long_val;</span><br><span class="line">  <span class="type">double</span> double_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">a pail;</span><br><span class="line">pail.int_val = <span class="number">5</span>; <span class="comment">// valid</span></span><br><span class="line">pail.double_val = <span class="number">5.20</span> <span class="comment">// valid, int value is lost</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体 <code>enum color=&#123;red, green, blue&#125;</code> red等叫枚举量,分别对应0-2      也可以这样初始化<code>enum a =&#123;first, second = 100, third&#125;</code>这里，first在默认情况下为0。后面没有被初始化的枚举量的值将比 其前面的枚举量大1。因此，third的值为101。  也可以这样创建:<code>enrm a =&#123;aa, aaa = 0, bb, bbb = 1&#125;</code>  其中，aa和aaa都为0，bb和bbb都为1。</p>
</li>
<li><p>指针的写法可以:<code> int* ptr</code>或<code>int *ptr</code>或<code>int*ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="type">int</span>* ptr;</span><br><span class="line">ptr = <span class="number">0xB8000000</span>; <span class="comment">// 报错</span></span><br><span class="line">ptr = (<span class="type">int</span> *) <span class="number">0xB8000000</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">//正确,注意释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 错误,没有new 则不能delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. </span></span><br><span class="line"><span class="comment">// 动态数组和普通指针区别</span></span><br><span class="line"><span class="type">char</span> *p1 = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line"><span class="type">char</span> *p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1000</span>];</span><br><span class="line">*(p1 + <span class="number">4</span>) = <span class="number">12</span>; <span class="comment">// 等价于 p1[4] = 12;</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="type">int</span> * ar = <span class="keyword">new</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 则</span></span><br><span class="line">arr[i] = *(ar + i); </span><br><span class="line">&amp;arr[i] = ar + i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line">结构体对象访问成员用. 结构体指针访问成员用-&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类 型（如果有的话）以及参数的类型和数量告诉编译器。</p>
<ol>
<li><p>原型语法: <code>void funcA(int, char);</code></p>
</li>
<li><p>函数原型的作用:</p>
<p>1.帮助编译器正确处理函数返回值；</p>
<p>2.帮助 编译器检查使用的参数数目是否正确； </p>
<p>3.帮助编译器检查使用的参数类型是否正确。如果不正确，则转换为正确 的类型（如果可能的话）</p>
</li>
</ol>
</li>
<li><p>用<code>const</code>保护数组: 使用普通参数时，这种保护将 自动实现，这是由于C++按值传递数据，而且函数使用数据的副本。然而，接受数组名的函数将使用原始数据，为防止函数无意中修改数组的内容，可在声明形参时 使用关键字<code>const </code>    </p>
<ol>
<li>如 <code>void noChangeArr(const int arr[], int n);</code></li>
<li>原型里也要加<code>const</code></li>
</ol>
</li>
<li><p>指针和<code>const</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * var1 = &amp;a;  <span class="comment">//指向整形常量的指针，它指向的值不能修改</span></span><br><span class="line">*var1 = <span class="number">20</span>; <span class="comment">//错</span></span><br><span class="line">var = &amp;b; <span class="comment">// 对</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> var2;    <span class="comment">//指向整形的常量指针，它不能在指向别的变量，但指向（变量）的值可以修改。 </span></span><br><span class="line">*var2 = <span class="number">20</span>; <span class="comment">// 对</span></span><br><span class="line">var2 = b; <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> var3;  <span class="comment">//指向整形常量 的常量指针。它既不能再指向别的常量，指向的值也不能修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且 C++禁止将const的地址赋给非const指针。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当且仅当声明函数的形参时，下面两个声明才是等价的 <code>typeName arr[]</code>与<code>typeName *arr</code></p>
</li>
<li><p>假设要将<strong>字符串作为参数</strong>传递给函数，则表示字符串的方式有3种：</p>
<ol>
<li>char数组；</li>
<li>被设置为字符串的地址的char指针。</li>
<li>用引号括起的字符串常量（也称字符串字面值)</li>
</ol>
</li>
</ol>
<p>​		上述3种选择的类型都是char指针（准确的说是char*），因此可以将其作为字符串处理函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ghost[<span class="number">15</span>] = <span class="string">&quot;galloping&quot;</span>;</span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;galloping&quot;</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="built_in">strlen</span>(ghost);           <span class="comment">// ghost 是 &amp;ghost[0]  对应1</span></span><br><span class="line"><span class="type">int</span> n2 = <span class="built_in">strlen</span>(str);             <span class="comment">//str是 char 类型的指针  对应2</span></span><br><span class="line"><span class="type">int</span> n3 = <span class="built_in">strlen</span>(<span class="string">&quot;galloping&quot;</span>);     <span class="comment">//&quot;galloping&quot; 是 address of string  对应3</span></span><br></pre></td></tr></table></figure>

<ol start="15">
<li>函数指针:<ol>
<li>获取函数的地址：只要使用函数名（后面不跟参数）即可。如:think()是一个函数，则think就是该函数的地址。</li>
<li>如果要将函数作为参数进行传递，必须传递函数名。</li>
<li>函数括号中的形参可有可无，视情况而定。</li>
<li>与指针函数区别开来,指针函数是返回值类型为指针的函数</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数指针的声明方法为：</span><br><span class="line">返回值类型 ( * 指针变量名) ([形参列表]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">/* 声明一个函数 */</span></span><br><span class="line"><span class="built_in">int</span> (*f) (<span class="type">int</span> x); <span class="comment">/* 声明一个函数指针 */</span></span><br><span class="line">f=func; <span class="comment">/* 将func函数的首地址赋给指针f */</span></span><br><span class="line">f = &amp;func; <span class="comment">// 这也行,等同于上行的写法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用<span class="keyword">typedef</span>对函数指针进行简化:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> real;<span class="comment">//make real another name for double</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span><span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>  <span class="comment">//也可写成：char（*pFun)(int);</span></span></span><br><span class="line"><span class="function"><span class="comment">/*typedef的功能是定义新的类型。第一句就是定义了一种PFUN的类型，</span></span></span><br><span class="line"><span class="comment"><span class="function">并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。*/</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">glFun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="comment">//定义了一个函数glFun().该函数正好是一个以int为参数返回char的函数。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pFun =glFun; <span class="comment">//对指针进行赋值。</span></span><br><span class="line">	(*pFun)(<span class="number">2</span>); <span class="comment">//通过指针调用函数glFun。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>内联函数:编译器将使用相应的函数代码替换函数调用。[文本替换,会带来内存的占用]</li>
</ol>
<p>使用内联函数的措施：</p>
<ul>
<li>在函数声明前加上关键字inline；</li>
<li>在函数定义前加上关键字inline。</li>
</ul>
<ol start="17">
<li>引用变量:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建引用变量</span></span><br><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br><span class="line"><span class="comment">//上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元。</span></span><br><span class="line"><span class="comment">// 引用必须在声明时将其初始化。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用更接近const指针，一旦与某个变量关联，就将一直效忠于它。</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> pr = &amp;rats;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Django</title>
    <url>/2022/08/19/Django/</url>
    <content><![CDATA[<h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3><ul>
<li>Python知识点：函数、面向对象。</li>
<li>前端开发：HTML、CSS、JavaScript、jQuery、BootStrap。</li>
<li>MySQL数据库。</li>
<li>Python的Web框架：<ul>
<li>Flask，自身短小精悍 + 第三方组件。</li>
<li>Django，内部已集成了很多组件 +  第三方组件。【主要】</li>
</ul>
</li>
</ul>
<h4 id="安装django"><a href="#安装django" class="headerlink" title="安装django"></a>安装django</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用清华大学的镜像</span></span><br><span class="line">pip install some_package --index https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">pip install django --index https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查django版本</span></span><br><span class="line">python -m django --version</span><br><span class="line"><span class="comment"># 4.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c:\python39</span><br><span class="line">	- python.exe</span><br><span class="line">	- Scripts</span><br><span class="line">		- pip.exe</span><br><span class="line">		- django-admin.exe   【工具，创建django项目中的文件和文件夹】</span><br><span class="line">	- Lib</span><br><span class="line">		- 内置模块</span><br><span class="line">		- site-packages</span><br><span class="line">			- openpyxl</span><br><span class="line">			- python-docx</span><br><span class="line">			- flask</span><br><span class="line">			- django         【框架的源码】</span><br><span class="line">			</span><br><span class="line"><span class="comment"># /Users/jiangangkong/miniconda3/lib/python3.9</span></span><br></pre></td></tr></table></figure>



<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><blockquote>
<p>django中项目会有一些默认的文件和默认的文件夹。</p>
</blockquote>
<h5 id="在终端"><a href="#在终端" class="headerlink" title="在终端"></a>在终端</h5><ul>
<li><p>打开终端</p>
</li>
<li><p>进入某个目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/jiangangkong/workSpace/pycharmWorkSpace/</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令创建项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/jiangangkong/miniconda3/bin/django-admin startproject 项目名</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果 /Users/jiangangkong/miniconda3/bin/ 已加入环境系统环境变量。</span></span><br><span class="line"></span><br><span class="line">django-admin startproject 项目名称</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2022/08/19/Django/image-20220819015241441.png" alt="image-20220819015241441" style="zoom:50%;">

<img src="/2022/08/19/Django/image-20220819015324722.png" alt="image-20220819015324722" style="zoom: 33%;">

<h5 id="在Pycharm"><a href="#在Pycharm" class="headerlink" title="在Pycharm"></a>在Pycharm</h5><img src="/2022/08/19/Django/image-20220819131906745.png" alt="image-20220819131906745" style="zoom:50%;">

<p>特殊说明：</p>
<ul>
<li><p>命令行，创建的项目是标准的。</p>
</li>
<li><p>pycharm，在标准的基础上默认给咱们加了点东西。【现在删除，以后不一定要删。是关于模版的设置】</p>
<ul>
<li>创建了一个templates目录【删除】</li>
<li>settings.py中【删除划线处】<br><img src="/2022/08/19/Django/image-20211124091443354.png" alt="image-20211124091443354"></li>
</ul>
</li>
</ul>
<h4 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h4><p><img src="/2022/08/19/Django/image-20220819133037783.png" alt="image-20220819133037783"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mysite2</span><br><span class="line">├── manage<span class="selector-class">.py</span>         【项目的管理，启动项目、创建app、数据管理】【不要动】【***常常引用***】</span><br><span class="line">└── mysite2</span><br><span class="line">    ├── __init__<span class="selector-class">.py</span></span><br><span class="line">    ├── settings<span class="selector-class">.py</span>    【项目配置】          【***常常修改***】</span><br><span class="line">    ├── urls<span class="selector-class">.py</span>        【URL和处理函数的对应关系】【***常常修改***】</span><br><span class="line">    ├── asgi<span class="selector-class">.py</span>        【接收网络请求（django3异步式）】【不要动】</span><br><span class="line">    └── wsgi<span class="selector-class">.py</span>        【接收网络请求（同步式的）】【不要动】</span><br></pre></td></tr></table></figure>

<ul>
<li>要写的只有<code>settings.py</code>和<code>urls.py </code> 加之引用<code>manage.py </code></li>
</ul>
<h4 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h4><ul>
<li>此APP非彼APP，主要实现功能的划分</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- 项目</span><br><span class="line">	- app，用户管理【独立的数据库表结构、函数、前端模板】</span><br><span class="line">	- app，订单管理【表结构、函数、HTML模板、CSS】</span><br><span class="line">	- app，后台管理【表结构、函数、HTML模板、CSS】</span><br><span class="line">	- app，网站   【表结构、函数、HTML模板、CSS】</span><br><span class="line">	- app，API    【表结构、函数、HTML模板、CSS】</span><br><span class="line">	..</span><br><span class="line">	</span><br><span class="line">注意：我们开发比较简洁，用不到多app，一般情况下，项目下创建1个app即可。</span><br></pre></td></tr></table></figure>



<h5 id="创建app"><a href="#创建app" class="headerlink" title="创建app"></a>创建app</h5><ul>
<li>点击项目根目录，调出终端，输入：</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python3</span>.<span class="number">9</span> manage.<span class="keyword">py</span> startapp app01</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/2022/08/19/Django/image-20220819140621114.png" alt="image-20220819140621114"></li>
</ul>
<h5 id="app目录结构"><a href="#app目录结构" class="headerlink" title="app目录结构"></a>app目录结构</h5><p><img src="/2022/08/19/Django/image-20220819141005961.png" alt="image-20220819141005961"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── app01</span><br><span class="line">│   ├── __init__<span class="selector-class">.py</span></span><br><span class="line">│   ├── admin<span class="selector-class">.py</span>         【不用动】django默认提供了admin后台管理。</span><br><span class="line">│   ├── apps<span class="selector-class">.py</span>          【不用动】app启动类</span><br><span class="line">│   ├── migrations       【不用动】数据库变更记录</span><br><span class="line">│   │   └── __init__<span class="selector-class">.py</span></span><br><span class="line">│   ├── models<span class="selector-class">.py</span>        【**重要**】，对数据库操作。</span><br><span class="line">│   ├── tests<span class="selector-class">.py</span>         【前期不用动】单元测试</span><br><span class="line">│   └── views<span class="selector-class">.py</span>         【**重要**】，就是urls中指定的函数。</span><br><span class="line">├── manage<span class="selector-class">.py</span></span><br><span class="line">└── mysite2</span><br><span class="line">    ├── __init__<span class="selector-class">.py</span></span><br><span class="line">    ├── asgi<span class="selector-class">.py</span></span><br><span class="line">    ├── settings<span class="selector-class">.py</span></span><br><span class="line">    ├── urls<span class="selector-class">.py</span>          【URL-&gt;函数】</span><br><span class="line">    └── wsgi.py</span><br></pre></td></tr></table></figure>

<ul>
<li>所以对app的操作只在<code>models.py</code>和<code>views.py</code>中进行</li>
</ul>
<h4 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h4><ul>
<li>在项目settings.py中注册创建的app【settings.py】</li>
</ul>
<img src="/2022/08/19/Django/image-20220819143640297.png" alt="image-20220819143640297" style="zoom:50%;">

<ul>
<li>编写url与视图函数的对应关系【urls.py中】</li>
</ul>
<img src="/2022/08/19/Django/image-20220819143456426.png" alt="image-20220819143456426" style="zoom:50%;">

<ul>
<li>编写视图函数【在对应app的 views.py中编写】</li>
</ul>
<img src="/2022/08/19/Django/image-20220819144404087.png" alt="image-20220819144404087" style="zoom:67%;">

<ul>
<li><p>启动django项目</p>
<ul>
<li><p>命令行启动 <code>python manage.py runserver </code></p>
</li>
<li><p>pycharm启动</p>
</li>
</ul>
<img src="/2022/08/19/Django/image-20220819144820134.png" alt="image-20220819144820134" style="zoom:50%;">

<ul>
<li>访问 <a href="http://127.0.0.1:8000/index">http://127.0.0.1:8000/index</a></li>
</ul>
<img src="/2022/08/19/Django/image-20220819144941981.png" alt="image-20220819144941981" style="zoom:50%;">

<img src="/2022/08/19/Django/image-20220819145109541.png" alt="image-20220819145109541" style="zoom:50%;"></li>
</ul>
<h4 id="开发流程【补】"><a href="#开发流程【补】" class="headerlink" title="开发流程【补】"></a>开发流程【补】</h4><p>在app根目录中添加<code> templates</code>文件夹以及<code>static</code>文件夹</p>
<p><img src="/2022/08/19/Django/image-20220819151701802.png"></p>
<p>引用静态文件【用之前的写法也可以】</p>
<p><img src="/2022/08/19/Django/image-20220819153922108.png" alt="image-20220819153922108"></p>
<h4 id="模版语法【重要】"><a href="#模版语法【重要】" class="headerlink" title="模版语法【重要】"></a>模版语法【重要】</h4><ul>
<li>本质上：在HTML中写一些占位符，由数据对这些占位符进行替换和处理。</li>
</ul>
<p><img src="/2022/08/19/Django/image-20220819155958331.png" alt="image-20220819155958331"></p>
<ul>
<li><code>views.py</code>中要传键值对，<code>html</code>中要用两对花括号接收</li>
<li>获取列表元素不用<code>[]</code>，而用<code>.</code></li>
</ul>
<p><img src="/2022/08/19/Django/image-20220819160733066.png" alt="image-20220819160733066"></p>
<p>也可以这么写</p>
<p><img src="/2022/08/19/Django/image-20220819161001747.png" alt="image-20220819161001747"></p>
<p>通过<code>.</code>获取属性</p>
<p><img src="/2022/08/19/Django/image-20220819161153749.png" alt="image-20220819161153749"></p>
<h4 id="案例：伪联通新闻中心"><a href="#案例：伪联通新闻中心" class="headerlink" title="案例：伪联通新闻中心"></a>案例：伪联通新闻中心</h4><ul>
<li>这里的<code>requests</code>是第三方模块，是python专门用来发送请求的</li>
<li>而<code>views.py</code>中的<code>request</code>是django的参数。为了不混淆可以写为<code>req</code></li>
</ul>
<p><img src="/2022/08/19/Django/image-20211124115145293.png" alt="image-20211124115145293"></p>
<p><img src="/2022/08/19/Django/image-20211124115155394.png" alt="image-20211124115155394"></p>
<p><img src="/2022/08/19/Django/image-20211124115209067.png" alt="image-20211124115209067"></p>
<p><img src="/2022/08/19/Django/image-20211124115218937.png" alt="image-20211124115218937"></p>
<h4 id="请求和响应【重要】"><a href="#请求和响应【重要】" class="headerlink" title="请求和响应【重要】"></a>请求和响应【重要】</h4><ul>
<li>request是浏览器向后台发的【请求】</li>
<li>使用redirect需要导入redirect包</li>
</ul>
<p><img src="/2022/08/19/Django/image-20220819163251655.png" alt="image-20220819163251655"></p>
<ul>
<li>关于重定向【是2号路线】<ul>
<li>后台让浏览器自己去重定向的网站寻找资源</li>
</ul>
</li>
</ul>
<p><img src="/2022/08/19/Django/image-20211124142033257.png" alt="image-20211124142033257"></p>
<h4 id="案例：用户登录-无数据库版"><a href="#案例：用户登录-无数据库版" class="headerlink" title="案例：用户登录(无数据库版)"></a>案例：用户登录(无数据库版)</h4><ul>
<li>流程梳理</li>
</ul>
<ol>
<li>首先明确所有发送到&#x2F;login的页面都会被送到后台views.login处理</li>
<li>用户第一次请求访问login页面时，是GET请求，所以后台要返回login.html</li>
<li>若用户在login.html中提交form表单则向后台发送POST请求，则验证用户名与密码</li>
<li><code>&#123;% csrf_token %&#125;</code>是django用来保证访问的合法性的，若不带，则浏览器会阻止该次请求。（也可以加在html最头部）</li>
</ol>
<p><img src="/2022/08/19/Django/image-20211124151119553.png" alt="image-20211124151119553"></p>
<p><img src="/2022/08/19/Django/image-20211124151127364.png" alt="image-20211124151127364"></p>
<p><img src="/2022/08/19/Django/image-20211124151135563.png" alt="image-20211124151135563"></p>
<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul>
<li><p>原始版采用：MySQL数据库 + pymysql</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.连接MySQL</span></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&quot;00000000&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>, db=<span class="string">&#x27;库名&#x27;</span>)</span><br><span class="line">cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.发送指令</span></span><br><span class="line">cursor.execute(<span class="string">&quot;insert into 表名(属性1,属性2,属性3) values(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)&quot;</span>)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.关闭</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>



<p>Django开发操作数据库更简单，内部提供了ORM框架。（将django简洁的代码翻译成sql语句）<br><img src="/2022/08/19/Django/image-20211124151748712.png" alt="image-20211124151748712"></p>
</li>
</ul>
<h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><ul>
<li>在pycharm项目终端输入<code>pip3.9 install mysqlclient</code></li>
</ul>
<h5 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h5><p>ORM可以：</p>
<ul>
<li><p>创建、修改、删除数据库中的表（不用写SQL语句）。 <strong>【无法创建数据库】</strong></p>
</li>
<li><p>操作表中的数据（不用写SQL语句）。</p>
</li>
</ul>
<h6 id="1-自己建库"><a href="#1-自己建库" class="headerlink" title="1. 自己建库"></a>1. 自己建库</h6><p><img src="/2022/08/19/Django/image-20220819173816571.png" alt="image-20220819173816571"></p>
<h6 id="2-django连接数据库"><a href="#2-django连接数据库" class="headerlink" title="2. django连接数据库"></a>2. django连接数据库</h6><ul>
<li>在<code>settings.py</code>中修改<code>DATABASE</code>字段</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;djangomysql&#x27;,  <span class="meta"># 数据库名字</span></span><br><span class="line">        &#x27;USER&#x27;: &#x27;root&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;<span class="number">00000000</span>&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,  <span class="meta"># 那台机器安装了MySQL</span></span><br><span class="line">        &#x27;PORT&#x27;: <span class="number">3306</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-django操作表"><a href="#3-django操作表" class="headerlink" title="3. django操作表"></a>3. django操作表</h6><ul>
<li>创建表</li>
</ul>
<ol>
<li>创建表：在models.py文件中</li>
</ol>
<p><img src="/2022/08/19/Django/image-20211124154658774.png" alt="image-20211124154658774"></p>
<ol start="2">
<li>打开pycharm项目终端执行命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里我出了bug，原因是找不到libmysqlclient.21.dylib</span></span><br><span class="line"><span class="comment"># 解决方法 找到系统里的libmysqlclient.21.dylib，将它与报错找不到的地方软链接起来</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/mysql-8.0.28-macos11-arm64/lib/libmysqlclient.21.dylib /Users/jiangangkong/miniconda3/lib/libmysqlclient.21.dylib</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># ORM相当于执行了以下代码 表名为 app名_类名小写</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app01_userinfo(</span><br><span class="line">    id <span class="type">bigint</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其余的表是django内置的app生成的表【暂时不用管它们】</p>
<p><img src="/2022/08/19/Django/image-20220819203327273.png" alt="image-20220819203327273"></p>
<ul>
<li>删除表</li>
</ul>
<p>删掉<code>models.py</code>中的代码并且执行以下命令</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> manage.<span class="keyword">py</span> makemigrations</span><br><span class="line"><span class="keyword">python</span> manage.<span class="keyword">py</span> migrate</span><br></pre></td></tr></table></figure>



<ul>
<li>修改表</li>
</ul>
<p>在表中新增列时，由于已存在列中可能已有数据，所以新增列必须要指定新增列对应的数据：</p>
<p>终端会提醒你两个解决方法</p>
<ol>
<li>设置默认值</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">age</span> <span class="operator">=</span> models.IntegerField(default<span class="operator">=</span><span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>允许为空</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">data = models.IntegerField(<span class="attribute">null</span>=<span class="literal">True</span>, <span class="attribute">blank</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h6 id="4-增删改查"><a href="#4-增删改查" class="headerlink" title="4. 增删改查"></a>4. 增删改查</h6><ul>
<li><code>create</code> 增</li>
<li><code>delete</code> 删</li>
<li><code>update(xx = xx)</code> 改</li>
<li><code>all</code> 查</li>
<li><code>filter(xx = xx)</code>  查</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># #### 1.新增表项 ####</span></span><br><span class="line"><span class="comment"># Department.objects.create(title=&quot;销售部&quot;)</span></span><br><span class="line"><span class="comment"># Department.objects.create(title=&quot;IT部&quot;)</span></span><br><span class="line"><span class="comment"># Department.objects.create(title=&quot;运营部&quot;)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.create(name=&quot;武沛齐&quot;, password=&quot;123&quot;, age=19)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.create(name=&quot;朱虎飞&quot;, password=&quot;666&quot;, age=29)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.create(name=&quot;吴阳军&quot;, password=&quot;666&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #### 2.删除 ####</span></span><br><span class="line"><span class="comment"># UserInfo.objects.filter(id=3).delete()</span></span><br><span class="line"><span class="comment"># Department.objects.all().delete()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #### 3.获取数据 ####</span></span><br><span class="line"><span class="comment"># 3.1 获取符合条件的所有数据</span></span><br><span class="line"><span class="comment"># data_list = [对象,对象,对象,...]  QuerySet类型</span></span><br><span class="line"><span class="comment"># data_list = UserInfo.objects.all()</span></span><br><span class="line"><span class="comment"># 根据id升序</span></span><br><span class="line"><span class="comment"># data_list = UserInfo.objects.all().order_by(&quot;id&quot;)</span></span><br><span class="line"><span class="comment"># 根据id降序</span></span><br><span class="line"><span class="comment"># data_list = UserInfo.objects.all().order_by(&quot;-id&quot;)</span></span><br><span class="line"><span class="comment"># for obj in data_list:</span></span><br><span class="line"><span class="comment">#     print(obj.id, obj.name, obj.password, obj.age)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = UserInfo.objects.filter(id=1)</span></span><br><span class="line"><span class="comment"># print(data_list)</span></span><br><span class="line"><span class="comment"># 3.1 获取第一条数据【对象】</span></span><br><span class="line"><span class="comment"># row_obj = UserInfo.objects.filter(id=1).first()</span></span><br><span class="line"><span class="comment"># print(row_obj.id, row_obj.name, row_obj.password, row_obj.age)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># #### 4.更新数据 ####</span></span><br><span class="line"><span class="comment"># UserInfo.objects.all().update(password=999)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.filter(id=2).update(age=999)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.filter(name=&quot;朱虎飞&quot;).update(age=999)</span></span><br></pre></td></tr></table></figure>

<h6 id="搜索-查"><a href="#搜索-查" class="headerlink" title="搜索[查]"></a>搜索[查]</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile=<span class="string">&quot;19999999991&quot;</span>,<span class="built_in">id</span>=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">data_dict = &#123;<span class="string">&quot;mobile&quot;</span>:<span class="string">&quot;19999999991&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="number">123</span>&#125;</span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(**data_dict)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">12</span>)       <span class="comment"># 等于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__gt=<span class="number">12</span>)   <span class="comment"># 大于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__gte=<span class="number">12</span>)  <span class="comment"># 大于等于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__lt=<span class="number">12</span>)   <span class="comment"># 小于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__lte=<span class="number">12</span>)  <span class="comment"># 小于等于12</span></span><br><span class="line"></span><br><span class="line">data_dict = &#123;<span class="string">&quot;id__lte&quot;</span>:<span class="number">12</span>&#125;</span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(**data_dict)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile=<span class="string">&quot;999&quot;</span>)               <span class="comment"># 等于</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__startswith=<span class="string">&quot;1999&quot;</span>)  <span class="comment"># 筛选出以1999开头</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__endswith=<span class="string">&quot;999&quot;</span>)     <span class="comment"># 筛选出以999结尾</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__contains=<span class="string">&quot;999&quot;</span>)     <span class="comment"># 筛选出包含999</span></span><br><span class="line"></span><br><span class="line">data_dict = &#123;<span class="string">&quot;mobile__contains&quot;</span>:<span class="string">&quot;999&quot;</span>&#125;</span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(**data_dict)</span><br></pre></td></tr></table></figure>

<h6 id="分页-原理-查"><a href="#分页-原理-查" class="headerlink" title="分页-原理[查]"></a>分页-原理[查]</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset = models.PrettyNum.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">queryset = models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第1页</span></span><br><span class="line">queryset = models.PrettyNum.objects.<span class="built_in">all</span>()[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2页</span></span><br><span class="line">queryset = models.PrettyNum.objects.<span class="built_in">all</span>()[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3页</span></span><br><span class="line">queryset = models.PrettyNum.objects.<span class="built_in">all</span>()[<span class="number">20</span>:<span class="number">30</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = models.PrettyNum.objects.<span class="built_in">all</span>().count()</span><br><span class="line">data = models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).count()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分页的逻辑和处理规则</p>
</li>
<li><p>封装分页类</p>
<ul>
<li>从头到尾开发</li>
<li>写项目用【pagination.py】公共组件。</li>
</ul>
</li>
<li><p>小Bug，搜索 + 分页情况下。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">分页时候，保留原来的搜索条件</span><br><span class="line"></span><br><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span><span class="regexp">/pretty/</span>list/?q=<span class="number">888</span></span><br><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span><span class="regexp">/pretty/</span>list/?page=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span><span class="regexp">/pretty/</span>list/?q=<span class="number">888</span>&amp;page=<span class="number">23</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="5-表之间的关联关系"><a href="#5-表之间的关联关系" class="headerlink" title="5.表之间的关联关系"></a>5.表之间的关联关系</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 部门表 &quot;&quot;&quot;</span></span><br><span class="line">    title = models.CharField(verbose_name=<span class="string">&#x27;标题&#x27;</span>, max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 员工表 &quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">&quot;姓名&quot;</span>, max_length=<span class="number">16</span>)</span><br><span class="line">    password = models.CharField(verbose_name=<span class="string">&quot;密码&quot;</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">    account = models.DecimalField(verbose_name=<span class="string">&quot;账户余额&quot;</span>, max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>, default=<span class="number">0</span>)</span><br><span class="line">    create_time = models.DateTimeField(verbose_name=<span class="string">&quot;入职时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无约束</span></span><br><span class="line">    <span class="comment"># depart_id = models.BigIntegerField(verbose_name=&quot;部门ID&quot;)</span></span><br><span class="line">    <span class="comment"># 1.有约束</span></span><br><span class="line">    <span class="comment">#   - to，与那张表关联</span></span><br><span class="line">    <span class="comment">#   - to_field，表中的那一列关联</span></span><br><span class="line">    <span class="comment"># 2.django自动</span></span><br><span class="line">    <span class="comment">#   - 写的depart</span></span><br><span class="line">    <span class="comment">#   - django内部自动生成数据列 depart_id</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.当部门表被删除时，两种选择</span></span><br><span class="line">    <span class="comment"># ### 1 级联删除</span></span><br><span class="line">    depart = models.ForeignKey(to=<span class="string">&quot;Department&quot;</span>, to_field=<span class="string">&quot;id&quot;</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># ### 2 置空</span></span><br><span class="line">    <span class="comment"># depart = models.ForeignKey(to=&quot;Department&quot;, to_field=&quot;id&quot;, null=True, blank=True, on_delete=models.SET_NULL)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在django中做的约束(数据库里这列存的是1，2。然后再去django中查找对应的值)</span></span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.SmallIntegerField(verbose_name=<span class="string">&quot;性别&quot;</span>, choices=gender_choices)</span><br></pre></td></tr></table></figure>



<h4 id="模板的继承"><a href="#模板的继承" class="headerlink" title="模板的继承"></a>模板的继承</h4><p>定义模板：<code>layout.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;plugin...min.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;% block css %&#125;&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jquery-3.6.0.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    &#123;% block js %&#125;&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继承模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block css %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;pluxxx.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jqxxxin.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>



<h4 id="取关联或特殊数据"><a href="#取关联或特殊数据" class="headerlink" title="取关联或特殊数据"></a>取关联或特殊数据</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.create_time|date:&quot;Y-m-d&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 2022-8-21 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.get_gender_display&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- “男”，“女” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.depart.title &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>	<span class="comment">&lt;!-- “采购部”，“研发部” --&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="ModelForm【牛逼】"><a href="#ModelForm【牛逼】" class="headerlink" title="ModelForm【牛逼】"></a>ModelForm【牛逼】</h4><ul>
<li>解决数据校验和错误提示</li>
<li>避免views.py和html页面中有太多冗余代码</li>
</ul>
<ol>
<li>models.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;部门表&quot;&quot;&quot;</span></span><br><span class="line">    title = models.CharField(verbose_name=<span class="string">&#x27;部门名&#x27;</span>,max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 员工表 &quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">&quot;姓名&quot;</span>, max_length=<span class="number">16</span>)</span><br><span class="line">    password = models.CharField(verbose_name=<span class="string">&quot;密码&quot;</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">    account = models.DecimalField(verbose_name=<span class="string">&quot;账户余额&quot;</span>, max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>, default=<span class="number">0</span>)</span><br><span class="line">    create_time = models.DateTimeField(verbose_name=<span class="string">&quot;入职时间&quot;</span>)</span><br><span class="line">    depart = models.ForeignKey(to=<span class="string">&quot;Department&quot;</span>, to_field=<span class="string">&quot;id&quot;</span>, on_delete=models.CASCADE)</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.SmallIntegerField(verbose_name=<span class="string">&quot;性别&quot;</span>, choices=gender_choices)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>views.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;depart&quot;</span>,<span class="string">&quot;create_time&quot;</span>]</span><br><span class="line">        <span class="comment"># widgets = &#123;</span></span><br><span class="line">        <span class="comment">#     &quot;name&quot;: forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;),</span></span><br><span class="line">        <span class="comment">#     &quot;password&quot;: forms.PasswordInput(attrs=&#123;&quot;class&quot;: &quot;form-control&quot;&#125;),</span></span><br><span class="line">        <span class="comment">#     &quot;age&quot;: forms.TextInput(attrs=&#123;&quot;class&quot;: &quot;form-control&quot;&#125;),</span></span><br><span class="line">        <span class="comment">#     &quot;gender&quot;: forms.TextInput(attrs=&#123;&quot;class&quot;: &quot;form-control&quot;&#125;),</span></span><br><span class="line">        <span class="comment">#     &quot;depart&quot;: forms.TextInput(attrs=&#123;&quot;class&quot;: &quot;form-control&quot;&#125;)</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args,**kwargs)</span><br><span class="line">        <span class="keyword">for</span> name,field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            field.widget.attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method==<span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = MyForm()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;useradd.html&#x27;</span>,&#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST方式提交数据，需要数据校验</span></span><br><span class="line">    form = MyForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/user/list/&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;useradd.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_edit</span>(<span class="params">request,nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        obj=models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        form = MyForm(instance=obj)  <span class="comment"># form 就只为obj这一行</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;useredit.html&#x27;</span>,&#123;<span class="string">&#x27;form&#x27;</span>:form&#125;)</span><br><span class="line"></span><br><span class="line">    obj = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">    form=MyForm(data=request.POST,instance=obj) <span class="comment"># form 就只为obj这一行</span></span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/user/list/&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;useredit.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_delete</span>(<span class="params">request,nid</span>):</span><br><span class="line">    models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).delete()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/user/list/&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>useradd.html和useredit.html【useredit.html中post不用填action，填了会出错，bug未知】</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/add/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">            &#123;% csrf_token %&#125;</span><br><span class="line">            &#123;% for field in form %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; field.label &#125;&#125;:&#123;&#123; field &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&#123;&#123; field.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span>  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">            &#123;% csrf_token %&#125;</span><br><span class="line">            &#123;% for field in form %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; field.label &#125;&#125;:&#123;&#123; field &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&#123;&#123; field.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ModelForm数据校验"><a href="#ModelForm数据校验" class="headerlink" title="ModelForm数据校验"></a>ModelForm数据校验</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyModelForm</span>(forms.ModelForm):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证方法1:</span></span><br><span class="line">    mobile = forms.CharField(</span><br><span class="line">        label=<span class="string">&quot;手机号&quot;</span>,</span><br><span class="line">        validators=[RegexValidator(<span class="string">r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;</span>, <span class="string">&quot;手机号格式错误&quot;</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.PrettyNum</span><br><span class="line">        fields = [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;mobile&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;status&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            field.widget.attrs = &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证方法2 :钩子方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clean_mobile</span>(<span class="params">self</span>):</span><br><span class="line">        txt_mobile = self.cleaned_data[<span class="string">&quot;mobile&quot;</span>]</span><br><span class="line">        exists = models.PrettyNum.objects.<span class="built_in">filter</span>(mobile=txt_mobile).exists()</span><br><span class="line">        <span class="keyword">if</span> exists:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&quot;手机号已存在&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> txt_mobile</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/19/Django/image-20220822212707657.png" alt="image-20220822212707657"></p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li><code>app01/utils/pagination.py</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">自定义的分页组件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pagination</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># page_param=&quot;page&quot;意思是获取页面里的 page 字段的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, request, queryset, page_size=<span class="number">10</span>, page_param=<span class="string">&quot;page&quot;</span>, plus=<span class="number">5</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解决搜索后分页 url拼接参数</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        <span class="keyword">from</span> django.http.request <span class="keyword">import</span> QueryDict</span><br><span class="line">        query_dict = copy.deepcopy(request.GET)</span><br><span class="line">        query_dict._multable = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># self.query_dict 包含了原来所有的参数</span></span><br><span class="line">        self.query_dict = query_dict</span><br><span class="line">        self.page_param = page_param</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到 页数 page 和 页面大小 page_size</span></span><br><span class="line">        page = request.GET.get(page_param, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> page.isdecimal():    <span class="comment"># 如果page是十进制的数</span></span><br><span class="line">            page = <span class="built_in">int</span>(page)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            page = <span class="number">1</span></span><br><span class="line">        self.page = page</span><br><span class="line">        self.page_size = page_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一页的起始索引和结束索引</span></span><br><span class="line">        self.start = (page - <span class="number">1</span>) * page_size</span><br><span class="line">        self.end = page * page_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一页的queryset</span></span><br><span class="line">        self.page_queryset = queryset[self.start: self.end]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数据总条数</span></span><br><span class="line">        self.total_count = queryset.count()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 总页码</span></span><br><span class="line">        total_page_count, div = <span class="built_in">divmod</span>(self.total_count, page_size)</span><br><span class="line">        <span class="keyword">if</span> div:</span><br><span class="line">            total_page_count += <span class="number">1</span></span><br><span class="line">        self.total_page_count = total_page_count</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示前后 plus 页</span></span><br><span class="line">        self.plus = plus</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">html</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 显示当前页的前五页,后五页</span></span><br><span class="line">        <span class="keyword">if</span> self.total_page_count &lt;= <span class="number">2</span> * self.plus + <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 数据库中的数据比较少,未达到11页</span></span><br><span class="line">            <span class="keyword">if</span> self.total_count == <span class="number">0</span>:</span><br><span class="line">                start_page = <span class="number">1</span></span><br><span class="line">                end_page = self.total_page_count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start_page = <span class="number">1</span></span><br><span class="line">                end_page = self.total_page_count </span><br><span class="line">        <span class="comment"># 数据库中的数据大于11页</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.page &lt;= self.plus:</span><br><span class="line">                start_page = <span class="number">1</span></span><br><span class="line">                end_page = <span class="number">2</span> * self.plus + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span>(self.page + self.plus) &gt; self.total_page_count:</span><br><span class="line">                    start_page = self.total_page_count - <span class="number">2</span> * self.plus</span><br><span class="line">                    end_page = self.total_page_count</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start_page = self.page - self.plus</span><br><span class="line">                    end_page = self.page + self.plus</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一页的html标签</span></span><br><span class="line">        page_str_list = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首页</span></span><br><span class="line">        self.query_dict.setlist(self.page_param, [<span class="number">1</span>])</span><br><span class="line">        page_str_list.append(<span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;?&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode()))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上一页</span></span><br><span class="line">        <span class="keyword">if</span> self.page &gt; <span class="number">1</span>:</span><br><span class="line">            self.query_dict.setlist(self.page_param, [self.page - <span class="number">1</span>])</span><br><span class="line">            prev = <span class="string">&#x27;&lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;?&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.query_dict.setlist(self.page_param, [<span class="number">1</span>])</span><br><span class="line">            prev = <span class="string">&#x27;&lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;?&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode())</span><br><span class="line">        page_str_list.append(prev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">            self.query_dict.setlist(self.page_param, [i])</span><br><span class="line">            <span class="keyword">if</span> i == self.page:</span><br><span class="line">                ele = <span class="string">&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a  href=&quot;?&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode(), i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ele = <span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;?&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode(), i)</span><br><span class="line">            page_str_list.append(ele)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下一页</span></span><br><span class="line">        <span class="keyword">if</span> self.page &lt; self.total_page_count:</span><br><span class="line">            self.query_dict.setlist(self.page_param, [self.page + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">next</span> = <span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;?&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.query_dict.setlist(self.page_param, [self.total_page_count])</span><br><span class="line">            <span class="built_in">next</span> = <span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;?&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>.<span class="built_in">format</span>(self.query_dict.urlencode())</span><br><span class="line">        page_str_list.append(<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        page_string = mark_safe(<span class="string">&quot; &quot;</span>.join(page_str_list))</span><br><span class="line">        <span class="keyword">return</span> page_string</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>views.py</code>中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01.utils.pagination <span class="keyword">import</span> Pagination</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_list</span>(<span class="params">request</span>):</span><br><span class="line">    data_list = &#123;&#125;</span><br><span class="line">    value = request.GET.get(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&quot;</span>)  <span class="comment"># &quot; &quot;为默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value:</span><br><span class="line">        data_list[<span class="string">&quot;mobile__contains&quot;</span>] = value</span><br><span class="line">    queryset = models.PrettyNum.objects.<span class="built_in">filter</span>(**data_list).order_by(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">    page_object = Pagination(request, queryset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;pretty_list.html&#x27;</span>, &#123;<span class="string">&quot;value&quot;</span>: value, <span class="string">&quot;queryset&quot;</span>: page_object.page_queryset, <span class="string">&quot;page_string&quot;</span>: page_object.html()&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>html</code>中</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 10px &quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">&quot;Page navigation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?page=1&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            &#123;&#123; page_string &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="时间选择插件"><a href="#时间选择插件" class="headerlink" title="时间选择插件"></a>时间选择插件</h4><ul>
<li>引入<code>bootstrap-datepicker</code></li>
<li>在应用ModelForm的网页中 id要变化, 具体id要在网页上检查元素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;static/plugins/bootstrap-3.4.1/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;static/plugins/bootstrap-datepicker/css/bootstrap-datepicker.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dt&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;入职日期&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/js/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/plugins/bootstrap-3.4.1/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/plugins/bootstrap-datepicker/js/bootstrap-datepicker.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/plugins/bootstrap-datepicker/locales/bootstrap-datepicker.zh-CN.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&#x27;#dt&#x27;</span>).<span class="title function_">datepicker</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>: <span class="string">&#x27;yyyy-mm-dd&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">startDate</span>: <span class="string">&#x27;0&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">language</span>: <span class="string">&quot;zh-CN&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">autoclose</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ModelForm和BootStrap"><a href="#ModelForm和BootStrap" class="headerlink" title="ModelForm和BootStrap"></a>ModelForm和BootStrap</h4><ul>
<li><p>ModelForm可以帮助我们生成HTML标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>,]</span><br><span class="line"></span><br><span class="line">form = UserModelForm()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;form.name&#125;&#125;      普通的input框</span><br><span class="line">&#123;&#123;form.password&#125;&#125;  普通的input框</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义插件[太繁琐]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>,]</span><br><span class="line">        widgets = &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: forms.TextInput(attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;),</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: forms.PasswordInput(attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;),</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: forms.TextInput(attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    name = forms.CharField(</span><br><span class="line">        min_length=<span class="number">3</span>,</span><br><span class="line">        label=<span class="string">&quot;用户名&quot;</span>,</span><br><span class="line">        widget=forms.TextInput(attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;form.name&#125;&#125;      BootStrap的input框</span><br><span class="line">&#123;&#123;form.password&#125;&#125;  BootStrap的input框</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新定义的init方法[批量设置,较便捷]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;age&quot;</span>,]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环ModelForm中的所有字段，给每个字段的插件设置</span></span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">			field.widget.attrs = &#123;</span><br><span class="line">                <span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>, </span><br><span class="line">                <span class="string">&quot;placeholder&quot;</span>: field.label</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;age&quot;</span>,]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环ModelForm中的所有字段，给每个字段的插件设置</span></span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            <span class="comment"># 字段中有属性，保留原来的属性，没有属性，才增加。</span></span><br><span class="line">            <span class="keyword">if</span> field.widget.attrs:</span><br><span class="line">				field.widget.attrs[<span class="string">&quot;class&quot;</span>] = <span class="string">&quot;form-control&quot;</span></span><br><span class="line">				field.widget.attrs[<span class="string">&quot;placeholder&quot;</span>] = field.label</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                field.widget.attrs = &#123;</span><br><span class="line">                    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;placeholder&quot;</span>: field.label</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BootStrapModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 循环ModelForm中的所有字段，给每个字段的插件设置</span></span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            <span class="comment"># 字段中有属性，保留原来的属性，没有属性，才增加。</span></span><br><span class="line">            <span class="keyword">if</span> field.widget.attrs:</span><br><span class="line">				field.widget.attrs[<span class="string">&quot;class&quot;</span>] = <span class="string">&quot;form-control&quot;</span></span><br><span class="line">				field.widget.attrs[<span class="string">&quot;placeholder&quot;</span>] = field.label</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                field.widget.attrs = &#123;</span><br><span class="line">                    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;placeholder&quot;</span>: field.label</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserEditModelForm</span>(<span class="title class_ inherited__">BootStrapModelForm</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;age&quot;</span>,]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="让不同的页面输入框使用不同的-class"><a href="#让不同的页面输入框使用不同的-class" class="headerlink" title="让不同的页面输入框使用不同的 class"></a>让不同的页面输入框使用不同的 class</h4><ul>
<li><p>提取公共的类</p>
<p><img src="/2022/08/19/Django/image-20211126175803303.png" alt="image-20211126175803303"><br><img src="/2022/08/19/Django/image-20211126175826579.png" alt="image-20211126175826579"></p>
</li>
<li><p>ModelForm拆分出来<br><img src="/2022/08/19/Django/image-20211126175852716.png" alt="image-20211126175852716"></p>
</li>
<li><p>视图函数的归类<br><img src="/2022/08/19/Django/image-20211126175927378.png" alt="image-20211126175927378"></p>
<p><img src="/2022/08/19/Django/image-20211126175946996.png" alt="image-20211126175946996"></p>
</li>
</ul>
<h4 id="md5密码加密"><a href="#md5密码加密" class="headerlink" title="md5密码加密"></a>md5密码加密</h4><ul>
<li><code>utils/encrypt.py</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span>  settings</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">md5</span>(<span class="params">data_string</span>):</span><br><span class="line">    obj = hashlib.md5(settings.SECRET_KEY.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    obj.update(data_string.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> obj.hexdigest()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_password</span>(<span class="params">self</span>):</span><br><span class="line">    pwd = self.cleaned_data.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> md5(pwd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_confirm_password</span>(<span class="params">self</span>):</span><br><span class="line">    pwd = self.cleaned_data.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    confirm = md5(self.cleaned_data.get(<span class="string">&quot;confirm_password&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> confirm != pwd:</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">&quot;请输入相同密码&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> confirm</span><br></pre></td></tr></table></figure>



<h4 id="cookie-amp-session"><a href="#cookie-amp-session" class="headerlink" title="cookie &amp; session"></a>cookie &amp; session</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin/<span class="built_in">list</span>/</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">https://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin/<span class="built_in">list</span>/</span><br></pre></td></tr></table></figure>

<ul>
<li>http或者https都是无状态的短链接</li>
</ul>
<p><img src="/2022/08/19/Django/image-20220824223956247.png" alt="image-20220824223956247"></p>
<ul>
<li>解决方案</li>
</ul>
<p><img src="/2022/08/19/Django/image-20211127111106780.png" alt="image-20211127111106780"></p>
<ol>
<li>响应体即是你能看见的内容</li>
<li>k1是网站发给浏览器某个请求的凭证</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account_login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 登录 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = AccountModelForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">    form = AccountModelForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        <span class="keyword">if</span> models.Admin.objects.<span class="built_in">filter</span>(adminName=form.cleaned_data.get(<span class="string">&quot;adminName&quot;</span>)).exists():</span><br><span class="line">            obj = models.Admin.objects.<span class="built_in">filter</span>(adminName=form.cleaned_data.get(<span class="string">&quot;adminName&quot;</span>)).first()</span><br><span class="line">            <span class="keyword">if</span> obj.password == form.cleaned_data.get(<span class="string">&quot;password&quot;</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用户名和密码正确</span></span><br><span class="line">                <span class="comment"># 网站生成随机字符串; 写到用户浏览器的cookie中；在写入到session中；</span></span><br><span class="line">                request.session[<span class="string">&quot;info&quot;</span>] = &#123;<span class="string">&#x27;id&#x27;</span>: obj.<span class="built_in">id</span>, <span class="string">&#x27;name&#x27;</span>: obj.adminName&#125;</span><br><span class="line">                <span class="comment"># session可以保存7天</span></span><br><span class="line">                request.session.set_expiry(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/pretty/list/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            form.add_error(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line">        form.add_error(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = request.session.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p><img src="/2022/08/19/Django/image-20211127142838372.png" alt="image-20211127142838372"></p>
<ul>
<li><p>在<code>app01/Middleware/auth.py</code>中定义中间件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M1</span>(<span class="title class_ inherited__">MiddlewareMixin</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 中间件1 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果方法中没有返回值（返回None），继续向后走</span></span><br><span class="line">        <span class="comment"># 如果有返回值 HttpResponse、render 、redirect</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M1.process_request&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;无权访问&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_response</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M1.process_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M2</span>(<span class="title class_ inherited__">MiddlewareMixin</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 中间件2 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M2.process_request&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_response</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M2.process_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用中间件 setings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.middleware.auth.M1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.middleware.auth.M2&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在中间件的process_request方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果方法中没有返回值（返回None），继续向后走</span></span><br><span class="line"><span class="comment"># 如果有返回值 HttpResponse、render 、redirect，则不再继续向后执行。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="中间件实现登录校验"><a href="#中间件实现登录校验" class="headerlink" title="中间件实现登录校验"></a>中间件实现登录校验</h5><ul>
<li><p>编写中间件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse, redirect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthMiddleware</span>(<span class="title class_ inherited__">MiddlewareMixin</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># 0.排除那些不需要登录就能访问的页面</span></span><br><span class="line">        <span class="comment">#   request.path_info 获取当前用户请求的URL /login/</span></span><br><span class="line">        <span class="keyword">if</span> request.path_info == <span class="string">&quot;/login/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.读取当前访问的用户的session信息，如果能读到，说明已登陆过，就可以继续向后走。</span></span><br><span class="line">        info_dict = request.session.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(info_dict)</span><br><span class="line">        <span class="keyword">if</span> info_dict:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.没有登录过，重新回到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用中间件(<code>要在settings.py中注册</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.middleware.auth.AuthMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 注销 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    request.session.clear()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="html中获取已登录用户信息"><a href="#html中获取已登录用户信息" class="headerlink" title="html中获取已登录用户信息"></a>html中获取已登录用户信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=<span class="string">&quot;#&quot;</span>&gt;<span class="built_in">id</span>: &#123;&#123; request.session.info.<span class="built_in">id</span> &#125;&#125;&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>



<h4 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h4><img src="/2022/08/19/Django/image-20211127152344329.png" alt="image-20211127152344329" style="zoom: 50%;">

<ul>
<li>在项目根目录下导入<code>Monaco.ttf</code></li>
<li>在<code>app01/utils/code.py</code>中写入下方文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_code</span>(<span class="params">width=<span class="number">120</span>, height=<span class="number">30</span>, char_length=<span class="number">5</span>, font_file=<span class="string">&#x27;Monaco.ttf&#x27;</span>, font_size=<span class="number">28</span></span>):</span><br><span class="line">    code = []</span><br><span class="line">    <span class="comment"># 创建一张图片</span></span><br><span class="line">    img = Image.new(mode=<span class="string">&#x27;RGB&#x27;</span>, size=(width, height), color=(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">    draw = ImageDraw.Draw(img, mode=<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rndChar</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成随机字母</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(random.randint(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rndColor</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成随机颜色</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (random.randint(<span class="number">0</span>, <span class="number">255</span>), random.randint(<span class="number">10</span>, <span class="number">255</span>), random.randint(<span class="number">64</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写文字</span></span><br><span class="line">    font = ImageFont.truetype(font_file, font_size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(char_length):</span><br><span class="line">        char = rndChar()</span><br><span class="line">        code.append(char)</span><br><span class="line">        h = random.randint(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写干扰点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        draw.point([random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)], fill=rndColor())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写干扰圆圈</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        draw.point([random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)], fill=rndColor())</span><br><span class="line">        x = random.randint(<span class="number">0</span>, width)</span><br><span class="line">        y = random.randint(<span class="number">0</span>, height)</span><br><span class="line">        draw.arc((x, y, x + <span class="number">4</span>, y + <span class="number">4</span>), <span class="number">0</span>, <span class="number">90</span>, fill=rndColor())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画干扰线</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        x1 = random.randint(<span class="number">0</span>, width)</span><br><span class="line">        y1 = random.randint(<span class="number">0</span>, height)</span><br><span class="line">        x2 = random.randint(<span class="number">0</span>, width)</span><br><span class="line">        y2 = random.randint(<span class="number">0</span>, height)</span><br><span class="line"></span><br><span class="line">        draw.line((x1, y1, x2, y2), fill=rndColor())</span><br><span class="line"></span><br><span class="line">    img = img.<span class="built_in">filter</span>(ImageFilter.EDGE_ENHANCE_MORE)</span><br><span class="line">    <span class="keyword">return</span> img, <span class="string">&#x27;&#x27;</span>.join(code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  	</span><br><span class="line">    <span class="comment"># code_str 即是写入图片的文字</span></span><br><span class="line">    img, code_str = check_code()</span><br><span class="line">    <span class="built_in">print</span>(code_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img.save(f, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>login.html</code>中</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id_code&quot;</span>&gt;</span>图片验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-7&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; form.code &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; form.code.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-5&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;image_code&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/image/code/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>urls.py</code>中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;image/code/&#x27;</span>, account.image_code)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>app01/views/account.py</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account_login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 登录 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = AccountModelForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">    form = AccountModelForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证码的校验</span></span><br><span class="line">        user_input_code = form.cleaned_data.pop(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">        code = request.session.get(<span class="string">&#x27;image_code&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> code.upper() != user_input_code.upper():</span><br><span class="line">            form.add_error(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&#x27;form&#x27;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> models.Admin.objects.<span class="built_in">filter</span>(adminName=form.cleaned_data.get(<span class="string">&quot;adminName&quot;</span>)).exists():</span><br><span class="line">            obj = models.Admin.objects.<span class="built_in">filter</span>(adminName=form.cleaned_data.get(<span class="string">&quot;adminName&quot;</span>)).first()</span><br><span class="line">            <span class="keyword">if</span> obj.password == form.cleaned_data.get(<span class="string">&quot;password&quot;</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用户名和密码正确</span></span><br><span class="line">                <span class="comment"># 网站生成随机字符串; 写到用户浏览器的cookie中；在写入到session中；</span></span><br><span class="line">                request.session[<span class="string">&quot;info&quot;</span>] = &#123;<span class="string">&#x27;id&#x27;</span>: obj.<span class="built_in">id</span>, <span class="string">&#x27;name&#x27;</span>: obj.adminName&#125;</span><br><span class="line">                <span class="comment"># session可以保存7天</span></span><br><span class="line">                request.session.set_expiry(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/pretty/list/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            form.add_error(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line">        form.add_error(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_code</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 生成图片验证码 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用pillow函数，生成图片</span></span><br><span class="line">    img, code_string = check_code()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入到自己的session中（以便于后续获取验证码再进行校验）</span></span><br><span class="line">    request.session[<span class="string">&#x27;image_code&#x27;</span>] = code_string</span><br><span class="line">    <span class="comment"># 给Session设置60s超时</span></span><br><span class="line">    request.session.set_expiry(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入内存</span></span><br><span class="line">    stream = BytesIO()</span><br><span class="line">    img.save(stream, <span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(stream.getvalue())</span><br></pre></td></tr></table></figure>

<ul>
<li>并且在<code>AccountModelForm</code>中新加入<code>code</code>字段</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer pytorch</title>
    <url>/2022/08/01/Transformer-pytorch/</url>
    <content><![CDATA[<h3 id="Transformer概览"><a href="#Transformer概览" class="headerlink" title="Transformer概览"></a>Transformer概览</h3><p><img src="/2022/08/01/Transformer-pytorch/901659325530_.pic_%E5%89%AF%E6%9C%AC.png" alt="901659325530_.pic"></p>
<p><img src="/2022/08/01/Transformer-pytorch/7613b15f43674c298bd4b21fd372b140.png" alt="img"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="comment"># === Pytorch手写Transformer完整代码</span></span><br><span class="line"><span class="comment"># ======================================</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"></span><br><span class="line">device = <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="comment"># device = &#x27;cuda&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># transformer epochs</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我没有用什么大型的数据集，而是手动输入了两对中文→英语的句子</span></span><br><span class="line"><span class="comment"># 还有每个字的索引也是我手动硬编码上去的，主要是为了降低代码阅读难度</span></span><br><span class="line"><span class="comment"># S: Symbol that shows starting of decoding input</span></span><br><span class="line"><span class="comment"># E: Symbol that shows starting of decoding output</span></span><br><span class="line"><span class="comment"># P: Symbol that will fill in blank sequence if current batch data size is short than time steps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># 中文和英语的单词个数不要求相同</span></span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 一 个 好 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have a good friend .&#x27;</span>, <span class="string">&#x27;i have a good friend . E&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;S i have zero girl friend .&#x27;</span>, <span class="string">&#x27;i have zero girl friend . E&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集（希望transformer能达到的效果）</span></span><br><span class="line"><span class="comment"># 输入：&quot;我 有 一 个 女 朋 友&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;i have a girlfriend&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文和英语的单词要分开建立词库</span></span><br><span class="line"><span class="comment"># Padding Should be Zero</span></span><br><span class="line">src_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;我&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;有&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;一&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;个&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;好&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;朋&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;友&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;零&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;女&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">src_idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(src_vocab)&#125;</span><br><span class="line">src_vocab_size = <span class="built_in">len</span>(src_vocab)</span><br><span class="line"></span><br><span class="line">tgt_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;have&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;good&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;friend&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;zero&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;girl&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(tgt_vocab)&#125;</span><br><span class="line">tgt_vocab_size = <span class="built_in">len</span>(tgt_vocab)</span><br><span class="line"></span><br><span class="line">src_len = <span class="number">8</span>  <span class="comment"># （源句子的长度）enc_input max sequence length</span></span><br><span class="line">tgt_len = <span class="number">7</span>  <span class="comment"># dec_input(=dec_output) max sequence length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transformer Parameters</span></span><br><span class="line">d_model = <span class="number">512</span>  <span class="comment"># Embedding Size 每个词被嵌入成几维词向量</span></span><br><span class="line">d_ff = <span class="number">2048</span>  <span class="comment"># FeedForward dimension (两次线性层中的隐藏层 512-&gt;2048-&gt;512，线性层是用来做特征提取的），当然最后会再接一个projection层</span></span><br><span class="line">d_k = d_v = <span class="number">64</span>  <span class="comment"># dimension of K(=Q), V（Q和K的维度需要相同，这里为了方便让K=V）</span></span><br><span class="line">n_layers = <span class="number">6</span>  <span class="comment"># number of Encoder of Decoder Layer（Block的个数）</span></span><br><span class="line">n_heads = <span class="number">8</span>  <span class="comment"># number of heads in Multi-Head Attention（有几个头）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==============================================================================================</span></span><br><span class="line"><span class="comment"># 数据构建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_data</span>(<span class="params">sentences</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把单词序列转换为数字序列&quot;&quot;&quot;</span></span><br><span class="line">    enc_inputs, dec_inputs, dec_outputs = [], [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sentences)):</span><br><span class="line">        enc_input = [[src_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">0</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_input = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">1</span>].split()]]  <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_output = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[i][<span class="number">2</span>].split()]]  <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line"></span><br><span class="line">        enc_inputs.extend(enc_input) <span class="comment"># [[1, 2, 3, 4, 0], [1, 2, 3, 5, 0]]</span></span><br><span class="line">        dec_inputs.extend(dec_input) <span class="comment"># [[6, 1, 2, 3, 4, 8], [6, 1, 2, 3, 5, 8]]</span></span><br><span class="line">        dec_outputs.extend(dec_output) <span class="comment"># [[1, 2, 3, 4, 8, 7], [1, 2, 3, 5, 8, 7]]</span></span><br><span class="line">        <span class="comment"># A = [1, 2, 3]</span></span><br><span class="line">        <span class="comment"># B = [[&#x27;a&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line">        <span class="comment"># A.extend([4])</span></span><br><span class="line">        <span class="comment"># A.extend([5, 6])</span></span><br><span class="line">        <span class="comment"># B.extend([&#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class="line">        <span class="comment"># B.extend([[&#x27;e&#x27;, &#x27;f&#x27;]])</span></span><br><span class="line">        <span class="comment"># print(A)</span></span><br><span class="line">        <span class="comment"># print(B)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># result:</span></span><br><span class="line">        <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="comment"># [[&#x27;a&#x27;, &#x27;b&#x27;], &#x27;c&#x27;, &#x27;d&#x27;, [&#x27;e&#x27;, &#x27;f&#x27;]]</span></span><br><span class="line">    <span class="keyword">return</span> torch.LongTensor(enc_inputs), torch.LongTensor(dec_inputs), torch.LongTensor(dec_outputs)</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>(Data.Dataset):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义DataLoader&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, enc_inputs, dec_inputs, dec_outputs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyDataSet, self).__init__()</span><br><span class="line">        self.enc_inputs = enc_inputs</span><br><span class="line">        self.dec_inputs = dec_inputs</span><br><span class="line">        self.dec_outputs = dec_outputs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.enc_inputs[idx], self.dec_inputs[idx], self.dec_outputs[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># data.DataLoader</span></span><br><span class="line"><span class="comment"># dataset：（数据类型 dataset）</span></span><br><span class="line"><span class="comment"># batch_size：（数据类型 int）</span></span><br><span class="line"><span class="comment"># shuffle：（数据类型 bool）洗牌。默认设置为False。在每次迭代训练时是否将数据洗牌，默认设置是False。将输入数据的顺序打乱，是为了使数据更有独立性，但如果数据是有序列特征的，就不要设置成True了。</span></span><br><span class="line"><span class="comment"># batch_sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># sampler：（数据类型 Sampler）</span></span><br><span class="line"><span class="comment"># num_workers：（数据类型 Int）</span></span><br><span class="line"><span class="comment"># pin_memory：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># drop_last：（数据类型 bool）</span></span><br><span class="line"><span class="comment"># timeout：（数据类型 numeric）</span></span><br><span class="line"></span><br><span class="line">loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)  <span class="comment"># 2个batch是训练两句话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="comment"># Transformer模型(省去了Embedding层，因为我们之前自己定义过src_vocab和tgt_vocab)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout=<span class="number">0.1</span>, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(torch.arange(0, 5, dtype=torch.float).unsqueeze(1))</span></span><br><span class="line">        <span class="comment"># tensor([[0.],</span></span><br><span class="line">        <span class="comment">#         [1.],</span></span><br><span class="line">        <span class="comment">#         [2.],</span></span><br><span class="line">        <span class="comment">#         [3.],</span></span><br><span class="line">        <span class="comment">#         [4.]])</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        <span class="comment"># div_term = torch.exp(torch.arange(0, 10, 2).float() * (-math.log(10000.0) / 10))</span></span><br><span class="line">        <span class="comment"># print(div_term)</span></span><br><span class="line">        <span class="comment"># tensor([1.0000e+00, 1.5849e-01, 2.5119e-02, 3.9811e-03, 6.3096e-04])</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># a = torch.tensor([1, 2, 3])</span></span><br><span class="line">        <span class="comment"># print(a.unsqueeze(0))</span></span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: [seq_len, batch_size, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = x + self.pe[:x.size(<span class="number">0</span>), :]</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_pad_mask</span>(<span class="params">seq_q, seq_k</span>):<span class="comment">#序列（句子），不够长时用pad填补。为了让pad的位置不参与权重计算，将pad=0的位置设为true</span></span><br><span class="line">    <span class="comment"># pad mask的作用：在对value向量加权平均的时候，可以让pad对应的alpha_ij=0，这样注意力就不会考虑到pad向量</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里的q,k表示的是两个序列（跟注意力机制的q,k没有关系），例如encoder_inputs (x1,x2,..xm)和encoder_inputs (x1,x2..xm)</span></span><br><span class="line"><span class="string">    encoder和decoder都可能调用这个函数，所以seq_len视情况而定</span></span><br><span class="line"><span class="string">    seq_q: [batch_size, seq_len] 两个句子，每个句子单词个数</span></span><br><span class="line"><span class="string">    seq_k: [batch_size, seq_len]</span></span><br><span class="line"><span class="string">    seq_len could be src_len or it could be tgt_len</span></span><br><span class="line"><span class="string">    seq_len in seq_q and seq_len in seq_k maybe not equal</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    batch_size, len_q = seq_q.size()  <span class="comment"># 这个seq_q只是用来expand维度的</span></span><br><span class="line">    batch_size, len_k = seq_k.size()</span><br><span class="line">    <span class="comment"># eq(zero) is PAD token</span></span><br><span class="line">    <span class="comment"># 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]</span></span><br><span class="line">    <span class="comment"># 判断是否为0，是0则为True，True则masked，并扩一个维度。# 例如:seq_k = [[1,2,3,4,0], [1,2,3,5,0]]，--&gt;[[F,F,F,F,T],[F,F,F,F,T]]</span></span><br><span class="line">    pad_attn_mask = seq_k.data.eq(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># [batch_size, 1, len_k]</span></span><br><span class="line">    <span class="keyword">return</span> pad_attn_mask.expand(batch_size, len_q, len_k)  <span class="comment"># [batch_size, len_q, len_k] 构成一个立方体(batch_size个这样的矩阵)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_subsequence_mask</span>(<span class="params">seq</span>):<span class="comment">#一次只翻译一个词</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;建议打印出来看看是什么的输出（一目了然）</span></span><br><span class="line"><span class="string">    seq: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    attn_shape = [seq.size(<span class="number">0</span>), seq.size(<span class="number">1</span>), seq.size(<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># attn_shape: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">    subsequence_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>)  <span class="comment"># 生成一个上三角矩阵</span></span><br><span class="line">    subsequence_mask = torch.from_numpy(subsequence_mask).byte()</span><br><span class="line">    <span class="keyword">return</span> subsequence_mask  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># subsequence_mask = np.triu(np.ones([2,3,3]), k=1)  # 生成一个上三角矩阵</span></span><br><span class="line"><span class="comment"># subsequence_mask = torch.Tensor(subsequence_mask).byte()</span></span><br><span class="line"><span class="comment"># print(subsequence_mask)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># tensor([[[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]],</span></span><br><span class="line"><span class="comment">#         [[0, 1, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 1],</span></span><br><span class="line"><span class="comment">#          [0, 0, 0]]], dtype=torch.uint8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x = torch.tensor(2, 2, 2)</span></span><br><span class="line">        <span class="comment"># t = x.view(1, 8)  # 输出数组的大小为1*8</span></span><br><span class="line">        <span class="comment"># t = x.view(-1, 4)  # 输出数组的大小为2*4, -1表示自行判断</span></span><br><span class="line">        <span class="comment"># t = x.view(8)  # 输出数组的大小为8*1</span></span><br><span class="line">        <span class="comment"># t = x.view(-1)  # 输出数组的大小为1*8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderLayer, self).__init__()</span><br><span class="line">        self.enc_self_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, enc_self_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;E</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        enc_self_attn_mask: [batch_size, src_len, src_len]  mask矩阵(pad mask or sequence mask)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 第一个enc_inputs * W_Q = Q</span></span><br><span class="line">        <span class="comment"># 第二个enc_inputs * W_K = K</span></span><br><span class="line">        <span class="comment"># 第三个enc_inputs * W_V = V</span></span><br><span class="line">        enc_outputs, attn = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># enc_inputs to same Q,K,V（未线性变换前）</span></span><br><span class="line">        enc_outputs = self.pos_ffn(enc_outputs)</span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.dec_self_attn = MultiHeadAttention()</span><br><span class="line">        self.dec_enc_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]</span></span><br><span class="line"><span class="string">        dec_self_attn_mask: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"><span class="string">        dec_enc_attn_mask: [batch_size, tgt_len, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len]</span></span><br><span class="line">        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs,</span><br><span class="line">                                                        dec_self_attn_mask)  <span class="comment"># 这里的Q,K,V全是Decoder自己的输入</span></span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs,</span><br><span class="line">                                                      dec_enc_attn_mask)  <span class="comment"># Attention层的Q(来自decoder) 和 K,V(来自encoder)</span></span><br><span class="line">        dec_outputs = self.pos_ffn(dec_outputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn  <span class="comment"># dec_self_attn, dec_enc_attn这两个是为了可视化的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line">        self.src_emb = nn.Embedding(src_vocab_size, d_model)  <span class="comment"># token Embedding</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)  <span class="comment"># Transformer中位置编码时固定的，不需要学习</span></span><br><span class="line">        self.layers = nn.ModuleList([EncoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_outputs = self.src_emb(enc_inputs)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs = self.pos_emb(enc_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># [batch_size, src_len, d_model]</span></span><br><span class="line">        <span class="comment"># Encoder输入序列的pad mask矩阵</span></span><br><span class="line">        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)  <span class="comment"># [batch_size, src_len, src_len]</span></span><br><span class="line">        enc_self_attns = []  <span class="comment"># 在计算中不需要用到，它主要用来保存你接下来返回的attention的值（这个主要是为了你画热力图等，用来看各个词之间的关系</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:  <span class="comment"># for循环访问nn.ModuleList对象</span></span><br><span class="line">            <span class="comment"># 上一个block的输出enc_outputs作为当前block的输入</span></span><br><span class="line">            <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attn: [batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">            enc_outputs, enc_self_attn = layer(enc_outputs,</span><br><span class="line">                                               enc_self_attn_mask)  <span class="comment"># 传入的enc_outputs其实是input，传入mask矩阵是因为你要做self attention</span></span><br><span class="line">            enc_self_attns.append(enc_self_attn)  <span class="comment"># 这个只是为了可视化</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, enc_self_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.tgt_emb = nn.Embedding(tgt_vocab_size, d_model)  <span class="comment"># Decoder输入的embed词表</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([DecoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])  <span class="comment"># Decoder的blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_inputs, enc_outputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        enc_outputs: [batch_size, src_len, d_model]   # 用在Encoder-Decoder Attention层</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dec_outputs = self.tgt_emb(dec_inputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        dec_outputs = self.pos_emb(dec_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="comment"># Decoder输入序列的pad mask矩阵（这个例子中decoder是没有加pad的，实际应用中都是有pad填充的）</span></span><br><span class="line">        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">        <span class="comment"># Masked Self_Attention：当前时刻是看不到未来的信息的</span></span><br><span class="line">        dec_self_attn_subsequence_mask = get_attn_subsequence_mask(dec_inputs).to(</span><br><span class="line">            device)  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decoder中把两种mask矩阵相加（既屏蔽了pad的信息，也屏蔽了未来时刻的信息）</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequence_mask),</span><br><span class="line">                                      <span class="number">0</span>).to(device)  <span class="comment"># [batch_size, tgt_len, tgt_len]; torch.gt比较两个矩阵的元素，大于则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个mask主要用于encoder-decoder attention层</span></span><br><span class="line">        <span class="comment"># get_attn_pad_mask主要是enc_inputs的pad mask矩阵(因为enc是处理K,V的，求Attention时是用v1,v2,..vm去加权的，要把pad对应的v_i的相关系数设为0，这样注意力就不会关注pad向量)</span></span><br><span class="line">        <span class="comment">#                       dec_inputs只是提供expand的size的</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)  <span class="comment"># [batc_size, tgt_len, src_len]</span></span><br><span class="line"></span><br><span class="line">        dec_self_attns, dec_enc_attns = [], []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attn: [batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [batch_size, h_heads, tgt_len, src_len]</span></span><br><span class="line">            <span class="comment"># Decoder的Block是上一个Block的输出dec_outputs（变化）和Encoder网络的输出enc_outputs（固定）</span></span><br><span class="line">            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask,</span><br><span class="line">                                                             dec_enc_attn_mask)</span><br><span class="line">            dec_self_attns.append(dec_self_attn)</span><br><span class="line">            dec_enc_attns.append(dec_enc_attn)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        self.encoder = Encoder().to(device)</span><br><span class="line">        self.decoder = Decoder().to(device)</span><br><span class="line">        self.projection = nn.Linear(d_model, tgt_vocab_size, bias=<span class="literal">False</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, dec_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Transformers的输入：两个序列</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># tensor to store decoder outputs</span></span><br><span class="line">        <span class="comment"># outputs = torch.zeros(batch_size, tgt_len, tgt_vocab_size).to(self.device)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># enc_outputs: [batch_size, src_len, d_model], enc_self_attns: [n_layers, batch_size, n_heads, src_len, src_len]</span></span><br><span class="line">        <span class="comment"># 经过Encoder网络后，得到的输出还是[batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs, enc_self_attns = self.encoder(enc_inputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model], dec_self_attns: [n_layers, batch_size, n_heads, tgt_len, tgt_len], dec_enc_attn: [n_layers, batch_size, tgt_len, src_len]</span></span><br><span class="line">        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)</span><br><span class="line">        <span class="comment"># dec_outputs: [batch_size, tgt_len, d_model] -&gt; dec_logits: [batch_size, tgt_len, tgt_vocab_size]</span></span><br><span class="line">        dec_logits = self.projection(dec_outputs)</span><br><span class="line">        <span class="keyword">return</span> dec_logits.view(-<span class="number">1</span>, dec_logits.size(-<span class="number">1</span>)), enc_self_attns, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Transformer().to(device)</span><br><span class="line"><span class="comment"># 这里的损失函数里面设置了一个参数 ignore_index=0，因为 &quot;pad&quot; 这个单词的索引为 0，这样设置以后，就不会计算 &quot;pad&quot; 的损失（因为本来 &quot;pad&quot; 也没有意义，不需要计算）</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(ignore_index=<span class="number">0</span>)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>, momentum=<span class="number">0.99</span>)  <span class="comment"># 用adam的话效果不好</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================================================</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> enc_inputs, dec_inputs, dec_outputs <span class="keyword">in</span> loader:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        enc_inputs: [batch_size, src_len]</span></span><br><span class="line"><span class="string">        dec_inputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        dec_outputs: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_inputs, dec_inputs, dec_outputs = enc_inputs.to(device), dec_inputs.to(device), dec_outputs.to(device)</span><br><span class="line">        <span class="comment"># outputs: [batch_size * tgt_len, tgt_vocab_size]</span></span><br><span class="line">        outputs, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs)</span><br><span class="line">        loss = criterion(outputs, dec_outputs.view(-<span class="number">1</span>))  <span class="comment"># dec_outputs.view(-1):[batch_size * tgt_len * tgt_vocab_size]</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;loss =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greedy_decoder</span>(<span class="params">model, enc_input, start_symbol</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心编码</span></span><br><span class="line"><span class="string">    For simplicity, a Greedy Decoder is Beam search when K=1. This is necessary for inference as we don&#x27;t know the</span></span><br><span class="line"><span class="string">    target sequence input. Therefore we try to generate the target input word by word, then feed it into the transformer.</span></span><br><span class="line"><span class="string">    Starting Reference: http://nlp.seas.harvard.edu/2018/04/03/attention.html#greedy-decoding</span></span><br><span class="line"><span class="string">    :param model: Transformer Model</span></span><br><span class="line"><span class="string">    :param enc_input: The encoder input</span></span><br><span class="line"><span class="string">    :param start_symbol: The start symbol. In this example it is &#x27;S&#x27; which corresponds to index 4</span></span><br><span class="line"><span class="string">    :return: The target input</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    enc_outputs, enc_self_attns = model.encoder(enc_input)</span><br><span class="line">    dec_input = torch.zeros(<span class="number">1</span>, <span class="number">0</span>).type_as(enc_input.data)  <span class="comment"># 初始化一个空的tensor: tensor([], size=(1, 0), dtype=torch.int64)</span></span><br><span class="line">    terminal = <span class="literal">False</span></span><br><span class="line">    next_symbol = start_symbol</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> terminal:</span><br><span class="line">        <span class="comment"># 预测阶段：dec_input序列会一点点变长（每次添加一个新预测出来的单词）</span></span><br><span class="line">        dec_input = torch.cat([dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span><br><span class="line">                              -<span class="number">1</span>)</span><br><span class="line">        dec_outputs, _, _ = model.decoder(dec_input, enc_input, enc_outputs)</span><br><span class="line">        projected = model.projection(dec_outputs)</span><br><span class="line">        prob = projected.squeeze(<span class="number">0</span>).<span class="built_in">max</span>(dim=-<span class="number">1</span>, keepdim=<span class="literal">False</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 增量更新（我们希望重复单词预测结果是一样的）</span></span><br><span class="line">        <span class="comment"># 我们在预测是会选择性忽略重复的预测的词，只摘取最新预测的单词拼接到输入序列中</span></span><br><span class="line">        next_word = prob.data[-<span class="number">1</span>]  <span class="comment"># 拿出当前预测的单词(数字)。我们用x&#x27;_t对应的输出z_t去预测下一个单词的概率，不用z_1,z_2..z_&#123;t-1&#125;</span></span><br><span class="line">        next_symbol = next_word</span><br><span class="line">        <span class="keyword">if</span> next_symbol == tgt_vocab[<span class="string">&quot;E&quot;</span>]:</span><br><span class="line">            terminal = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># print(next_word)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># greedy_dec_predict = torch.cat(</span></span><br><span class="line">    <span class="comment">#     [dec_input.to(device), torch.tensor([[next_symbol]], dtype=enc_input.dtype).to(device)],</span></span><br><span class="line">    <span class="comment">#     -1)</span></span><br><span class="line">    greedy_dec_predict = dec_input[:, <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> greedy_dec_predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================================</span></span><br><span class="line"><span class="comment"># 预测阶段</span></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">sentences = [</span><br><span class="line">    <span class="comment"># enc_input                dec_input           dec_output</span></span><br><span class="line">    [<span class="string">&#x27;我 有 零 个 女 朋 友 P&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">enc_inputs, dec_inputs, dec_outputs = make_data(sentences)</span><br><span class="line">test_loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), <span class="number">2</span>, <span class="literal">True</span>)</span><br><span class="line">enc_inputs, _, _ = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_loader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;利用训练好的Transformer模型将中文句子&#x27;我 有 零 个 女 朋 友&#x27; 翻译成英文句子: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc_inputs)):</span><br><span class="line">    greedy_dec_predict = greedy_decoder(model, enc_inputs[i].view(<span class="number">1</span>, -<span class="number">1</span>).to(device), start_symbol=tgt_vocab[<span class="string">&quot;S&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(enc_inputs[i], <span class="string">&#x27;-&gt;&#x27;</span>, greedy_dec_predict.squeeze())</span><br><span class="line">    <span class="built_in">print</span>([src_idx2word[t.item()] <span class="keyword">for</span> t <span class="keyword">in</span> enc_inputs[i]], <span class="string">&#x27;-&gt;&#x27;</span>,</span><br><span class="line">          [idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> greedy_dec_predict.squeeze()])</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="Tensor数据类型转换"><a href="#Tensor数据类型转换" class="headerlink" title="Tensor数据类型转换"></a>Tensor数据类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. CPU和GPU的Tensor之间转换</span></span><br><span class="line"><span class="comment">#从cpu –&gt; gpu，使用data.cuda()即可。</span></span><br><span class="line"><span class="comment">#若从gpu –&gt; cpu，则使用data.cpu()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. Tensor与Numpy Array之间的转换</span></span><br><span class="line"><span class="comment">#Tensor –&gt; Numpy.ndarray 可以使用 data.numpy()，其中data的类型为torch.Tensor。</span></span><br><span class="line"><span class="comment">#Numpy.ndarray –&gt; Tensor 可以使用torch.from_numpy(data)，其中data的类型为numpy.ndarray。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. Tensor的基本类型转换</span></span><br><span class="line"><span class="comment">#为了方便测试，我们构建一个新的张量，你要转变成不同的类型只需要根据自己的需求选择即可</span></span><br><span class="line"></span><br><span class="line">tensor = torch.Tensor(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.long() 将tensor投射为long类型</span></span><br><span class="line">newtensor = tensor.long()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.half()将tensor投射为半精度浮点(16位浮点)类型</span></span><br><span class="line">newtensor = tensor.half()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.int()将该tensor投射为int类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">int</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.double()将该tensor投射为double类型</span></span><br><span class="line">newtensor = tensor.double()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.float()将该tensor投射为float类型</span></span><br><span class="line">newtensor = tensor.<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.char()将该tensor投射为char类型</span></span><br><span class="line">newtensor = tensor.char()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.byte()将该tensor投射为byte类型</span></span><br><span class="line">newtensor = tensor.byte()</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.short()将该tensor投射为short类型</span></span><br><span class="line">newtensor = tensor.short()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ScaledDotProductionAttention"><a href="#ScaledDotProductionAttention" class="headerlink" title="ScaledDotProductionAttention"></a>ScaledDotProductionAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/30933330-a4d34b59f098ee806e9467a65f7c2770.png" alt="30933330-a4d34b59f098ee806e9467a65f7c2770"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line"><span class="string">        K: [batch_size, n_heads, len_k, d_k]</span></span><br><span class="line"><span class="string">        V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        说明：在encoder-decoder的Attention层中len_q(q1,..qt)和len_k(k1,...km)可能不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)  <span class="comment"># scores : [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        <span class="comment"># mask矩阵填充scores（用-1e9填充scores中与attn_mask中值为1位置相对应的元素）</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>)  <span class="comment"># Fills elements of self tensor with value where mask is True.</span></span><br><span class="line"></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)  <span class="comment"># 对最后一个维度(v)做softmax</span></span><br><span class="line">        <span class="comment"># scores : [batch_size, n_heads, len_q, len_k] * V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        context = torch.matmul(attn, V)  <span class="comment"># context: [batch_size, n_heads, len_q, d_v]</span></span><br><span class="line">        <span class="comment"># context：[[z1,z2,...],[...]]向量, attn注意力稀疏矩阵（用于可视化的）</span></span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br></pre></td></tr></table></figure>



<h4 id="MultiheadAttention"><a href="#MultiheadAttention" class="headerlink" title="MultiheadAttention"></a>MultiheadAttention</h4><p><img src="/2022/08/01/Transformer-pytorch/6d551c2d2f7d42d3a6ae851cef300b05.png" alt="MultiheadAttention"></p>
<p><img src="/2022/08/01/Transformer-pytorch/59c6160448f5436f9bd55e71ba054176.png" alt="img"></p>
<p><img src="/2022/08/01/Transformer-pytorch/5c7875a11923457f87f2ad57ed30ec75.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个Attention类可以实现:</span></span><br><span class="line"><span class="string">    Encoder的Self-Attention</span></span><br><span class="line"><span class="string">    Decoder的Masked Self-Attention</span></span><br><span class="line"><span class="string">    Encoder-Decoder的Attention</span></span><br><span class="line"><span class="string">    输入：seq_len x d_model</span></span><br><span class="line"><span class="string">    输出：seq_len x d_model</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)  <span class="comment"># q,k必须维度相同，不然无法做点积</span></span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        self.fc = nn.Linear(n_heads * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_Q, input_K, input_V, attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_Q: [batch_size, len_q, d_model]</span></span><br><span class="line"><span class="string">        input_K: [batch_size, len_k, d_model]</span></span><br><span class="line"><span class="string">        input_V: [batch_size, len_v(=len_k), d_model]</span></span><br><span class="line"><span class="string">        attn_mask: [batch_size, seq_len, seq_len]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual, batch_size = input_Q, input_Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 下面的多头的参数矩阵是放在一起做线性变换的，然后再拆成多个头，这是工程实现的技巧</span></span><br><span class="line">        <span class="comment"># B: batch_size, S:seq_len, D: dim</span></span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D_new) -split-&gt; (B, S, Head, W) -trans-&gt; (B, Head, S, W)</span></span><br><span class="line">        <span class="comment">#           线性变换               拆成多头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q: [batch_size, n_heads, len_q, d_k]</span></span><br><span class="line">        Q = self.W_Q(input_Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># K: [batch_size, n_heads, len_k, d_k] # K和V的长度一定相同，维度可以不同</span></span><br><span class="line">        K = self.W_K(input_K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># V: [batch_size, n_heads, len_v(=len_k), d_v]</span></span><br><span class="line">        V = self.W_V(input_V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是多头，所以mask矩阵要扩充成4维的</span></span><br><span class="line">        <span class="comment"># attn_mask: [batch_size, seq_len, seq_len] -&gt; [batch_size, n_heads, seq_len, seq_len]</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v], attn: [batch_size, n_heads, len_q, len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(Q, K, V, attn_mask)</span><br><span class="line">        <span class="comment"># 下面将不同头的输出向量拼接在一起</span></span><br><span class="line">        <span class="comment"># context: [batch_size, n_heads, len_q, d_v] -&gt; [batch_size, len_q, n_heads * d_v]</span></span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(batch_size, -<span class="number">1</span>, n_heads * d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个全连接层可以保证多头attention的输出仍然是seq_len x d_model</span></span><br><span class="line">        output = self.fc(context)  <span class="comment"># [batch_size, len_q, d_model]</span></span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual), attn</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Add-amp-Norm"><a href="#Add-amp-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h4><p><img src="/2022/08/01/Transformer-pytorch/7534cf449cc0414695ffcfc0f6eb3c14.png" alt="img"></p>
<ul>
<li>Add指 X+MultiHeadAttention(X)，是一种残差连接，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到</li>
<li>Norm指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pytorch中的Linear只会对最后一维操作，所以正好是我们希望的每个位置用同一个全连接网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        inputs: [batch_size, seq_len, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        residual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        <span class="keyword">return</span> nn.LayerNorm(d_model).to(device)(output + residual)  <span class="comment"># [batch_size, seq_len, d_model]</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>deeplearning pytorch</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
        <tag>Transformer</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/09/26/Linux/</url>
    <content><![CDATA[<h3 id="unix和linux的区别"><a href="#unix和linux的区别" class="headerlink" title="unix和linux的区别"></a>unix和linux的区别</h3><ul>
<li><p>UNIX是商业化的，而Linux是开源的，是免费、公开源代码的；</p>
</li>
<li><p>UNIX系统大多是与硬件配套的，也就是说无法安装在x86服务器和个人计算机上的，而Linux则可以运行在多种硬件平台上。</p>
</li>
</ul>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul>
<li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。<br>Shell 本身并不是内核的一部分，它只是在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。<br>然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。</p>
<h3 id="bash与zsh的区别"><a href="#bash与zsh的区别" class="headerlink" title="bash与zsh的区别"></a>bash与zsh的区别</h3></li>
<li><p>一句话，二者均是shell的一种，zsh能基本完美兼容bash的命令，并且使用起来更加优雅。由于bash或zsh本质上都是解释器，他们所共同服务的是shell语言，因此在命令语法上基本相同，部分兼容性差异可参考：zsh和bash的兼容性差异。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash <span class="comment"># 切换bash</span></span><br><span class="line">chsh -s /bin/zsh <span class="comment"># 切换zsh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bash读取的配置文件：<del>&#x2F;.bash_profile文件<br>zsh读取的配置文件：</del>&#x2F;.zshrc文件<br>当从bash切换为zsh时，如果不想重新配置一遍.zshrc文件，可以__在.zshrc文件中加上source ~&#x2F;.bash_profile，从而直接从.bash_profile文件读取配置。</p>
</li>
</ul>
<h3 id="yum和rpm"><a href="#yum和rpm" class="headerlink" title="yum和rpm"></a>yum和rpm</h3><ul>
<li>rpm命令和yum命令都可以用来安装软件</li>
<li>但与yum命令最大的区别为yum命令在安装软件时如果碰到了依赖性的问题，yum会去主动尝试解决依赖性，如果解决不了才会反馈给用户。而rpm命令一旦遇到了依赖性的问题不会去解决依赖性，而是直接反馈给用户，让用户自行解决</li>
</ul>
<h4 id="repo源"><a href="#repo源" class="headerlink" title="repo源"></a>repo源</h4><ul>
<li>repo文件是linux中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！</li>
</ul>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><ul>
<li>homebrew是MacOS系统里面包的管理工具，类似于CentOS系统里面的<a href="https://so.csdn.net/so/search?q=yum&spm=1001.2101.3001.7020">yum</a>，主要解决软件或者包下载时的各种依赖包。</li>
<li>拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</li>
</ul>
<h3 id="mac终端和linux"><a href="#mac终端和linux" class="headerlink" title="mac终端和linux"></a>mac终端和linux</h3><ul>
<li><p>Mac和Linux基于都是基于Unix，命令也很多都是仿照Unix的，所以常用命令基本没有区别，如查看文件(ls)，查找文件(find)，复制文件(cp)，创建目录(mkdir)，打包文件(tar)等等，以及他们的软件包安装都是基于相同的理念(.&#x2F;configure，install)。</p>
</li>
<li><p>但是一些细节是不同的，比如Linux因为是用C语言写的，所以命令需要区分大小写，而Mac是不存在的。</p>
<p>使用mac的终端时候，需要递归复制目录，在Linux系统中一般是-r参数，请注意在mac中是-Rp，如果复制的路径是在&#x2F;usr&#x2F;local等级别的路径下，还需要sudo权限</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -Rp <span class="built_in">source</span> /usr/local/source_copy</span><br></pre></td></tr></table></figure>

<ul>
<li>linux中的yum工具在mac中用homebrew替代</li>
</ul>
<h3 id="《高级Linux》-Centos7"><a href="#《高级Linux》-Centos7" class="headerlink" title="《高级Linux》 -Centos7"></a>《高级Linux》 -Centos7</h3><h4 id="LVM和标准分区"><a href="#LVM和标准分区" class="headerlink" title="LVM和标准分区"></a>LVM和标准分区</h4><p>简单的说就是LVM可以方便的动态调整分区大小。比如你的&#x2F;home分区不够用了，如果是基于分区，那将是非常痛苦的事情。但如果是LVM，使用lvextend命令就可以了</p>
<p>lvm 分区 虽然 方便也有蛋疼的事   误删除不能恢复  风险 大   一般lvm 用的也少 </p>
<h4 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h4><p>touch	<code>touch [选项] [文件]</code>	如果文件不存在，使用touch命令默认创建一个空文件。</p>
<blockquote>
<p>-c -t	touch -c -t 06071930 file1	将文件file1现在的时间已经改为6月7日19点30分</p>
</blockquote>
<p>cp	<code>cp [选项] [源文件/目录] [目标文件/目录]</code>拷贝文件</p>
<blockquote>
<p><code>cp makefile makefile1</code>	将makefile另外复制一份为makefile1</p>
<p><code>cp -r a/ b/ ../lesson5</code> 将当前目录	a&#x2F;文件夹	b&#x2F;文件夹 递归拷贝到上一级目录下的lesson5目录</p>
</blockquote>
<p>file	<code>file [文件]</code>显示文件类型</p>
<p>tree 	<code>tree</code>查看该文件夹内垂直目录结构</p>
<p>pwd	<code>pwd</code>显示用户当前工作目录路径</p>
<p>ls 	<code>ls [选项] [文件]</code>查看当前目录下所有可见文件		</p>
<blockquote>
<p>-d	只显示当前文件夹	</p>
<p>-l	以长格式的形式查看当前目录下所有可见文件的详细属性,不包括隐藏文件</p>
<p>-la	查看文件详细信息，包括隐藏文件。</p>
<p>-ld	查看当前目录本身的权限与属性信息</p>
</blockquote>
<p>mkdir 	<code>mkdir [选项] [文件]</code>创建目录	</p>
<blockquote>
<p>-m xxx	创建具有xxx权限的目录</p>
</blockquote>
<p>rmdir	 <code>rmdir [选项] [文件]</code>删除目录</p>
<p>mv	<code>mv [选项] [源文件] [目标文件]</code>文件和目录改名、移动文件和目录路径  如<code>mv -f *.png picture</code></p>
<blockquote>
<p>-f	不询问，或者说覆盖前不询问<br>-i 	询问，或者说覆盖前询问<br>-n	不覆盖已存在的文件</p>
</blockquote>
<p>rm	<code>rm [选项] [文件]</code>删除文件或目录</p>
<blockquote>
<p>-f	 忽略不存在的文件，从不给出提示。</p>
<p>-i	进行交互式删除</p>
<p>-r	指示rm将参数中列出的全部目录和子目录均递归地删除。</p>
<p>-rf	无提示地强制递归删除文件</p>
<p>-v	详细显示进行的步骤</p>
</blockquote>
<p>wc	<code>wc [选项] [文件]</code>统计文件行数、单词数和字节数和字符数 		不加选项的话总是按行数、单词数、字节数、文件的顺序显示每项信息。</p>
<blockquote>
<p>-c或–bytes或–chars 	只显示Bytes数。</p>
<p>-l或–lines 	只显示列数。</p>
<p>-w或–words 	只显示字数。</p>
<p>-m	只显示字符数</p>
</blockquote>
<p>ln	<code>ln [选项] [源文件] [目标文件]</code>使用ln命令可以创建链接文件（包括软链接文件和硬链接文件）</p>
<blockquote>
<p>硬链接文件的使用	<code>echo hello &gt; a</code>	<code>ln a b</code></p>
<p>软链接文件的使用	<code>echo hello &gt; a</code>	<code>ln –s a b</code></p>
</blockquote>
<h4 id="文本内容显示"><a href="#文本内容显示" class="headerlink" title="文本内容显示"></a>文本内容显示</h4><p>cat	<code>cat [选项] [文件]</code>显示文本文件</p>
<blockquote>
<p>无选项 	显示文件内容</p>
<p>cat -n textfile1 &gt; textfile2  	把textfile1文件的内容加上行号后输入到textfile2文件中</p>
<p>cat &gt;mm.txt&lt;&lt;EOF 输入&gt;Hello	&gt;Linux	&gt;EOF	使用cat命令创建mm.txt并输入Hello Linux。</p>
</blockquote>
<p>more	<code>more [选项] [文件名]</code>分页显示文本文件</p>
<blockquote>
<p>无选项	分页显示该文件内容</p>
<p>more -s testfile	逐页显示testfile文件内容，如有连续两行以上空白行则以一行空白行显示</p>
<p>more +20 testfile	从第20行开始显示testfile文件的内容</p>
<p>more -2 &#x2F;etc&#x2F;passwd	一次两行显示&#x2F;etc&#x2F;passwd文件内容</p>
</blockquote>
<p>less	<code>less [选项] [文件名]</code>回卷显示文本文件</p>
<blockquote>
<p> less &#x2F;etc&#x2F;services	回卷显示&#x2F;etc&#x2F;services文件的内容</p>
</blockquote>
<p>head	<code>head［选项］[文件]</code>显示指定文件前若干行 如果没有给出具体行数值，默认为10行</p>
<blockquote>
<p>head -c -50 a	查看a文件前五十个字节数据</p>
<p>head -50 a	查看a文件前五十行数据</p>
</blockquote>
<p>tail	<code>tail［选项］[文件]</code>显示指定文件末尾若干行 如果没有给出具体行数值，默认为10行 具体选项用法完全同<code>head</code></p>
<h4 id="文本内容处理"><a href="#文本内容处理" class="headerlink" title="文本内容处理"></a>文本内容处理</h4><p>sort	<code>sort [选项] [文件]</code>对文件中的数据进行排序</p>
<blockquote>
<p>-r	倒序排序</p>
</blockquote>
<p>uniq	<code>uniq [选项] [文件] </code>将重复行从输出文件中删除</p>
<blockquote>
<p>-d	查看文件中重复的数据内容</p>
<p>-u	查看文件中不重复的数据内容</p>
</blockquote>
<p>cut	<code>cut [选项] [ 文件 ]</code>从文件每行中显示出选定的字节、字符或字段</p>
<blockquote>
<p>-b	以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</p>
<p>-c	以字符为单位进行分割。</p>
<p>-d	自定义分隔符，默认为制表符。</p>
<p>-f	与-d一起使用，指定显示哪个区域。</p>
<p>-n	取消分割多字节字符。仅和 -b 标志一起使用。</p>
</blockquote>
<blockquote>
<p>cut -f 1,5 -d: &#x2F;etc&#x2F;passwd 	显示文件&#x2F;etc&#x2F;passwd中的第1个和第5个字段，由冒号隔开。</p>
</blockquote>
<p>comm	<code>comm [选项] [文件1] [文件2]</code>逐行比较两个已排过序的文件</p>
<blockquote>
<p>-1	不输出文件1特有的行</p>
<p>-2	不输出文件2特有的行</p>
<p>-3	不输出两个文件共有的行</p>
</blockquote>
<p>diff	<code>diff ［选项］ [文件1] [文件2]</code>逐行比较两个文本文件，列出其不同之处</p>
<h4 id="文件和命令查找"><a href="#文件和命令查找" class="headerlink" title="文件和命令查找"></a>文件和命令查找</h4><p>grep	<code>grep [选项] [查找模式] [文件名] </code>查找文件中符合条件的字符串</p>
<blockquote>
<p>grep ‘test file’ kkk	在文件kkk中搜索匹配字符“test file”</p>
<p>grep ‘test’ d*	显示所有以d开头的文件中包含“test”的行数据内容</p>
<p>grep ^b &#x2F;root&#x2F;aa	 在&#x2F;root&#x2F;aa文件中找出以b开头的行内容</p>
<p>grep -v ^b &#x2F;root&#x2F;aa	在&#x2F;root&#x2F;aa文件中找出不以b开头的行内容</p>
<p>grep le$ &#x2F;root&#x2F;kkk	在&#x2F;root&#x2F;kkk文件中找出以le结尾的行内容</p>
<p>ps –ef|grep sshd	查找sshd进程信息</p>
</blockquote>
<p>find	<code>find [路径] [选项]</code>列出文件系统内符合条件的文件</p>
<blockquote>
<p>find &#x2F; -name ‘*.conf’	查找&#x2F;目录下所有以“.conf”为扩展名的文件</p>
<p>find . -ctime -20	列出当前目录及其子目录下所有最近20天内更改过的文件</p>
</blockquote>
<p>locate	<code>locate [选项][范本样式]</code>在数据库中查找文件</p>
<blockquote>
<p>locate httpd.conf	查找httpd.conf</p>
<p>locate -c httpd.conf	显示找到几个httpd.conf文件</p>
</blockquote>
<h4 id="系统信息显示"><a href="#系统信息显示" class="headerlink" title="系统信息显示"></a>系统信息显示</h4><p>uname	<code>uname [选项]</code>显示计算机及操作系统相关信息</p>
<blockquote>
<p>-r	显示操作系统的内核发行号</p>
<p>-m	显示计算机硬件架构名称</p>
<p>-a	显示操作系统的全部信息</p>
</blockquote>
<p>hostname	<code>设置主机名:hostname [选项] [主机名] 	显示主机名:hostname [选项] </code>显示或修改计算机主机名</p>
<p>free	<code>free [选项]</code>查看内存信息</p>
<blockquote>
<p>free	查看系统的物理内存和交换分区使用情况</p>
<p>free -m	以MB为单位查看系统的物理内存和交换分区使用情况</p>
<p>free -t	显示系统的物理内存加上交换分区总的容量</p>
</blockquote>
<p>du	<code>du [选项] [文件|目录]</code>显示目录或文件的磁盘占用量</p>
<blockquote>
<p>无选项	显示文件的磁盘占用量</p>
<p>-s	显示目录的磁盘占用量</p>
<p>-sh	以MB为单位显示目录磁盘占用量</p>
</blockquote>
<h4 id="查看日期与时间"><a href="#查看日期与时间" class="headerlink" title="查看日期与时间"></a>查看日期与时间</h4><p>cal	<code>cal [选项] [[[日] 月] 年]</code>显示日历信息</p>
<blockquote>
<p>cal	显示本月的月历</p>
<p>cal 2001	显示公元2001年年历。</p>
<p>cal 9 2007	显示公元2007年9月的月历。</p>
<p>cal -m 	以星期一为每周的第一天的方式显示本月的日历。</p>
<p>cal -jy	以1月1日起的天数显示今年的年历。</p>
</blockquote>
<p>date	<code>date [选项] [显示时间格式]（以+开头，后面接格式）</code>显示和设置系统日期和时间</p>
<blockquote>
<p>date	显示当前计算机上的日期和时间</p>
<p>date 0202191428	设置计算机日期和时间为2028年2月2日19点14分</p>
<p>date +’%r%a%d%h%y’	按照指定的格式显示计算机日期和时间</p>
<p>date -s 09:16:00	设置计算机时间为上午9点16分</p>
<p>date -s 240414	设置计算机时间为2024年4月14日</p>
</blockquote>
<p>hwclock	<code>hwclock [选项] </code>查看和设置硬件时钟</p>
<blockquote>
<p>hwclock	查看硬件时间</p>
<p>hwclock -w 	以系统时间更新硬件时间</p>
<p>hwclock -s	以硬件时间更新系统时间</p>
</blockquote>
<h4 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h4><p>echo	<code>echo [选项] [字符串] </code>在显示器上显示文字</p>
<blockquote>
<p>echo Hello Linux	将一段信息写到标准输出	结果:Hello Linux</p>
<p>echo Hello Linux &gt; notes	将文本“Hello Linux”添加到新文件notes中</p>
<p>echo $HOME	 显示$HOME变量的值</p>
</blockquote>
<p>mesg	<code>mesg [选项]</code>允许或拒绝写消息</p>
<blockquote>
<p>控制系统中的其它用户是否能够用 write 命令或 talk 命令向您发送消息。不带选项的情况下，mesg 命令显示当前主机消息许可设置</p>
</blockquote>
<p>wall	<code>wall [消息] </code>对全部已登录用户发送信息</p>
<blockquote>
<p>wall ‘aaaaaaa’	对全部已登录用户发送aaaaaaa</p>
</blockquote>
<p>write	<code>write [用户] [终端名称] </code>向用户发送消息</p>
<blockquote>
<p>write root tty3	向tty3终端上的root用户发送信息</p>
</blockquote>
<h4 id="用户和组群账户管理"><a href="#用户和组群账户管理" class="headerlink" title="用户和组群账户管理"></a>用户和组群账户管理</h4><h5 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h5><p>在Linux系统中，用户账户是登录系统的唯一凭证，其中root用户是系统的最高管理者，该用户的UID是0级，与用户和组账户相关的配置文件有&#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;shadow、&#x2F;etc&#x2F;group和&#x2F;etc&#x2F;gshadow。</p>
<p>在实际的管理中，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中有三大类用户，分别是</p>
<blockquote>
<p>   root用户：UID为0</p>
<p>   系统用户：比如bin、daemon、adm、ftp、mail等，这类用户都是系统自身拥有的。系统用户的UID为1~999</p>
<p>   普通用户：能登录系统，在Linux系统上进行普通操作，能操作自己目录的内容，其使用系统的权限受限，这类用户都是系统管理员创建的。普通用户的UID为1000~60000</p>
</blockquote>
<ul>
<li><p><strong>&#x2F;etc&#x2F;passwd文件</strong>是系统识别用户的一个重要文件，Linux系统中所有的用户都记录在该文件中。假设用户以账户zhangsan登录系统时，系统首先会检查&#x2F;etc&#x2F;passwd文件，看是否有zhangsan这个账户，然后确定用户zhangsan的UID，通过UID来确认用户的身份，如果存在则读取&#x2F;etc&#x2F;shadow文件中所对应的密码。如果密码核实无误则登录系统，读取用户的配置文件</p>
<p>任何用户都可以读取&#x2F;etc&#x2F;passwd文件内容，在&#x2F;etc&#x2F;passwd文件中，每一行表示的是一个用户账户的信息，一行有7个段位，每个段位用“:”分隔。<code>zhangsan:x:1000:1000:张三:/home/zhangsan:/bin/bash</code></p>
<p>&#x2F;etc&#x2F;passwd文件字段含义</p>
</li>
</ul>
<img src="/2022/09/26/Linux/image-20221108180023752.png" alt="image-20221108180023752" style="zoom:50%;">

<ul>
<li><p><strong>&#x2F;etc&#x2F;shadow文件</strong>是&#x2F;etc&#x2F;passwd的影子文件，这个文件并不是由&#x2F;etc&#x2F;passwd文件产生，这两个文件应该是对应互补的。&#x2F;etc&#x2F;shadow文件内容包括用户及被加密的密码以及其它&#x2F;etc&#x2F;passwd不能包括的信息，比如用户账户的有效期等。</p>
<p>&#x2F;etc&#x2F;shadow文件只有root用可以读取和操作</p>
</li>
</ul>
<p>​	   &#x2F;etc&#x2F;shadow文件字段含义</p>
<img src="/2022/09/26/Linux/image-20221108180638552.png" alt="image-20221108180638552" style="zoom:50%;">



<p>useradd	<code>useradd [选项] [用户名] </code>   在Linux系统中创建用户账户</p>
<blockquote>
<p>  useradd zhangsan</p>
<p>  cat &#x2F;etc&#x2F;passwd|grep zhangsan	&#x2F;&#x2F;查看&#x2F;etc&#x2F;passwd文件，显示已经创建了用户zhangsan</p>
<p>  passwd zhangsan	&#x2F;&#x2F;更改张三的密码</p>
</blockquote>
<blockquote>
<p>  useradd -u 1010 moon		创建用户moon，并设置该用户UID为1010</p>
<p>  useradd -g root pp		创建用户pp，并指定该用户是属于组群root的成员</p>
<p>  useradd -s &#x2F;bin&#x2F;ksh abc		创建用户abc，并设置该用户的Shell类型是&#x2F;bin&#x2F;ksh</p>
<p>  useradd -d &#x2F;home&#x2F;www newuser		创建用户newuser，并设置该用户主目录为&#x2F;home&#x2F;www</p>
</blockquote>
<p>usermod   <code>	usermod [选项][用户名]</code>  更改用户的Shell类型、所属的组群、用户密码的有效期，还能更改用户的登录名</p>
<blockquote>
<p>  usermod -d &#x2F;home&#x2F;kkk zhangsan		修改用户zhangsan的主目录为&#x2F;home&#x2F;kkk</p>
<p>  usermod -s &#x2F;bin&#x2F;ksh zhangsan		 修改用户zhangsan的Shell类型为&#x2F;bin&#x2F;ksh</p>
<p>  usermod -l zhaoliu wangwu		修改用户wangwu的登录名为zhaoliu</p>
<p>  usermod -u 1700 zhangsan		修改用户账户zhangsan的UID为1700</p>
<p>  usermod -c 张三 zhangsan		修改用户zhangsan的用户名全称为张三</p>
<p>  usermod -f 20 zhangsan		修改用户zhangsan在密码过期后20天就禁用该账户</p>
<p>  usermod -g root sun		修改用户sun所属的组群为root，该组群必须事先存在</p>
<p>  usermod -L zhangsan		锁住用户zhangsan密码，使密码无效</p>
<p>  usermod -U zhangsan		解除用户zhangsan密码锁住</p>
</blockquote>
<p>userdel	<code>userdel [选项][用户名]</code>	以在Linux系统中删除用户账户，甚至连用户的主目录也一起删除</p>
<blockquote>
<p>  userdel -r moon  	删除用户moon，并且在删除该用户的同时一起删除主目录</p>
</blockquote>
<h5 id="族群账户管理"><a href="#族群账户管理" class="headerlink" title="族群账户管理"></a>族群账户管理</h5><p>具有某种共同特征的用户集合就是组群。通过组群可以集中设置访问权限和分配管理任务。</p>
<p>组群账户有关的配置文件&#x2F;etc&#x2F;group和&#x2F;etc&#x2F;gshadow</p>
<p><strong>&#x2F;etc&#x2F;group文件</strong>是组群的配置文件，内容包括用户和组群，并且能显示出用户是归属哪个组群或哪几个组群。一个用户可以归属一个或多个不同的组群，同一组群的用户之间具有相似的特征。比如把某一用户加入到root组群，那么这个用户就可以浏览root用户主目录的文件，如果root用户把某个文件的读写执行权限开放，root组群的所有用户都可以修改此文件；如果是可执行的文件，root组群的用户也是可以执行的。</p>
<ul>
<li><p>组群的特性在系统管理中为系统管理员提供了极大的方便，但安全性也是值得关注的，如某个用户有对系统管理有最重要的内容，最好让用户拥有独立的组群，或者把用户的文件的权限设置为完全私有。</p>
</li>
<li><p>&#x2F;etc&#x2F;group文件的内容包括组群名、组群密码、GID及该组群所包含的用户，每个组群一条记录，一行有4个段位，每个段位用“:”分隔。<code>zhangsan:x:1000:</code></p>
</li>
</ul>
<img src="/2022/09/26/Linux/image-20221108191645542.png" alt="image-20221108191645542" style="zoom:50%;">

<p>&#x2F;etc&#x2F;gshadow是&#x2F;etc&#x2F;group的加密文件，组群密码就是存放在这个文件中。&#x2F;etc&#x2F;gshadow和 &#x2F;etc&#x2F;group是互补的两个文件；对于大型服务器，针对很多用户和组群，定制一些关系结构比较复杂的权限模型，设置组群密码是很有必要的。比如不想让一些非组群成员永久拥有组群的权限和特性，可以通过密码验证的方式来让某些用户临时拥有一些组群特性，这时就要用到组群密码。</p>
<ul>
<li>&#x2F;etc&#x2F;gshadow文件中每个组群都有一条记录。每个段位用“:”分隔。<code>beijing:$6$E/xvWMmh$rhYLQwwffEqIudVLFzMlv1::ou</code></li>
</ul>
<img src="/2022/09/26/Linux/image-20221108191848542.png" alt="image-20221108191848542" style="zoom:50%;">



<p>groupadd</p>
<blockquote>
<p>  groupmod -g 1800 group1		创建组群group1，并且在创建时设置其GID为180</p>
</blockquote>
<p>groupmod</p>
<blockquote>
<p>  groupmod -n shanghai group1		修改组群group1的新组群名称为“shanghai”</p>
</blockquote>
<p>groupdel</p>
<h4 id="磁盘分区和文件系统管理"><a href="#磁盘分区和文件系统管理" class="headerlink" title="磁盘分区和文件系统管理"></a>磁盘分区和文件系统管理</h4><p>磁盘分区：</p>
<ul>
<li><p>在Linux中，如需在某个磁盘上存储数据。则需将<strong>磁盘进行分区，然后创建文件系统，最后将文件系统挂载到目录下</strong></p>
</li>
<li><p>在安装Linux系统后需要添加更多的交换空间，可以通过添加一个交换分区或添加一个交换文件来实现</p>
</li>
<li><p>磁盘分区一共有3种：主分区、扩展分区和逻辑驱动器。扩展分区只不过是逻辑驱动器的“容器”，实际上只有主分区和逻辑驱动器才能进行数据存储。在一块磁盘上最多只能有四个主分区，可以另外建立一个扩展分区来代替四个主分区的其中一个，然后在扩展分区下可以建立更多的逻辑驱动器</p>
</li>
<li><p>在Linux系统中进行分区可以使用<code>fdisk</code>和<code>parted</code>等命令，或者使用相同功能的图形界面程序</p>
</li>
</ul>
<p>格式化：</p>
<ul>
<li>磁盘经过分区之后，下一个步骤就是要对磁盘分区进行格式化的工作（也就是创建文件系统的工作）。格式化是指对磁盘分区进行初始化的一种操作，这种操作通常会导致现有的分区中所有的数据被清除。简单说，就是<strong>把一张空白的磁盘划分成一个个小区域并编号</strong>，供计算机储存和读取数据使用</li>
<li>通过分区当然不能产生任何文件系统。分区只是对磁盘上的磁盘空间进行了保留，还不能直接使用，在此之后分区必须要进行格式化。在Windows系统下可以通过资源管理器下的文件菜单或者format程序来执行，而在Linux系统中大多使用<code>mkfs</code>命令来完成</li>
<li>Linux系统支持不同的文件系统，目前应用最广泛的就是<code>xfs</code>和<code>ext4</code></li>
</ul>
<h5 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h5><p>fdisk	<code>fdisk [选项] [设备]</code>		使用fdisk命令可以用来对磁盘进行分区</p>
<blockquote>
<p>  m 	显示所有能在fdisk中使用的子命令</p>
<p>  p 	显示磁盘分区信息</p>
<p>  a 	设置磁盘启动分区</p>
<p>  n 	创建新的分区</p>
<p>  e 	创建扩展分区</p>
<p>  p 	创建主分区-t 	更改分区的系统ID（也就是分区类型ID）</p>
<p>  d 	删除磁盘分区</p>
<p>  q 	退出fdisk，不保存磁盘分区设置</p>
<p>  l 	列出已知的分区类型</p>
<p>  v 	验证分区表</p>
<p>  w 	保存磁盘分区设置并退出fdisk</p>
</blockquote>
<blockquote>
<p>   fdisk -l &#x2F;dev&#x2F;sda	查看当前磁盘上的分区情况，该磁盘设备是&#x2F;dev&#x2F;sda</p>
</blockquote>
<p>Linux常用分区类型</p>
<img src="/2022/09/26/Linux/image-20221108194826444.png" alt="image-20221108194826444" style="zoom:50%;">



<h5 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h5><p>partprobe </p>
<blockquote>
<p>  使用fdisk工具只是将分区信息写到磁盘，如果需要mkfs创建文件系统则需要事先重启系统，而使用partprobe则可以使kernel重新读取分区信息，从而避免重启系统</p>
</blockquote>
<p>mkfs	<code>mkfs [选项] [设备]</code>	使用mkfs命令可以在分区上创建各种文件系统</p>
<blockquote>
<p>  mkfs并不建立文件系统，而是调用相关的程序来执行。这里的文件系统是要指定的，比如xfs、ext4、ext3、vfat或者是msdos等</p>
</blockquote>
<blockquote>
<p>   mkfs -t ext4 &#x2F;dev&#x2F;sda5	格式化&#x2F;dev&#x2F;sda5分区，创建ext4文件系统</p>
</blockquote>
<h5 id="挂载和卸载文件系统"><a href="#挂载和卸载文件系统" class="headerlink" title="挂载和卸载文件系统"></a>挂载和卸载文件系统</h5><p>mount 	<code>mount [选项] [设备] [挂载目录] </code>	将指定分区、光盘、U盘或者是移动硬盘挂载到Linux系统的目录下</p>
<img src="/2022/09/26/Linux/image-20221108201743403.png" alt="image-20221108201743403" style="zoom:50%;">

<blockquote>
<p>  mount &#x2F;dev&#x2F;sda5 &#x2F;mnt&#x2F;kk		挂载分区&#x2F;dev&#x2F;sda5到&#x2F;mnt&#x2F;kk目录中</p>
<p>  mount -o ro &#x2F;dev&#x2F;sda5 &#x2F;mnt&#x2F;kk	 以只读方式挂载&#x2F;dev&#x2F;sda5分区到&#x2F;mnt&#x2F;kk目录中</p>
</blockquote>
<p>umount	<code>umount [选项] [设备|挂载目录]</code>	卸载分区</p>
<blockquote>
<p>   umount &#x2F;dev&#x2F;sda5	卸载分区&#x2F;dev&#x2F;sda5文件系统</p>
</blockquote>
<p>df	<code>df [选项] [文件]</code> 	查看磁盘分区挂载情况</p>
<h6 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h6><p>修改&#x2F;etc&#x2F;fstab文件，使得1GB分区开机时自动挂载到&#x2F;mnt&#x2F;kk目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 kjg]<span class="comment">#vim /etc/fstab</span></span><br><span class="line">[root@centos7 kjg]<span class="comment">#/dev/sdb1 /mnt/kk xfs defaults 1 2 # 添加</span></span><br></pre></td></tr></table></figure>



<h5 id="交换文件"><a href="#交换文件" class="headerlink" title="交换文件"></a>交换文件</h5><p>在计算机上添加交换文件，文件大小为1GB</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 kjg]<span class="comment">#mkswap /dev/sda5</span></span><br><span class="line">[root@centos7 kjg]<span class="comment">#swapon /dev/sda5</span></span><br><span class="line">[root@centos7 kjg]<span class="comment">#free</span></span><br><span class="line">[root@centos7 kjg]<span class="comment">#vim /etc/fstab</span></span><br><span class="line">[root@centos7 kjg]<span class="comment">#/dev/sda5 swap swap defaults 0 0 # 添加</span></span><br></pre></td></tr></table></figure>



<h4 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h4><h5 id="RPM软件包管理"><a href="#RPM软件包管理" class="headerlink" title="RPM软件包管理"></a>RPM软件包管理</h5><p>在Linux系统中，最常用的软件包是RPM包和tar包。要管理RPM软件包可以使用rpm和yum命令，yum命令自动化地收集RPM软件包的相关信息，检查依赖性，并且一次安装所有依赖的软件包，无需繁琐地一次次安装。</p>
<p>目前在众多的Linux系统上都采用RPM软件包，这种软件包格式在安装、升级、删除以及查询方面非常方便，不需要进行编译即可安装软件包。本节主要讲述RPM软件包的使用和管理。</p>
<p><strong>RPM软件包管理用途：</strong></p>
<ul>
<li>可以安装、删除、升级、刷新和管理RPM软件包；</li>
<li>通过RPM软件包管理能知道软件包包含哪些文件，也能知道系统中的某个文件属于哪个RPM软件包；</li>
<li>可以查询系统中的RPM软件包是否安装并查询其安装的版本；</li>
<li>可以把自己的程序打包为RPM软件包并发布；</li>
<li>软件包签名GPG和MD5的导入、验证和签名发布；</li>
<li>依赖性的检查，查看是否有RPM软件包由于不兼容而扰乱系统</li>
</ul>
<p>RPM软件包管理主要有安装（添加）、删除（卸载）、刷新、升级、查询这五种基本操作模式</p>
<h5 id="使用yum管理RPM软件包"><a href="#使用yum管理RPM软件包" class="headerlink" title="使用yum管理RPM软件包"></a>使用yum管理RPM软件包</h5><ul>
<li><p>yum（Yellow dog Updater Modified）起初是由Terra Soft研发，其宗旨是自动化地升级、安装和删除RPM软件包，收集RPM软件包的相关信息，检查依赖性并且一次安装所有依赖的软件包，无须繁琐地一次次安装。</p>
</li>
<li><p>yum的关键之处是要有可靠的软件仓库，软件仓库可以是HTTP站点、FTP站点或者是本地软件池，但必须包含rpm的header，header包括了RPM软件包的各种信息，包括描述、功能、提供的文件以及依赖性等。正是收集了这些header并加以分析，才能自动化地完成余下的任务。</p>
</li>
<li><p>yum特点</p>
<blockquote>
<p>  可以同时配置多个软件仓库；</p>
<p>  简洁的配置文件&#x2F;etc&#x2F;yum.conf； </p>
<p>  自动解决安装或者删除RPM软件包时遇到的依赖性问题；</p>
<p>  保持与RPM数据库的一致性</p>
</blockquote>
</li>
</ul>
<h6 id="yum软件仓库"><a href="#yum软件仓库" class="headerlink" title="yum软件仓库"></a>yum软件仓库</h6><ul>
<li>yum软件仓库配置文件</li>
</ul>
<p>repo文件是Linux系统中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，比如从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用。软件仓库配置文件默认存储在&#x2F;etc&#x2F;yum.repos.d目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下是yum软件仓库配置文件的格式内容。</span></span><br><span class="line">[rhel-source]		<span class="comment">#方括号里面是软件源的名称，会被yum识别。</span></span><br><span class="line">name=Red Hat <span class="variable">$releasever</span>-<span class="variable">$basearch</span>-Source		<span class="comment">#定义软件仓库名称，$releasever变量定义了发行版本，$basearch变量定义了系统架构，方便yum升级时选择适合当前系统的软件包。</span></span><br><span class="line">baseurl= ftp://ftp.redhat.com/pub/redhat/linux/enterprise/<span class="variable">$releasever</span>/en/os/SRPM/ 	<span class="comment">#指定RPM软件包来源，支持的协议有http://、ftp://、file:///（本地源）</span></span><br><span class="line">enabled=1		<span class="comment">#软件仓库中的源是否启用，0禁用，1启用。</span></span><br><span class="line">gpgcheck=1		<span class="comment">#表示对软件仓库中下载的RPM软件包进行GPG校验，确定来源是否有效和安全。</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/the-file		<span class="comment">#用于校验的GPG密钥</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建本地软件仓库</li>
</ul>
<ol>
<li><p>安装软件包：安装deltarpm、python-deltarpm和createrepo软件包</p>
</li>
<li><p>复制软件包：复制Linux系统安装光盘中的软件包</p>
</li>
<li><p>创建软件仓库配置文件：创建软件仓库配置文件</p>
</li>
<li><p>创建软件仓库：使用createrepo命令创建软件仓库</p>
</li>
</ol>
<h6 id="使用yum命令进行软件管理"><a href="#使用yum命令进行软件管理" class="headerlink" title="使用yum命令进行软件管理"></a>使用yum命令进行软件管理</h6><ol>
<li><p>yum help 显示使用信息</p>
</li>
<li><p>yum list 列出软件包</p>
</li>
<li><p>yum search keyword 搜索关键字</p>
</li>
<li><p>yum info packagename 列出软件包详细信息</p>
</li>
<li><p>yum install packagename 安装软件包</p>
</li>
<li><p>yum remove packagename 删除软件包</p>
</li>
<li><p>yum update packagename 升级软件包</p>
</li>
</ol>
<h6 id="使用yum命令管理软件包组"><a href="#使用yum命令管理软件包组" class="headerlink" title="使用yum命令管理软件包组"></a>使用yum命令管理软件包组</h6><ol>
<li><p>yum grouplist 列出所有可用组</p>
</li>
<li><p>yum groupinfo 提供特定组的信息</p>
</li>
<li><p>yum groupinstall 安装软件包组</p>
</li>
<li><p>yum groupupdate 更新软件包组</p>
</li>
<li><p>yum grouperase 删除软件包组</p>
</li>
</ol>
<h6 id="使用yum命令安装本地rpm包"><a href="#使用yum命令安装本地rpm包" class="headerlink" title="使用yum命令安装本地rpm包"></a>使用yum命令安装本地rpm包</h6><p>yum localinstall *.rpm </p>
<h6 id="例"><a href="#例" class="headerlink" title="例"></a>例</h6><p>yum -y bind 	无需确认、直接安装bind软件包</p>
<p>yum info bind 	显示bind软件包的详细信息</p>
<p>yum info installed	显示所有已经安装的软件包信息</p>
<p>yum list bind	列出bind软件包</p>
<p>yum deplist bind	列出bind软件包的依赖关系</p>
<p>yum repolist	显示软件仓库的配置</p>
<p>yum provides &#x2F;etc&#x2F;named.conf	查看&#x2F;etc&#x2F;named.conf文件是属于哪个软件包的</p>
<p>yum remove bind	删除bind软件包</p>
<h5 id="tar包管理"><a href="#tar包管理" class="headerlink" title="tar包管理"></a>tar包管理</h5><p>使用tar命令可以将许多文件一起保存到一个单独的磁带或磁盘归档，并能从归档中单独还原所需文件 <code>tar [选项][文件|目录]</code></p>
<p>tar cvf abc.tar &#x2F;root&#x2F;abc	备份&#x2F;root&#x2F;abc目录及其子目录下的全部文件，备份文件名为abc.tar</p>
<p>tar tvf abc.tar	查看abc.tar备份文件的内容，并显示在显示器上</p>
<p>tar xvf abc.tar	将打包文件abc.tar解包出来</p>
<p>tar rvf abc.tar &#x2F;root&#x2F;abc&#x2F;d	将文件&#x2F;root&#x2F;abc&#x2F;d添加到abc.tar包里面去</p>
<p>tar uvf abc.tar &#x2F;root&#x2F;abc&#x2F;d	更新原来tar包abc.tar中的文件&#x2F;root&#x2F;abc&#x2F;d</p>
<h4 id="权限和所有者"><a href="#权限和所有者" class="headerlink" title="权限和所有者"></a>权限和所有者</h4><p>权限字符组合举例</p>
<p><img src="/2022/09/26/Linux/image-20221128215509056.png" alt="image-20221128215509056"></p>
<p><code>ls –l  [文件名]</code>	可以显示文件的详细信息</p>
<p><img src="/2022/09/26/Linux/image-20221128215934831.png" alt="image-20221128215934831"></p>
<h5 id="文字设定法设置权限"><a href="#文字设定法设置权限" class="headerlink" title="文字设定法设置权限"></a>文字设定法设置权限</h5><p><code>chmod [操作对象] [操作符号] [权限] [文件|目录] </code></p>
<p><img src="/2022/09/26/Linux/image-20221128220607286.png" alt="image-20221128220607286"></p>
<p><img src="/2022/09/26/Linux/image-20221128220621457.png" alt="image-20221128220621457"></p>
<p>chmod u+w a	添加所有者对a文件的写入权限</p>
<p>chmod u-r a	取消所有者对a文件的读取权限</p>
<p>chmod g&#x3D;w a	重新分配同组用户对a文件有写入的权限</p>
<p>chmod u+rw,g+r,o+rwx a	添加所有者为读取、写入权限;同组用户为读取权限;其他用户读取、写入和执行的权限</p>
<p>chmod a-rwx a	取消所有用户的读取、写入和执行权限</p>
<h5 id="数字设定法设置权限"><a href="#数字设定法设置权限" class="headerlink" title="数字设定法设置权限"></a>数字设定法设置权限</h5><p><code>chmod [n1n2n3] [文件|目录]</code></p>
<blockquote>
<p>  n1表示用户所有者的权限 ，n2表示组群所有者的权限，n3表示其它用户的权限。</p>
</blockquote>
<ul>
<li><p>文件和目录的权限表中用r、w、x这三个字符来为用户所有者、组群所有者和其它用户设置权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需3个数字。</p>
</li>
<li><p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。</p>
</li>
<li><p>所有数字属性的格式应该是三个0～7的数，其顺序是u、g、o。</p>
</li>
</ul>
<blockquote>
<p>  r：对应数值4</p>
<p>  w：对应数值2</p>
<p>  x：对应数值1</p>
<p>  -：对应数值0</p>
</blockquote>
<blockquote>
<p>  -rwx——：用数字表示为700； </p>
<p>  -rwxr–r–：用数字表示为744； </p>
<p>  -rw-rw-r-x：用数字表示为665；</p>
<p>  drwx–x–x：用数字表示为711；</p>
<p>  drwx——：用数字表示为700。</p>
</blockquote>
<blockquote>
<p>  chmod 777 a	所有用户拥有读取、写入和执行的权限</p>
<p>  chmod 7 a	设置a文件权限，其他用户拥有读取、写入和执行的权限</p>
</blockquote>
<h5 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h5><p>（1）SUID</p>
<p>对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的用户所有者身份来执行；对一个目录无影响</p>
<p>（2）SGID</p>
<p>对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的组群所有者身份来执行；对一个目录，在该目录中创建的任意新文件的所属组与该目录的所属组相同。</p>
<p>（3）Sticky</p>
<p>对一个可执行文件无影响；对目录设置Sticky之后，尽管其它用户有写权限，也必须由文件所有者执行删除和移动等操作</p>
<h6 id="文字设定法设置特殊权限"><a href="#文字设定法设置特殊权限" class="headerlink" title="文字设定法设置特殊权限"></a>文字设定法设置特殊权限</h6><p>chmod u+s a	添加a文件的特殊权限为SUID</p>
<p>chmod g+s a	添加a文件的特殊权限为SGID</p>
<p>chmod o+t a	添加a文件的特殊权限为Sticky</p>
<h6 id="数字设定法设置特殊权限"><a href="#数字设定法设置特殊权限" class="headerlink" title="数字设定法设置特殊权限"></a>数字设定法设置特殊权限</h6><p>chmod 4000 a	设置文件a具有SUID权限</p>
<p>chmod 2000 a	设置文件a具有SGID权限</p>
<p>chmod 1000 a	设置文件a具有Sticky权限</p>
<p>chmod 7000 a	设置文件a具有SUID，SGID和Sticky权限</p>
<h5 id="更改文件和目录所有者"><a href="#更改文件和目录所有者" class="headerlink" title="更改文件和目录所有者"></a>更改文件和目录所有者</h5><p>使用chown命令可以更改文件和目录的用户所有者和组群所有者</p>
<p><code>chown [选项] [用户.组群] [文件|目录]</code> 或 <code>chown [选项] [用户:组群] [文件|目录]</code></p>
<p>chown root.root a	将文件a的所有者和用户组一起改成root</p>
<p>chown .newuser a	将文件a的用户组改成newuser</p>
<p>chown -R newuser.newuser &#x2F;root&#x2F;b	将目录&#x2F;root&#x2F;b连同它的下级文件&#x2F;root&#x2F;b&#x2F;ccc的所有者和用户组一起更改为newuser</p>
<h4 id="Linux日常管理和维护"><a href="#Linux日常管理和维护" class="headerlink" title="Linux日常管理和维护"></a>Linux日常管理和维护</h4><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><h6 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h6><p><code>ps [选项]</code></p>
<p>ps命令是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行以及进程运行的状态、进程是否结束、进程有没有僵死，以及哪些进程占用了过多的资源等</p>
<p><img src="/2022/09/26/Linux/image-20221128230540723.png" alt="image-20221128230540723"></p>
<p>ps –e	显示所有进程</p>
<p>ps -aux	显示所有不带控制台终端的进程，并显示用户名和进程的起始时间</p>
<p>ps -ax|grep less	查看less进程是否在运行</p>
<p>ps -u	显示用户名和进程的起始时间</p>
<p>ps -u root	显示用户root的进程。</p>
<p>ps -t tty1	显示tty1终端下的进程</p>
<p>ps -p 1659	显示进程号为1659的进程</p>
<h6 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h6><p><code>top [选项]</code></p>
<p>使用top命令可以显示当前正在运行的进程以及关于它们的重要信息，包括它们的内存和CPU使用量。执行top命令可以显示目前正在系统中执行的进程，并通过它所提供的互动式界面，用热键加以管理。要退出top，按[q] 键即可</p>
<p>top	使用top命令动态显示进程信息</p>
<h6 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps –ef|grep crond 	<span class="comment">#查询到crond进程号为1659</span></span><br><span class="line"><span class="built_in">kill</span> –9 1659	<span class="comment">#强制杀死进程号为1659的进程</span></span><br></pre></td></tr></table></figure>



<h5 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h5><ul>
<li><p>如果要在固定的时间上触发某个作业，就需要创建任务计划，按时执行该作业，在Linux系统中常用cron实现该功能</p>
</li>
<li><p>使用cron实现任务自动化可以通过修改&#x2F;etc&#x2F;crontab文件以及使用crontab命令实现，其结果是一样的</p>
</li>
</ul>
<h6 id="x2F-etc-x2F-crontab文件详解"><a href="#x2F-etc-x2F-crontab文件详解" class="headerlink" title="&#x2F;etc&#x2F;crontab文件详解"></a>&#x2F;etc&#x2F;crontab文件详解</h6><ul>
<li><p>root用户通过修改&#x2F;etc&#x2F;crontab文件可以实现任务计划，而普通用户却无法修改该文件。crond守护进程可以在无需人工干预的情况下，根据时间和日期的组合来调度执行重复任务。</p>
</li>
<li><p>&#x2F;etc&#x2F;crontab文件是cron的默认配置文件，前面3行是用来配置cron任务运行环境的变量:</p>
<blockquote>
<p>  Shell: 告诉系统要使用哪个Shell环境（在这个例子里是&#x2F;bin&#x2F;bash）</p>
<p>  PATH: 定义用来执行命令的路径</p>
<p>  MAILTO: cron任务的输出被邮寄给MAILTO变量定义的用户名。如果MAILTO变量被定义为空白字符串，电子邮件就不会被寄出</p>
</blockquote>
</li>
<li><p>&#x2F;etc&#x2F;crontab文件中的每一行都代表一项任务，它的格式如下：</p>
</li>
</ul>
<pre><code>`minute hour day month dayofweek user-name commands`
</code></pre>
<ul>
<li><p>&#x2F;etc&#x2F;crontab文件内容</p>
<p><img src="/2022/09/26/Linux/image-20221128232732524.png" alt="image-20221128232732524"></p>
</li>
<li><p>&#x2F;etc&#x2F;crontab时间格式</p>
<p><img src="/2022/09/26/Linux/image-20221128232808175.png" alt="image-20221128232808175"></p>
</li>
</ul>
<h6 id="x2F-etc-x2F-crontab文件配置举例"><a href="#x2F-etc-x2F-crontab文件配置举例" class="headerlink" title="&#x2F;etc&#x2F;crontab文件配置举例"></a>&#x2F;etc&#x2F;crontab文件配置举例</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="number">30</span> <span class="number">21</span>* * * root /root/backup.sh <span class="comment">//在每天晚上的21:30执行/root/backup.sh文件</span></span><br><span class="line"><span class="number">45</span> <span class="number">4</span> <span class="number">1</span>,<span class="number">10</span>,<span class="number">22</span> * * root /root/backup.sh <span class="comment">//在每月1、10、22日的4:45执行/root/backup.sh文件</span></span><br><span class="line"><span class="number">20</span> <span class="number">1</span> * * <span class="number">6</span>,<span class="number">0</span> root /bin/find / -name core -exec rm &#123;&#125; \; <span class="comment">//在每星期六、星期日的1:20执行一个find命令，查找相应的文件</span></span><br><span class="line"><span class="number">0</span>,<span class="number">30</span> <span class="number">18</span><span class="number">-23</span> * * * root /root/backup.sh <span class="comment">//在每天18:00～23:00之间每隔30分钟执行/root/backup.sh</span></span><br><span class="line"><span class="number">0</span> <span class="number">23</span> * * <span class="number">6</span> root /root/backup.sh <span class="comment">//在每星期六的23:00执行/root/backup.sh</span></span><br></pre></td></tr></table></figure>



<h6 id="x2F-etc-x2F-cron-d目录"><a href="#x2F-etc-x2F-cron-d目录" class="headerlink" title="&#x2F;etc&#x2F;cron.d目录"></a>&#x2F;etc&#x2F;cron.d目录</h6><p>除了通过修改&#x2F;etc&#x2F;crontab文件实现任务计划之外，还可以在&#x2F;etc&#x2F;cron.d目录中创建文件来实现。</p>
<p>该目录中的所有文件和&#x2F;etc&#x2F;crontab文件使用一样的配置语法。</p>
<h6 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h6><p><code>crontab [选项]</code></p>
<p><code>crontab [选项] [文件]</code></p>
<p>使用crontab命令可以创建、修改、查看以及删除crontab条目</p>
<h5 id="GRUB-2相关"><a href="#GRUB-2相关" class="headerlink" title="GRUB 2相关"></a>GRUB 2相关</h5><p>设置GRUB 2 PBKDF2加密口令</p>
<blockquote>
<p>  先要使用grub2-mkpasswd-pbkdf2命令PBKDF2加密口令，然后在&#x2F;etc&#x2F;grub.d&#x2F;00_header文件中添加超级用户和PBKDF2加密口令，最后使用grub2-mkconfig命令生成GRUB 2配置文件</p>
</blockquote>
<p>破解root用户密码</p>
<blockquote>
<ol>
<li><p>开机按光标上下键停止启动，在GRUB2菜单处按<e>进入编辑模式</e></p>
</li>
<li><p>在 linux16 行，按<End>键定位到这行末尾，添加 rd.break console&#x3D;tty0</End></p>
</li>
<li><p>按<Ctrl-x>继续启动，然后输入下面命令行：</Ctrl-x></p>
<p># mount -o remount,rw &#x2F;sysroot&#x2F; </p>
<p># chroot &#x2F;sysroot&#x2F;</p>
<p># passwd root # 或者 echo redhat123 | passwd –stdin root</p>
<p># touch &#x2F;.autorelabel</p>
<p># sync</p>
<p># exit # 两次 或者 ctrl + d </p>
</li>
<li><p>重新启动后，使用指定的密码登录系统，从而验证密码是否正确</p>
</li>
</ol>
</blockquote>
<p>将网卡名称eno16777736更改为eth0</p>
<blockquote>
<p>  1．修改&#x2F;etc&#x2F;default&#x2F;grub文件</p>
<p>  在GRUB_CMDLINE_LINUX变量中添加“net.ifnames&#x3D;0 biosdevname&#x3D;0” </p>
<p>  2．生成GRUB 2配置文件，执行下面命令：</p>
<p>  grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</p>
<p>  3．查看网卡名称: 重新启动Linux系统，使用ifconfig查看网卡名称</p>
</blockquote>
<h4 id="Linux网络基本配置"><a href="#Linux网络基本配置" class="headerlink" title="Linux网络基本配置"></a>Linux网络基本配置</h4><h5 id="常用网络配置文件"><a href="#常用网络配置文件" class="headerlink" title="常用网络配置文件"></a>常用网络配置文件</h5><ol>
<li><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eno16777736文件</p>
<blockquote>
<p>  在Linux统中，系统网络设备的配置文件保存在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts目录下，其中文件ifcfg-eno16777736包含一块网卡的配置信息，文件ifcfg-lo包含回路IP地址信息</p>
</blockquote>
</li>
<li><p>&#x2F;etc&#x2F;resolv.conf文件</p>
<blockquote>
<p>  &#x2F;etc&#x2F;resolv.conf文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件</p>
</blockquote>
</li>
<li><p>&#x2F;etc&#x2F;hosts文件</p>
<blockquote>
<p>  当计算机启动时，在可以查询DNS前，计算机需要查询一些主机名到IP地址的匹配。这些匹配信息存放在&#x2F;etc&#x2F;hosts文件中。在没有域名服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的IP地址</p>
</blockquote>
</li>
<li><p>&#x2F;etc&#x2F;services文件</p>
<blockquote>
<p>  &#x2F;etc&#x2F;services文件定义了Linux系统中所有服务的名称、协议类型、服务的端口等信息</p>
</blockquote>
</li>
</ol>
<h5 id="常用网络命令"><a href="#常用网络命令" class="headerlink" title="常用网络命令"></a>常用网络命令</h5><p>在Linux系统中提供了大量的网络命令用于网络配置、测试以及诊断：traceroute、ifconfig、ping、netstat、arp、tcpdump</p>
<h6 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h6><p><code>traceroute [选项] [主机名|IP地址] [数据包大小]</code></p>
<blockquote>
<p>  使用traceroute命令可以显示数据包到目标主机之间的路径。traceroute命令使用户可以追踪网络数据包的路由途径，预设IPv4数据包大小是60字节，用户可以另外设置</p>
</blockquote>
<blockquote>
<p>  traceroute <a href="http://www.163.com/">www.163.com</a>	跟踪从本地计算机到<a href="http://www.163.com网站的路径/">www.163.com网站的路径</a></p>
</blockquote>
<h6 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h6><p><code>ifconfig [接口] [选项| IP地址]</code></p>
<blockquote>
<p>  使用ifconfig命令可以显示和配置网络接口，比如设置IP地址、MAC地址、激活或关闭网络接口</p>
</blockquote>
<blockquote>
<p>  ifconfig eno16777736 192.168.0.100 netmask 255.255.255.0 up		配置网卡eno16777736的IP地址， 同时激活该设备</p>
<p>  ifconfig eno16777736:1 192.168.0.3		配置网卡eno16777736别名设备eno16777736:1的IP地址为192.168.0.3</p>
<p>  ifconfig eno16777736:1 up		激活网卡eno16777736:1设备</p>
<p>  ifconfig eno16777736		查看网卡eno16777736网络接口的配置</p>
<p>  ifconfig		查看所有的网卡网络接口配置</p>
<p>  ifconfig eno16777736:1 down		禁用网卡eno16777736:1设备</p>
<p>  ifconfig eno16777736 hw ether 00:0C:29:18:2E:3D		更改网卡eno16777736的硬件MAC地址为00:0C:29:18:2E:3D</p>
</blockquote>
<h6 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h6><p><code>ping [选项] [目标]</code></p>
<blockquote>
<p>  使用ping命令用来测试与目标计算机之间的连通性。执行ping命令会使用ICMP传输协议发出要求回应的信息，如果远程主机的网络功能没有问题，就会回应该信息，因而得知该主机是否运作正常</p>
</blockquote>
<blockquote>
<p>  ping <a href="http://www.ak.com/">www.ak.com</a>		测试与网站<a href="http://www.ak.com的连通性/">www.ak.com的连通性</a></p>
<p>  ping -s 128 192.168.0.222		测试与192.168.0.222计算机的连通性，每次发送的ICMP数据包大小为128字节</p>
<p>  ping -c 4 192.168.0.5		测试与192.168.0.5计算机的连通性，要求返回4个ICMP数据包</p>
</blockquote>
<h6 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h6><p><code>netstat [选项] [延迟]</code></p>
<blockquote>
<p>  使用netstat命令来显示网络状态的信息，得知整个Linux系统的网络情况，比如网络连接、路由表、接口统计、伪装连接和组播成员</p>
</blockquote>
<blockquote>
<p>  netstat -r		显示内核路由表信息</p>
<p>  netstat –antu |grep 22		显示端口号为22的连接情况</p>
<p>  netstat -u		显示UDP传输协议的连接状态</p>
</blockquote>
<h6 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h6><p><code>arp [选项] [IP地址][MAC地址]</code></p>
<blockquote>
<p>  使用arp命令可以用来增加、删除和显示ARP缓存条目。</p>
</blockquote>
<blockquote>
<p>  arp		查看系统arp缓存</p>
<p>  arp -s 192.168.0.99 00:60:08:27:CE:B2		添加一个IP地址和MAC地址的对应记录</p>
<p>  arp -d 192.168.0.99		删除一个IP地址和MAC地址的对应缓存记录</p>
</blockquote>
<h6 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h6><p><code>tcpdump [选项] [表达式]</code></p>
<blockquote>
<p>  是Linux系统中强大的网络数据采集分析工具之一，可以将网络中传送的数据包的头完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来筛选信息。作为互联网上经典的的系统管理员必备工具 tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的工具之一</p>
</blockquote>
<blockquote>
<p>  tcpdump -i eno16777736		捕获经过网络接口eno16777736的数据包</p>
</blockquote>
<h5 id="管理网络服务"><a href="#管理网络服务" class="headerlink" title="管理网络服务"></a>管理网络服务</h5><h6 id="systemd简介"><a href="#systemd简介" class="headerlink" title="systemd简介"></a>systemd简介</h6><p>RHEL 7系统使用systemd，它提供更优秀的框架以表示系统服务间的依赖关系，并实现系统初始化时服务的并行启动，同时达到降低Shell的系统开销的效果，最终代替现在常用的System V</p>
<p>在RHEL7之前，服务管理工作是由System V通过&#x2F;etc&#x2F;rc.d&#x2F;init.d目录下的Shell脚本来执行的，通过这些脚本允许管理员控制服务的状态。在RHEL 7中，这些脚本被服务单元文件替换。在systemd中，服务、设备、挂载等资源统一被称为单元，所以systemd中有许多单元类型，服务单元文件的扩展名是.service，同Shell脚本的功能相似。比如有查看、启动、停止、重启、启用或者禁止服务的参数。</p>
<p>一个单元的配置文件可以描述 系统服务（.service）、挂载点（.mount）、sockets（.sockets）、系统设备（.device）、交换分区（.swap）、文件路径（.path）、启动目标（.target）、由systemd管理的计时器（.timer）</p>
<h6 id="systemd单元文件放置位置"><a href="#systemd单元文件放置位置" class="headerlink" title="systemd单元文件放置位置"></a>systemd单元文件放置位置</h6><p>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system：systemd默认单元文件安装目录</p>
<p>&#x2F;etc&#x2F;systemd&#x2F;system：系统管理员创建和管理的单元目录，优先级最高</p>
<h6 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h6><p><code>systemctl [选项] [单元命令|单元文件命令]</code></p>
<blockquote>
<p>  使用 systemctl 控制单元时，通常需要使用单元文件的全名，包括扩展名（比如sshd.service）。如果没有指定扩展名，systemctl 默认把扩展名当作.service。</p>
</blockquote>
<blockquote>
<p>  systemctl start named.service		启动named服务</p>
<p>  systemctl status named.service		查看named服务当前状态</p>
<p>  systemctl stop named.service		停止named服务</p>
<p>  systemctl restart named.service		重新启动named服务</p>
<p>  systemctl reload named.service		重新加载named服务配置文件</p>
<p>  systemctl enable named.service		设置named服务开机自动启动</p>
<p>  systemctl is-enabled named.service enabled		查询named服务是否开机自动启动</p>
<p>  systemctl disable named.service		停止named服务开机自动启动</p>
<p>  systemctl list-units –type&#x3D;service		查看所有已启动的服务</p>
</blockquote>
]]></content>
      <categories>
        <category>linux &amp;&amp; 服务器</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>前端</title>
    <url>/2022/08/15/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title="*"></a>*</h3><h4 id="HTML和CSS之间的区别"><a href="#HTML和CSS之间的区别" class="headerlink" title="HTML和CSS之间的区别"></a>HTML和CSS之间的区别</h4><ol>
<li>性质不同</li>
</ol>
<p>HTML是描述网页内容和结构的基本标记语言。而，CSS是HTML的扩展，它修改了网页的设计和显示。</p>
<p>HTML是网页的结构，CSS是网页的样式。例如如果把整个网页比喻成一个人，那么HTML就是骨头，CSS就是衣服。</p>
<ol start="2">
<li>语法不同</li>
</ol>
<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/1621330138713106.jpg" alt="1.jpg"></p>
<p>CSS声明位于大括号内，并且每个声明均由两部分组成：属性及其值，用冒号分隔。可以在一个声明中定义多个属性，每个属性之间用分号分隔。<strong>选择器：指示要设置样式的HTML元素。</strong></p>
<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/1621330407352175.jpg" alt="2.jpg"></p>
<ol start="3">
<li>注释的格式不同</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML注释风格：<span class="comment">&lt;!-- 注释内容 --&gt;</span>      CSS注释风格：/*注释内容*/</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>HTML文件可以包含CSS代码，而CSS样式表绝对不能包含HTML代码。</p>
<p>即CSS可以在HTML文件中使用，但HTML不能在CSS样式表中使用。</p>
</li>
</ol>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><p>Javascript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言。使用它的目的是与HTML超文本标记语言、Java脚本语言(Java小程序)一起实现在一个Web页面中链接多个对象，与Web客户交互作用。例如可以设置鼠标悬停效果，在客户端验证表单，创建定制的HTML页面，显示警告框，设置cookie等等。</p>
<p>function jsHello{ alert(‘Hello World!’); }</p>
<p>把代码嵌入HTML语言中，它会在加载时弹出一个“Hello World”对话框。</p>
<ul>
<li>HTML，裸体</li>
<li>CSS，好看</li>
<li>JavaScript，动态。<ul>
<li>编程语言</li>
<li>类库（模块）【jQuery是javaScript的类库】</li>
</ul>
</li>
</ul>
<h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><p>jQuery是一个快速、简洁的JavaScript框架,是继Prototype之后又一个优秀的JavaScript代码库(或JavaScript框架)。jQuery设计的宗旨是“write Less,Do More”,即倡导写更少的代码,做更多的事情。它封装JavaScript常用的功能代码,提供一种简便的JavaScript设计模式,优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>
<h4 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h4><p>Bootstrap是一个免费的前端框架，并且是基于html和JavaScript、css三者开发的框架，主要用于响应式网站上的结构和布局，Bootstrap的出现主要是简化Web工作者的工作，其中还包括对JavaScript中的动态调整。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="浏览器标题"><a href="#浏览器标题" class="headerlink" title="浏览器标题"></a>浏览器标题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的联通<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="页面内容标题"><a href="#页面内容标题" class="headerlink" title="页面内容标题"></a>页面内容标题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 默认块级标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>3级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h4</span>&gt;</span>4级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h5</span>&gt;</span>5级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h6</span>&gt;</span>6级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div，一个人占一整行。【块级标签】    </span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>山东蓝翔<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>挖掘机哪家强<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在两行 --&gt;</span></span><br><span class="line"></span><br><span class="line">span，自己多大占多少。【内联标签】    </span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span>&gt;</span>山东蓝翔<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>挖掘机哪家强<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在同一行 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前页面打开 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.chinaunicom.com.cn/about/about.html&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳转到自己网站其他的地址 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://127.0.0.1:5000/get/news&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/get/news&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当前页面打开 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/get/news&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 新页面打开 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/get/news&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 直接显示别人的图片地址（防盗链）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://pic4.zhimg.com/v2-b23f984c2aeaa7bed12e890b4338d499_720w.jpg&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 显示自己的图片：- 自己项目中创建：static目录，图片要放在static --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/wbq.png&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 关于设置图片的高度和宽度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100px; width:200px;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:10%; width:20%;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 划分 - 块级标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 行内标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国电信<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>中国电信<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220816223409760.png" alt="image-20220816223409760"></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span>  <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span>   <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span>  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>10<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>武沛齐<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span>   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>吴阳军<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span>   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>12<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>刘东<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>13<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>郭智<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>14<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>电摩<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220816223936179.png" alt="image-20220816223936179"></p>
<h4 id="input系列"><a href="#input系列" class="headerlink" title="input系列"></a>input系列</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span>&gt;</span>男 <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span>&gt;</span>女</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>篮球 <span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>乒乓球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>棒球</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span> --&gt;普通的按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span> --&gt;提交表单</span><br></pre></td></tr></table></figure>



<h4 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220816224753826.png" alt="image-20220816224753826"></p>
<h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h4><p>页面上的数据，想要提交到后台的条件:</p>
<ol>
<li>form标签包裹要提交的数据的标签。</li>
</ol>
<ul>
<li>提交方式：<code>method=&quot;get&quot;</code></li>
<li>提交的地址：<code>action=&quot;/xxx/xxx/xx&quot;</code></li>
</ul>
<ol>
<li>在form标签里面必须有一个submit标签。</li>
<li>在form里面的一些标签：input&#x2F;select&#x2F;textarea 一定要写name属性</li>
</ol>
<ul>
<li><code>&lt;input type=&quot;text&quot; name=&quot;uu&quot;/&gt; </code></li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="CSS应用方式-3种"><a href="#CSS应用方式-3种" class="headerlink" title="CSS应用方式(3种)"></a>CSS应用方式(3种)</h4><ol>
<li>在标签上</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100px&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在head标签中写style标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>写到文件中</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在flask项目中的static中创建common.css */</span></span><br><span class="line"><span class="selector-class">.c1</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c2</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;common.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&#x27;c2&#x27;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&#x27;c2&#x27;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul>
<li><p>ID选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#c1</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&#x27;c1&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器（最多）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> clss=&#x27;c1&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;xxx&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;text&#x27;</span>]</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v1</span><span class="selector-attr">[xx=<span class="string">&quot;456&quot;</span>]</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">xx</span>=<span class="string">&quot;123&quot;</span>&gt;</span>s<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">xx</span>=<span class="string">&quot;456&quot;</span>&gt;</span>f<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">xx</span>=<span class="string">&quot;999&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后代选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.yy</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.yy</span> &gt; <span class="selector-tag">a</span>&#123;  <span class="comment">/* 不加&gt;s是子子孙孙 加&gt;只对儿子起作用 */</span></span><br><span class="line">    <span class="attribute">color</span>: dodgerblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;yy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>韩国<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>关于选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">多：类选择器、标签选择器、后代选择器</span><br><span class="line">少：属性选择器、ID选择器</span><br></pre></td></tr></table></figure>



<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="高度和宽度"><a href="#高度和宽度" class="headerlink" title="高度和宽度"></a>高度和宽度</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>宽度，支持百分比。</li>
<li>设置高度和宽度对行内标签,如<code>&lt;span&gt;</code>默认无效</li>
<li>对块级标签默认有效（但div霸道，即使右侧区域空白，也不给其他标签占用）</li>
</ul>
<h4 id="块级和行内标签"><a href="#块级和行内标签" class="headerlink" title="块级和行内标签"></a>块级和行内标签</h4><ul>
<li>块级</li>
<li>行内</li>
<li>css样式：标签 -&gt; <code>display:inline-block</code></li>
</ul>
<p>示例：行内&amp;块级特性【能应用长度高度，又没有那么霸道】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>联通<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>联通<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>联通<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h4><ul>
<li>颜色</li>
<li>大小</li>
<li>加粗 <code>font-weight</code></li>
<li>字体格式 <code>font-family</code></li>
<li>对齐方式 <code>text-align: center</code> ,<code>line-height: 58px</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#00FF7F</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">58px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: Microsoft Yahei;</span></span><br><span class="line"><span class="language-css">          	<span class="attribute">text-align</span>: center; <span class="comment">/* 水平方向居中 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">58px</span>; <span class="comment">/* 垂直方向居中 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>中国移动<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;float: right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>div默认块级标签（霸道），如果浮动起来，就不霸道了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">280px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">170px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      	<span class="comment">&lt;!-- 这三个div可以水平相连 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你让标签浮动起来之后，就会脱离文档流。</p>
<p>这时候我们可以用<code>style=&quot;clear: both;&quot;</code>将它拽回来。不加clear的话 你好就与几个div同一行了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">280px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">170px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: dodgerblue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h4><h5 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 padding</h5><ul>
<li>内边距会把容器撑大 比如加内边距前div大小为 202 * 202 ，加后242 * 242</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">          	<span class="comment">/* 等价于 padding: 20px */</span></span></span><br><span class="line"><span class="language-css">          	<span class="comment">/* padding: 20px 10px 5px 20px; 上 右 下 左 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-right</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: gold;&quot;</span>&gt;</span>听妈妈的话<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            小朋友你是否下水道发</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距 margin"></a>外边距 margin</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 200px;background-color: dodgerblue;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red;height: 100px;margin-top: 20px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>body标签，默认有一个边距，造成页面四边都有白色间隙，如何去除呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内容居中</p>
<ul>
<li><p>文本居中，文本会在这个区域中居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; text-align: center;&quot;</span>&gt;</span>武沛齐<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>区域居中，自己要有宽度 + <code>margin-left:auto;margin-right:auto</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 980px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	adfasdf</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>a标签是行内标签，行内标签的高度、内外边距，默认无效。</p>
</li>
<li><p>文本和图片的垂直方向居中</p>
<ul>
<li>本文 + line-height</li>
<li>图片 + 边距</li>
</ul>
</li>
<li><p>a标签默认有下划线。 <code>a.&#123;text-decoration: none;&#125;</code></p>
</li>
<li><p>鼠标放上去之后hover 【在header中<code>&lt;style&gt;</code>】</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>设置透明度 <code>opacity:0.5;    /* 0 ~ 1 */</code></li>
</ul>
<h4 id="CSS补充"><a href="#CSS补充" class="headerlink" title="CSS补充"></a>CSS补充</h4><h5 id="hover"><a href="#hover" class="headerlink" title="hover"></a>hover</h5><ul>
<li>注意download以及display选项</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">18px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c2</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.download</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.app</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.download</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.app</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.title</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>联通<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>广西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>下载APP<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;download&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/qcode.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="after"><a href="#after" class="headerlink" title="after"></a>after</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&quot;大帅哥&quot;</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>AA<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输出： A大帅哥 AA大帅哥</li>
</ul>
<h5 id="position"><a href="#position" class="headerlink" title="position"></a>position</h5><ul>
<li>fixed 固定在窗口的某个位置</li>
</ul>
<h6 id="案例：返回顶部（back永远在窗口的一个位置）"><a href="#案例：返回顶部（back永远在窗口的一个位置）" class="headerlink" title="案例：返回顶部（back永远在窗口的一个位置）"></a>案例：返回顶部（back永远在窗口的一个位置）</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.back</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">bottom</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 1000px;background-color: #5f5750&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="案例：对话框"><a href="#案例：对话框" class="headerlink" title="案例：对话框"></a>案例：对话框</h6><ul>
<li>z-index 谁的z-index大谁就在上面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dialog</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.mask</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">999</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 1000px&quot;</span>&gt;</span>asdfasdfasd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="relative与absolute（一般成对出现）"><a href="#relative与absolute（一般成对出现）" class="headerlink" title="relative与absolute（一般成对出现）"></a>relative与absolute（一般成对出现）</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">59px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">59px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#00FF7F</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="border"><a href="#border" class="headerlink" title="border"></a>border</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-left</span>: <span class="number">3px</span> solid <span class="number">#00FF7F</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#5f5750</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="BootStrap-1"><a href="#BootStrap-1" class="headerlink" title="BootStrap"></a>BootStrap</h3><p>是别人帮我们已写好的CSS样式，我们如果想要使用这个BootStrap：</p>
<ul>
<li>下载BootStrap 并解压<code>bootstrap-3.4.1-dist</code></li>
<li>使用时<ul>
<li>在页面上引入BootStrap</li>
<li>编写HTML时，按照BootStrap的规定来编写 + 自定制。</li>
</ul>
</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>将bootstrap拷贝到static&#x2F;plugins&#x2F;下</li>
</ol>
<img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220817220458315.png" alt="image-20220817220458315" style="zoom:50%;">

<ol start="2">
<li>在<code>&lt;head&gt;</code>标签中引入bootstrap</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  bootstrap.min.css一样的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/plugins/bootstrap-3.4.1-dist/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>class</code>标签中使用</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/plugins/bootstrap-3.4.1-dist/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-primary&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-danger&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-group-xs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-success&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220817222200378.png" alt="image-20220817222200378"></p>
<h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p><a href="https://v3.bootcss.com/components/">https://v3.bootcss.com/components/</a></p>
<h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p><a href="https://v3.bootcss.com/css/#grid">https://v3.bootcss.com/css/#grid</a></p>
<ul>
<li><p>把整体划分为了12格</p>
</li>
<li><p>分类</p>
<ul>
<li><p>响应式，根据屏幕宽度不同</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.col-lg-   <span class="comment">&lt;!-- 1-12 页面宽度大于1170px则左右堆放变为上下堆放 --&gt;</span></span><br><span class="line">.col-md-   <span class="comment">&lt;!-- 页面宽度大于970px才生效 --&gt;</span></span><br><span class="line">.col-sm-   <span class="comment">&lt;!-- 页面宽度大于750px才生效 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非响应式（总是水平排列）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-6&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-6&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: green&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列偏移（不用在左边填充div了）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;static/plugins/bootstrap-3.4.1/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-offset-2 col-sm-6&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: green&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span> <span class="comment">&lt;!-- 平铺 左右居中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-9&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-3&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span> <span class="comment">&lt;!-- 清除浮动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-9&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-3&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span> <span class="comment">&lt;!-- 默认宽度=1170px 左右居中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-9&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-3&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p><a href="https://v3.bootcss.com/components/">https://v3.bootcss.com/components/</a></p>
<h4 id="案例：登录"><a href="#案例：登录" class="headerlink" title="案例：登录"></a>案例：登录</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/plugins/bootstrap-3.4.1-dist/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid snow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-right</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">5px</span>  <span class="number">10px</span> <span class="number">#aaa</span>;	<span class="comment">/* x轴 y轴 模糊度 颜色 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;exampleInputEmail1&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exampleInputEmail1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Email&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;exampleInputPassword1&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exampleInputPassword1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default &quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220818023655235.png" alt="image-20220818023655235" style="zoom:67%;">

<h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><ul>
<li><p>bootstrap提供，不多。</p>
</li>
<li><p>fontawesome组件: <a href="https://fontawesome.dashgame.com/">https://fontawesome.dashgame.com/</a></p>
<ul>
<li><p>下载</p>
</li>
<li><p>引入（将文件夹拖入static&#x2F;）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attribute">href</span>=<span class="string">&quot;../static/plugins/font-awesome-4.7.0/css/font-awesome.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20211120173023121.png" alt="image-20211120173023121"></p>
</li>
</ul>
</li>
</ul>
<h4 id="BootStrap依赖"><a href="#BootStrap依赖" class="headerlink" title="BootStrap依赖"></a>BootStrap依赖</h4><p>（引入js才能发挥出BootStrap的动态效果）</p>
<p>1.将js文件拷贝至项目&#x2F;static&#x2F;js&#x2F;目录下</p>
<p>2.在<code>&lt;body&gt;</code>标签中写下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../static/js/jquery-3.6.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../static/plugins/bootstrap-3.4.1-dist/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一门编程语言。</p>
<p>JavaScript的意义是什么？- 让程序实现一些动态效果</p>
<ul>
<li>新建项目javascript01</li>
</ul>
<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220818134123235.png" alt="image-20220818134123235"></p>
<h4 id="javascript应用方式（两种）"><a href="#javascript应用方式（两种）" class="headerlink" title="javascript应用方式（两种）"></a>javascript应用方式（两种）</h4><ol>
<li>当前HTML中。<code>&lt;head&gt;</code>标签中或者<code>&lt;body&gt;</code>标签中【推荐】都行</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 编写JavaScript代码</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在其他js文件中，导入使用。</li>
</ol>
<p><img src="/2022/08/15/%E5%89%8D%E7%AB%AF/image-20220818134619449.png" alt="image-20220818134619449"></p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li><p>HTML的注释</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS的注释，放在<code>style代码块</code>里</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注释内容 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript的注释，放在<code>script代码块</code>里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注释内容 */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>Python，编程语言。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;高倩&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript，编程语言。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> name = <span class="string">&quot;高倩&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//输出至控制台，浏览器右键-&gt;检查-&gt;console	</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;高倩&quot;</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="title class_">String</span>(<span class="string">&quot;高倩&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见功能</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;中国联通&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = name.<span class="property">length</span>; </span><br><span class="line"><span class="keyword">var</span> v2 = name[<span class="number">0</span>];   <span class="comment">// name.charAt(3)</span></span><br><span class="line"><span class="keyword">var</span> v3 = name.<span class="title function_">trim</span>(); <span class="comment">//去除空白，得到新的字符串</span></span><br><span class="line"><span class="keyword">var</span> v4 = name.<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 前取后不取</span></span><br></pre></td></tr></table></figure>



<h4 id="案例：跑马灯"><a href="#案例：跑马灯" class="headerlink" title="案例：跑马灯"></a>案例：跑马灯</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>欢迎中国联通领导高倩莅临指导<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1.去HTML中找到某个标签并获取他的内容（DOM）</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txt&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> dataString = tag.<span class="property">innerText</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2.动态起来，把文本中的第一个字符放在字符串的最后面。</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> firstChar = dataString[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> otherString = dataString.<span class="title function_">substring</span>(<span class="number">1</span>, dataString.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> newText = otherString + firstChar;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3.在HTML标签中更新内容</span></span></span><br><span class="line"><span class="language-javascript">        tag.<span class="property">innerText</span> = newText;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// JavaScript中的定时器，如：每1s执行一次show函数。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(show, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">var</span> v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>];</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="title class_">Array</span>([<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1[1]</span></span><br><span class="line">v1[<span class="number">0</span>] = <span class="string">&quot;高倩&quot;</span>;</span><br><span class="line"></span><br><span class="line">v1.<span class="title function_">push</span>(<span class="string">&quot;联通&quot;</span>);        <span class="comment">// 尾部追加 [11,22,33,44,&quot;联通&quot;]</span></span><br><span class="line">v1.<span class="title function_">unshift</span>(<span class="string">&quot;联通&quot;</span>);     <span class="comment">// 头部追加 [&quot;联通&quot;, 11,22,33,44]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v1.splice(索引位置,0,元素);</span></span><br><span class="line">v1.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;中国&quot;</span>);  <span class="comment">// 尾部追加 [11,&quot;中国&quot;,22,33,44]</span></span><br><span class="line"></span><br><span class="line">v1.<span class="title function_">pop</span>()     <span class="comment">//尾部删除</span></span><br><span class="line">v1.<span class="title function_">shift</span>()   <span class="comment">//头部删除</span></span><br><span class="line"><span class="comment">// v1.splice(索引位置,1)  1为固定写法</span></span><br><span class="line">v1.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>);  <span class="comment">// 索引为2的元素删除 [11,22,44];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里循环的其实是索引</span></span><br><span class="line"><span class="keyword">var</span> v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> v1)&#123;</span><br><span class="line">    <span class="comment">// idx=0/1/2/3/    data=v1[idx]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;v1.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// i=0/1/2/3   data=v1[idx]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="案例：动态数据"><a href="#案例：动态数据" class="headerlink" title="案例：动态数据"></a>案例：动态数据</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;li&gt;北京&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送网络请求，获取数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cityList = [<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> cityList)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> text = cityList[idx];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建 &lt;li&gt;&lt;/li&gt;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在li标签中写入内容</span></span></span><br><span class="line"><span class="language-javascript">            tag.<span class="property">innerText</span> = text;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 添加到id=city那个标签的里面。DOM</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> parentTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            parentTag.<span class="title function_">appendChild</span>(tag);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="对象【即python中的字典】"><a href="#对象【即python中的字典】" class="headerlink" title="对象【即python中的字典】"></a>对象【即python中的字典】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info = &#123; <span class="comment">// python中的写法 js中可以这么写</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;高倩&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info = &#123; <span class="comment">//js也可以这么写</span></span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;高倩&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info.<span class="property">age</span></span><br><span class="line">info.<span class="property">name</span> = <span class="string">&quot;郭智&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// info[&quot;age&quot;]</span></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;郭智&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> info[<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;高倩&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> info)&#123;</span><br><span class="line">    <span class="comment">// key=name/age      data=info[key]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="案例：-动态表格"><a href="#案例：-动态表格" class="headerlink" title="案例： 动态表格"></a>案例： 动态表格</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> info = &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;郭智&quot;</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> tr = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> text = info[key];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> td = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;td&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        td.<span class="property">innerText</span> = text;</span></span><br><span class="line"><span class="language-javascript">        tr.<span class="title function_">appendChild</span>(td);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> bodyTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;body&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    bodyTag.<span class="title function_">appendChild</span>(tr);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 )  &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>



<h4 id="DOM【不用记，后期用jQuery】"><a href="#DOM【不用记，后期用jQuery】" class="headerlink" title="*DOM【不用记，后期用jQuery】"></a>*DOM【不用记，后期用jQuery】</h4><p>DOM，就是一个模块，模块可以对HTML页面中的标签进行操作。</p>
<ol>
<li>获取HTML内容</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据ID获取标签</span></span><br><span class="line"><span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取标签中的文本</span></span><br><span class="line">tag.<span class="property">innerText</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改标签中的文本</span></span><br><span class="line">tag.<span class="property">innerText</span> = <span class="string">&quot;哈哈哈哈哈&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建标签 &lt;div&gt;哈哈哈哈哈&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签写内容</span></span><br><span class="line">tag.<span class="property">innerText</span> = <span class="string">&quot;哈哈哈哈哈&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &lt;li&gt;北京&lt;/li&gt;</span></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> newTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    newTag.<span class="property">innerText</span> = <span class="string">&quot;北京&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    tag.<span class="title function_">appendChild</span>(newTag);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>事件的绑定</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击添加&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;addCityInfo()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">addCityInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> newTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        newTag.<span class="property">innerText</span> = <span class="string">&quot;联通&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> parentTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        parentTag.<span class="title function_">appendChild</span>(newTag);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将用户输入的值动态填充入城市列表 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入内容&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtUser&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击添加&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;addCityInfo()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">addCityInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1.找到输入标签</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> txtTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtUser&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2.获取input框中用户输入的内容</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> newString = txtTag.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 判断用户输入是否为空，只有不为空才能继续。</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (newString.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 3.创建标签 &lt;li&gt;&lt;/li&gt; 中间的文本信息就是用户输入的内容</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> newTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            newTag.<span class="property">innerText</span> = newString;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 4.标签添加到ul中</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> parentTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            parentTag.<span class="title function_">appendChild</span>(newTag);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 3.将input框内容清空</span></span></span><br><span class="line"><span class="language-javascript">            txtTag.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;输入不能为空&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实际开发中很少手写DOM操作，而是用一个封装了DOM的类库——jquery来实现【企业中更高级的框架还有vue.js和react.js】</li>
</ul>
<h3 id="j-Q-u-e-r-y"><a href="#j-Q-u-e-r-y" class="headerlink" title="j Q u e r y"></a>j Q u e r y</h3><h4 id="应用-j-Q-u-e-r-y"><a href="#应用-j-Q-u-e-r-y" class="headerlink" title="应用 j Q u e r y"></a>应用 j Q u e r y</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 利用jQuery中的功能实现某些效果</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#txt&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;广西移动&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="j-Q-u-e-r-y-选择器"><a href="#j-Q-u-e-r-y-选择器" class="headerlink" title="j Q u e r y 选择器"></a>j Q u e r y 选择器</h4><h5 id="直接寻找"><a href="#直接寻找" class="headerlink" title="直接寻找"></a>直接寻找</h5><ul>
<li><p>ID选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#txt&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>中国联通3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.c1&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>中国联通3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;h1&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>层级选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>中国联通3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.c1 .c2 a&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>中国联通1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>中国联通3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c3,#c2,li&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;n2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input[name=&#x27;n1&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="间接寻找"><a href="#间接寻找" class="headerlink" title="间接寻找"></a>间接寻找</h5><ul>
<li><p>找到兄弟</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">prev</span>()        <span class="comment">// 上一个</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>)</span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">next</span>()        <span class="comment">// 下一个</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">next</span>().<span class="title function_">next</span>() <span class="comment">// 下一个、下一个</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">siblings</span>()    <span class="comment">// 所有的系统</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找父子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">div</span>&gt;</span>青浦区<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p10&quot;</span>&gt;</span>宝山区<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">div</span>&gt;</span>浦东新区<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>陕西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>山西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">parent</span>()            <span class="comment">// 父亲</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">parent</span>().<span class="title function_">parent</span>()   <span class="comment">// 父亲、父亲</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">children</span>()                <span class="comment">// 所有的儿子</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">children</span>(<span class="string">&quot;.p10&quot;</span>)          <span class="comment">// 所有的儿子中寻找class=p10</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">find</span>(<span class="string">&quot;.p10&quot;</span>)              <span class="comment">// 去所有子孙中寻找class=p10</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">find</span>(<span class="string">&quot;div&quot;</span>)              <span class="comment">// 去所有子孙中寻找div标签</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例：菜单的切换【重要】"><a href="#案例：菜单的切换【重要】" class="headerlink" title="案例：菜单的切换【重要】"></a>案例：菜单的切换【重要】</h4><ul>
<li>版本1：一开始隐藏，点击一下显示菜单栏，但收不回去</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menus</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menus</span> <span class="selector-class">.header</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted <span class="number">#dddddd</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menus</span> <span class="selector-class">.content</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted <span class="number">#dddddd</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.hide</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menus&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;clickMe(this);&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content hide&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>宝山区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>青浦区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>浦东新区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>普陀区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;clickMe(this);&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content hide&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>海淀区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>朝阳区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>大兴区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>昌平区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">clickMe</span>(<span class="params">self</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// $(self)  -&gt; 表示当前点击的那个标签。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// $(self).next() 下一个标签</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// $(self).next().removeClass(&quot;hide&quot;);   删除样式</span></span></span><br><span class="line"><span class="language-javascript">            $(self).<span class="title function_">next</span>().<span class="title function_">removeClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>版本2 ，其余不变，但再次点击能够收回</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">clickMe</span>(<span class="params">self</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hasHide = $(self).<span class="title function_">next</span>().<span class="title function_">hasClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(hasHide)&#123;</span></span><br><span class="line"><span class="language-javascript">            $(self).<span class="title function_">next</span>().<span class="title function_">removeClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            $(self).<span class="title function_">next</span>().<span class="title function_">addClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>版本3 ，点击其中一栏，其他栏如果已经展开的话，要收回。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   	<span class="keyword">function</span> <span class="title function_">clickMe</span>(<span class="params">self</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       	<span class="comment">// 让自己下面的功能展示出来</span></span></span><br><span class="line"><span class="language-javascript">       	$(self).<span class="title function_">next</span>().<span class="title function_">removeClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       	<span class="comment">// 找父亲，父亲的所有兄弟，再去每个兄弟的子孙中寻找 class=content，添加hide样式</span></span></span><br><span class="line"><span class="language-javascript">       	$(self).<span class="title function_">parent</span>().<span class="title function_">siblings</span>().<span class="title function_">find</span>(<span class="string">&quot;.content&quot;</span>).<span class="title function_">addClass</span>(<span class="string">&quot;hide&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   	&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><ul>
<li>addClass</li>
<li>removeClass</li>
<li>hasClass</li>
</ul>
<h4 id="值的操作"><a href="#值的操作" class="headerlink" title="值的操作"></a>值的操作</h4><ul>
<li>获取已经存在的内容用<code>.text</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">text</span>()        <span class="comment">// 获取文本内容</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;休息&quot;</span>)   <span class="comment">// 设置文本内容</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取用户输入的内容用<code>.val</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;c2&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c2&quot;</span>).<span class="title function_">val</span>()            <span class="comment">// 获取用户输入的值</span></span><br><span class="line">$(<span class="string">&quot;#c2&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;哈哈哈&quot;</span>)     <span class="comment">// 设置值</span></span><br></pre></td></tr></table></figure>



<h4 id="案例：动态创建数据"><a href="#案例：动态创建数据" class="headerlink" title="案例：动态创建数据"></a>案例：动态创建数据</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtUser&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtEmail&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;邮箱&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getInfo()&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../static/js/jquery-3.6.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1.获取用户输入的用户名和密码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> username = $(<span class="string">&quot;#txtUser&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> email = $(<span class="string">&quot;#txtEmail&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> dataString = username + <span class="string">&quot; - &quot;</span> + email;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2.创建li标签，在li的内部写入内容。 $(&quot;&lt;li&gt;&quot;)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> newLi = $(<span class="string">&quot;&lt;li&gt;&quot;</span>).<span class="title function_">text</span>(dataString);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3.把新创建的li标签添加到ul里面。</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#view&quot;</span>).<span class="title function_">append</span>(newLi);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><ul>
<li>原生javascript</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getInfo()&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>搜狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;li&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 点击li标签时，自动执行这个函数；</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// $(this)  当前你点击的是那个标签。</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>搜狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;li&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> text = $(<span class="variable language_">this</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;c1&#x27;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>搜狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 当页面的框架加载完成之后，自动就执行。</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;li&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="variable language_">this</span>).<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="前端整合"><a href="#前端整合" class="headerlink" title="前端整合"></a>前端整合</h3><ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript、jQuery【JavaScript方便版】</li>
<li>BootStrap（动态效果依赖jQuery）</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣精选TOP面试题</title>
    <url>/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">二分</a>: O(lg(m + n))</p>
</li>
<li><p>合并 O(m + n)</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">merge</span>(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> a = nums1.<span class="built_in">size</span>(), b = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx1 = (a + b)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> idx2 = (a + b) % <span class="number">2</span> ? idx1 : idx1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)(res[idx1] + res[idx2])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;<span class="comment">//一个新数组用来存储排序好的数组</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//两个变量分别指向左边和右边两组数的第一个数</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; b[j]) s.<span class="built_in">push_back</span>(a[i++]);</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">push_back</span>(b[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>()) s.<span class="built_in">push_back</span>(a[i++]);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; b.<span class="built_in">size</span>())  s.<span class="built_in">push_back</span>(b[j++]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h3><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<p> <strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   <span class="string">-42</span>&quot;</span><br><span class="line">输出：<span class="string">-42</span></span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   <span class="string">-42</span>&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   <span class="string">-42</span>&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   <span class="string">-42</span>&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 <span class="string">-42</span> 。</span><br><span class="line">由于 &quot;<span class="string">-42</span>&quot; 在范围 [<span class="string">-231</span>, 231 - 1] 内，最终结果为 <span class="string">-42</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为这里不存在 <span class="string">&#x27;-&#x27;</span> 或者 <span class="string">&#x27;+&#x27;</span>）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;4193 with words&quot;</span>（读入 <span class="string">&quot;4193&quot;</span>；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 <span class="number">4193</span> 。</span><br><span class="line">由于 <span class="string">&quot;4193&quot;</span> 在范围 [<span class="number">-231</span>, <span class="number">231</span> - <span class="number">1</span>] 内，最终结果为 <span class="number">4193</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230202171319925.png" alt="image-20230202171319925" style="zoom: 25%;">

<img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230202171443648.png" alt="image-20230202171443648" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span>&#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    map&lt;string, vector&lt;string&gt;&gt; mp&#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>,&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCol</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isspace</span>(ch)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// &#x27; &#x27; 是start状态</span></span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// &#x27;+ / -&#x27; 是signed状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch)) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//  &#x27;数字&#x27; 是in_number状态</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        state = mp[state][<span class="built_in">getCol</span>(ch)];</span><br><span class="line">        <span class="keyword">if</span>(state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res = sign == <span class="number">1</span> ? <span class="built_in">min</span>(res, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(res, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&quot;signed&quot;</span>) sign = ch == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&quot;end&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s)</span><br><span class="line">            automaton.<span class="built_in">get</span>(ch);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aa&quot;</span>, <span class="attr">p</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aa&quot;</span>, p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab&quot;</span>, p = <span class="string">&quot;.*&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="string">&#x27;*&#x27;</span>）任意字符（<span class="string">&#x27;.&#x27;</span>）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>
</ul>
<h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>)); </span><br><span class="line">        <span class="comment">// dp[i][j]表示 s[0..i - 1]是否能被 p[0..j - 1]覆盖</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">islower</span>(p[j - <span class="number">1</span>]) || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">// p[j] == &#x27;*&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j - <span class="number">1</span>)) </span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>]; <span class="comment">//字母* 用上or (字母*) 没用上</span></span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>]; <span class="comment">// (字母*) 用不上</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br><span class="line">解释：最小覆盖子串 <span class="string">&quot;BANC&quot;</span> 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入<span class="symbol">:</span> s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">t</span> 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == s.length</code></li>
<li><code>n == t.length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p> <strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？</p>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; ms, mt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: t) </span><br><span class="line">            mt[e] ++;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 对t的元素的已经完成的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>, l = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); r ++ ) &#123;</span><br><span class="line">            ms[s[r]] ++ ;</span><br><span class="line">            <span class="keyword">if</span> (ms[s[r]] &lt;= mt[s[r]]) cnt ++ ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (ms[s[l]] &gt; mt[s[l]]) ms[s[l ++ ]] -- ;</span><br><span class="line">            <span class="keyword">if</span>(cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || r - l + <span class="number">1</span> &lt; res.<span class="built_in">size</span>())</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(l, r - l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 ：</strong></p>
<p><img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/tree1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="comment">[3,9,20,null,null,15,7]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[3]</span>,<span class="comment">[20,9]</span>,<span class="comment">[15,7]</span>]</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">bool</span> isLeftToRight = <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; levelList;</span><br><span class="line">            <span class="keyword">while</span>(n -- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                isLeftToRight ? levelList.<span class="built_in">push_back</span>(t -&gt; val) : levelList.<span class="built_in">push_front</span>(t -&gt; val);</span><br><span class="line">                <span class="keyword">if</span>(t -&gt; left) q.<span class="built_in">push</span>(t -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(t -&gt; right) q.<span class="built_in">push</span>(t -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            isLeftToRight = !isLeftToRight;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;levelList.<span class="built_in">begin</span>(), levelList.<span class="built_in">end</span>()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">tokens</span> = [<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：tokens = [<span class="string">&quot;10&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-11&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;+&quot;</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">stoi</span>(tokens[<span class="number">0</span>]);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stkNum;</span><br><span class="line">        stack&lt;string&gt; stkOperator;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; tokens.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(stkOperator.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) stkOperator.<span class="built_in">emplace</span>(tokens[i++]);</span><br><span class="line">                <span class="keyword">else</span> stkNum.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(tokens[i++]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> op = stkOperator.<span class="built_in">top</span>();</span><br><span class="line">            stkOperator.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> b = stkNum.<span class="built_in">top</span>();</span><br><span class="line">            stkNum.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> a = stkNum.<span class="built_in">top</span>();</span><br><span class="line">            stkNum.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&quot;+&quot;</span>) c = a + b;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&quot;-&quot;</span>) c = a - b;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&quot;*&quot;</span>) c = a * b;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&quot;/&quot;</span>) c = a / b;</span><br><span class="line">            stkNum.<span class="built_in">emplace</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stkNum.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h3><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">&quot;210&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3,30,34,5</span>,<span class="number">9</span>]</span><br><span class="line">输出：&quot;<span class="number">9534330</span>&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        string sa = <span class="built_in">to_string</span>(a), sb = <span class="built_in">to_string</span>(b);</span><br><span class="line">        <span class="keyword">return</span> sa + sb &gt; sb + sa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: nums)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">向右轮转 1 步</span><span class="punctuation">:</span> <span class="string">[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="attribute">向右轮转 2 步</span><span class="punctuation">:</span> <span class="string">[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="attribute">向右轮转 3 步</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,<span class="string">-100</span>,3,99], k = 2</span><br><span class="line">输出：[3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,<span class="string">-1</span>,<span class="string">-100</span>,3]</span><br><span class="line">向右轮转 2 步: [3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            temp[(i + k) % nums.<span class="built_in">size</span>()] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">assign</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a></h3><p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于<span class="number"> 10 </span>的质数一共有<span class="number"> 4 </span>个, 它们是 2, 3, 5,<span class="number"> 7 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 5 * 106</code></li>
</ul>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// 质数则为1</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123; <span class="comment">// 统计所有&lt;n的质数数量</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123; <span class="comment">// 若i为质数</span></span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &lt; n) &#123; <span class="comment">// 从i*i开始标记i的倍数为合数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-231, 231 - 1]</code> 的范围内。</p>
<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li>
<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li>
<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
<h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">char</span> preSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; !<span class="built_in">isspace</span>(s[i])) || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">back</span>() *= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        stk.<span class="built_in">back</span>() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><ul>
<li>multiset 可重复set,内部用红黑树实现,可排序 begin()最小, rbegin()最大</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = l + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line">            pq.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        res.<span class="built_in">push_back</span>(*pq.<span class="built_in">rbegin</span>());</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">            pq.<span class="built_in">insert</span>(nums[++r]);</span><br><span class="line">            <span class="keyword">auto</span> it = pq.<span class="built_in">find</span>(nums[l++]);</span><br><span class="line">            pq.<span class="built_in">erase</span>(it);</span><br><span class="line">            res.<span class="built_in">push_back</span>(*pq.<span class="built_in">rbegin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230206204159315.png" alt="image-20230206204159315" style="zoom:50%;"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h3><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/searchgrid2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,4,7,11,15]</span>,<span class="comment">[2,5,8,12,19]</span>,<span class="comment">[3,6,9,16,22]</span>,<span class="comment">[10,13,14,17,24]</span>,<span class="comment">[18,21,23,26,30]</span>]</span>, target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>



<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) i ++;</span><br><span class="line">            <span class="keyword">else</span> j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></h3><p>根据 <a href="https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin">百度百科</a> ， <strong>生命游戏</strong> ，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 <code>m × n</code> 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 <strong>活细胞</strong> （live），或 <code>0</code> 即为 <strong>死细胞</strong> （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p>
<p><strong>示例 ：</strong></p>
<p><img src="/2023/02/02/%E5%8A%9B%E6%89%A3%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/grid1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：board = <span class="comment">[<span class="comment">[0,1,0]</span>,<span class="comment">[0,0,1]</span>,<span class="comment">[1,1,1]</span>,<span class="comment">[0,0,0]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[0,0,0]</span>,<span class="comment">[1,0,1]</span>,<span class="comment">[0,1,1]</span>,<span class="comment">[0,1,0]</span>]</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 25</code></li>
<li><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><ul>
<li>原地算法的话，就用复合状态表示每个位置，再重新遍历赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">temp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                temp[i][j] = <span class="built_in">getState</span>(i, j, board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(temp[i][j])&#123;</span><br><span class="line">                    <span class="built_in">case</span>(<span class="number">1</span>):</span><br><span class="line">                        board[i][j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">case</span>(<span class="number">2</span>):</span><br><span class="line">                        board[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">case</span>(<span class="number">3</span>):</span><br><span class="line">                        board[i][j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">case</span>(<span class="number">4</span>):</span><br><span class="line">                        board[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        board[i][j] = board[i][j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAroundOne</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r + i &lt; <span class="number">0</span> || r + i &gt;= m || c + j &lt; <span class="number">0</span> || c + j &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[r + i][c + j]) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - board[r][c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getState</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getAroundOne</span>(r, c, board) &lt; <span class="number">2</span> &amp;&amp; board[r][c] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 活 -&gt; 死</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">getAroundOne</span>(r, c, board) == <span class="number">2</span> || <span class="built_in">getAroundOne</span>(r, c, board) == <span class="number">3</span>) &amp;&amp; (board[r][c] == <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 活 -&gt; 活</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getAroundOne</span>(r, c, board) &gt; <span class="number">3</span> &amp;&amp; board[r][c] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 活 -&gt; 死</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getAroundOne</span>(r, c, board) == <span class="number">3</span> &amp;&amp; board[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>; <span class="comment">// 死 -&gt; 活</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// 不变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></h3><p>给你一个嵌套的整数列表 <code>nestedList</code> 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>
<p>实现扁平迭代器类 <code>NestedIterator</code> ：</p>
<ul>
<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> 用嵌套列表 <code>nestedList</code> 初始化迭代器。</li>
<li><code>int next()</code> 返回嵌套列表的下一个整数。</li>
<li><code>boolean hasNext()</code> 如果仍然存在待迭代的整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p>你的代码将会用下述伪代码检测：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">initialize <span class="keyword">iterator</span> <span class="keyword">with</span> nestedList</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">iterator</span>.hasNext()</span><br><span class="line">    append <span class="keyword">iterator</span>.<span class="keyword">next</span>() <span class="keyword">to</span> the <span class="keyword">end</span> <span class="keyword">of</span> res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>如果 <code>res</code> 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nestedList = <span class="string">[[1,1],2,[1,1]]</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：通过重复调用 <span class="built_in">next</span> 直到 hasNext 返回 <span class="literal">false</span>，<span class="built_in">next</span> 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nestedList = <span class="comment">[1,<span class="comment">[4,<span class="comment">[6]</span>]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,4,6]</span></span><br><span class="line">解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: <span class="comment">[1,4,6]</span>。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>
<li>嵌套列表中的整数值在范围 <code>[-106, 106]</code> 内</li>
</ul>
<h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedIterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;NestedInteger&gt; &amp;nestedList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : nestedList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.<span class="built_in">isInteger</span>()) all.<span class="built_in">push_back</span>(e.<span class="built_in">getInteger</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">dfs</span>(e.<span class="built_in">getList</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; all;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nestedList);</span><br><span class="line">        itr = all.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(itr++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr &lt; all.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="348-设计井字棋"><a href="#348-设计井字棋" class="headerlink" title="348. 设计井字棋"></a><a href="https://leetcode.cn/problems/design-tic-tac-toe/">348. 设计井字棋</a></h3><p>请在 n × n 的棋盘上，实现一个判定井字棋胜负的神器，判断每一次玩家落子后，是否有胜出的玩家。</p>
<p>在这个井字棋游戏中，会有 2 名玩家，他们将轮流在棋盘上放置自己的棋子。</p>
<p>在实现这个判定器的过程中，你可以假设以下这些规则一定成立：</p>
<ol>
<li><p>每一步棋都是在棋盘内的，并且只能被放置在一个空的格子里；</p>
</li>
<li><p>一旦游戏中有一名玩家胜出的话，游戏将不能再继续；</p>
</li>
<li><p>一个玩家如果在同一行、同一列或者同一斜对角线上都放置了自己的棋子，那么他便获得胜利。</p>
</li>
</ol>
<p><strong>示例:</strong></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">给定棋盘边长 n = 3, 玩家 1 的棋子符号是 <span class="string">&quot;X&quot;</span>，玩家 2 的棋子符号是 <span class="string">&quot;O&quot;</span>。</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; 函数返回 0 (此时，暂时没有玩家赢得这场对决)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">    // 玩家 1 在 (0, 0) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; 函数返回 0 (暂时没有玩家赢得本场比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">    // 玩家 2 在 (0, 2) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; 函数返回 0 (暂时没有玩家赢得比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">    // 玩家 1 在 (2, 2) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">X</span>|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; 函数返回 0 (暂没有玩家赢得比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">O</span>|<span class="string"> </span>|<span class="string">    // 玩家 2 在 (1, 1) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">X</span>|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; 函数返回 0 (暂无玩家赢得比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">O</span>|<span class="string"> </span>|<span class="string">    // 玩家 1 在 (2, 0) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string">X</span>|<span class="string"> </span>|<span class="string">X</span>|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; 函数返回 0 (没有玩家赢得比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string">O</span>|<span class="string">O</span>|<span class="string"> </span>|<span class="string">    // 玩家 2 在 (1, 0) 落子.</span></span><br><span class="line"><span class="string"></span>|<span class="string">X</span>|<span class="string"> </span>|<span class="string">X</span>|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; 函数返回 1 (此时，玩家 1 赢得了该场比赛)</span><br><span class="line">|<span class="string">X</span>|<span class="string"> </span>|<span class="string">O</span>|</span><br><span class="line">|<span class="string">O</span>|<span class="string">O</span>|<span class="string"> </span>|<span class="string">    // 玩家 1 在 (2, 1) 落子。</span></span><br><span class="line"><span class="string"></span>|<span class="string">X</span>|<span class="string">X</span>|<span class="string">X</span>|</span><br></pre></td></tr></table></figure>

<h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicTacToe</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid, Row, Col;</span><br><span class="line">    <span class="type">int</span> mDiagonal,sDiagonal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TicTacToe</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        grid.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        Row.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        Col.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        mDiagonal,sDiagonal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">move</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        Col[row][col] += player == <span class="number">1</span> ? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        Row[col][row] += player == <span class="number">1</span> ? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(row == col) mDiagonal += player == <span class="number">1</span> ? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(row + col == n - <span class="number">1</span>) sDiagonal += player == <span class="number">1</span> ? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">accumulate</span>(Row[col].<span class="built_in">begin</span>(), Row[col].<span class="built_in">end</span>(), <span class="number">0</span>)) == n || </span><br><span class="line">        <span class="built_in">abs</span>(<span class="built_in">accumulate</span>(Col[row].<span class="built_in">begin</span>(), Col[row].<span class="built_in">end</span>(), <span class="number">0</span>)) == n ||</span><br><span class="line">        <span class="built_in">abs</span>(mDiagonal) == n || <span class="built_in">abs</span>(sDiagonal) == n) <span class="keyword">return</span> player;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aaabb&quot;</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长子串为 <span class="string">&quot;aaa&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="number">3</span> 次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ababbc&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长子串为 <span class="string">&quot;ababb&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="number">2</span> 次， &#x27;b&#x27; 重复了 <span class="number">3</span> 次。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
<li><code>1 &lt;= k &lt;= 105</code></li>
</ul>
<h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="built_in">fill</span>(count.<span class="built_in">begin</span>(), count.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// vetor.clear()并不能将所有元素清零，只能让size变为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                count[s[j] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="type">int</span> minK = <span class="number">1e8</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> e : count)&#123; <span class="comment">// minK为此时出现过的次数最少的元素的出现次数</span></span><br><span class="line">                    <span class="keyword">if</span>(!e) <span class="keyword">continue</span>;</span><br><span class="line">                    minK = <span class="built_in">min</span>(minK, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(minK &gt;= k) res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h3><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">-2</span>,<span class="number">-1</span>], <span class="symbol">nums3</span> = [<span class="number">-1</span>,<span class="number">2</span>], <span class="symbol">nums4</span> = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line"><span class="number">1.</span> <span class="comment">(0, 0, 0, 1)</span> -&gt; <span class="symbol">nums1</span>[<span class="number">0</span>] + <span class="symbol">nums2</span>[<span class="number">0</span>] + <span class="symbol">nums3</span>[<span class="number">0</span>] + <span class="symbol">nums4</span>[<span class="number">1</span>] = <span class="number">1</span> + <span class="comment">(-2)</span> + <span class="comment">(-1)</span> + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> <span class="comment">(1, 1, 0, 0)</span> -&gt; <span class="symbol">nums1</span>[<span class="number">1</span>] + <span class="symbol">nums2</span>[<span class="number">1</span>] + <span class="symbol">nums3</span>[<span class="number">0</span>] + <span class="symbol">nums4</span>[<span class="number">0</span>] = <span class="number">2</span> + <span class="comment">(-1)</span> + <span class="comment">(-1)</span> + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">0</span>], <span class="symbol">nums2</span> = [<span class="number">0</span>], <span class="symbol">nums3</span> = [<span class="number">0</span>], <span class="symbol">nums4</span> = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>
</ul>
<h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; AB;</span><br><span class="line">        map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; CD;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e1: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> e2: nums2)&#123;</span><br><span class="line">                AB[e1 + e2] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e3: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> e4: nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>( AB.<span class="built_in">count</span>(- e3 - e4)) res += AB[- e3 - e4];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>FOREX</title>
    <url>/2022/12/12/FOREX/</url>
    <content><![CDATA[<h2 id="FOREX交易"><a href="#FOREX交易" class="headerlink" title="FOREX交易"></a>FOREX交易</h2><h3 id="货币对-amp-代码"><a href="#货币对-amp-代码" class="headerlink" title="货币对&amp;代码"></a>货币对&amp;代码</h3><h4 id="Currencies-Pairs"><a href="#Currencies-Pairs" class="headerlink" title="Currencies Pairs"></a>Currencies Pairs</h4><p>Currencies Pairs 中的前一个货币叫 <em><strong>base currency</strong></em>, and the second currency is called the <em><strong>quote currency</strong></em>. </p>
<blockquote>
<p>  The currency pair indicates 多少单位的 quote currency 能购买一单位的 base currency</p>
</blockquote>
<p>Example: Currency Pair USD&#x2F;CAD&#x3D; 1.35   -&gt;  1.35个单位的CAD能够兑1单位的USD；可以看做 前 除 后</p>
<h5 id="Cross-Pair"><a href="#Cross-Pair" class="headerlink" title="Cross Pair"></a>Cross Pair</h5><p>Pairs that do not include USD, like CAD&#x2F;JPY</p>
<h4 id="Currencies-Codes"><a href="#Currencies-Codes" class="headerlink" title="Currencies Codes"></a>Currencies Codes</h4><table>
<thead>
<tr>
<th><strong>ENTITY</strong></th>
<th><strong>Currency</strong></th>
<th><strong>Alphabetic Code</strong></th>
<th><strong>Numeric Code</strong></th>
<th><strong>Minor unit</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AFGHANISTAN</td>
<td>Afghani</td>
<td>AFN</td>
<td>971</td>
<td>2</td>
</tr>
<tr>
<td>ALAND ISLANDS</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>ALBANIA</td>
<td>Lek</td>
<td>ALL</td>
<td>008</td>
<td>2</td>
</tr>
<tr>
<td>ALGERIA</td>
<td>Algerian Dinar</td>
<td>DZD</td>
<td>012</td>
<td>2</td>
</tr>
<tr>
<td>AMERICAN SAMOA</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>ANDORRA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>ANGOLA</td>
<td>Kwanza</td>
<td>AOA</td>
<td>973</td>
<td>2</td>
</tr>
<tr>
<td>ANGUILLA</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>ANTARCTICA</td>
<td>No universal currency</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ANTIGUA AND BARBUDA</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>ARGENTINA</td>
<td>Argentine Peso</td>
<td>ARS</td>
<td>032</td>
<td>2</td>
</tr>
<tr>
<td>ARMENIA</td>
<td>Armenian Dram</td>
<td>AMD</td>
<td>051</td>
<td>2</td>
</tr>
<tr>
<td>ARUBA</td>
<td>Aruban Florin</td>
<td>AWG</td>
<td>533</td>
<td>2</td>
</tr>
<tr>
<td><strong>AUSTRALIA</strong></td>
<td><strong>Australian Dollar</strong></td>
<td><strong>AUD</strong></td>
<td><strong>036</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>AUSTRIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>AZERBAIJAN</td>
<td>Azerbaijan Manat</td>
<td>AZN</td>
<td>944</td>
<td>2</td>
</tr>
<tr>
<td>BAHAMAS (THE)</td>
<td>Bahamian Dollar</td>
<td>BSD</td>
<td>044</td>
<td>2</td>
</tr>
<tr>
<td>BAHRAIN</td>
<td>Bahraini Dinar</td>
<td>BHD</td>
<td>048</td>
<td>3</td>
</tr>
<tr>
<td>BANGLADESH</td>
<td>Taka</td>
<td>BDT</td>
<td>050</td>
<td>2</td>
</tr>
<tr>
<td>BARBADOS</td>
<td>Barbados Dollar</td>
<td>BBD</td>
<td>052</td>
<td>2</td>
</tr>
<tr>
<td>BELARUS</td>
<td>Belarusian Ruble</td>
<td>BYN</td>
<td>933</td>
<td>2</td>
</tr>
<tr>
<td>BELGIUM</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>BELIZE</td>
<td>Belize Dollar</td>
<td>BZD</td>
<td>084</td>
<td>2</td>
</tr>
<tr>
<td>BENIN</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>BERMUDA</td>
<td>Bermudian Dollar</td>
<td>BMD</td>
<td>060</td>
<td>2</td>
</tr>
<tr>
<td>BHUTAN</td>
<td>Indian Rupee</td>
<td>INR</td>
<td>356</td>
<td>2</td>
</tr>
<tr>
<td>BHUTAN</td>
<td>Ngultrum</td>
<td>BTN</td>
<td>064</td>
<td>2</td>
</tr>
<tr>
<td>BOLIVIA (PLURINATIONAL STATE OF)</td>
<td>Boliviano</td>
<td>BOB</td>
<td>068</td>
<td>2</td>
</tr>
<tr>
<td>BOLIVIA (PLURINATIONAL STATE OF)</td>
<td>Mvdol</td>
<td>BOV</td>
<td>984</td>
<td>2</td>
</tr>
<tr>
<td>BONAIRE, SINT EUSTATIUS AND SABA</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>BOSNIA AND HERZEGOVINA</td>
<td>Convertible Mark</td>
<td>BAM</td>
<td>977</td>
<td>2</td>
</tr>
<tr>
<td>BOTSWANA</td>
<td>Pula</td>
<td>BWP</td>
<td>072</td>
<td>2</td>
</tr>
<tr>
<td>BOUVET ISLAND</td>
<td>Norwegian Krone</td>
<td>NOK</td>
<td>578</td>
<td>2</td>
</tr>
<tr>
<td><strong>BRAZIL</strong></td>
<td><strong>Brazilian Real</strong></td>
<td><strong>BRL</strong></td>
<td><strong>986</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>BRITISH INDIAN OCEAN TERRITORY (THE)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>BRUNEI DARUSSALAM</td>
<td>Brunei Dollar</td>
<td>BND</td>
<td>096</td>
<td>2</td>
</tr>
<tr>
<td>BULGARIA</td>
<td>Bulgarian Lev</td>
<td>BGN</td>
<td>975</td>
<td>2</td>
</tr>
<tr>
<td>BURKINA FASO</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>BURUNDI</td>
<td>Burundi Franc</td>
<td>BIF</td>
<td>108</td>
<td>0</td>
</tr>
<tr>
<td>CABO VERDE</td>
<td>Cabo Verde Escudo</td>
<td>CVE</td>
<td>132</td>
<td>2</td>
</tr>
<tr>
<td>CAMBODIA</td>
<td>Riel</td>
<td>KHR</td>
<td>116</td>
<td>2</td>
</tr>
<tr>
<td>CAMEROON</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td><strong>CANADA</strong></td>
<td><strong>Canadian Dollar</strong></td>
<td><strong>CAD</strong></td>
<td><strong>124</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>CAYMAN ISLANDS (THE)</td>
<td>Cayman Islands Dollar</td>
<td>KYD</td>
<td>136</td>
<td>2</td>
</tr>
<tr>
<td>CENTRAL AFRICAN REPUBLIC (THE)</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td>CHAD</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td>CHILE</td>
<td>Chilean Peso</td>
<td>CLP</td>
<td>152</td>
<td>0</td>
</tr>
<tr>
<td>CHILE</td>
<td>Unidad de Fomento</td>
<td>CLF</td>
<td>990</td>
<td>4</td>
</tr>
<tr>
<td><strong>CHINA</strong></td>
<td><strong>Yuan Renminbi</strong></td>
<td><strong>CNY</strong></td>
<td><strong>156</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>CHRISTMAS ISLAND</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>COCOS (KEELING) ISLANDS (THE)</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>COLOMBIA</td>
<td>Colombian Peso</td>
<td>COP</td>
<td>170</td>
<td>2</td>
</tr>
<tr>
<td>COLOMBIA</td>
<td>Unidad de Valor Real</td>
<td>COU</td>
<td>970</td>
<td>2</td>
</tr>
<tr>
<td>COMOROS (THE)</td>
<td>Comorian Franc</td>
<td>KMF</td>
<td>174</td>
<td>0</td>
</tr>
<tr>
<td>CONGO (THE DEMOCRATIC REPUBLIC OF THE)</td>
<td>Congolese Franc</td>
<td>CDF</td>
<td>976</td>
<td>2</td>
</tr>
<tr>
<td>CONGO (THE)</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td>COOK ISLANDS (THE)</td>
<td>New Zealand Dollar</td>
<td>NZD</td>
<td>554</td>
<td>2</td>
</tr>
<tr>
<td>COSTA RICA</td>
<td>Costa Rican Colon</td>
<td>CRC</td>
<td>188</td>
<td>2</td>
</tr>
<tr>
<td>CÔTE D’IVOIRE</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>CROATIA</td>
<td>Kuna</td>
<td>HRK</td>
<td>191</td>
<td>2</td>
</tr>
<tr>
<td>CUBA</td>
<td>Cuban Peso</td>
<td>CUP</td>
<td>192</td>
<td>2</td>
</tr>
<tr>
<td>CUBA</td>
<td>Peso Convertible</td>
<td>CUC</td>
<td>931</td>
<td>2</td>
</tr>
<tr>
<td>CURAÇAO</td>
<td>Netherlands Antillean Guilder</td>
<td>ANG</td>
<td>532</td>
<td>2</td>
</tr>
<tr>
<td>CYPRUS</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>CZECHIA</td>
<td>Czech Koruna</td>
<td>CZK</td>
<td>203</td>
<td>2</td>
</tr>
<tr>
<td>DENMARK</td>
<td>Danish Krone</td>
<td>DKK</td>
<td>208</td>
<td>2</td>
</tr>
<tr>
<td>DJIBOUTI</td>
<td>Djibouti Franc</td>
<td>DJF</td>
<td>262</td>
<td>0</td>
</tr>
<tr>
<td>DOMINICA</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>DOMINICAN REPUBLIC (THE)</td>
<td>Dominican Peso</td>
<td>DOP</td>
<td>214</td>
<td>2</td>
</tr>
<tr>
<td>ECUADOR</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>EGYPT</td>
<td>Egyptian Pound</td>
<td>EGP</td>
<td>818</td>
<td>2</td>
</tr>
<tr>
<td>EL SALVADOR</td>
<td>El Salvador Colon</td>
<td>SVC</td>
<td>222</td>
<td>2</td>
</tr>
<tr>
<td>EL SALVADOR</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>EQUATORIAL GUINEA</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td>ERITREA</td>
<td>Nakfa</td>
<td>ERN</td>
<td>232</td>
<td>2</td>
</tr>
<tr>
<td>ESTONIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>ESWATINI</td>
<td>Lilangeni</td>
<td>SZL</td>
<td>748</td>
<td>2</td>
</tr>
<tr>
<td>ETHIOPIA</td>
<td>Ethiopian Birr</td>
<td>ETB</td>
<td>230</td>
<td>2</td>
</tr>
<tr>
<td>EUROPEAN UNION</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>FALKLAND ISLANDS (THE) [MALVINAS]</td>
<td>Falkland Islands Pound</td>
<td>FKP</td>
<td>238</td>
<td>2</td>
</tr>
<tr>
<td>FAROE ISLANDS (THE)</td>
<td>Danish Krone</td>
<td>DKK</td>
<td>208</td>
<td>2</td>
</tr>
<tr>
<td>FIJI</td>
<td>Fiji Dollar</td>
<td>FJD</td>
<td>242</td>
<td>2</td>
</tr>
<tr>
<td>FINLAND</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>FRANCE</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>FRENCH GUIANA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>FRENCH POLYNESIA</td>
<td>CFP Franc</td>
<td>XPF</td>
<td>953</td>
<td>0</td>
</tr>
<tr>
<td>FRENCH SOUTHERN TERRITORIES (THE)</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>GABON</td>
<td>CFA Franc BEAC</td>
<td>XAF</td>
<td>950</td>
<td>0</td>
</tr>
<tr>
<td>GAMBIA (THE)</td>
<td>Dalasi</td>
<td>GMD</td>
<td>270</td>
<td>2</td>
</tr>
<tr>
<td>GEORGIA</td>
<td>Lari</td>
<td>GEL</td>
<td>981</td>
<td>2</td>
</tr>
<tr>
<td>GERMANY</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>GHANA</td>
<td>Ghana Cedi</td>
<td>GHS</td>
<td>936</td>
<td>2</td>
</tr>
<tr>
<td>GIBRALTAR</td>
<td>Gibraltar Pound</td>
<td>GIP</td>
<td>292</td>
<td>2</td>
</tr>
<tr>
<td>GREECE</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>GREENLAND</td>
<td>Danish Krone</td>
<td>DKK</td>
<td>208</td>
<td>2</td>
</tr>
<tr>
<td>GRENADA</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>GUADELOUPE</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>GUAM</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>GUATEMALA</td>
<td>Quetzal</td>
<td>GTQ</td>
<td>320</td>
<td>2</td>
</tr>
<tr>
<td>GUERNSEY</td>
<td>Pound Sterling</td>
<td>GBP</td>
<td>826</td>
<td>2</td>
</tr>
<tr>
<td>GUINEA</td>
<td>Guinean Franc</td>
<td>GNF</td>
<td>324</td>
<td>0</td>
</tr>
<tr>
<td>GUINEA-BISSAU</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>GUYANA</td>
<td>Guyana Dollar</td>
<td>GYD</td>
<td>328</td>
<td>2</td>
</tr>
<tr>
<td>HAITI</td>
<td>Gourde</td>
<td>HTG</td>
<td>332</td>
<td>2</td>
</tr>
<tr>
<td>HAITI</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>HEARD ISLAND AND McDONALD ISLANDS</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>HOLY SEE (THE)</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>HONDURAS</td>
<td>Lempira</td>
<td>HNL</td>
<td>340</td>
<td>2</td>
</tr>
<tr>
<td>HONG KONG</td>
<td>Hong Kong Dollar</td>
<td>HKD</td>
<td>344</td>
<td>2</td>
</tr>
<tr>
<td>HUNGARY</td>
<td>Forint</td>
<td>HUF</td>
<td>348</td>
<td>2</td>
</tr>
<tr>
<td>ICELAND</td>
<td>Iceland Krona</td>
<td>ISK</td>
<td>352</td>
<td>0</td>
</tr>
<tr>
<td>INDIA</td>
<td>Indian Rupee</td>
<td>INR</td>
<td>356</td>
<td>2</td>
</tr>
<tr>
<td>INDONESIA</td>
<td>Rupiah</td>
<td>IDR</td>
<td>360</td>
<td>2</td>
</tr>
<tr>
<td>INTERNATIONAL MONETARY FUND (IMF)</td>
<td>SDR (Special Drawing Right)</td>
<td>XDR</td>
<td>960</td>
<td>N.A.</td>
</tr>
<tr>
<td>IRAN (ISLAMIC REPUBLIC OF)</td>
<td>Iranian Rial</td>
<td>IRR</td>
<td>364</td>
<td>2</td>
</tr>
<tr>
<td>IRAQ</td>
<td>Iraqi Dinar</td>
<td>IQD</td>
<td>368</td>
<td>3</td>
</tr>
<tr>
<td>IRELAND</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>ISLE OF MAN</td>
<td>Pound Sterling</td>
<td>GBP</td>
<td>826</td>
<td>2</td>
</tr>
<tr>
<td>ISRAEL</td>
<td>New Israeli Sheqel</td>
<td>ILS</td>
<td>376</td>
<td>2</td>
</tr>
<tr>
<td>ITALY</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>JAMAICA</td>
<td>Jamaican Dollar</td>
<td>JMD</td>
<td>388</td>
<td>2</td>
</tr>
<tr>
<td><strong>JAPAN</strong></td>
<td><strong>Yen</strong></td>
<td><strong>JPY</strong></td>
<td><strong>392</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>JERSEY</td>
<td>Pound Sterling</td>
<td>GBP</td>
<td>826</td>
<td>2</td>
</tr>
<tr>
<td>JORDAN</td>
<td>Jordanian Dinar</td>
<td>JOD</td>
<td>400</td>
<td>3</td>
</tr>
<tr>
<td>KAZAKHSTAN</td>
<td>Tenge</td>
<td>KZT</td>
<td>398</td>
<td>2</td>
</tr>
<tr>
<td>KENYA</td>
<td>Kenyan Shilling</td>
<td>KES</td>
<td>404</td>
<td>2</td>
</tr>
<tr>
<td>KIRIBATI</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>KOREA (THE DEMOCRATIC PEOPLE’S REPUBLIC OF)</td>
<td>North Korean Won</td>
<td>KPW</td>
<td>408</td>
<td>2</td>
</tr>
<tr>
<td>KOREA (THE REPUBLIC OF)</td>
<td>Won</td>
<td>KRW</td>
<td>410</td>
<td>0</td>
</tr>
<tr>
<td>KUWAIT</td>
<td>Kuwaiti Dinar</td>
<td>KWD</td>
<td>414</td>
<td>3</td>
</tr>
<tr>
<td>KYRGYZSTAN</td>
<td>Som</td>
<td>KGS</td>
<td>417</td>
<td>2</td>
</tr>
<tr>
<td>LAO PEOPLE’S DEMOCRATIC REPUBLIC (THE)</td>
<td>Lao Kip</td>
<td>LAK</td>
<td>418</td>
<td>2</td>
</tr>
<tr>
<td>LATVIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>LEBANON</td>
<td>Lebanese Pound</td>
<td>LBP</td>
<td>422</td>
<td>2</td>
</tr>
<tr>
<td>LESOTHO</td>
<td>Loti</td>
<td>LSL</td>
<td>426</td>
<td>2</td>
</tr>
<tr>
<td>LESOTHO</td>
<td>Rand</td>
<td>ZAR</td>
<td>710</td>
<td>2</td>
</tr>
<tr>
<td>LIBERIA</td>
<td>Liberian Dollar</td>
<td>LRD</td>
<td>430</td>
<td>2</td>
</tr>
<tr>
<td>LIBYA</td>
<td>Libyan Dinar</td>
<td>LYD</td>
<td>434</td>
<td>3</td>
</tr>
<tr>
<td>LIECHTENSTEIN</td>
<td>Swiss Franc</td>
<td>CHF</td>
<td>756</td>
<td>2</td>
</tr>
<tr>
<td>LITHUANIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>LUXEMBOURG</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MACAO</td>
<td>Pataca</td>
<td>MOP</td>
<td>446</td>
<td>2</td>
</tr>
<tr>
<td>NORTH MACEDONIA</td>
<td>Denar</td>
<td>MKD</td>
<td>807</td>
<td>2</td>
</tr>
<tr>
<td>MADAGASCAR</td>
<td>Malagasy Ariary</td>
<td>MGA</td>
<td>969</td>
<td>2</td>
</tr>
<tr>
<td>MALAWI</td>
<td>Malawi Kwacha</td>
<td>MWK</td>
<td>454</td>
<td>2</td>
</tr>
<tr>
<td>MALAYSIA</td>
<td>Malaysian Ringgit</td>
<td>MYR</td>
<td>458</td>
<td>2</td>
</tr>
<tr>
<td>MALDIVES</td>
<td>Rufiyaa</td>
<td>MVR</td>
<td>462</td>
<td>2</td>
</tr>
<tr>
<td>MALI</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>MALTA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MARSHALL ISLANDS (THE)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>MARTINIQUE</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MAURITANIA</td>
<td>Ouguiya</td>
<td>MRU</td>
<td>929</td>
<td>2</td>
</tr>
<tr>
<td>MAURITIUS</td>
<td>Mauritius Rupee</td>
<td>MUR</td>
<td>480</td>
<td>2</td>
</tr>
<tr>
<td>MAYOTTE</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MEMBER COUNTRIES OF THE AFRICAN DEVELOPMENT BANK GROUP</td>
<td>ADB Unit of Account</td>
<td>XUA</td>
<td>965</td>
<td>N.A.</td>
</tr>
<tr>
<td>MEXICO</td>
<td>Mexican Peso</td>
<td>MXN</td>
<td>484</td>
<td>2</td>
</tr>
<tr>
<td>MEXICO</td>
<td>Mexican Unidad de Inversion (UDI)</td>
<td>MXV</td>
<td>979</td>
<td>2</td>
</tr>
<tr>
<td>MICRONESIA (FEDERATED STATES OF)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>MOLDOVA (THE REPUBLIC OF)</td>
<td>Moldovan Leu</td>
<td>MDL</td>
<td>498</td>
<td>2</td>
</tr>
<tr>
<td>MONACO</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MONGOLIA</td>
<td>Tugrik</td>
<td>MNT</td>
<td>496</td>
<td>2</td>
</tr>
<tr>
<td>MONTENEGRO</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>MONTSERRAT</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>MOROCCO</td>
<td>Moroccan Dirham</td>
<td>MAD</td>
<td>504</td>
<td>2</td>
</tr>
<tr>
<td>MOZAMBIQUE</td>
<td>Mozambique Metical</td>
<td>MZN</td>
<td>943</td>
<td>2</td>
</tr>
<tr>
<td>MYANMAR</td>
<td>Kyat</td>
<td>MMK</td>
<td>104</td>
<td>2</td>
</tr>
<tr>
<td>NAMIBIA</td>
<td>Namibia Dollar</td>
<td>NAD</td>
<td>516</td>
<td>2</td>
</tr>
<tr>
<td>NAMIBIA</td>
<td>Rand</td>
<td>ZAR</td>
<td>710</td>
<td>2</td>
</tr>
<tr>
<td>NAURU</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>NEPAL</td>
<td>Nepalese Rupee</td>
<td>NPR</td>
<td>524</td>
<td>2</td>
</tr>
<tr>
<td>NETHERLANDS (THE)</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>NEW CALEDONIA</td>
<td>CFP Franc</td>
<td>XPF</td>
<td>953</td>
<td>0</td>
</tr>
<tr>
<td>NEW ZEALAND</td>
<td>New Zealand Dollar</td>
<td>NZD</td>
<td>554</td>
<td>2</td>
</tr>
<tr>
<td>NICARAGUA</td>
<td>Cordoba Oro</td>
<td>NIO</td>
<td>558</td>
<td>2</td>
</tr>
<tr>
<td>NIGER (THE)</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>NIGERIA</td>
<td>Naira</td>
<td>NGN</td>
<td>566</td>
<td>2</td>
</tr>
<tr>
<td>NIUE</td>
<td>New Zealand Dollar</td>
<td>NZD</td>
<td>554</td>
<td>2</td>
</tr>
<tr>
<td>NORFOLK ISLAND</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>NORTHERN MARIANA ISLANDS (THE)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>NORWAY</td>
<td>Norwegian Krone</td>
<td>NOK</td>
<td>578</td>
<td>2</td>
</tr>
<tr>
<td>OMAN</td>
<td>Rial Omani</td>
<td>OMR</td>
<td>512</td>
<td>3</td>
</tr>
<tr>
<td>PAKISTAN</td>
<td>Pakistan Rupee</td>
<td>PKR</td>
<td>586</td>
<td>2</td>
</tr>
<tr>
<td>PALAU</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>PALESTINE, STATE OF</td>
<td>No universal currency</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PANAMA</td>
<td>Balboa</td>
<td>PAB</td>
<td>590</td>
<td>2</td>
</tr>
<tr>
<td>PANAMA</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>PAPUA NEW GUINEA</td>
<td>Kina</td>
<td>PGK</td>
<td>598</td>
<td>2</td>
</tr>
<tr>
<td>PARAGUAY</td>
<td>Guarani</td>
<td>PYG</td>
<td>600</td>
<td>0</td>
</tr>
<tr>
<td>PERU</td>
<td>Sol</td>
<td>PEN</td>
<td>604</td>
<td>2</td>
</tr>
<tr>
<td>PHILIPPINES (THE)</td>
<td>Philippine Peso</td>
<td>PHP</td>
<td>608</td>
<td>2</td>
</tr>
<tr>
<td>PITCAIRN</td>
<td>New Zealand Dollar</td>
<td>NZD</td>
<td>554</td>
<td>2</td>
</tr>
<tr>
<td>POLAND</td>
<td>Zloty</td>
<td>PLN</td>
<td>985</td>
<td>2</td>
</tr>
<tr>
<td>PORTUGAL</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>PUERTO RICO</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>QATAR</td>
<td>Qatari Rial</td>
<td>QAR</td>
<td>634</td>
<td>2</td>
</tr>
<tr>
<td>RÉUNION</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>ROMANIA</td>
<td>Romanian Leu</td>
<td>RON</td>
<td>946</td>
<td>2</td>
</tr>
<tr>
<td>RUSSIAN FEDERATION (THE)</td>
<td>Russian Ruble</td>
<td>RUB</td>
<td>643</td>
<td>2</td>
</tr>
<tr>
<td>RWANDA</td>
<td>Rwanda Franc</td>
<td>RWF</td>
<td>646</td>
<td>0</td>
</tr>
<tr>
<td>SAINT BARTHÉLEMY</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SAINT HELENA, ASCENSION AND TRISTAN DA CUNHA</td>
<td>Saint Helena Pound</td>
<td>SHP</td>
<td>654</td>
<td>2</td>
</tr>
<tr>
<td>SAINT KITTS AND NEVIS</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>SAINT LUCIA</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>SAINT MARTIN (FRENCH PART)</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SAINT PIERRE AND MIQUELON</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SAINT VINCENT AND THE GRENADINES</td>
<td>East Caribbean Dollar</td>
<td>XCD</td>
<td>951</td>
<td>2</td>
</tr>
<tr>
<td>SAMOA</td>
<td>Tala</td>
<td>WST</td>
<td>882</td>
<td>2</td>
</tr>
<tr>
<td>SAN MARINO</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SAO TOME AND PRINCIPE</td>
<td>Dobra</td>
<td>STN</td>
<td>930</td>
<td>2</td>
</tr>
<tr>
<td>SAUDI ARABIA</td>
<td>Saudi Riyal</td>
<td>SAR</td>
<td>682</td>
<td>2</td>
</tr>
<tr>
<td>SENEGAL</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>SERBIA</td>
<td>Serbian Dinar</td>
<td>RSD</td>
<td>941</td>
<td>2</td>
</tr>
<tr>
<td>SEYCHELLES</td>
<td>Seychelles Rupee</td>
<td>SCR</td>
<td>690</td>
<td>2</td>
</tr>
<tr>
<td>SIERRA LEONE</td>
<td>Leone</td>
<td>SLL</td>
<td>694</td>
<td>2</td>
</tr>
<tr>
<td>SIERRA LEONE</td>
<td>Leone</td>
<td>SLE</td>
<td>925</td>
<td>2</td>
</tr>
<tr>
<td>SINGAPORE</td>
<td>Singapore Dollar</td>
<td>SGD</td>
<td>702</td>
<td>2</td>
</tr>
<tr>
<td>SINT MAARTEN (DUTCH PART)</td>
<td>Netherlands Antillean Guilder</td>
<td>ANG</td>
<td>532</td>
<td>2</td>
</tr>
<tr>
<td>SISTEMA UNITARIO DE COMPENSACION REGIONAL DE PAGOS “SUCRE”</td>
<td>Sucre</td>
<td>XSU</td>
<td>994</td>
<td>N.A.</td>
</tr>
<tr>
<td>SLOVAKIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SLOVENIA</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SOLOMON ISLANDS</td>
<td>Solomon Islands Dollar</td>
<td>SBD</td>
<td>090</td>
<td>2</td>
</tr>
<tr>
<td>SOMALIA</td>
<td>Somali Shilling</td>
<td>SOS</td>
<td>706</td>
<td>2</td>
</tr>
<tr>
<td>SOUTH AFRICA</td>
<td>Rand</td>
<td>ZAR</td>
<td>710</td>
<td>2</td>
</tr>
<tr>
<td>SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS</td>
<td>No universal currency</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SOUTH SUDAN</td>
<td>South Sudanese Pound</td>
<td>SSP</td>
<td>728</td>
<td>2</td>
</tr>
<tr>
<td>SPAIN</td>
<td>Euro</td>
<td>EUR</td>
<td>978</td>
<td>2</td>
</tr>
<tr>
<td>SRI LANKA</td>
<td>Sri Lanka Rupee</td>
<td>LKR</td>
<td>144</td>
<td>2</td>
</tr>
<tr>
<td>SUDAN (THE)</td>
<td>Sudanese Pound</td>
<td>SDG</td>
<td>938</td>
<td>2</td>
</tr>
<tr>
<td>SURINAME</td>
<td>Surinam Dollar</td>
<td>SRD</td>
<td>968</td>
<td>2</td>
</tr>
<tr>
<td>SVALBARD AND JAN MAYEN</td>
<td>Norwegian Krone</td>
<td>NOK</td>
<td>578</td>
<td>2</td>
</tr>
<tr>
<td>SWEDEN</td>
<td>Swedish Krona</td>
<td>SEK</td>
<td>752</td>
<td>2</td>
</tr>
<tr>
<td>SWITZERLAND</td>
<td>Swiss Franc</td>
<td>CHF</td>
<td>756</td>
<td>2</td>
</tr>
<tr>
<td>SWITZERLAND</td>
<td>WIR Euro</td>
<td>CHE</td>
<td>947</td>
<td>2</td>
</tr>
<tr>
<td>SWITZERLAND</td>
<td>WIR Franc</td>
<td>CHW</td>
<td>948</td>
<td>2</td>
</tr>
<tr>
<td>SYRIAN ARAB REPUBLIC</td>
<td>Syrian Pound</td>
<td>SYP</td>
<td>760</td>
<td>2</td>
</tr>
<tr>
<td>TAIWAN (PROVINCE OF CHINA)</td>
<td>New Taiwan Dollar</td>
<td>TWD</td>
<td>901</td>
<td>2</td>
</tr>
<tr>
<td>TAJIKISTAN</td>
<td>Somoni</td>
<td>TJS</td>
<td>972</td>
<td>2</td>
</tr>
<tr>
<td>TANZANIA, UNITED REPUBLIC OF</td>
<td>Tanzanian Shilling</td>
<td>TZS</td>
<td>834</td>
<td>2</td>
</tr>
<tr>
<td>THAILAND</td>
<td>Baht</td>
<td>THB</td>
<td>764</td>
<td>2</td>
</tr>
<tr>
<td>TIMOR-LESTE</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>TOGO</td>
<td>CFA Franc BCEAO</td>
<td>XOF</td>
<td>952</td>
<td>0</td>
</tr>
<tr>
<td>TOKELAU</td>
<td>New Zealand Dollar</td>
<td>NZD</td>
<td>554</td>
<td>2</td>
</tr>
<tr>
<td>TONGA</td>
<td>Pa’anga</td>
<td>TOP</td>
<td>776</td>
<td>2</td>
</tr>
<tr>
<td>TRINIDAD AND TOBAGO</td>
<td>Trinidad and Tobago Dollar</td>
<td>TTD</td>
<td>780</td>
<td>2</td>
</tr>
<tr>
<td>TUNISIA</td>
<td>Tunisian Dinar</td>
<td>TND</td>
<td>788</td>
<td>3</td>
</tr>
<tr>
<td>TÜRKİYE</td>
<td>Turkish Lira</td>
<td>TRY</td>
<td>949</td>
<td>2</td>
</tr>
<tr>
<td>TURKMENISTAN</td>
<td>Turkmenistan New Manat</td>
<td>TMT</td>
<td>934</td>
<td>2</td>
</tr>
<tr>
<td>TURKS AND CAICOS ISLANDS (THE)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>TUVALU</td>
<td>Australian Dollar</td>
<td>AUD</td>
<td>036</td>
<td>2</td>
</tr>
<tr>
<td>UGANDA</td>
<td>Uganda Shilling</td>
<td>UGX</td>
<td>800</td>
<td>0</td>
</tr>
<tr>
<td>UKRAINE</td>
<td>Hryvnia</td>
<td>UAH</td>
<td>980</td>
<td>2</td>
</tr>
<tr>
<td>UNITED ARAB EMIRATES (THE)</td>
<td>UAE Dirham</td>
<td>AED</td>
<td>784</td>
<td>2</td>
</tr>
<tr>
<td><strong>UNITED KINGDOM OF GREAT BRITAIN AND NORTHERN IRELAND (THE)</strong></td>
<td><strong>Pound Sterling</strong></td>
<td><strong>GBP</strong></td>
<td><strong>826</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>UNITED STATES MINOR OUTLYING ISLANDS (THE)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td><strong>UNITED STATES OF AMERICA (THE)</strong></td>
<td><strong>US Dollar</strong></td>
<td><strong>USD</strong></td>
<td><strong>840</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td><strong>UNITED STATES OF AMERICA (THE)</strong></td>
<td><strong>US Dollar (Next day)</strong></td>
<td><strong>USN</strong></td>
<td><strong>997</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>URUGUAY</td>
<td>Peso Uruguayo</td>
<td>UYU</td>
<td>858</td>
<td>2</td>
</tr>
<tr>
<td>URUGUAY</td>
<td>Uruguay Peso en Unidades Indexadas (UI)</td>
<td>UYI</td>
<td>940</td>
<td>0</td>
</tr>
<tr>
<td>URUGUAY</td>
<td>Unidad Previsional</td>
<td>UYW</td>
<td>927</td>
<td>4</td>
</tr>
<tr>
<td>UZBEKISTAN</td>
<td>Uzbekistan Sum</td>
<td>UZS</td>
<td>860</td>
<td>2</td>
</tr>
<tr>
<td>VANUATU</td>
<td>Vatu</td>
<td>VUV</td>
<td>548</td>
<td>0</td>
</tr>
<tr>
<td>VENEZUELA (BOLIVARIAN REPUBLIC OF)</td>
<td>Bolívar Soberano</td>
<td>VES</td>
<td>928</td>
<td>2</td>
</tr>
<tr>
<td>VENEZUELA (BOLIVARIAN REPUBLIC OF)</td>
<td>Bolívar Soberano</td>
<td>VED</td>
<td>926</td>
<td>2</td>
</tr>
<tr>
<td>VIET NAM</td>
<td>Dong</td>
<td>VND</td>
<td>704</td>
<td>0</td>
</tr>
<tr>
<td>VIRGIN ISLANDS (BRITISH)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>VIRGIN ISLANDS (U.S.)</td>
<td>US Dollar</td>
<td>USD</td>
<td>840</td>
<td>2</td>
</tr>
<tr>
<td>WALLIS AND FUTUNA</td>
<td>CFP Franc</td>
<td>XPF</td>
<td>953</td>
<td>0</td>
</tr>
<tr>
<td>WESTERN SAHARA</td>
<td>Moroccan Dirham</td>
<td>MAD</td>
<td>504</td>
<td>2</td>
</tr>
<tr>
<td>YEMEN</td>
<td>Yemeni Rial</td>
<td>YER</td>
<td>886</td>
<td>2</td>
</tr>
<tr>
<td>ZAMBIA</td>
<td>Zambian Kwacha</td>
<td>ZMW</td>
<td>967</td>
<td>2</td>
</tr>
<tr>
<td>ZIMBABWE</td>
<td>Zimbabwe Dollar</td>
<td>ZWL</td>
<td>932</td>
<td>2</td>
</tr>
<tr>
<td>ZZ01_Bond Markets Unit European_EURCO</td>
<td>Bond Markets Unit European Composite Unit (EURCO)</td>
<td>XBA</td>
<td>955</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ02_Bond Markets Unit European_EMU-6</td>
<td>Bond Markets Unit European Monetary Unit (E.M.U.-6)</td>
<td>XBB</td>
<td>956</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ03_Bond Markets Unit European_EUA-9</td>
<td>Bond Markets Unit European Unit of Account 9 (E.U.A.-9)</td>
<td>XBC</td>
<td>957</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ04_Bond Markets Unit European_EUA-17</td>
<td>Bond Markets Unit European Unit of Account 17 (E.U.A.-17)</td>
<td>XBD</td>
<td>958</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ06_Testing_Code</td>
<td>Codes specifically reserved for testing purposes</td>
<td>XTS</td>
<td>963</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ07_No_Currency</td>
<td>The codes assigned for transactions where no currency is involved</td>
<td>XXX</td>
<td>999</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ08_Gold</td>
<td>Gold</td>
<td>XAU</td>
<td>959</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ09_Palladium</td>
<td>Palladium</td>
<td>XPD</td>
<td>964</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ10_Platinum</td>
<td>Platinum</td>
<td>XPT</td>
<td>962</td>
<td>N.A.</td>
</tr>
<tr>
<td>ZZ11_Silver</td>
<td>Silver</td>
<td>XAG</td>
<td>961</td>
<td>N.A.</td>
</tr>
</tbody></table>
<h4 id="Major-Pairs-amp-Codes"><a href="#Major-Pairs-amp-Codes" class="headerlink" title="Major Pairs &amp; Codes"></a>Major Pairs &amp; Codes</h4><ul>
<li>EUR&#x2F;USD - euro &#x2F; U.S. dollar</li>
<li>**(The Cable) **GBP&#x2F;USD - Great Britain pound (sterling) &#x2F; U.S. dollar </li>
<li>USD&#x2F;JPY - U.S. dollar &#x2F; Japanese yen</li>
<li><strong>(Swissy)</strong> USD&#x2F;CHF - U.S. dollar &#x2F; Swiss Franc</li>
<li><strong>(Loonie)</strong> USD&#x2F;CAD</li>
<li><strong>(Aussie)</strong> AUD&#x2F;USD</li>
</ul>
<blockquote>
<p>  Value traded vs. the U.S. dollar is the top criteria for classification as major currency pairs.</p>
</blockquote>
<p>Other important currencies include:</p>
<ul>
<li>AUD - Australian dollar 澳元</li>
<li>CAD - Canadian dollar 加元</li>
<li>CNY - China yuan renminbi 人民币</li>
<li>NZD - New Zealand dollar 新西兰元</li>
<li>INR - Indian rupee 印度卢比</li>
<li>BZR - Brazilian real 巴西雷亚尔</li>
<li>SEK - Swedish krona 瑞典克朗</li>
<li>ZAR - South African rand 南非兰特</li>
<li>HKD - Hong Kong dollar 港币</li>
</ul>
<h3 id="Forex市场结构"><a href="#Forex市场结构" class="headerlink" title="Forex市场结构"></a>Forex市场结构</h3><p>Transactions are done OTC (over the counter 场外交易).  There is no central exchange to trade on. </p>
<p>Because it is OTC, execution prices will vary. 	</p>
<blockquote>
<p>  比如股票就是非OTC的，它们有一个center「也就是自己上市的交易所」去交易，因此同一时刻的价格是固定的</p>
</blockquote>
<h4 id="银行间市场"><a href="#银行间市场" class="headerlink" title="银行间市场"></a>银行间市场</h4><p>RX Dealers的玩法：The interbank market is where banks exchange currencies with one another. </p>
<p>They can do this by transacting directly through <strong>EBS (Electronic Broking Services)</strong> or <strong>Thompson Reuters</strong> who are the two electronic brokering中介 platforms at this level. This is only available to very large banks.</p>
<h4 id="The-Players"><a href="#The-Players" class="headerlink" title="The Players"></a>The Players</h4><img src="/2022/12/12/FOREX/image-20221212170039697.png" alt="image-20221212170039697" style="zoom:50%;">

<p>RX Dealers ： huge bank like 花旗 摩根 瑞银 汇丰 …</p>
<p>Other Large Participants：当地银行，对冲基金，跨国公司</p>
<p>forex brokers and retail ECNs：你必须挑一个brokers中介，在他那里交易</p>
<h3 id="价格相关术语"><a href="#价格相关术语" class="headerlink" title="价格相关术语"></a>价格相关术语</h3><h4 id="Prices"><a href="#Prices" class="headerlink" title="Prices"></a><em>Prices</em></h4><p><strong>Spot Price:</strong> The current price of a currency pair  </p>
<p><strong>Order Book:</strong> All the buy orders and sell orders that are open </p>
<blockquote>
<p>  Order Book 记录所有等待成交的买方报价和卖方出价</p>
</blockquote>
<p><strong>Bid Price:</strong> The price you can sell at right now  买方现在想买的价格</p>
<p><strong>Ask Price:</strong> The price you can buy at right now 卖方现在想卖的价格 </p>
<p><strong>Spread:</strong> Difference between the bid and ask  </p>
<p><img src="/2022/12/12/FOREX/image-20221212172836404.png" alt="image-20221212172836404"></p>
<h4 id="Pips"><a href="#Pips" class="headerlink" title="Pips"></a><em>Pips</em></h4><p>**Point ** &#x3D;  min change</p>
<p>**Pip ** &#x3D; 0.0001</p>
<p>**Pipette  &#x2F;pɪˈpet&#x2F;  ** &#x3D;  0.00001</p>
<h4 id="Lots"><a href="#Lots" class="headerlink" title="Lots"></a><em>Lots</em></h4><p><strong>Standard lot</strong> &#x3D; 100,000 units (of base currency)  十万</p>
<p><strong>Mini lot</strong>  &#x3D; 10,000 units 一万</p>
<p><strong>Micro lot</strong>  &#x3D; 1,000 units 一千</p>
<h3 id="Pip-Value-Calculation"><a href="#Pip-Value-Calculation" class="headerlink" title="Pip Value Calculation"></a>Pip Value Calculation</h3><p>Example: USD&#x2F;CAD &#x3D; 1.35251<br>Contract value for one Lot: 100,000 USD * 1.35251 &#x3D; 135,251$ CAD<br>Pip value is the profit&#x2F;loss for 1 Pip movement.</p>
<ul>
<li>If price goes up to 1.35261 </li>
<li>Then Contract value &#x3D; 100,000USD * 1.35261 &#x3D; 135,261$ CAD</li>
<li>Pip value&#x3D; 135,261 - 135,251 &#x3D; $10 CAD<br>In base currency this is equal to 10&#x2F;1.35251 &#x3D; 7.39 USD</li>
</ul>
<blockquote>
<p>  Pip value is always in quote currency</p>
</blockquote>
<h3 id="Leverage-杠杆"><a href="#Leverage-杠杆" class="headerlink" title="Leverage 杠杆"></a>Leverage 杠杆</h3><p>Funds loaned to you by your broker 你的经纪人借给你的资金, 最多高达一千倍</p>
<p><img src="/2022/12/12/FOREX/image-20221212184321794.png" alt="image-20221212184321794"></p>
<h3 id="Short-Selling-卖空"><a href="#Short-Selling-卖空" class="headerlink" title="Short Selling 卖空"></a>Short Selling 卖空</h3><p>卖空:出售卖方不拥有的资产后，一段时间后以更低的价格购入相同份额还给原主。</p>
<img src="/2022/12/12/FOREX/image-20221212190234360.png" alt="image-20221212190234360" style="zoom:50%;">



<h3 id="Brokers"><a href="#Brokers" class="headerlink" title="Brokers"></a>Brokers</h3><h4 id="好的经纪人需要："><a href="#好的经纪人需要：" class="headerlink" title="好的经纪人需要："></a>好的经纪人需要：</h4><ul>
<li><p>A broker that is Regulated</p>
</li>
<li><p>Transparency</p>
</li>
<li><p>Alignment of interests 利益联盟</p>
</li>
<li><p>Low Fees</p>
</li>
<li><p>Leverage 恰到好处的杠杆</p>
</li>
<li><p>Good Platform 好的平台</p>
</li>
<li><p>Support</p>
</li>
</ul>
<h4 id="经纪人种类"><a href="#经纪人种类" class="headerlink" title="经纪人种类"></a>经纪人种类</h4><p><strong>Brokers use A book ：</strong>The A book is the order book that has the major liquidity providers. When a broker is using this book, he is sending your orders to be executed with one of those liquidity providers.  This is the order book used by ECN brokers. </p>
<p><strong>Brokers use B book ：</strong>The B book is the broker’s in-house order book.  When a broker is using this order book, he is taking the other side of your trade (can be hedged or unhedged).  This is the order book used by market maker brokers. （B book自己交易挣取Spread）</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h4><p>也就是对图表的研究,利用价格和成交量分析</p>
<h5 id="Candles"><a href="#Candles" class="headerlink" title="Candles"></a>Candles</h5><p>O指OPEN，开盘价；<em>C</em>指CLOSE，收盘价；<em>H</em>指HIGHT，最高价； <em>L</em>指LOW，最低价</p>
<img src="/2022/12/12/FOREX/image-20221213093528937.png" alt="image-20221213093528937" style="zoom:50%;">

<h5 id="Trends"><a href="#Trends" class="headerlink" title="Trends"></a>Trends</h5><img src="/2022/12/12/FOREX/image-20221213100608334.png" alt="image-20221213100608334" style="zoom:50%;">

<h5 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h5><p>如果Volume很大，注意会有something happen</p>
<h5 id="Channels、Supports-amp-Resistance"><a href="#Channels、Supports-amp-Resistance" class="headerlink" title="Channels、Supports &amp; Resistance"></a>Channels、Supports &amp; Resistance</h5><img src="/2022/12/12/FOREX/image-20221213102447645.png" alt="image-20221213102447645" style="zoom:50%;">



<h5 id="Chart-Patterns"><a href="#Chart-Patterns" class="headerlink" title="Chart Patterns"></a>Chart Patterns</h5><p><strong>Double Tops and Bottoms</strong></p>
<blockquote>
<p>  触底时极有可能回升；触顶时极有可能回落</p>
</blockquote>
<img src="/2022/12/12/FOREX/image-20221213121637463.png" alt="image-20221213121637463" style="zoom: 75%;">

<img src="/2022/12/12/FOREX/image-20221213121706734.png" alt="image-20221213121706734" style="zoom:67%;">

<p><strong>Ascending Triangles</strong></p>
<blockquote>
<p>  容易向上爆炸</p>
</blockquote>
<img src="/2022/12/12/FOREX/image-20221213123909440.png" alt="image-20221213123909440" style="zoom:50%;">



<p><strong>Descending Triangles</strong></p>
<blockquote>
<p>  容易向下爆炸</p>
</blockquote>
<img src="/2022/12/12/FOREX/image-20221213125543154.png" alt="image-20221213125543154" style="zoom:50%;">

<p><strong>Symmetrical Triangles</strong></p>
<blockquote>
<p>  向上或向下都极有可能爆炸</p>
</blockquote>
<img src="/2022/12/12/FOREX/image-20221213133138667.png" alt="image-20221213133138667" style="zoom:50%;">



<h5 id="Wedge"><a href="#Wedge" class="headerlink" title="Wedge"></a><strong>Wedge</strong></h5><img src="/2022/12/12/FOREX/image-20221213134255389.png" alt="image-20221213134255389" style="zoom: 33%;">

<img src="/2022/12/12/FOREX/image-20221213134317435.png" alt="image-20221213134317435" style="zoom: 33%;">



<h5 id="技术分析指标"><a href="#技术分析指标" class="headerlink" title="技术分析指标"></a>技术分析指标</h5><h6 id="Simple-Moving-Average-均线"><a href="#Simple-Moving-Average-均线" class="headerlink" title="Simple Moving Average 均线"></a>Simple Moving Average 均线</h6><p>SMA(4)代表近4天的平均值 </p>
<p><strong>MA &#x3D; N天收盘价总和 &#x2F; N</strong></p>
<p>以日均线为例，若计算BTC 30日均线值（30MA，日K线），就是将过去（含最新一天）30天内BTC的收盘价加总后除以30。再将每日K线对应的30日均线值连接起来，即可以得到一条BTC 30日均线</p>
<p>与此同时，根据不同类型交易者交易周期不同，其采用的均线也有不同，常见类型表现如下：</p>
<table>
<thead>
<tr>
<th>交易周期</th>
<th>常用均线</th>
</tr>
</thead>
<tbody><tr>
<td>短线、对冲交易者</td>
<td>k线周期：1分k、5分k、10分k对应均线：5MA、10MA、20MA</td>
</tr>
<tr>
<td>波段交易者</td>
<td>k线周期：小时k、日k对应均线：5MA、10MA、20MA、60MA</td>
</tr>
<tr>
<td>中长期交易者</td>
<td>k线周期：日k对应均线：20MA、60MA、120MA、240MA</td>
</tr>
</tbody></table>
<p>无论采用何种类型的均线模型，其依据的均线核心理论基础都可以用一句话概括，即**平均价格不断上涨就表示市场处于上升趋势，反之，则表示市场处于下跌趋势 ** 以下，简单介绍几种常用的均线分析方法。</p>
<ol>
<li>若价格向上穿越MA线，代表市场走强，为买进信号；若价格向下穿越MA线，代表市场走弱，为卖出信号</li>
</ol>
<p><img src="/2022/12/12/FOREX/image-20221214224546499.png" alt="image-20221214224546499"></p>
<ol start="2">
<li>金叉——买入信号 死叉——卖出信号</li>
</ol>
<p><img src="/2022/12/12/FOREX/image-20221214224626763.png" alt="image-20221214224626763"></p>
<ol start="3">
<li>多头排列 和 空头排列</li>
</ol>
<p>多头排列是指短均线价格均大于长均线价格，同时整个均线系统呈现向上发散态势。这表明市场处于强劲上涨趋势信号，交易者可逢低买入</p>
<p>空头排列是指短均线价格均小于长均线价格，同时整个均线系统呈现向下发散态势。这表明市场处于强劲下跌趋势信号，交易者可逢高做空</p>
<p><img src="/2022/12/12/FOREX/image-20221214225030421.png" alt="image-20221214225030421"></p>
<h6 id="Bollinger-Band-布林带"><a href="#Bollinger-Band-布林带" class="headerlink" title="Bollinger Band 布林带"></a>Bollinger Band 布林带</h6><img src="/2022/12/12/FOREX/image-20221214225836273.png" alt="image-20221214225836273" style="zoom:50%;">

<p>⑴股价由下向上穿越下轨线（Down）时，可视为买进信号。</p>
<p>⑵股价由下向上穿越中轨时，股价将加速上扬，是加仓买进的信号。</p>
<p>⑶股价在中轨与上轨(UPER）之间波动运行时为多头市场，可持股观望。</p>
<p>⑷股价长时间在中轨与上轨（UPER）间运行后，由上向下跌破中轨为卖出信号。</p>
<p>⑸股价在中轨与下轨（Down）之间向下波动运行时为空头市场，此时投资者应持币观望。</p>
<p>⑹布林中轨经长期大幅下跌后转平，出现向上的拐点，且股价在2～3日内均在中轨之上。此时，若股价回调，其回档低点往往是适量低吸的中短线切入点。</p>
<p>⑺对于在布林中轨与上轨之间运作的强势股，不妨以回抽中轨作为低吸买点，并以中轨作为其重要的止盈、止损线。</p>
<p>⑻飚升股往往股价会短期冲出布林线上轨运行，一旦冲出上轨过多，而成交量又无法持续放出，注意短线高抛了结，如果由上轨外回落跌破上轨，此时也是一个卖点。</p>
<p>(9)以下情况，SELL</p>
<p><img src="/2022/12/12/FOREX/image-20221215000243187.png" alt="image-20221215000243187"></p>
<h6 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h6><img src="/2022/12/12/FOREX/image-20221214230318897.png" alt="image-20221214230318897" style="zoom:50%;">

<p>市场有惯性 ：  超买时不要立刻卖，过一会儿； 超卖时不要立刻卖，过一会儿</p>
<h6 id="斐波那契Ratio"><a href="#斐波那契Ratio" class="headerlink" title="斐波那契Ratio"></a>斐波那契Ratio</h6><img src="/2022/12/12/FOREX/image-20221214230443488.png" alt="image-20221214230443488" style="zoom:50%;">

<p>最高点和最低点作为两端； 中间几个指标作为可能的买入或者卖出点</p>
<h4 id="基本面分析"><a href="#基本面分析" class="headerlink" title="基本面分析"></a>基本面分析</h4><p>基本上其他所有与价格和成交量量无关的东西都是基本面分析的一部分。</p>
<p>比如政治，利率，就业。GDP。贸易赤字，印刷</p>
<h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><p><img src="/2022/12/12/FOREX/image-20221215022824709.png" alt="image-20221215022824709"></p>
<p><img src="/2022/12/12/FOREX/image-20221215023131722.png" alt="image-20221215023131722"></p>
<h3 id="资金管理"><a href="#资金管理" class="headerlink" title="资金管理"></a>资金管理</h3><p>MaxMimum Loss per trade:  2%</p>
<p>公式：<code>((Max Loss $) / (Entry Price - Stop Loss Price)) / 100000 * Entry Price</code></p>
<p>网页：<code>https://www.myfxbook.com/forex-calculators/position-size</code></p>
<h3 id="交易分析"><a href="#交易分析" class="headerlink" title="交易分析"></a>交易分析</h3><p>知道如何分析你的历史成交并总结经验</p>
<p>先引入两个专有名词：</p>
<p><strong>Batting Average:</strong>  The percentage of trades that are profitable.<br><strong>Win&#x2F;Loss Ratio:</strong>  The ratio of the average profitable trades over the average un-profitable trades.</p>
<img src="/2022/12/12/FOREX/image-20221215212908243.png" alt="image-20221215212908243" style="zoom:50%;">

<p>需要制作分析的Excel表格</p>
<h3 id="实时交易"><a href="#实时交易" class="headerlink" title="实时交易"></a>实时交易</h3><p>挂单操作： 只有价格触发条件，订单才会执行</p>
<p>buy limit——买入限价，在当前价格下方挂买单（低价买入）</p>
<p>sell limit——卖出限价，在当前价格上方挂卖单（高价卖出）</p>
<p>buy stop——买入止损，在当前价格上方挂买单（高价买入）</p>
<p>sell stop——卖出止损，在当前价格下方挂卖单（低价卖出）</p>
<p>Buy stop:止损买进，是指在相对与目前现价而言高于现价的价格挂单的买进操作指令</p>
<p>stop：1.4410，那么当EURUSD上升到1.4410，你的买单才会成交，如果继续上扬，你将会盈利。</p>
<p>buy limit：限价买进，是指相对现价而言，低于现价的价格挂单的买进的操作指令。</p>
<p>limit：1.4300，当价格回落到1.4300，你的买单将会成交，如果价格上扬，你将会盈利。</p>
<p>sell stop：止损卖出，是指相对现价而言，低于现价的价格挂单的卖出操作指令。</p>
<p>stop：1.4290，那么当EURUSD下跌到1.4290，你的卖单才会成交，如果继续下跌，你将会盈利。</p>
<p>Sell limit：限价卖出，是指相对现价而言，高于现价的价格挂单的卖出操作指令。</p>
<h3 id="交易心理"><a href="#交易心理" class="headerlink" title="交易心理"></a>交易心理</h3><h2 id="FOREX量化"><a href="#FOREX量化" class="headerlink" title="FOREX量化"></a>FOREX量化</h2><h3 id="EA"><a href="#EA" class="headerlink" title="EA"></a>EA</h3><p>Expert Advisors (EAs) are programs that run on the MetaTrader 4 (MT4) platform, used to monitor and trade financial markets using algorithms. They find opportunities according to the parameters you set, then either notify you or open a position automatically.</p>
<h3 id="MetaQuotes报价-Language-4-MQL-4"><a href="#MetaQuotes报价-Language-4-MQL-4" class="headerlink" title="MetaQuotes报价 Language 4 (MQL 4)"></a>MetaQuotes报价 Language 4 (MQL 4)</h3><p>MetaQuotes L anguage 4 (MQL _4) is a built-in language for programming trading strategies (developed by MetaQuotes Ltd.).</p>
<p><strong>Using this language, you can create:</strong></p>
<ul>
<li><p>Expert Advisors 在某种意义上像一个脚本，区别是每次价格更新都会调用一段代码</p>
</li>
<li><p>Technical indicators 自定义指标</p>
</li>
<li><p>Scripts 只运行一次就结束，相当于简单版的EA</p>
</li>
<li><p>Libraries 函数库</p>
</li>
<li><p>include(*.mqh) 储存大量函数的文件，这些函数可以在代码的其他部分中被访问</p>
</li>
</ul>
<p>Doc：<a href="https://docs.mql4.com/cn">https://docs.mql4.com/cn</a></p>
<h4 id="iBands"><a href="#iBands" class="headerlink" title="iBands"></a>iBands</h4><p><img src="/2022/12/12/FOREX/image-20221218231307399.png" alt="image-20221218231307399"></p>
<p>运用：</p>
<p><img src="/2022/12/12/FOREX/image-20221219021340456.png" alt="image-20221219021340456"></p>
<p><img src="/2022/12/12/FOREX/image-20221219022526459.png" alt="image-20221219022526459"></p>
<p><img src="/2022/12/12/FOREX/image-20221221165149054.png" alt="image-20221221165149054"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//+------------------------------------------------------------------+</span><br><span class="line">//|                                                   HelloWorld.mq4 |</span><br><span class="line">//|                                                    Kong Jiangang |</span><br><span class="line">//|                                       https://kjgggggg.github.io |</span><br><span class="line">//+------------------------------------------------------------------+</span><br><span class="line">#property copyright &quot;Kong Jiangang&quot;</span><br><span class="line">#property link      &quot;https://kjgggggg.github.io&quot;</span><br><span class="line">#property version   &quot;1.00&quot;</span><br><span class="line">#property strict</span><br><span class="line">#include &lt;UsefulFuncs.mqh&gt;</span><br><span class="line"></span><br><span class="line">int bbPeriod = 20;</span><br><span class="line">int band1Std = 0.5;</span><br><span class="line">int band2Std = 3;</span><br><span class="line">//+------------------------------------------------------------------+</span><br><span class="line">//| Script program start function                                    |</span><br><span class="line">//+------------------------------------------------------------------+</span><br><span class="line">void OnStart()</span><br><span class="line">  &#123;</span><br><span class="line">//---</span><br><span class="line">    Alert(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">    double bbLower1 = iBands(NULL, 0, bbPeriod, band1Std, 0, PRICE_CLOSE, MODE_LOWER, 0);</span><br><span class="line">    double bbUpper1 = iBands(NULL, 0, bbPeriod, band1Std, 0, PRICE_CLOSE, MODE_UPPER, 0);</span><br><span class="line">    double bbMid = iBands(NULL, 0, bbPeriod, band1Std, 0, PRICE_CLOSE, 0, 0);</span><br><span class="line">    </span><br><span class="line">    double bbLower2 = iBands(NULL, 0, bbPeriod, band2Std, 0, PRICE_CLOSE, MODE_LOWER, 0);</span><br><span class="line">    double bbUpper2 = iBands(NULL, 0, bbPeriod, band2Std, 0, PRICE_CLOSE, MODE_UPPER, 0);</span><br><span class="line">    </span><br><span class="line">    if(Ask &lt; bbLower1) // buy</span><br><span class="line">    &#123;</span><br><span class="line">      double stopLossPrice = bbLower2;</span><br><span class="line">      double takeProfitPrice = bbMid;</span><br><span class="line">      </span><br><span class="line">      int orderId = OrderSend(NULL, OP_BUYSTOP, 0.01, Ask, 10, stopLossPrice, takeProfitPrice);</span><br><span class="line">      if(orderId &lt; 0) Alert(&quot;Error, Errorno is:&quot; + GetLastError());</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    else if(Bid &gt; bbUpper1)// sell</span><br><span class="line">    &#123;</span><br><span class="line">      double stopLossPrice = bbUpper2;</span><br><span class="line">      double takeProfitPrice = bbMid;</span><br><span class="line">            </span><br><span class="line">      int orderId = OrderSend(NULL, OP_BUYLIMIT, 0.01, Bid, 10, stopLossPrice, takeProfitPrice);</span><br><span class="line">      if(orderId &lt; 0) Alert(&quot;Error, Errorno is:&quot; + GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">//+------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>



<h4 id="tickValue"><a href="#tickValue" class="headerlink" title="tickValue"></a>tickValue</h4><p> quote currency 动一个pip（货币对的pip） 相当于你账户的货币动多少pip（USD的pip）</p>
<p><img src="/2022/12/12/FOREX/image-20221219200421712.png" alt="image-20221219200421712"></p>
<h4 id="计算符合风险的最佳lotSize"><a href="#计算符合风险的最佳lotSize" class="headerlink" title="计算符合风险的最佳lotSize"></a>计算符合风险的最佳lotSize</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算符合风险的最佳lotSize</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">OptimalLotSize</span><span class="params">(<span class="type">double</span> maxRiskPrc, <span class="type">int</span> maxLossInPips)</span> <span class="comment">// maxRiskPrc一般取0.02</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span> accEquity = <span class="built_in">AccountEquity</span>(); <span class="comment">// 计算账户余额：加上了未平仓的</span></span><br><span class="line">   <span class="type">double</span> lotSize = <span class="built_in">MarketInfo</span>(<span class="literal">NULL</span>, MODE_LOTSIZE); <span class="comment">// 你的broker可交易的最小lotsize</span></span><br><span class="line">   <span class="type">double</span> tickValue = <span class="built_in">MarketInfo</span>(<span class="literal">NULL</span>, MODE_TICKVALUE);</span><br><span class="line">   <span class="keyword">if</span>(Digits &lt;= <span class="number">3</span>) tickValue = tickValue / <span class="number">100</span>; <span class="comment">// 处理日元交易</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">double</span> maxLossDollar = accEquity * maxRiskPrc; </span><br><span class="line">   <span class="type">double</span> maxLossInQuoteCurr = maxLossDollar / tickValue;</span><br><span class="line">   <span class="type">double</span> optimalLotSize = <span class="built_in">NormalizeDouble</span>(maxLossInQuoteCurr/(maxLossInPips * <span class="built_in">GetPipValue</span>())/lotSize, <span class="number">2</span>);</span><br><span class="line">   <span class="keyword">return</span> optimalLotSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h3><h4 id="打印HelloWorld脚本"><a href="#打印HelloWorld脚本" class="headerlink" title="打印HelloWorld脚本"></a>打印HelloWorld脚本</h4><ol>
<li><img src="/2022/12/12/FOREX/image-20221217230210876.png" alt="image-20221217230210876" style="zoom:50%;">


</li>
<li><img src="/2022/12/12/FOREX/image-20221217230210876.png" alt="image-20221217230210876" style="zoom:50%;">


</li>
<li><img src="/2022/12/12/FOREX/image-20221217230417145.png" alt="image-20221217230417145" style="zoom: 31%;">


</li>
<li><img src="/2022/12/12/FOREX/image-20221217230917047.png" alt="image-20221217230917047" style="zoom:35%;"></li>
</ol>
<img src="/2022/12/12/FOREX/image-20221217230951823.png" alt="image-20221217230951823" style="zoom:95%;">



<ol start="5">
<li><p>下图是一个脚本成功执行一次的日志</p>
<img src="/2022/12/12/FOREX/image-20221217231720381.png" alt="image-20221217231720381" style="zoom:67%;"></li>
</ol>
<h3 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h3><p>view -&gt; Strategy tester</p>
<h2 id="Candle-Pattern"><a href="#Candle-Pattern" class="headerlink" title="Candle Pattern"></a>Candle Pattern</h2><h3 id="Single-Candle-Patterns"><a href="#Single-Candle-Patterns" class="headerlink" title="Single Candle Patterns"></a>Single Candle Patterns</h3><h4 id="Bullish-Hammer-看涨"><a href="#Bullish-Hammer-看涨" class="headerlink" title="Bullish Hammer 看涨"></a>Bullish Hammer 看涨</h4><ul>
<li>芯起码是蜡烛身体的2倍</li>
<li>Occurs at the bottom of a downward trend</li>
<li>结合RSI等</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114021219310.png" alt="image-20230114021219310" style="zoom: 50%;">

<h4 id="Inverted-Hammer-看涨"><a href="#Inverted-Hammer-看涨" class="headerlink" title="Inverted Hammer 看涨"></a>Inverted Hammer 看涨</h4><p>Inverted Hammer不应与Shooting Star混淆。这两种蜡烛的外观相似，但意义却大不相同。Shooting Star是一个看跌信号，出现在上升趋势的顶部，而Inverted Hammer是一个看涨信号，出现在下降趋势的底部。</p>
<img src="/2022/12/12/FOREX/image-20230114023231696.png" alt="image-20230114023231696" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114023254274.png" alt="image-20230114023254274" style="zoom:33%;">

<h4 id="Hanging-Man-看跌"><a href="#Hanging-Man-看跌" class="headerlink" title="Hanging Man 看跌"></a>Hanging Man 看跌</h4><ul>
<li><p>Uptrend</p>
</li>
<li><p>上方芯较短, 下方芯较长</p>
</li>
<li><p>下芯起码是蜡烛身体的2倍</p>
</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114022218065.png" alt="image-20230114022218065" style="zoom:33%;">

<ul>
<li>实盘 : H4</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114022922884.png" alt="image-20230114022922884" style="zoom:33%;">



<h4 id="Shooting-Star-看跌"><a href="#Shooting-Star-看跌" class="headerlink" title="Shooting Star 看跌"></a>Shooting Star 看跌</h4><ul>
<li>不算太可靠</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114024958886.png" alt="image-20230114024958886" style="zoom: 33%;">



<h4 id="Spinning-Top-涨-x2F-跌"><a href="#Spinning-Top-涨-x2F-跌" class="headerlink" title="Spinning Top 涨&#x2F;跌"></a>Spinning Top 涨&#x2F;跌</h4><ul>
<li>结合RSI</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114025226746.png" alt="image-20230114025226746" style="zoom:30%;">

<img src="/2022/12/12/FOREX/image-20230114025321911.png" alt="image-20230114025321911" style="zoom:33%;">

<h4 id="Doji-涨-x2F-跌"><a href="#Doji-涨-x2F-跌" class="headerlink" title="Doji 涨&#x2F;跌"></a>Doji 涨&#x2F;跌</h4><p><img src="/2022/12/12/FOREX/doji-candlestick-pattern_body_DojiTablefinal.png.full.png" alt="Doji variations table"></p>
<h3 id="Two-Candle-Patterns"><a href="#Two-Candle-Patterns" class="headerlink" title="Two Candle Patterns"></a>Two Candle Patterns</h3><h4 id="Engulfing-涨-x2F-跌"><a href="#Engulfing-涨-x2F-跌" class="headerlink" title="Engulfing  涨&#x2F;跌"></a>Engulfing  涨&#x2F;跌</h4><ul>
<li>需要确认框外右边第一根蜡烛close价格是否低&#x2F;高于前一根close价格</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230113214945257.png" alt="image-20230113214945257" style="zoom: 33%;">



<h4 id="Harami-涨-x2F-跌"><a href="#Harami-涨-x2F-跌" class="headerlink" title="Harami 涨&#x2F;跌"></a>Harami 涨&#x2F;跌</h4><ul>
<li>需要确认第三根蜡烛</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230113215209111.png" alt="image-20230113215209111" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230113215235627.png" alt="image-20230113215235627" style="zoom: 33%;">



<h4 id="Piercing-看涨"><a href="#Piercing-看涨" class="headerlink" title="Piercing  看涨"></a>Piercing  看涨</h4><ul>
<li>Traders can look to trade more traditional trending markets such as the GBP&#x2F;USD or EUR&#x2F;USD</li>
<li>需要结合RSI,在相对低的位置,或者图标趋势趋于横向而非纵向</li>
<li>需要前红后绿</li>
<li>只能用于看多</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230113215420690.png" alt="image-20230113215420690" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230113215439134.png" alt="image-20230113215439134" style="zoom:50%;">



<h4 id="Dark-Cloud-看跌"><a href="#Dark-Cloud-看跌" class="headerlink" title="Dark Cloud 看跌"></a>Dark Cloud 看跌</h4><ul>
<li><p>Traders can look to trade more traditional trending markets such as the GBP&#x2F;USD or EUR&#x2F;USD</p>
</li>
<li><p>需要结合RSI在相对高的位置, 或者图标趋势趋于横向而非纵向</p>
</li>
<li><p>需要前绿后红</p>
</li>
<li><p>只能用于看空</p>
</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230113215656564.png" alt="image-20230113215656564" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230113215710055.png" alt="image-20230113215710055" style="zoom:33%;">

<h3 id="Three-Candle-Patterns"><a href="#Three-Candle-Patterns" class="headerlink" title="Three Candle Patterns"></a>Three Candle Patterns</h3><h4 id="Morning-Star-看涨"><a href="#Morning-Star-看涨" class="headerlink" title="Morning Star 看涨"></a>Morning Star 看涨</h4><img src="/2022/12/12/FOREX/image-20230114013651877.png" alt="image-20230114013651877" style="zoom: 33%;">

<ul>
<li>条件 ( 5. After a successful reversal, traders will observe higher highs and higher lows )</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114014059868.png" alt="image-20230114014059868" style="zoom:33%;">



<ul>
<li>实盘</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114014416916.png" alt="image-20230114014416916" style="zoom:33%;">

<h4 id="Evening-Star-看跌"><a href="#Evening-Star-看跌" class="headerlink" title="Evening Star 看跌"></a>Evening Star 看跌</h4><img src="/2022/12/12/FOREX/image-20230114014826363.png" alt="image-20230114014826363" style="zoom:33%;">

<ul>
<li>条件</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114014915711.png" alt="image-20230114014915711" style="zoom:33%;">

<ul>
<li>实盘</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114015019685.png" alt="image-20230114015019685" style="zoom:33%;">



<h3 id="Advanced-Candle-Patterns"><a href="#Advanced-Candle-Patterns" class="headerlink" title="Advanced Candle Patterns"></a>Advanced Candle Patterns</h3><h4 id="Long-Wick"><a href="#Long-Wick" class="headerlink" title="Long Wick"></a>Long Wick</h4><img src="/2022/12/12/FOREX/image-20230114154945649.png" alt="image-20230114154945649" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114155040908.png" alt="image-20230114155040908" style="zoom:33%;">

<h4 id="Inside-Bar"><a href="#Inside-Bar" class="headerlink" title="Inside Bar"></a>Inside Bar</h4><img src="/2022/12/12/FOREX/image-20230114160107999.png" alt="image-20230114160107999" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114162156480.png" alt="image-20230114162156480" style="zoom:33%;">



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">看涨</th>
<th align="left">看跌</th>
<th>都行</th>
<th>延续之前趋势</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bullish Hammer  <img src="/2022/12/12/FOREX/image-20230114031941230.png" alt="image-20230114031941230" style="zoom:5%;"></td>
<td align="left">Hanging Man <img src="/2022/12/12/FOREX/image-20230114032236370.png" alt="image-20230114032236370" style="zoom:5%;"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">Inverted Hammer  <img src="/2022/12/12/FOREX/image-20230114032052638.png" alt="image-20230114032052638" style="zoom:5%;"></td>
<td align="left">Shooting Star <img src="/2022/12/12/FOREX/image-20230114032427754.png" alt="image-20230114032427754" style="zoom:5%;"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Spinning Top</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Doji</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Engulfing</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Harami</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Piercing &#x2F; DarkCloud</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Morning &#x2F; Evening Stars</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Long Wick</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td>Inside Bar</td>
<td>Inside Bar</td>
</tr>
</tbody></table>
<h2 id="Chart-Pattern"><a href="#Chart-Pattern" class="headerlink" title="Chart Pattern"></a>Chart Pattern</h2><h3 id="Rising-Wedge-看跌"><a href="#Rising-Wedge-看跌" class="headerlink" title="Rising Wedge  看跌"></a>Rising Wedge  看跌</h3><ul>
<li>在进入楔型后成交量要持续下降</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114164053345.png" alt="image-20230114164053345" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114164219478.png" alt="image-20230114164219478" style="zoom:33%;">

<h3 id="Falling-Wedge-看涨"><a href="#Falling-Wedge-看涨" class="headerlink" title="Falling Wedge 看涨"></a>Falling Wedge 看涨</h3><ul>
<li>预示着牛市 </li>
<li>在进入楔型后成交量要持续下降</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114164438479.png" alt="image-20230114164438479" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114164628395.png" alt="image-20230114164628395" style="zoom:33%;">

<h3 id="Cup-and-Handle-延续"><a href="#Cup-and-Handle-延续" class="headerlink" title="Cup and Handle 延续"></a>Cup and Handle 延续</h3><img src="/2022/12/12/FOREX/image-20230114170000196.png" alt="image-20230114170000196" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114165941227.png" alt="image-20230114165941227" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114170601670.png" alt="image-20230114170601670" style="zoom:33%;">

<h3 id="Pennant-延续"><a href="#Pennant-延续" class="headerlink" title="Pennant 延续"></a>Pennant 延续</h3><ul>
<li><p>同对称三角</p>
</li>
<li><p>类似Inside Bar</p>
</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114171239573.png" alt="image-20230114171239573" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114171857240.png" alt="image-20230114171857240" style="zoom:50%;">

<h3 id="Rectangle-延续"><a href="#Rectangle-延续" class="headerlink" title="Rectangle 延续"></a>Rectangle 延续</h3><img src="/2022/12/12/FOREX/image-20230114172727197.png" alt="image-20230114172727197" style="zoom:40%;">

<img src="/2022/12/12/FOREX/image-20230114173326037.png" alt="image-20230114173326037" style="zoom:50%;">



<h3 id="Triangle-延续"><a href="#Triangle-延续" class="headerlink" title="Triangle 延续"></a>Triangle 延续</h3><img src="/2022/12/12/FOREX/image-20230114173721193.png" alt="image-20230114173721193" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114174306978.png" alt="image-20230114174306978" style="zoom: 33%;">

<img src="/2022/12/12/FOREX/image-20230114174410948.png" alt="image-20230114174410948" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114174345356.png" alt="image-20230114174345356" style="zoom:33%;">

<h3 id="Bull-Flag-amp-Bear-Flag"><a href="#Bull-Flag-amp-Bear-Flag" class="headerlink" title="Bull Flag &amp; Bear Flag"></a>Bull Flag &amp; Bear Flag</h3><ul>
<li>Bull Flag</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114174653999.png" alt="image-20230114174653999" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114174725085.png" alt="image-20230114174725085" style="zoom:33%;">



<ul>
<li>Bear Flag</li>
</ul>
<img src="/2022/12/12/FOREX/image-20230114175012546.png" alt="image-20230114175012546" style="zoom:33%;">

<img src="/2022/12/12/FOREX/image-20230114175101985.png" alt="image-20230114175101985" style="zoom:33%;">
]]></content>
      <categories>
        <category>FOREX</category>
      </categories>
      <tags>
        <tag>FOREX</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高性能服务器编程</title>
    <url>/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装了远程连接服务器的工具,操作它就不要打开再操作了	<code>sudo yum install openssh-server</code></p>
<p>查看虚拟机ip地址	<code>ifconfig</code> </p>
<p>登录该虚拟机	<code>ssh kjg@172.16.208.128</code></p>
<p>利用Vscode远程连接该虚拟机</p>
<h4 id="Gcc编译"><a href="#Gcc编译" class="headerlink" title="Gcc编译"></a>Gcc编译</h4><h5 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h5><p>GCC 原名为 GNU C语言编译器（GNU C Compiler）</p>
<p>可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个C 标准。如，当使用 <code>-std = c99</code>启动 GCC时，编译器支持 C99 标准</p>
<h5 id="GCC命令"><a href="#GCC命令" class="headerlink" title="GCC命令"></a>GCC命令</h5><p>安装命令 <code>sudo yum install gcc g++ </code>（版本＞4.8.5）</p>
<p>查看版本 <code>gcc / g++ -v / --version</code></p>
<p>预处理指定的源文件,不进行编译[ .c -&gt; .i ]	<code>gcc test.c -E -o test.i</code></p>
<p>编译指定的源文件,但是不进行汇编[ .i -&gt; .s ]	<code>gcc test.i -S -o test.s</code></p>
<p>编译,汇编指定的源文件,但不进行链接[ .s -&gt; .o ]	<code>gcc test.s -c -o test.o</code></p>
<p>编译生成可执行文件[ .c -&gt; .out ]	<code>gcc test.c -o app</code>	如果<code>gcc test.c</code>则生成一个默认的<code>a.out</code>文件</p>
<p>运行	<code>./app</code> 或 <code>./a.out</code></p>
<h5 id="GCC工作流程"><a href="#GCC工作流程" class="headerlink" title="GCC工作流程"></a>GCC工作流程</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221026150832523.png" alt="image-20221026150832523" style="zoom:50%;">



<h5 id="gcc与g-区别"><a href="#gcc与g-区别" class="headerlink" title="gcc与g++区别"></a>gcc与g++区别</h5><p>gcc编译c文件，g++编译c++文件</p>
<p>编译可以用<code>gcc / g++</code> 链接可用 <code>g++</code> 或者 <code>gcc -lstdc++</code></p>
<h4 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h4><h5 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h5><ul>
<li><p>库是特殊的一种程序，提供给使用者一些可以直接拿来用的变量、函数或类,编写库的程序和编写一般的程序区别不大，只是库不能单独运待。</p>
</li>
<li><p>库文件有两种，静态库和动态库(共享库)区别是:</p>
<p>静态库在程序的链接阶段被复制到了程序中;</p>
<p>动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
</li>
<li><p>库的好处: 1.代码保密  2.方便部署和分发</p>
</li>
</ul>
<h5 id="静态库的命名规则"><a href="#静态库的命名规则" class="headerlink" title="静态库的命名规则"></a>静态库的命名规则</h5><p>Linux:	<code>libxxx.a</code>	(lib是固定前缀	a是固定后缀	中间的xxx是库名)</p>
<p>Windows:	<code>libxxx.lib</code></p>
<h5 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h5><ol>
<li><p><code>gcc - c</code>获得.o文件</p>
</li>
<li><p>将.o文件打包,使用ar工具(archive)    </p>
<p><code>ar rcs libxxx.a xxx.o xxx.o</code>		r是将文件插入备存文件(在这里是库文件)中 c是建立备存文件 s是索引</p>
</li>
</ol>
<h5 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a><a href="https://blog.csdn.net/qq_56673429/article/details/124168013">静态库的使用</a></h5><p>得到了一个可用的静态库之后，将其与相应的头文件放到一个目录中(就相当于发布了)，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。</p>
<p>这里我把生成的静态库和相应的头文件放到temp文件夹中进行测试。<br>这里我们会用到gcc的两个参数</p>
<p>-l 	在程序编译的时候，指定使用的库。（静态库的名字一定要掐头去尾。如：libCalc.a变为Calc）<br>-L 	在程序编译的时候，指定使用的库的路径。</p>
<p>如:	<code>gcc main.c -o Calc -L ./ -l Calc</code> [第一个Calc是生成的可执行文件名]</p>
<p>运行:	<code>./Calc</code></p>
<h5 id="动态库的命名规则"><a href="#动态库的命名规则" class="headerlink" title="动态库的命名规则"></a>动态库的命名规则</h5><p>Linux:	<code>libxxx.so</code> 	lib:前缀(固定)	xxx ：库的名字，自己起 	so:后缀（固定）	在Linux下是一个可执行文件 </p>
<p>Windows:	<code>libxxx.dll</code></p>
<h5 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h5><p>gcc 得到.o文件，得到和位置无关的代码	 <code>gcc -c -fpic/-fPIC a.c b.c</code><br>gcc 得到动态库	<code>gcc －shared a.o b.o -o libcalc.so</code></p>
<h5 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h5><p>库文件是src里源文件的定义，头文件是src里源文件的声明；使用时需要将库文件和头文件都分发给src里的文件们</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028142406885.png" alt="image-20221028142406885" style="zoom:50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要将使用的库文件拷贝到当前lib目录下</span></span><br><span class="line">gcc main.c -o main -I include/ -L /lib -l calc   </span><br><span class="line"><span class="comment"># -I include/ 是为了找到head.h  	-L /lib是为了找到库文件的目录		-l calc是为了指定库文件名</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028143032281.png" alt="image-20221028143032281" style="zoom:50%;"> 



<h5 id="动态库加载失败的原因"><a href="#动态库加载失败的原因" class="headerlink" title="动态库加载失败的原因"></a>动态库加载失败的原因</h5><ul>
<li><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中</p>
</li>
<li><p>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中</p>
</li>
<li><p>程序启动之后，动态库会被动态加载到内存中，通过 <code>ldd </code> 命令检查动态库依赖关系 在上例中就是 <code>ldd main</code></p>
</li>
<li><p>如何定位共享库文件呢？</p>
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于<code>elf</code>格式的可执行程序，是由<code>ld-linux.so</code>来完成的，它先后搜索<code>elf</code>文件的 <code>DT_RPATH段</code>→<code>环境变量 LD_LIBRARY_PATH</code>→<code>/etc/1d.so.cache文件列表</code>→<code>/lib/</code>或<code>／usr/lib</code>目录找到库文件后将其载入内存。</p>
</li>
<li><p>解决动态库加载失败方式</p>
<ol>
<li>配置环境变量[一次性的,临时的]</li>
</ol>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028154045633.png" alt="image-20221028154045633"></p>
<ol start="2">
<li>在 <code>.bashrc</code>里配置 同图上同样内容	后输入<code>source .bashrc</code></li>
<li>在<code>/etc/profile</code>里配置 同图上同样内容    后输入<code>source /etc/profile</code></li>
</ol>
</li>
</ul>
<h5 id="动静态库优缺点"><a href="#动静态库优缺点" class="headerlink" title="动静态库优缺点"></a>动静态库优缺点</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160925281.png" alt="image-20221028160925281" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028160951754.png" alt="image-20221028160951754" style="zoom: 33%;">





<h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><h5 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h5><ul>
<li><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shel1 脚本一样,也可以执行操作系统的命令</p>
</li>
<li><p>Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令[是Makefile的启动器]，整个工程完全自动编译，极大提高了软件开发效率。</p>
</li>
<li><p>make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi的make，Visual C++的 nmake，Linux下 GNU的make</p>
</li>
</ul>
<h5 id="Makefile文件命名和规则"><a href="#Makefile文件命名和规则" class="headerlink" title="Makefile文件命名和规则"></a>Makefile文件命名和规则</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028163708993.png" alt="image-20221028163708993" style="zoom: 50%;">

<p>例1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Makefile <span class="comment"># 不管当前目录有没有Makefile , 只要有你想编译的.c文件就行</span></span><br><span class="line"></span><br><span class="line">================================================</span><br><span class="line">app : add.c	sub.c	multi.c	div.c	main.c</span><br><span class="line">	gcc add.c	sub.c	multi.c	div.c	main.c -o app</span><br><span class="line">================================================</span><br><span class="line"></span><br><span class="line">make <span class="comment"># sudo yum install make</span></span><br></pre></td></tr></table></figure>

<p>例2:</p>
<p>如果第一个规则的依赖在当前目录暂时找不到, 那就往后查找看后面的规则的目标是否有满足的</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028172215221.png" alt="image-20221028172215221" style="zoom:50%;">

<p>但这样写太繁琐,	 如何简化呢?	下面引入变量和模式匹配和函数</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><h6 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h6><p>变量名＝ 变量值 	<code>var = hello</code></p>
<h6 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h6><p>AR 	归档维护程序的名称，默认值为 <code>ar</code></p>
<p>CC	C编译器的名称，默认值为 <code>cc</code></p>
<p>CXX	C＋＋编译器的名称，默认值为 <code>g++</code></p>
<p>$@	目标的完整名称</p>
<p>$&lt;	第一个依赖文件的名称</p>
<p>$^	所有的依赖文件</p>
<h6 id="获取变量的值"><a href="#获取变量的值" class="headerlink" title="获取变量的值"></a>获取变量的值</h6><p>＄（变量名）	如<code>$(var)</code></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174622965.png" alt="image-20221028174622965"></p>
<h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028174905118.png" alt="image-20221028174905118" style="zoom:50%;">



<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h6><p>获取指定目录下指定类型的文件列表</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175247985.png" alt="image-20221028175247985"></p>
<h6 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028175559945.png" alt="image-20221028175559945" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221028180448158.png" alt="image-20221028180448158" style="zoom:50%;">



<h4 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h4><h5 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h5><p>GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，是Linux和许多类Unix系统中的标准开发环境。</p>
<p>一般来说，GDB主要帮助你完成下面四个方面的功能:</p>
<ol>
<li><p>启动程序，可以按照自定义的要求随心所欲的运行程序</p>
</li>
<li><p>可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)</p>
</li>
<li><p>当程序被停住时，可以检查此时程序中所发生的事</p>
</li>
<li><p>可以改变程序，将一个BUG产生的影响修正从而测试其他BUG</p>
</li>
</ol>
<h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><ul>
<li><p>通常，在为调试而编译时，我们会关掉编译器的优化选项(-o)，并打开调试选项(-g)</p>
<p>  另外，<code>-Wall</code>可以在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p>
</li>
<li><p><code>gcc -g -Wall program.c -o program</code></p>
</li>
<li><p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文</p>
<p>  件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p>
</li>
</ul>
<h5 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h5><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h5 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h5><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h5 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h5><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	(每次调试时(输入n, s), 如果a, b值发生变化的话, 自动打印指定变量(在这里是a, b)的值)</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<h4 id="Linux文件IO"><a href="#Linux文件IO" class="headerlink" title="Linux文件IO"></a>Linux文件IO</h4><ul>
<li><p>文件角度:	输入: 内存 -&gt; 文件	输出: 文件 -&gt; 内存	</p>
</li>
<li><p>内存角度:	输入: 文件 -&gt; 内存	输出: 内存 -&gt; 文件	【我们通常站在内存角度】</p>
</li>
</ul>
<h5 id="标准C库文件函数"><a href="#标准C库文件函数" class="headerlink" title="标准C库文件函数"></a>标准C库文件函数</h5><p>标准C库函数是带缓冲区的， <strong>Linux文件操作时可选用C库函数，效率更好。 网络通信时使用Linux自己的库函数，效率更好</strong></p>
<p>C语言写出的程序可以跨平台运行的原因是C库函数继续调用各系统的库函数</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029165648092.png" alt="image-20221029165648092" style="zoom:50%;">



<h5 id="标准C库IO和LinuxIO的区别"><a href="#标准C库IO和LinuxIO的区别" class="headerlink" title="标准C库IO和LinuxIO的区别"></a>标准C库IO和LinuxIO的区别</h5><p>即 C库IO <strong>调用</strong> LinuxIO</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029171653493.png" alt="image-20221029171653493" style="zoom:50%;">



<h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><ul>
<li><p>它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）</p>
</li>
<li><p>一个进程一个虚拟地址空间，该空间会被MMU映射到真实的内存中（以32位机器举例）</p>
</li>
<li><p>大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等</p>
</li>
<li><p>内核区可以通过调用Linux的API访问</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221029172431281.png" alt="image-20221029172431281" style="zoom:50%;">



<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>负责 索引到对应的磁盘文件</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030145918168.png" alt="image-20221030145918168" style="zoom:50%;">







<h4 id="LInux系统函数"><a href="#LInux系统函数" class="headerlink" title="LInux系统函数"></a>LInux系统函数</h4><blockquote>
<p>   帮助文档 ：</p>
<p>  <code>man 2 关键词</code></p>
<p>  <code>关键词 --help</code></p>
</blockquote>
<h5 id="errno-amp-perror"><a href="#errno-amp-perror" class="headerlink" title="errno &amp; perror"></a>errno &amp; perror</h5><p><code>errno</code>	 记录错误号</p>
<p><code>void perror(const string *s)</code>	打印错误描述</p>
<h5 id="open-amp-close"><a href="#open-amp-close" class="headerlink" title="open &amp; close"></a>open &amp; close</h5><p><code>int open (const char *pathname, int flags);</code>	打开一个已经存在的文件， 返回一个新的文件描述符 FILE *</p>
<blockquote>
<p>  pathname 要打开的文件路径</p>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code> <code>O_WRONLY``O_RDWR</code></p>
<p>  使用:	 <code>int fd = open(&quot;a.txt&quot;, O_RDONLY);</code></p>
</blockquote>
<p><code>int open (const char *pathname, int flags, mode_t mode);</code>	创建一个新的文件</p>
<blockquote>
<p>  flags 对文件的操作权限设置 有三个:	<code> O_RDONLY</code> <code>O_WRONLY</code> <code>_RDWR</code>  这里多一个可选项 <code>O_CREAT</code>: 文件不存在， 创建新文件</p>
<p>  mode:	八进制权限码，一定是在flags中使用了O_CREAT标志，mode记录待创建的文件的访问权限</p>
<p>  如<code>fd = open(&quot;./file1&quot;, O_RDWR|O_CREAT, 0600);</code></p>
</blockquote>
<p><code>int close (int fd);</code></p>
<h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<blockquote>
<p>  fd	为文件描述符；buf	表示读出数据缓冲区地址；count	表示要读出的字节数。</p>
<p>  返回值：若读取成功，则返回读到的字节数；若失败，返回-1；若已达到文件尾，则返回0。因此读到的字节数可能小于count的值</p>
</blockquote>
<h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p><code>ssize_t write (int fd, const void *buf, size_t count);</code></p>
<h5 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h5><p>在程序中，在调用read函数之前，先调用了close函数和open函数，这是为了让光标移到文件的头，否则将读取失败。因此，就还需要用到lseek函数来移动文件中光标的位置。通过调用lseek函数可以改变光标的位置，其函数原型为</p>
<p><code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<blockquote>
<p>  其中，fd为文件描述符；offset指的是每一次读写操作所需移动距离，以字节为单位 ，可正可负，正值表示想文件尾部移动，负值表示向文件头部移动。whence表示当前位置的基点，主要有以下三个基点符号常量。</p>
<p>  SEEK_SEK	将光标移到距离文件头前后offset个字节；</p>
<p>  SEEK_CUR	将光标移到当前位置前后offset个字节；</p>
<p>  SEEK_END	将光标移到文件末尾前后offset个字节。</p>
<ul>
<li>除此之外,lseek函数还可以用来计算文件大小，因为他的返回值是以字节为单位，从文件的起始点开始计算到当前位置的字节数</li>
<li><code>int size_of_file = lseek(fd, 0, SEEK_END);</code></li>
</ul>
</blockquote>
<h5 id="stat-amp-lstat"><a href="#stat-amp-lstat" class="headerlink" title="stat &amp; lstat"></a>stat &amp; lstat</h5><p>stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细</p>
<p><a href="https://blog.csdn.net/carefree2005/article/details/122454333">stat</a>	<code>int stat(const char *pathname, struct stat *buf);</code>	(使用时要先<code>struct stat st;</code> 传入<code>&amp;st</code>)</p>
<p><a href="https://blog.csdn.net/W1024201/article/details/125118032">lstat</a>	<code>int lstat(const char *pathname, struct stat buf);</code></p>
<blockquote>
<p>  stat	获取链接文件的信息时，具有穿透能力，直接穿越链接文件，获取所被链接文件的信息。</p>
<p>  lstat	获取链接文件的信息，无穿透能力</p>
<p>  st.st_mode	获取到的部分文件信息用st.st_mode 与下面这13个码分别相与得到，第一个&amp;得出4位，后面的每个&amp;得出1位</p>
<p>  st.st_xxx	其他的所有属性也在这里面，到时查手册即可</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221030193146766.png" alt="image-20221030193146766" style="zoom:50%;">



<h4 id="Linux文件属性操作函数"><a href="#Linux文件属性操作函数" class="headerlink" title="Linux文件属性操作函数"></a>Linux文件属性操作函数</h4><h5 id="access"><a href="#access" class="headerlink" title="access"></a>access</h5><p><code>int access(const char* pathname, int mode);</code></p>
<blockquote>
<p>  返回值：成功0，失败-1</p>
<p>  mode：指定access的作用，取值如下</p>
<ol>
<li>F_OK 值为0，判断文件是否存在</li>
<li>X_OK 值为1，判断对文件是可执行权限</li>
<li>W_OK 值为2，判断对文件是否有写权限</li>
<li>R_OK 值为4，判断对文件是否有读权限</li>
</ol>
<p>   注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</p>
</blockquote>
<h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p><code>int chmod(const char* filename ,int mode);</code></p>
<p><code>chmod [-cfvR] [--help] [--version] mode file</code>	其中<code>mode</code>格式 : <code>[ugoa] [+ - =] [rwxX] [ ,... ]</code></p>
<blockquote>
<p>  <code>u</code> 表示该档案的拥有者，<code>g</code>表示与该档案的拥有者属于同一个群体(group)者，<code>o </code>表示其他以外的人，<code>a</code> 表示这三者皆是。</p>
<p>  <code>+</code>表示增加权限、<code>-</code> 表示取消权限、<code>=</code> 表示唯一设定权限。</p>
<p>  <code>r </code>表示可读取，<code>w</code> 表示可写入，<code>x</code> 表示可执行，<code>X</code> 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</p>
<p>  -c 	若该档案权限确实已经更改，才显示其更改动作</p>
<p>  -f 	若该档案权限无法被更改也不要显示错误讯息</p>
<p>  -v 	显示权限变更的详细资料</p>
<p>  -R 	对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</p>
<p>  –help	显示辅助说明</p>
<p>  –version	显示版本</p>
</blockquote>
<blockquote>
<p>  <code>chmod ugo+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod a+r file1.txt </code>	将档案 file1.txt 设为所有人皆可读取 :</p>
<p>  <code>chmod ug+w,o-w file1.txt file2.txt </code>	将档案 file1.txt 与 file2.txt 设为该档案拥有者与其同组可写入，其他人不可写入 </p>
<p>  <code>chmod u+x ex1.py </code>	将 ex1.py 设定为只有该档案拥有者可以执行 </p>
<p>  <code>chmod -R a+r * </code>	将目前目录下的所有档案与子目录皆设为任何人可读取 </p>
<p>  <code>chmod ug=rwx,o=x file </code>	设置该档案拥有者与其同组可读写执行，其他人只能执行</p>
</blockquote>
<h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p><code>int chown(const char *path, uid_t owner, gid_t group);</code></p>
<p><code>chown [参数] user[:group] [文件]</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>新的文件拥有者的使用者 ID</td>
</tr>
<tr>
<td>group</td>
<td>新的文件拥有者的使用者组(group)</td>
</tr>
<tr>
<td>-c</td>
<td>显示更改的部分的信息</td>
</tr>
<tr>
<td>-f</td>
<td>忽略错误信息</td>
</tr>
<tr>
<td>-h</td>
<td>-h 改变的是链接文件属主， 不加-h改变的是链接源文件属主</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>-R</td>
<td>处理指定目录以及其子目录下的所有文件</td>
</tr>
<tr>
<td>–help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<p>以下选项修改了在还指定了-R选项时遍历层次结构的方式。如果指定了多个，则只有最后一个生效。</p>
<blockquote>
<p>  -H 如果命令行参数是指向目录的符号链接，则遍历它</p>
<p>  -L 遍历遇到的每个指向目录的符号链接</p>
<p>  -P 不遍历任何符号链接（默认）</p>
</blockquote>
<h5 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h5><p><code>int truncate(const char *path, off_t length);</code></p>
<p><code>truncate OPTION... FILE...</code>	命令可以将一个文件缩小或者扩展到某个给定的大小.可以用-s选项来指定文件的大小</p>
<blockquote>
<p>  -c	do not create any files</p>
<p>  -o	treat SIZE as number of IO blocks instead of bytes</p>
<p>  -r	base size on RFILE</p>
<p>  -s	set or adjust the file size by SIZE bytes</p>
<p>  –help </p>
<p>  –version</p>
</blockquote>
<h4 id="Linux目录操作函数"><a href="#Linux目录操作函数" class="headerlink" title="Linux目录操作函数"></a>Linux目录操作函数</h4><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p><code>int mkdir (const char *pathname, mode_t mode) ;</code></p>
<h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h5><p><code>int rmdir (const char *pathname) ;</code></p>
<h5 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h5><p><code>int rename (const char *oldname, const char* newname) ;</code></p>
<h5 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h5><p><code>char *getcwd (char *buf,size_t size) ;</code></p>
<blockquote>
<p>  getcwd	会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</p>
</blockquote>
<h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h5><p><code>DIR* opendir (const char* name) ;</code></p>
<blockquote>
<p>  打开一个目录并建立一个目录流</p>
<p>  如果打开成功的话返回一个DIR结构的指针,该指针用于读取目录数据项。</p>
<p>  如果失败的话返回一个空指针如果文件中的文件过多也可能打开失败</p>
</blockquote>
<h5 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h5><p><code>int chdir (const char* path) ;</code></p>
<blockquote>
<p>  改变当前工作目录</p>
</blockquote>
<h5 id="readir"><a href="#readir" class="headerlink" title="readir"></a>readir</h5><p><code>struct dirent* readdir (DIR* dirp) ;</code></p>
<blockquote>
<p>  返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h5><p><code>int closedir (DIR* dirp) ;</code></p>
<h4 id="dup-amp-dup2"><a href="#dup-amp-dup2" class="headerlink" title="dup &amp; dup2"></a>dup &amp; dup2</h4><p><code>int dup(int oldfd) ;</code></p>
<blockquote>
<p>  在 Linux 系统中， open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具 有读写权限；在 Linux 系统下，可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制。我们来学习下两个函数的用法以及它们之间的区别。</p>
<p>  复制得到的文件描述符与旧的文件描述符都指向了同一个文件表，假设 fd1 为原文件描述符， fd2 为复制得到的文件描述符，如下图所示：</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VwZXJzbWFydEA=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>  因为复制得到的文件描述符与旧的文件描述符指向的是同一个文件表，所以可知，这两个文件描述符的 属性是一样，譬如对文件的读写权限、文件状态标志、文件偏移量等，所以从这里也可知道“复制”的含义实则是复制文件表。同样，在使用完毕之后也需要使用 close 来关闭文件描述符。</p>
<p>  例子：若fd 等于 3 ，复制得到的新的文件描述符为可能为 5</p>
</blockquote>
<p><code>int dup2(int oldfd, int newfd);</code></p>
<blockquote>
<p>  oldfd ： 需要被复制的文件描述符。<br>  newfd ： 指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>  返回值： 成功时将返回一个新的文件描述符，即手动指定的文件描述符 newfd ；如复制失败将返回-1 ，并且会设置 errno 值。</p>
</blockquote>
<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><p><code>int fcntl(int fd, int cmd);</code></p>
<p><code>int fcntl(int fd, int cmd, long arg);</code></p>
<p><code>int fcntl(int fd, int cmd ,struct flock* lock);</code></p>
<blockquote>
<p>  fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</p>
<p>  执行失败返回-1 否则返回&gt;0</p>
<p>  cmd参数对应功能如下:</p>
<p>  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Center.png" alt="img"></p>
<p>  记录锁：实现只锁文件的某个部分，并且可以灵活的选择是阻塞方式还是立刻返回方式</p>
<p>  当fcntl用于管理文件记录锁的操作时，第三个参数指向一个struct flock *lock的结构体</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">flock</span> &#123;</span><br><span class="line">  short_l_type;    <span class="comment">/*锁的类型*/</span></span><br><span class="line">   short_l_whence;  <span class="comment">/*偏移量的起始位置：SEEK_SET,SEEK_CUR,SEEK_END*/</span></span><br><span class="line">   off_t_l_start;   <span class="comment">/*加锁的起始偏移*/</span></span><br><span class="line">   off_t_l_len;    <span class="comment">/*上锁字节*/</span></span><br><span class="line">   pid_t_l_pid;   <span class="comment">/*锁的属主进程ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Linux-多进程开发"><a href="#Linux-多进程开发" class="headerlink" title="Linux 多进程开发"></a>Linux 多进程开发</h3><h4 id="程序和进程概述"><a href="#程序和进程概述" class="headerlink" title="程序和进程概述"></a>程序和进程概述</h4><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB (Processing Control Block) 进程控制块，维护进程相关的信息。</p>
<p>Linux内核的进程控制块是<code>task_struct</code> 结构体。在<code>/usr/src/linux-headers-xxx/include/linux/sched.h</code>文件中可以查看其定义</p>
<p>其内部成员有很多，我们只需要掌握以下部分即可:</p>
<blockquote>
<p>  进程id:系统中每个进程有唯一的id, 用pid_t类型表示, 其实就是一个非负整数</p>
<p>  进程的状态:有就绪、运行、挂起、停止等状态</p>
<p>  进程切换时需要保存和恢复的一些CPU寄存器</p>
<p>  描述虚拟地址空间的信息</p>
<p>  描述控制终端的信息</p>
<p>  当前工作目录(Current Working Directory)</p>
<p>  umask掩杩</p>
<p>  文件描述符表, 包含很多指向file结构体的指针**(一个进程一个虚拟地址空间,该虚拟空间内核区有个PCB, PCB里有文件描述符表)**</p>
<p>  和信号相关的信息</p>
<p>  用户id和组id</p>
<p>  会话 (Session) 和 进程组</p>
<p>  进程可以使用的资源上限(Resource Limit)</p>
</blockquote>
<h5 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221031215037224.png" alt="image-20221031215037224" style="zoom: 67%;">



<h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h5><p><code>tty</code>	显示当前终端</p>
<h5 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h5><p><code>ulimit -a</code>	查看系统中所有资源使用情况</p>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p><code>ps -aux /ajx</code>	查看进程</p>
<blockquote>
<p>  a: 显示终端上的所有进程，包括其他用户的进程<br>  u: 显示进程的详细信息<br>  x: 显示没有控制终端的进程<br>  j: 列出与作业控制相关的信息</p>
</blockquote>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p><code>top</code>	实时显示进程动态</p>
<p>可以在使用top命令时加上-d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示的结果进行排序:</p>
<blockquote>
<p>  M	根据内存使用量排序<br>  P	根据CPU占有率排序<br>  T	根据进程运行时间长短排序<br>  U	根据用户名来筛选进程.<br>  K	输入指定的PID杀死进程</p>
</blockquote>
<h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p><code>kill [-选项] pid</code>	杀死进程</p>
<blockquote>
<p>  kill -l	列出所有可选选项</p>
<p>  -9	强制杀死进程</p>
</blockquote>
<h5 id="获取pid函数"><a href="#获取pid函数" class="headerlink" title="获取pid函数"></a>获取pid函数</h5><p><code>pid_t getpid (void);</code>	获取当前进程号</p>
<p><code>pid_t getppid (void);</code>	获取父进程号</p>
<p><code>pid_t getpgid(pid_t pid);</code>	获取组进程号</p>
<blockquote>
<p>  进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID) 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</blockquote>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p><code>pid_t fork(void);</code>	系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<blockquote>
<p>  成功:子进程中返回 0，父进程中返回子进程 ID	失败:返回 -1</p>
<p>  失败的两个主要原因:</p>
<p>  1.当前系统的进程数已经达到了系统规定的上限，这时 <code>errno</code> 的值被设置为 <code>EAGAIN</code></p>
<p>  2.系统内存不足，这时 <code>errno</code> 的值被设置为 <code>ENOMEM</code></p>
</blockquote>
<h4 id="父子进程虚拟地址空间"><a href="#父子进程虚拟地址空间" class="headerlink" title="父子进程虚拟地址空间"></a>父子进程虚拟地址空间</h4><ol>
<li>内核区的pid(自己的)不同</li>
<li>使用<code>pid_t a = fork()</code>后,栈内的返回值不同,父进程栈里a为子进程号, 子进程栈里a为0</li>
<li>修改栈空间的变量互不干扰</li>
<li>父子进程有相同的文件描述符,指向相同的文件表,引用计数增加,共享文件偏移指针</li>
</ol>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101013945568.png" alt="image-20221101013945568" style="zoom: 67%;">



<h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><p>使用GDB调试的时候，GDB 默认只能跟踪一个进程， 可以在fork 函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<p><code>set follow-fork-mode [parent (默认) | child]</code>	</p>
<blockquote>
<p>  设置调试父进程或者子进程[被调试的进程停在断点处, 另一个进程顺利执行]</p>
</blockquote>
<p><code>set detach-on-fork [on| off]</code>	</p>
<blockquote>
<p>  设置调试模式默认为on，表示调试当前进程的时候，其它的进程继续运行，如果为off, 调试当前进程的时候，其它进程被GDB挂起。</p>
</blockquote>
<p><code>info inferiors</code>	查看调试的进程</p>
<p><code> inferior id</code>	切换当前调试的进程</p>
<p><code>detach inferiors id </code>	使进程脱离GDB调试</p>
<h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样,颇有些神似“三十六计”中的“金蝉脱壳”。只有调用失败了，它们才会返回-1， 从原程序的调用点接着往下执行。</p>
<p>exec函数族共有6种不同形式的函数。这6个函数可以划分为两组：</p>
<p>(1)execl、execle和execlp。</p>
<blockquote>
<p>  这里的l是list(列表)的意思，表示execl系列函数需要将每个命令行参数作为函数的参数进行传递；</p>
</blockquote>
<p>(2)execv、execve和execvp。</p>
<blockquote>
<p>  而v是vector(矢量)的意思，表示execv系列函数将所有函数包装到一个矢量数组中传递即可</p>
</blockquote>
<p><code>int execl(const char * path，const char * arg，…)；</code></p>
<p><code>int execle(const char * path，const char * arg，char * const envp[])；</code></p>
<p><code>int execlp(const char * file，const char * arg，…)；</code></p>
<p><code>int execv(const char * path，char * const argv[])；</code></p>
<p><code>int execve(const char * path，char * const argv[]，char * const envp[])；</code></p>
<p><code>int execvp(const char * file，char * const argv[])；</code></p>
<blockquote>
<p>path	要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execve、execl和execle这4个函数中，使用带路径名的文件名作为参数。</p>
<p>file	要执行的程序名称。如果该参数中包含“&#x2F;”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。</p>
<p>argv	命令行参数的矢量数组。</p>
<p>envp	带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用进程的环境变量。</p>
<p>arg	程序的第0个参数，即程序名自身。相当于argv[0]。</p>
<p>…	命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。</p>
</blockquote>
<h4 id="结束进程、孤儿进程、僵尸进程"><a href="#结束进程、孤儿进程、僵尸进程" class="headerlink" title="结束进程、孤儿进程、僵尸进程"></a>结束进程、孤儿进程、僵尸进程</h4><h5 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h5><p>exit是标准C库函数</p>
<p>_exit是标准Linux库函数</p>
<blockquote>
<p>  status是进程退出是的一个状态信息,父进程回收子进程资源时可以获取到</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143024126.png" alt="image-20221101143024126" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221101143922053.png" alt="image-20221101143922053" style="zoom: 67%;">



<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><ul>
<li><p>**父进程运行结束，但子进程还在运行(未运行结束)**，这样的子进程就称为孤儿进程(Orphan Process) 。</p>
</li>
<li><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init ,而init进程会循环地wait() 它的已经退出的子进程。当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
</li>
</ul>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><ul>
<li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。</p>
</li>
<li><p><strong>进程终止时，父进程尚未回收它，子进程残留资源(PCB) 存放于内核中，变成僵尸(Zombie)进程</strong>。</p>
</li>
<li><p>僵尸进程不能被kill -9杀死。</p>
</li>
<li><p>这样就会导致一个问题，如果父进程不调用wait() 或waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
</li>
</ul>
<blockquote>
<p>  kill -9 僵尸进程号 杀不了僵尸进程, 只有把他父进程杀了&#x2F;在父进程中按<code>ctrl + c</code>&#x2F;调用<code>wait()</code>或<code>waitpid()</code>函数后, 他才会被杀死</p>
</blockquote>
<h4 id="wait、waitpid函数"><a href="#wait、waitpid函数" class="headerlink" title="wait、waitpid函数"></a>wait、waitpid函数</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主</p>
<p>要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。wait()和waitpid() 函数的功能一样</p>
<p>区别在于，wait()函数会阻塞  waitpid()可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</p>
<blockquote>
<p>  注意: 一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
</blockquote>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p><code> pid_t wait(int *stat_loc);</code></p>
<blockquote>
<p>  返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno 中</p>
</blockquote>
<blockquote>
<p>  stat_loc 可以是a, b, c 然后调用<code>WIFEXITED(a)</code> <code>WEXITSTATUS(b)</code> <code>WIFSIGNALED(stat_val)</code> <code>WTERMSIG(stat_val)</code> <code>WIFSTOPPED(stat_val)</code> <code>WSTOPSIG(stat_val)</code> <code>WIFCONTINUED(stat_val)</code>能获取各种返回状态</p>
</blockquote>
<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><p><code>pid_t waitpid(pid_t pid, int *stat_loc, int options);</code></p>
<blockquote>
<p>  pid &#x3D;&#x3D; -1	 等待任一子进程。与wait等效</p>
<p>  pid &gt; 0	等待其进程ID 与 pid 相等的子进程</p>
<p>  pid &#x3D;&#x3D; 0	 等待进程组ID 与 目前进程相同的任何子进程。（少用&#x2F;基本不用）</p>
<p>  pid &lt; -1	等待其组ID 等于 pid的绝对值的任一子进程。（少用&#x2F;基本不用)   </p>
</blockquote>
<blockquote>
<p>  options  &#x3D;&#x3D; 0，表示waitpid函数为阻塞的。（该函数会阻塞卡在这儿，若有子进程，就回收；若没有子进程，一直卡着）</p>
<p>  options &#x3D;&#x3D; WNOHANG，表示waitpid函数为非阻塞的（也即不管有没有子进程了，该函数都不会阻塞卡在这儿）</p>
</blockquote>
<h4 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h4><p>进程是一个独立的资源分配单元，不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC: Inter Processes Communication )。</p>
<p>进程通信的目的:</p>
<blockquote>
<p>  数据传输    一个进程需要将它的数据发送给另一个进程。</p>
<p>  通知事件    一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)</p>
<p>  资源共享    多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</p>
<p>  进程控制    有些进程希望完全控制另一个进程的执行(如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</blockquote>
<h5 id="Linux进程通信方式"><a href="#Linux进程通信方式" class="headerlink" title="* Linux进程通信方式"></a>* Linux进程通信方式</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230125202337973.png" alt="image-20230125202337973" style="zoom:50%;">



<h4 id="匿名管道-管道"><a href="#匿名管道-管道" class="headerlink" title="匿名管道[管道]"></a>匿名管道[管道]</h4><blockquote>
<p>   用在父子或兄弟进程中</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102140508146.png" alt="image-20221102140508146"></p>
<h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><ul>
<li><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</p>
</li>
<li><p>管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体，有名管道有文件实体,但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102143252014.png" alt="image-20221102143252014" style="zoom:50%;">



<h5 id="匿名管道进程间通信原理"><a href="#匿名管道进程间通信原理" class="headerlink" title="匿名管道进程间通信原理"></a>匿名管道进程间通信原理</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144326483.png" alt="image-20221102144326483" style="zoom:50%;">



<h5 id="匿名管道的数据结构"><a href="#匿名管道的数据结构" class="headerlink" title="匿名管道的数据结构"></a>匿名管道的数据结构</h5><ul>
<li>逻辑环形队列</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102144456528.png" alt="image-20221102144456528" style="zoom:50%;">



<h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><p> 使用	<code>xxx | xxx</code></p>
<h6 id="创建一个匿名管道"><a href="#创建一个匿名管道" class="headerlink" title="创建一个匿名管道"></a>创建一个匿名管道</h6><p><code>int pipe(int pipefd[2]);</code></p>
<blockquote>
<p>  pipefd 数组是一个传出参数	pipefd[0] 对应管道的读端 pipefd[1] 对应管道的写端</p>
<p>  返回值: 成功返回0, 失败返回-1</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在fork之前创建管道</span></span><br><span class="line">	<span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot; pipe&quot;</span> );</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//父进程, 读</span></span><br><span class="line">            <span class="comment">// 从管道的读取端读取数据, 返回读取到的字节数 若管道内没有数据自动阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>); <span class="comment">// 将buf置为全0</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//父进程, 写</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am a parent&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程, 写</span></span><br><span class="line">           <span class="type">char</span>* str = <span class="string">&quot;hello,i am a child&quot;</span>;</span><br><span class="line">           <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>	(<span class="number">1</span>); <span class="comment">// 若没有sleep 则下面读模块会读取自己刚写的</span></span><br><span class="line">      </span><br><span class="line">            <span class="comment">// 子进程, 读	一定要在子进程写后 不然父子进程都阻塞</span></span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process recv: %s, pid: %d&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">bzero</span>(buf, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="查看管道缓冲大小"><a href="#查看管道缓冲大小" class="headerlink" title="查看管道缓冲大小"></a>查看管道缓冲大小</h6><p><code>ulimit -a</code>	命令</p>
<p><code>long fpathconf (int fd, int name);</code>	函数</p>
<blockquote>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102174749178.png" alt="image-20221102174749178">
</blockquote>
<h6 id="设置管道非阻塞"><a href="#设置管道非阻塞" class="headerlink" title="设置管道非阻塞"></a>设置管道非阻塞</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_GETFL);		<span class="comment">//获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;		<span class="comment">//修改flag的值</span></span><br><span class="line"><span class="built_in">fcntl</span>(fd[<span class="number">0</span>], F_SETFL, flags);		<span class="comment">//设置新的flag</span></span><br></pre></td></tr></table></figure>



<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><blockquote>
<p>  用在没有关系的进程中</p>
</blockquote>
<ul>
<li>匿名管道，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO) ，也叫命名管道、FIF0文件。</li>
<li>有名管道(FIFO) 不同于匿名管道在于它提供了一个路径名与之关联，以FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。</li>
<li>一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了(如read()、 write ()和close())。与管道一样，FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。</li>
<li>有名管道(FIFO)和匿名管道(pipe) 有一些特点是相同的，不一样的地方在于:<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但FIFO 中的内容却存放在内存中。</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO有名字，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
</li>
</ul>
<h5 id="创建有名管道"><a href="#创建有名管道" class="headerlink" title="创建有名管道"></a>创建有名管道</h5><p><code>mkfifo 名字</code>		通过函数创建有名管道</p>
<p><code>int mkfifo(const char *pathname, mode_t mode);</code>		通过函数创建有名管道</p>
<blockquote>
<p>  mode 和 open 函数的mode是一样的</p>
</blockquote>
<blockquote>
<p>   一旦使用mkfifo 创建了一个FIFO， 就可以使用open打开，常见的文件I&#x2F;0函数都可用于fifo,如 close、read、 write、unlink</p>
<p>  FIFO严格遵循先进先出(First in First out)，对管道及FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
</blockquote>
<h5 id="使用有名管道"><a href="#使用有名管道" class="headerlink" title="使用有名管道"></a>使用有名管道</h5><ul>
<li>创建两个文件(两个进程)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向管道中写数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.一个为只读打开管道进程会阻塞，直到写端打开</span></span><br><span class="line"><span class="comment">2.一个为只写打开管道进程会阻塞，直到读端打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、先判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建管道文件</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        	<span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、打开管道，以只写的方式</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123; </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n &quot;</span>, i); 	<span class="comment">// sprintf函数调用的主要用途就是把一个字符串放在一个已知的字符数组里去</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从管道中读数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 ： 需要两个进程（这里是两个文件）同时执行</span></span><br></pre></td></tr></table></figure>



<h5 id="有名管道实现聊天功能"><a href="#有名管道实现聊天功能" class="headerlink" title="有名管道实现聊天功能"></a>有名管道实现聊天功能</h5><ul>
<li>这样的文件 (进程) 有两份 A文件中为以下代码，B文件与A中只读和只写的有名管道相反</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">//创建管道</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断管道2是否存在</span></span><br><span class="line">    ret=<span class="built_in">access</span>(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret ==- <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只写的方式打开fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道1fifo1成功, 等待写入数据\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以只读的方式打开fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功, 等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//4、循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">//读取标准输入的数据(test用户输入的东西)</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf,<span class="number">128</span>,stdin);</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        ret = <span class="built_in">write</span>(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、读管道数据</span></span><br><span class="line">        <span class="built_in">mset</span>(buf,<span class="number">0</span>,<span class="number">128</span>);<span class="comment">//清空数据</span></span><br><span class="line">        ret = <span class="built_in">read</span>(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf:%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6、关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端1</span></span><br><span class="line">gcc chatA.c -o a</span><br><span class="line">gcc chatB.c -o b</span><br><span class="line">./a</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 终端2</span></span><br><span class="line">./b</span><br><span class="line"><span class="comment">// 开始聊天...</span></span><br></pre></td></tr></table></figure>



<h4 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h4><blockquote>
<p>  关闭读描述符 <code>close(piped[0]);</code>		 写类似</p>
</blockquote>
<ul>
<li><strong>没有进程写，只有进程读</strong>	如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道的读端读数据，那么文件内的所有内容被读完后再次read就会返回0，就像读到文件结尾。</li>
<li><strong>写描述符没关，但也没写</strong>    如果有指向管道写端的文件描述符没有关闭（管道写段的引用计数大于0），而持有管道写端的进程没有向管道内写入数据，假如这时有进程从管道读端读数据，那么读完管道内剩余的数据后就会阻塞等待，直到有数据可读才读取数据并返回。</li>
<li><strong>没有进程读，只有进程写</strong>    如果所有指向管道读端的文件描述符都关闭，此时有进程通过写端文件描述符向管道内写数据时，则该进程就会收到SIGPIPE信号，并异常终止。</li>
<li><strong>读描述符没关，但也没读</strong>    如果有指向管道读端的文件描述符没有关闭（管道读端的引用计数大于0），而持有管道读端的进程没有从管道内读数据，假如此时有进程通过管道写段写数据，那么管道被写满后就会被阻塞，直到管道内有空位置后才写入数据并返回。</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221102194024601.png" alt="image-20221102194024601" style="zoom: 67%;">



<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><ul>
<li><p>内存映射区通信，是非阻塞。</p>
</li>
<li><p>进程间有无关系都可以</p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103120849314.png" alt="image-20221103120849314" style="zoom:50%;">

<h5 id="内存映射的相关系统调用"><a href="#内存映射的相关系统调用" class="headerlink" title="内存映射的相关系统调用"></a>内存映射的相关系统调用</h5><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size;</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<h5 id="使用内存映射实现进程间通信"><a href="#使用内存映射实现进程间通信" class="headerlink" title="使用内存映射实现进程间通信"></a>使用内存映射实现进程间通信</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>有关系的进程（父子进程）</span><br><span class="line">	- 还没有子进程的时候</span><br><span class="line">		- 通过唯一的父进程，先创建内存映射区</span><br><span class="line">	- 有了内存映射区以后，创建子进程</span><br><span class="line">	- 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>没有关系的进程间通信</span><br><span class="line">	- 准备一个大小不是<span class="number">0</span>的磁盘文件</span><br><span class="line">	- 进程<span class="number">1</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 进程<span class="number">2</span> 通过磁盘文件创建内存映射区</span><br><span class="line">		- 得到一个操作这块内存的指针</span><br><span class="line">	- 使用内存映射区通信</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 test.txt 在里面写一点数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父子进程间通讯(两个独立的进程通信：将下面的代码拆成两个文件 需要各打开同一个文件，都得创建内存映射区)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);	<span class="comment">// 子进程往文件中写数据，写完了后父进程就将它回收，再读</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr); <span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;nihao a, son!!!&quot;</span>);	<span class="comment">// 把 ptr 从 void * 强转为 char *</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="内存映射TIPS"><a href="#内存映射TIPS" class="headerlink" title="内存映射TIPS"></a>内存映射TIPS</h5><p>如果对mmap的返回值(ptr)做++操作(ptr++)，munmap是否能够成功?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * ptr = <span class="built_in">mmap</span>(...);</span><br><span class="line">ptr++;  <span class="comment">//可以对其进行++操作，但是不建议这样做，会导致无法正确释放映射</span></span><br><span class="line"><span class="built_in">munmap</span>(ptr, len);   <span class="comment">// 错误，要保存地址</span></span><br></pre></td></tr></table></figure>

<p>如果open时O_RDONLY, mmap 时 prot 参数指定PROT_READ | PROT_WRITE会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">错误，返回 <span class="function">MAP_FAILED</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">()</span>函数中的权限建议和 prot 参数的权限保持一致。</span></span><br></pre></td></tr></table></figure>

<p>如果文件偏移量为1000会怎样?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">偏移量必须是 <span class="number">4</span>K 的整数倍，返回 MAP_FAILED。</span><br></pre></td></tr></table></figure>

<p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- 可以的，但是创建的文件的大小如果为<span class="number">0</span>的话，肯定不行</span><br><span class="line">- 可以对新的文件进行扩展</span><br><span class="line">	- <span class="built_in">lseek</span>()</span><br><span class="line">  - <span class="built_in">truncate</span>()</span><br></pre></td></tr></table></figure>

<p>mmap后关闭文件描述符，对mmap映射有没有影响？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="built_in">mmap</span>(,,,,fd,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">close</span>(fd); <span class="comment">// 映射区还存在，创建映射区的fd被关闭，没有任何影响。</span></span><br></pre></td></tr></table></figure>



<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h5 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h5><ul>
<li><p>信号是Linux进程间通信的最古老的方式之一，<strong>是事件发生时对进程的通知机制，有时也称之为软件中断</strong>，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下:</p>
<ol>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用kill 函数。</li>
</ol>
</li>
<li><p>使用信号的两个主要目的是:</p>
<ol>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ol>
</li>
<li><p>信号的特点:</p>
<ol>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ol>
</li>
<li><p>查看系统定义的信号列表    <code>kill -l</code>     (前31个信号为常规信号，其余为实时信号)</p>
</li>
</ul>
<h5 id="部分信号一览表"><a href="#部分信号一览表" class="headerlink" title="部分信号一览表"></a>部分信号一览表</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103164530935.png" alt="image-20221103164530935" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165336300.png" alt="image-20221103165336300" style="zoom: 50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165127529.png" alt="image-20221103165127529" style="zoom:50%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221103165504053.png" alt="image-20221103165504053" style="zoom:50%;">



<h6 id="举例：SIGCHILD"><a href="#举例：SIGCHILD" class="headerlink" title="举例：SIGCHILD"></a>举例：SIGCHILD</h6><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221104170616515.png" alt="image-20221104170616515"></p>
<h5 id="信号的五种默认处理动作"><a href="#信号的五种默认处理动作" class="headerlink" title="信号的五种默认处理动作"></a>信号的五种默认处理动作</h5><p>查看信号的详细信息	<code>man 7 signal</code></p>
<p>信号的5种默认处理动作：</p>
<ol>
<li>Term	终止进程</li>
<li>Ign    当前进程忽略掉这个信号</li>
<li>Core    终止进程，并生成一个Core文件</li>
<li>Stop    暂停当前进程</li>
<li>Cont    继续执行当前被暂停的进程</li>
</ol>
<p>信号的几种状态：	产生、未决（没到达进程）、递达（到达进程）</p>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p>
<h5 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h6 id="kill-1"><a href="#kill-1" class="headerlink" title="kill"></a>kill</h6><p><code>int kill (pid_t pid, int sig);</code>		给任何进程或者进程组pid发送任何信号sig</p>
<blockquote>
<p>  pid:</p>
<p>  若 &gt; 0	将信号发送给指定的进程；</p>
<p>  &#x3D; 0	将信号发送给当前的进程组；</p>
<p>  &#x3D; -1	将信号发送给每一个有权限接收这个信号的进程</p>
<p>  &lt;-1：这个pid&#x3D;某个进程组的ID取反（-12345）</p>
<p>  sig	需要发送的信号的编号或者是宏值，0表示不发送任何信号</p>
</blockquote>
<h6 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h6><p><code>int raise(int sig);</code>		给当前进程发送信号</p>
<blockquote>
<p>  sig	要发送的信号</p>
<p>  返回值 	成功：0	失败：非0</p>
<p>  相当于  <code>kill(getpid(), sig);</code></p>
</blockquote>
<h6 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h6><p><code>void abort(void) ;</code>		发送SIGABRT信号给当前的进程，杀死当前进程</p>
<blockquote>
<p>  相当于 <code>kill(getpid(),SIGABRT);</code></p>
</blockquote>
<h6 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h6><p><code>unsigned int alarm(unsigned int seconds);</code>		</p>
<blockquote>
<p>  设置定时器(闹钟)。函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号 SIGALARM</p>
</blockquote>
<blockquote>
<p>  seconds	倒计时的时长，单位:秒。如果参数为0，定时器无效(不进行倒计时，不发送信号)</p>
<p>  取消一个定时器，通过alarm(0)</p>
<p>  返回值	之前没有定时器返回0;  之前有定时器,则返回之前定时剩余的倒计时剩余的时间</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> seconds = <span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    seconds = <span class="built_in">alarm</span>(<span class="number">2</span>);<span class="comment">//不阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>,seconds);<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h6><p><code>int setitimer (int which, const struct itimerval *new_val, struct itimerval *old_value) ;</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能:设置定时器(闹钟)，可以替代alarm函数。精度us，可以实现周期性的定时</span></span><br><span class="line"><span class="comment">          参数:</span></span><br><span class="line"><span class="comment">              which:定时器以什么时间计时</span></span><br><span class="line"><span class="comment">                  ITIMER_REAL:真实时间，时间到达，发送SIGALRM 	常用</span></span><br><span class="line"><span class="comment">                  ITIMER_VIRTUAL:用户时间，时间到达，发送SIGVTALRM</span></span><br><span class="line"><span class="comment">                  ITIMER_PROF:以该进程在用户态和内核态下所消耗的时间来计时，时间到达，发送SIGPROF</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">              new_value:设置定时器的属性</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              struct itimerval &#123;//定时器的结构体</span></span><br><span class="line"><span class="comment">                 struct timeval it_interval; //每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="comment">                 struct timeval it_value;    //延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              struct timeval &#123;//时间的结构体</span></span><br><span class="line"><span class="comment">                 time_t      tv_sec;  //秒数</span></span><br><span class="line"><span class="comment">                 suseconds_t tv_usec; //微秒</span></span><br><span class="line"><span class="comment">              &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              过10s后每隔2s定时一次</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">              old_value:记录上一次的定时的时间参数可以在这里获取到，用不到的话传递一个NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          	返回值:</span></span><br><span class="line"><span class="comment">              成功 0</span></span><br><span class="line"><span class="comment">              失败 -1 指定错误号</span></span><br><span class="line"><span class="comment">*/</span>            </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//过3s后每隔2s定时一次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置值</span></span><br><span class="line">    new_value.it_interval.tv_sec=<span class="number">2</span>;<span class="comment">//设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置延迟的时间,3s后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec=<span class="number">3</span>;<span class="comment">//s</span></span><br><span class="line">    new_value.it_value.tv_usec=<span class="number">0</span>;<span class="comment">//us</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">setitimer</span>(ITIMER_REAL,&amp;new_value,<span class="literal">NULL</span>); <span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>); <span class="comment">// 这里过了3s接收到sigALARM信号直接就终止了，如果想不终止，需要捕捉到信号后自定义处理</span></span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><p><code>sighandler_t signal (int signum, sighandler_t handler);</code></p>
<blockquote>
<p>  signum	要捕捉的信号，也可以是宏</p>
<p>  handler	捕捉到信号要如何处理</p>
<ul>
<li>SIG_IGN	忽略信号</li>
<li>SIG_DFL	使用信号默认的行为</li>
<li>回调函数	自定义函数（返回值一定要是 void 参数一定要是 int类型（或者信号宏名））</li>
</ul>
<p>  返回值</p>
<ul>
<li>成功，返回上一次注册的信号处理函数的地址。第次调用返回NULL</li>
<li>失败，返回SIG_ ERR， 设置错误号</li>
</ul>
<p>  <strong>SIGKILL SIGSTOP不能被捕捉或忽略</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalhandler</span><span class="params">(<span class="type">int</span> signo)</span></span>&#123;    <span class="comment">//signal函数会传递信号序号给这个函数</span></span><br><span class="line">    <span class="comment">//信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">14</span>, signalhandler);    <span class="comment">//收到14号信号「SIGALARM」时，就会执行对应的信号处理函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h6><p><code>int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);</code></p>
<blockquote>
<p>  sig 指出要捕获的信号类型，act 指定新的信号处理方式，oact 输出先前信号的处理方式（如果不为NULL的话）。</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__sigaction_u</span> __sigaction_u;  <span class="comment">/* signal handler */</span></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask;	<span class="comment">/* signal mask to apply */</span></span><br><span class="line">  <span class="type">int</span> sa_flags;	<span class="comment">/* see signal options below */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">__sigaction_u</span> &#123;</span><br><span class="line">  <span class="built_in">void</span> (*__sa_handler)(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">void</span> (*__sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler      __sigaction_u.__sa_handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction    __sigaction_u.__sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>  sa_handler	此参数和signal()的参数handler相同，代表新的信号处理函数</p>
<p>  sa_mask	用来设置在处理该信号时暂时将sa_mask 指定的信号集搁置</p>
<p>  sa_flags	用来设置信号处理的其他相关操作，下列的数值可用</p>
<ul>
<li><p>SA_RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</p>
</li>
<li><p>SA_RESTART：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</p>
</li>
<li><p>SA_NODEFER ：一般情况下， 当信号处理函数运行时，内核将阻塞该信号。但是如果设置了 SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p>其他查阅 <code>man sigaction</code></p>
</li>
</ul>
</blockquote>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存允许两个或者多个进程共享物理内存的同一块区域。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种IPC 机制无需内核介入。所有要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管</p>
<p>道是一种存在于内核的文件)，这种IPC技术的速度更快。</p>
<h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol>
<li><p>调用<code>shmget()</code>创建一个新共享内存段或取一个既有共享内存段的标识符。这个调用将返回后续调用中需要用到的共享内存标识符</p>
</li>
<li><p>使用<code>shmat()</code>和当前进程进行关联, 返回已开辟的内存的首地址</p>
<blockquote>
<p>  此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由<code>shmat() </code>返回的addr 值，它是一个指向进程的虛拟地址空间中该共享内存段的起点的指针。</p>
</blockquote>
</li>
<li><p>调用<code>shmdt() </code>来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步</p>
</li>
<li><p>调用<code>shmctl()</code>来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步</p>
</li>
</ol>
<h5 id="共享内存使用函数"><a href="#共享内存使用函数" class="headerlink" title="共享内存使用函数"></a>共享内存使用函数</h5><h6 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h6><p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>
<blockquote>
<p>  成功完成后，将共享内存段标识符为返回。否则，返回-1并设置全局变量errno表示错误</p>
</blockquote>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">key</span><br><span class="line"><span class="number">0</span>(IPC_PRIVATE)：会建立新共享内存对象</span><br><span class="line">大于<span class="number">0</span>的<span class="number">32</span>位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">大于<span class="number">0</span>的整数：新建的共享内存大小，以字节为单位</span><br><span class="line"><span class="number">0</span>：只获取共享内存时指定为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">shmflg</span><br><span class="line"><span class="number">0</span>：取共享内存标识符，若不存在则函数会报错</span><br><span class="line"></span><br><span class="line">IPC_CREAT：当shmflg&amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符</span><br><span class="line"></span><br><span class="line">IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h6><p><code>void* shmat(int shmid, const void * shmaddr, int shmflg);</code></p>
<blockquote>
<p>  成功：附加好的共享内存地址  出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid	共享内存标识符</p>
<p>  shmaddr	指定共享内存出现在进程内存地址的什么位置，直接指定为NULL让内核自己决定一个合适的地址位置</p>
<p>  shmflg	SHM_RDONLY：为只读模式， 0：为读写模式</p>
</blockquote>
<h6 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h6><p><code>int shmdt (const void *shmaddr) ;</code></p>
<blockquote>
<p>  成功返回0	出错返回-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmaddr	连接的共享内存的起始地址</p>
</blockquote>
<h6 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h6><p><code>int shmctl (int shmid, int cmd, struct shmid_ds *buf) ;</code></p>
<blockquote>
<p>  成功：0	出错：-1，错误原因存于error中</p>
</blockquote>
<blockquote>
<p>  shmid：共享内存标识符</p>
<p>  cmd</p>
<blockquote>
<p>  IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</p>
<p>  IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内</p>
<p>  IPC_RMID：删除这片共享内存</p>
</blockquote>
<p>  buf	需要设置或者获取的共享内存的属性信息, 一般写NULL</p>
<blockquote>
<p>  IPC_ STAT 	buf存储数据</p>
<p>  IPC_ SET 	buf中需要初始化数据，设置到内核中</p>
<p>  IPC_ RMID 	没有用，NULL</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /home/kjg/Linux/sharememory/write_shm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一块共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联, 返回已开辟的内存的首地址</span></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按任意键继续</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.释放共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h6><p><code>key_t ftok(const char *pathname, int proj_id);</code></p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105134241461.png" alt="image-20221105134241461">



<h5 id="操作系统如何知道一块共享内存被多少个进程关联"><a href="#操作系统如何知道一块共享内存被多少个进程关联" class="headerlink" title="操作系统如何知道一块共享内存被多少个进程关联"></a>操作系统如何知道一块共享内存被多少个进程关联</h5><ul>
<li>共享内存维护了一个结构体<code>struct shmid_ds</code> 这个结构体中有一个成员<code>shm_nattach </code>记录了关联的进程个数</li>
<li>ipcs用法</li>
</ul>
<blockquote>
<p>  ipcs -a	&#x2F;&#x2F;打印当前系统中所有的进程间通信方式的信息</p>
<p>  ipcs -m	&#x2F;&#x2F;打印出使用共享内存进行进程间通信的信息</p>
<p>  ipcs -q	&#x2F;&#x2F;打印出使用消息队列进行进程间通信的信息</p>
<p>  ipcs -s	&#x2F;&#x2F;打印出使用信号进行进程间通信的信息</p>
</blockquote>
<ul>
<li>ipcrm用法</li>
</ul>
<blockquote>
<p>  ipcrm -M shmkey	&#x2F;&#x2F;移除用shmkey创建的共享内存段</p>
<p>  ipcrm -m shmid	&#x2F;&#x2F; 移除用 shmid标识的共享内存段</p>
<p>  ipcrm -Q msgkey	&#x2F;&#x2F;移除用msqkey创建的消息队列</p>
<p>  ipcrm -q msqid	&#x2F;&#x2F;移除用msqid标识的消息队列</p>
<p>  ipcrm -S semkey	&#x2F;&#x2F;移除用semkey创建的信号</p>
<p>  ipcrm -s semid	&#x2F;&#x2F; 移除用semid标识的信号</p>
</blockquote>
<h4 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h4><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><ul>
<li><p>查看当前终端的pid	<code>echo $$</code></p>
</li>
<li><p>在UNIX系统中，用户通过终端登录系统后得到一个shell 进程，这个终端成为shell 进程的控制终端(Controlling Terminal) ，进程中，控制终端是保存在PCB 中的信息，而fork() 会复制PCB中的信息，因此由shell 进程启动的其它进程的控制终端也是这个终端。</p>
</li>
<li><p>默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
</li>
<li><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生SIGINT 信号，Ctrl + \会产生SIGQUIT 信号。</p>
</li>
</ul>
<h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><ul>
<li><p>进程组和会话在进程之间形成了一种两级层次关系:<strong>进程组是一组相关进程的集合,会话是一组相关进程组的集合</strong>。进程组和会话是为支持shell 作业控制而定义的抽象概念，用户通过shell 能够交互式地在前台或后台运行命令。</p>
</li>
<li><p>进程组由一个或多个共享同一进程组标识符(PGID) 的进程组成。<strong>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID,  新进程会继承其父进程所属的进程组ID</strong></p>
</li>
<li><p>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员</p>
</li>
</ul>
<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><ul>
<li><p>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</p>
</li>
<li><p><strong>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端</strong></p>
</li>
<li><p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入命令后，该信号会被发送到前台进程组中的所有成员。</p>
</li>
<li><p><strong>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程</strong></p>
</li>
</ul>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105165609594.png" alt="image-20221105165609594">



<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p><code>pid_t getpgrp(void);</code>	用来取得进程所属的组识别码。此函数相当于调用 <code>getpgid(0); </code></p>
<p><code>pid_t getpgid(pid_t pid);</code></p>
<p><code>int setpgid(pid_t pid, pid_t pgid);</code></p>
<p><code>pid_t getsid(pid_t pid);</code></p>
<p><code>pid_t setsid(void);</code></p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><ul>
<li>守护进程 (Daemon Process) ，也就是通常说的精灵进程，<strong>是Linux中的后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</li>
<li>守护进程具备下列特诊:<ul>
<li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如SIGINT、 SIGQUIT)。</li>
</ul>
</li>
<li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器inetd, web服务器httpd 等。</li>
</ul>
<h5 id="守护进程的创建步骤"><a href="#守护进程的创建步骤" class="headerlink" title="守护进程的创建步骤"></a>守护进程的创建步骤</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221105181155408.png" alt="image-20221105181155408"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现一个守护进程的实例（每隔 10s 在／tmp/dameon.log 写入一句话）*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Linux多线程开发"><a href="#Linux多线程开发" class="headerlink" title="Linux多线程开发"></a>Linux多线程开发</h3><h4 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h4><ul>
<li>与进程(process) 类似，线程(thread)是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的UNIX进程只是多线程程序的一个特例，该进程只包含一个线程)</li>
<li>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程 (LWP: Light Weight Process) ，在Linux环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号: <code>ps -Lf pid</code></li>
</ul>
<h5 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h5><ul>
<li><p>进程间的信息难以共享。 由于除去只读代码段外，父子进程并未共享内存，因此必须采一些进程间通信方式，在进程间进行信息交换</p>
</li>
<li><p>调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍热需要复制诸如内存页表和文件描述符表之类的多种进程属性,这意味着fork() 调用很慢</p>
</li>
<li><p>线程之间能够方便、快速地共享信息。只需将数据复制到共享(全局或堆)变量中即可</p>
</li>
<li><p>创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</p>
</li>
</ul>
<h5 id="线程和进程虚拟地址空间"><a href="#线程和进程虚拟地址空间" class="headerlink" title="线程和进程虚拟地址空间"></a>线程和进程虚拟地址空间</h5><p>子进程复制父进程的虚拟地址空间，而线程间共享进程的虚拟地址空间，只不过各线程在 <code>栈空间</code> <code>  .text段</code>占据了各一部分</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106215842522.png" alt="image-20221106215842522" style="zoom:50%;">



<h5 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221106220232940.png" alt="image-20221106220232940" style="zoom:50%;">



<h4 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h4><p><code>pthread_t pthread_self(void);</code></p>
<p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
<p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void* (*start routine) (void *), void *arg);</code></p>
<p><code>void pthread_exit(void *retval);</code></p>
<p><code>int pthread_join(pthread_t thread, void **retval);</code></p>
<p><code>int pthread_detach(pthread_t thread);</code></p>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
<h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start routine)(void *), void* arg);</code></p>
<p>创建一个子线程</p>
<blockquote>
<p>  thread	传出参数，线程创建成功后，子线程的线程ID被写到该变量</p>
<p>  attr	设置线程的属性，一般使用默认值，NULL</p>
<p>  start_ routine 	函数指针，这个函数是子线程需要处理的逻辑代码</p>
<p>  arg	给第三个参数使用，传参</p>
</blockquote>
<blockquote>
<p>  返回值:	成功: 0	失败:返回错误号。这个错误号和之前errno不太一样。</p>
<p>  获取错误号的信息:	<code>char * strerror(int errnum);</code></p>
</blockquote>
<h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p><code>pthread_t pthread_self(void);</code></p>
<blockquote>
<p>  获取当前线程id</p>
</blockquote>
<h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
<blockquote>
<p>  判断两个线程号是否相等</p>
</blockquote>
<h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p><code>void pthread_exit(void *retval);</code></p>
<blockquote>
<p>  主线程退出时，不影响其他线程的运行</p>
<p>  子线程中 return NULL 相当于 pthread_exit(NULL)</p>
</blockquote>
<h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_ join"></a>pthread_ join</h5><p><code>int pthread_join(pthread_t thread, void **retval);</code></p>
<blockquote>
<p>  pthread_t thread	被连接线程的线程号</p>
<p>  void **retval 	指向 一个指向被连接线程的返回码的指针 的指针</p>
<p>  返回值	线程连接的状态，0是成功，非0是失败</p>
</blockquote>
<blockquote>
<p>  在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果。也就是主线程需要等待子线程执行完成之后再结束，就要用pthread_join()</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;pthreadVC2.lib&quot;</span>) </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_run</span><span class="params">(<span class="type">void</span>* parm)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123; </span><br><span class="line">        count ++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The thread_run method count is = %d\n&quot;</span>,count); </span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="type">pthread_t</span> tid; </span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_run, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 加入pthread_join后，主线程&quot;main&quot;会一直等待直到tid这个线程执行完毕自己才结束 </span></span><br><span class="line">    <span class="comment">// 一般项目中需要子线程计算后的值就需要加join方法 </span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果没有join方法可以看看打印的顺序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The count is = %d\n&quot;</span>,count); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当A线程调用线程B并 pthread_join() 时，A线程会处于阻塞状态，直到B线程结束后，A线程才会继续执行下去</p>
<p>  当 pthread_join() 函数返回后，被调用线程才算真正意义上的结束，它的内存空间也会被释放（如果被调用线程是非分离的）</p>
<ol>
<li>被释放的内存空间仅仅是系统空间，你必须手动清除程序分配的空间，比如 malloc() 分配的空间。</li>
<li>一个线程只能被一个进程所连接。</li>
<li>被连接的线程必须是非分离的，否则连接会出错。</li>
</ol>
<p>  所以可以看出pthread_join()有两种作用：</p>
<p>  (1) 用于等待其他线程结束：调用pthread_join() 后, 当前线程会处于阻塞状态, 直到被调用的线程结束后当前线程才会重新开始执行</p>
<p>  (2) 对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”</p>
</blockquote>
<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p><code>int pthread_detach (pthread_t thread);</code></p>
<blockquote>
<p>  在任何一个时间点上，线程是可结合的，或者是分离的。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的</p>
<p>  <strong>一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">pthread_t</span> tid;</span><br><span class="line">  <span class="type">int</span> status = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">   	<span class="built_in">perror</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">pthread_detach</span>(tid);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p><code>int pthread_cancel (pthread_t thread);</code></p>
<blockquote>
<p>  功能：取消线程（终止）	如果成功，返回0;如果发生错误，则返回非零值错误的数字</p>
<p>   pthread_cancel并不立刻让线程终止，它只提出请求。线程在取消请求(pthread_cancel)发出后会继续运行，直到到达某个取消点(CancellationPoint)。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>
<p>  pthread标准指定了几个取消点，其中包括：</p>
<ol>
<li>通过pthread_testcancel调用以编程方式建立线程取消点。</li>
<li>线程等待pthread_cond_wait或pthread_cond_timewait()中的特定条件。</li>
<li>被sigwait(2)阻塞的函数</li>
<li>一些标准的库调用。通常，这些调用包括线程可基于阻塞的函数。</li>
</ol>
</blockquote>
<h4 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h4><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start routine) (void *) , void *arg);</code></p>
<p>中第二个参数就是线程属性</p>
<h5 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h5><p><code>int pthread_attr_init(pthread_attr_t *attr);</code></p>
<p><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></p>
<p><code>int pthread_attr_getdetachstate(const pthread_attr_t *attr, int detachstate);</code></p>
<p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程分离状态属性</span></span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, THREAD_FUNCTION, arg);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的:必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
<li>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li>
<li>线程同步:即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标,结果: 三个窗口，每个窗口都卖一百张票</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">        tickets --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标: 三个窗口，共卖一百张票, 但结果通常办不到</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>); <span class="comment">// tid1 进入循环休眠时, tid2,tid3都可能进入循环并执行过程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">        tickets --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// 548136161792正在卖第87 张票</span></span><br><span class="line"><span class="comment">// 548119376384正在卖第87 张票</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 547602481664正在卖第1 张票</span></span><br><span class="line"><span class="comment">// 547594088960正在卖第0 张票</span></span><br><span class="line"><span class="comment">// 547585696256正在卖第-1 张票</span></span><br></pre></td></tr></table></figure>



<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><ul>
<li>为避免线程更新共享变量时出现问题，可以使用互斥量(mutex )来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源(可能由多个相关变量组成)会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:<ul>
<li>针对共享资源锁定互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
</ul>
<h6 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h6><p>互斥量的类型	<code>pthread_mutex_t</code></p>
<p><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p>
<blockquote>
<p>  mutex 	需要初始化的互斥量变量</p>
<p>  attr 	互斥量相关的属性，NULL</p>
<p>  restrict 	C语言的修饰符，被修饰的指针的内容不能由另外的一个指针进行操作</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> *restrict mutex = XXX;</span><br><span class="line"><span class="type">pthread_mutex_t</span> * mutex1 = mutex;</span><br><span class="line">* mutex1 = ZZZ; <span class="comment">// 错误,因为 restrict mutex</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p>  释放互斥量的资源</p>
</blockquote>
<p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p>  上锁,阻塞</p>
</blockquote>
<p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex) ;</code></p>
<blockquote>
<p>上锁,非阻塞,如果加锁失败,直接返回</p>
</blockquote>
<p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex) ;</code></p>
<blockquote>
<p>  解锁</p>
</blockquote>
<p><code>lock_guard(mutex&amp; m);</code></p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_count = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_count1</span><span class="params">(std::mutex* mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;fun_count1:&quot;</span>&lt;&lt;--g_count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>*<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_count2</span><span class="params">(std::mutex* mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fun = [&amp;]&#123;</span><br><span class="line">        <span class="comment">//构造时自动加锁</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(*mutex);</span><br><span class="line">        <span class="keyword">if</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;fun_count2:&quot;</span>&lt;&lt;--g_count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//析构自动解锁</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(g_count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>*<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="案例改进版"><a href="#案例改进版" class="headerlink" title="案例改进版"></a>案例改进版</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三个窗口，卖一百张票</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第%d 张票\n&quot;</span>, <span class="built_in">pthread_self</span>() ,tickets);</span><br><span class="line">            tickets --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221108162830690.png" alt="image-20221108162830690"></p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul>
<li>当有一个线程已经持有互斥锁时，互斥销将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是<strong>实际上多个线程同时读访问共享资源并不会导致问题</strong></li>
<li>在对数据的读写操作中， 更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</li>
<li>读写锁的特点:<ul>
<li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li>
<li>如果有其它线程写数据，则其它线程都不允许读、写。 写的优先级高</li>
</ul>
</li>
</ul>
<h6 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h6><p>读写锁的类型	<code>pthread_rwlock_t</code></p>
<p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
<p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock; <span class="comment">// 声明失败是因为与C99冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">writeNum</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        num ++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write===pid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">readNum</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read===pid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个写进程,五个读进程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(wtids[i]); <span class="comment">// 设置线程分离, 线程结束后由系统释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);\</span><br><span class="line">        <span class="built_in">pthread_detach</span>(rtids[i]); <span class="comment">// 设置线程分离, 线程结束后由系统释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>); <span class="comment">// 不写这段话,直接进程退出,所有线程都没了.</span></span><br><span class="line">    <span class="comment">//若写了则主线程退出,子线程都设置了分离,运行完系统回收</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="条件变量-不是锁-不好用"><a href="#条件变量-不是锁-不好用" class="headerlink" title="条件变量(不是锁,不好用)"></a>条件变量(不是锁,不好用)</h5><p>条件变量的类型	<code>pthread_cond_t </code></p>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></p>
<p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p>
<p><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t * restrict mutex);</code></p>
<blockquote>
<p>  阻塞函数,调用了该函数,线程会阻塞等待</p>
</blockquote>
<p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p>
<blockquote>
<p>  阻塞函数,调用了该函数,线程会阻塞等待,直到指定的时间结束</p>
</blockquote>
<p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p>
<blockquote>
<p>  唤醒一个或者多个</p>
</blockquote>
<p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p>
<blockquote>
<p>  唤醒所有</p>
</blockquote>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的类型	<code>sem_t</code></p>
<p><code>int sem_init(sem_t *sem, int pshared, unsigned int value) ;</code></p>
<blockquote>
<p>  sem	信号量变量的地址</p>
<p>  pshared 	0用在线程间，非0用在进程间</p>
<p>  value 	信号量中的值</p>
</blockquote>
<p><code>int sem_destroy(sem_t *sem);</code></p>
<p><code>int sem_wait(sem_t *sem);</code>	P操作</p>
<blockquote>
<p>①S减1</p>
<p>②若S减1后仍大于或等于0，则进程继续执行</p>
<p>③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度</p>
</blockquote>
<p><code>int sem_trywait(sem_t *sem);</code></p>
<p><code>int sem_timedwait(sem_t * sem, const struct timespec *abs_timeout);</code></p>
<p><code>int sem_post(sem_t *sem);</code>		V操作</p>
<blockquote>
<p>  ①S加1</p>
<p>  ②若相加后结果大于0，则进程继续执行</p>
<p>  ③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度</p>
</blockquote>
<p><code>int sem_getvalue(sem_t *sem, int *sval);</code></p>
<blockquote>
<p>  要配合mutex一起用</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221109231419437.png" alt="image-20221109231419437"></p>
<h3 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h3><h4 id="BS和CS架构"><a href="#BS和CS架构" class="headerlink" title="BS和CS架构"></a>BS和CS架构</h4><h5 id="C-x2F-S"><a href="#C-x2F-S" class="headerlink" title="C&#x2F;S"></a>C&#x2F;S</h5><p>C&#x2F;S架构是第一种比较早的软件架构，主要用于局域网内。也叫客户机&#x2F;服务器模式</p>
<p><strong>它可以分为客户机和服务器两层：</strong></p>
<ul>
<li>第一层: 在客户机系统上结合了界面显示与业务逻辑</li>
<li>第二层: 通过网络结合了数据库服务器</li>
</ul>
<blockquote>
<p>  客户端不仅仅是一些简单的操作，它也是会处理一些运算，业务逻辑的处理等。也就是说，客户端也做着一些本该由服务器来做的一些事情，如图所示：</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-9fdab4ff37d12e944d2a9025b583d0ac_1440w.jpeg" alt="img"></p>
<p>C&#x2F;S架构软件有一个特点，就是如果用户要使用的话，需要下载一个客户端，安装后就可以使用。比如QQ,OFFICE软件等</p>
<p><strong>C&#x2F;S架构的优点：</strong></p>
<ol>
<li>C&#x2F;S架构的界面和操作可以很丰富。（客户端操作界面可以随意排列，满足客户的需要）</li>
<li>安全性能可以很容易保证。（因为只有两层的传输，而不是中间有很多层）</li>
<li>由于只有一层交互，因此响应速度较快。（直接相连，中间没有什么阻隔或岔路，比如QQ，每天那么多人在线，也不觉得慢）</li>
</ol>
<p><strong>C&#x2F;S架构的缺点：</strong></p>
<ol>
<li>适用面窄，通常用于局域网中</li>
<li>用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户</li>
<li>维护成本高，发生一次升级，则所有客户端的程序都需要改变</li>
</ol>
<h5 id="B-x2F-S"><a href="#B-x2F-S" class="headerlink" title="B&#x2F;S"></a>B&#x2F;S</h5><p>B&#x2F;S架构的全称为Browser&#x2F;Server，即浏览器&#x2F;服务器结构。</p>
<p>Browser指的是Web浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现</p>
<p>其实就是我们前端现在做的一些事情，大部分的逻辑交给后台来实现，我们前端大部分是做一些数据渲染，请求等比较少的逻辑。</p>
<p><strong>B&#x2F;S架构的优点：</strong></p>
<ol>
<li>成本低,方便维护,分布性强,开发简单</li>
<li>BS架构无需升级多个客户端，升级服务器即可。可以随时更新版本，而无需用户重新下载啊什么的。</li>
</ol>
<p><strong>B&#x2F;S架构的缺点：</strong></p>
<ol>
<li>在跨浏览器上，BS架构不尽如人意。</li>
<li>协议一般是固定的 http&#x2F;https ,所以无法操作大数据量的文件</li>
<li>无法实现个性化</li>
<li>在速度和安全性上无法保证</li>
</ol>
<h4 id="MAC地址-IP地址和端口"><a href="#MAC地址-IP地址和端口" class="headerlink" title="MAC地址,IP地址和端口"></a>MAC地址,IP地址和端口</h4><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><blockquote>
<p>  又称以太网地址,物理地址		</p>
</blockquote>
<blockquote>
<p>  网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有MAC地址，属于OSI模型的第2层，它使得用户可以通过电缆或无线相互连接。<strong>每一个网卡都有一个被称为MAC地址的独一无二的48位串行号</strong></p>
<p>  网卡的主要功能: 1 .数据的封装与解封装 2.链路管理 3.数据编码与译码      一台设备可以有多个网卡</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110150321181.png" alt="image-20221110150321181">
</blockquote>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><blockquote>
<p>  IP协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网.上进行通信时应当遵守的规则。</p>
<p>  任何厂家生产的计算机系统，只I守IP协议就可以与因特网互连互通。各个厂家生产的网络系统和设备,如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元(技术上称之为“帧”)的格式不同。</p>
<p>  IP 协议实际上是一套由软件程序组成的协议软件,它把各种不同”帧”统-转换成”IP 数据报”格式,这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有”开放性”的特点。正是因为有了IP协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，<strong>IP 协议也可以叫做”因特网协议</strong>”</p>
<p>  IP地址(Internet Protocol Address)是指互联网协议地址，又译为网际协议地址。IP 地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一 台主机分配一个逻辑地址, 以此来屏蔽物理地址的差异。</p>
<p>  IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”(也就是4个字节)。IP 地址通常用”点分十进制”表示成(a.b.c.d) 的形式，其中，a,b,c,d都是 0~255之间的十进制整数</p>
<p>  IP分类:</p>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/da60a6fcfe684b679c3ca13c116f3004.png" alt="img">

<p>  <strong>A类地址</strong><br>  为大型网络而设计的，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0）。可用的A类网络有127个，每个网络能容纳16777214个主机。其中127.0.0.1是一个特殊的IP地址，表示主机本身，用于本地机器的测试</p>
<p>  注：A: 0-127，其中<strong>0代表本网络的主机</strong>，<strong>127为回环测试地址</strong>，因此，A类ip地址的实际范围是1-126. 默认子网掩码为<strong>255.0.0.0</strong></p>
<p>  <strong>B类地址</strong><br>  一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p>
<p>  注：	B:128-191，其中128.0.0.0和191.255.0.0为保留ip，实际范围是128.1.0.0–191.254.0.0</p>
<p>  <strong>C类地址</strong><br>  一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。</p>
<p>  注：C:192-223，其中192.0.0.0和223.255.255.0为保留ip，实际范围是192.0.1.0–223.255.254.0</p>
<p>  <strong>D类地址</strong><br>  用于多点广播（Multicast）。 D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。224.0.0.0到239.255.255.255用于多点广播 </p>
<p>  <strong>E类IP地址</strong>	以“1111”开始，为将来使用保留。240.0.0.0到255.255.255.254，<strong>255.255.255.255用于广播地址</strong></p>
</blockquote>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><blockquote>
<p>  用来找到某个网络中的特定应用,一个应用可以同时有多个端口</p>
<p>  “端口”是英文port的意译,可以认为是设备与外界通讯交流的出口。<strong>端口可分为虚拟端口和物理端口</strong>,其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端口,是逻辑意义上的端口。例如计算机中的80端口、21 端口、23端口等</p>
<p>  物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等R]45端口。电话使用R]11插口也属于物理端口的范畴</p>
<p>  如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536 (即: 2^16) 个之多!<strong>端口是通过端口号</strong>来标记的，端口号只有整数，范围是从0到65535 (2^16-1)</p>
</blockquote>
<blockquote>
<p>  <strong>端口分类</strong></p>
<p>  1.周知端口<br>  周知端口是众所周知的端口号，也叫知名端口、公认端口或者官用端口，<strong>范围从0到1023</strong>,它们紧密绑定于一些特定的服务。例如80端口分配给WWW服务, 21端口分配给FTP服务, 23端口分配给Telnet服务等等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是在地址后面加上冒号”:” (半角)，再加上端口号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改变的，比如139端口专门用于NetBIOS与TCP&#x2F;IP之间的通信，不能手动改变。</p>
<p>  2.注册端口<br>  端口号从<strong>1024到49151</strong>,它们松散的绑定于一些服务，也就是说有许多服务绑定于这些端口，这些端口同样用于其他许多目的，如：许多系统处理端口从1024开始</p>
<p>  3.动态端口&#x2F;私有端口<br>  动态端口的范围是从49152到65535。之所以称为动态端口，是因为它一般不固定分配某种服务,而是动态分配</p>
</blockquote>
<h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110155956089.png" alt="image-20221110155956089"></p>
<h5 id="三种模型对比"><a href="#三种模型对比" class="headerlink" title="三种模型对比"></a>三种模型对比</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110160740252.png" alt="image-20221110160740252"></p>
<h5 id="封装（TCP-x2F-IP结构）"><a href="#封装（TCP-x2F-IP结构）" class="headerlink" title="封装（TCP&#x2F;IP结构）"></a>封装（TCP&#x2F;IP结构）</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140220057.png" alt="image-20221111140220057"></p>
<h5 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140701837.png" alt="image-20221111140701837"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221111140730605.png" alt="image-20221111140730605"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>应用层常见的协议有: <strong>FTP</strong>协议(File Transfer Protocol文件传输协议)、HTTP协议 (Hyper Text Transfer Protocol超文本传输协议)、<strong>NFS</strong> (Network File System网络文件系统)。</p>
<p>传输层常见协议有: <strong>TCP</strong>协议(Transmission Control Protocol传输控制协议)、UDP协议(User Datagram Protocol用户数据报协议)。</p>
<p>网络层常见协议有: <strong>IP</strong>协议(Internet Protocol因特网互联协议)、<strong>ICMP</strong>协议(Internet Control Message Protocol因特网控制报文协议)、IGMP协议(Internet Group Management Protocol因特网组管理协议)。</p>
<p>网络接口层常见协议有: <strong>ARP</strong>协议(Address Resolution Protocol地址解析协议)、<strong>RARP</strong>协议 (Reverse Address Resolution Protocol反向地址解析协议)。</p>
<h5 id="UDP头部格式"><a href="#UDP头部格式" class="headerlink" title="UDP头部格式"></a>UDP头部格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162651180.png" alt="image-20221110162651180"></p>
<h5 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162731372.png" alt="image-20221110162731372"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162838743.png" alt="image-20221110162838743"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162859467.png" alt="image-20221110162859467"></p>
<h5 id="IPv4头部结构"><a href="#IPv4头部结构" class="headerlink" title="IPv4头部结构"></a>IPv4头部结构</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110162942609.png" alt="image-20221110162942609"></p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163111692.png" alt="image-20221110163111692"></p>
<h5 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163326444.png" alt="image-20221110163326444"></p>
<h5 id="ARP报文格式"><a href="#ARP报文格式" class="headerlink" title="ARP报文格式"></a>ARP报文格式</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221110163211127.png" alt="image-20221110163211127"></p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>socket是一个接口，在用户进程与TCP&#x2F;IP协议之间充当中间人，完成TCP&#x2F;IP协议的书写，用户只需理解接口即可</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI1ODk3OQ==,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p>
<p>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议</p>
<p>socket本身有”插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的,我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将T封装成文件的目的是为了统-接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p>
<h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>字节序分为大端字节序(Big-Endian) 和小端字节序(ittle-Endian) </p>
<p>大端字节序是指一个整数的最高位字节(23<del>31 It)存储在内存的低地址处,低位字节(0</del> 7 bit)存储在内存的高地址处;</p>
<p>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</p>
<h6 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h6><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是:发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序,所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换(小端机转换,大端机不转换)。<strong>网络字节顺序是TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式</strong></p>
<p>BSD Socket提供了封装好的转换接口，方更程序员使用。包括</p>
<blockquote>
<p>  从主机字节序到网络字节序的转换函数: htons、htonl;</p>
<p>  从网络字节序到主机字节序的转换函数: ntohs、 ntohl。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">h- host主机，主机字节序</span><br><span class="line">to- 转换成什么</span><br><span class="line">n- network 网络字节序</span><br><span class="line">s- <span class="type">short</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口的 端口16位</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>; <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换IP的，IP地址32位</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">hton1</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntoh1</span><span class="params">(<span class="type">uint32_t</span> net1ong)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// htons 主机端口 -&gt; 网络端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = <span class="built_in">htons</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl 主机IP -&gt; 网络IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)buf;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">htonl</span>(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="IP转换函数（有字节序转换的功能）"><a href="#IP转换函数（有字节序转换的功能）" class="headerlink" title="IP转换函数（有字节序转换的功能）"></a>IP转换函数（有字节序转换的功能）</h5><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。</p>
<p><strong>但编程中我们需要先把它们转化为整数(二进制数)方能使用。</strong></p>
<p><strong>而记录日志时则相反,我们要把整数表示的IP地址转化为可读的字符串。</strong></p>
<p>下面 3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">in_addr_t inet_addr (const char *cp);</span></span><br><span class="line"><span class="comment">int inet_aton(const char *cp, struct in_addr *inp);</span></span><br><span class="line"><span class="comment">char *inet_ntoa(struct in_addr in);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面这对更新的函数也能完成前面3个函数同样的功能，并且它们同时适用IPv4地址和IPv6地址:</p>
<h6 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton"></a>inet_pton</h6><p><code>int inet_pton(int af, const char *src, void *dst); </code>	将点分十进制的ip地址转化为用于网络传输的数值格式</p>
<blockquote>
<p>  af 		选择ipv4还是ipv6   AF_INET 或者 AF_INET6</p>
<p>  src		需要转换的点分十进制IP字符串</p>
<p>  dst		传出参数，数据转换后保存在dst中</p>
<p>  返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1</p>
</blockquote>
<h6 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop"></a>inet_ntop</h6><p><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 	将数值格式转化为点分十进制的ip地址格式</p>
<blockquote>
<p>  af 		选择ipv4还是ipv6   AF_INET 或者 AF_INET6</p>
<p>  src		需要转换的整数的地址</p>
<p>  dst		传出参数，数据转换后保存在dst中（IP字符串）</p>
<p>  size		指定dst的大小（数组的容量）</p>
<p>  返回值：若成功则为转换后的字符串的指针（与dst为同一个值），若出错则为NULL</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.12.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 转成了整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个IP字符串</span></span><br><span class="line">    <span class="type">char</span> dst[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str = <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, dst, <span class="built_in">sizeof</span>(dst)); <span class="comment">// dst为数组首地址</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; <span class="comment">// 转成了IP字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h5><h6 id="通用socket地址-只为IPv4设计"><a href="#通用socket地址-只为IPv4设计" class="headerlink" title="通用socket地址(只为IPv4设计)"></a>通用socket地址(只为IPv4设计)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;<span class="comment">/*地址族类型，本教程使用AF_INET,代表TCP/IPv4协议族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];     <span class="comment">/*14字节，存放socket地址值，ip地址和端口号*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sa_family成员是地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应。常见的协议族和对应的地址族如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">协议族(domain)	地址族			描述</span></span><br><span class="line"><span class="comment">PF_UNIX		AF_UNIX		UNIX本地域协议族</span></span><br><span class="line"><span class="comment">PF_INET		AF_INET		TCP/IPv4协议族</span></span><br><span class="line"><span class="comment">PF_INET6	AF_INET6	TCP/IPv6协议族</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h6 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h6><p>作为参数使用时要强转成sockaddr类型</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112140046029.png" alt="image-20221112140046029"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;<span class="comment">//地址族：AF_INET</span></span><br><span class="line">	<span class="type">u_int16_t</span> sin_port;<span class="comment">//端口号，要用网络字节序表示</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">//IPV4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">	<span class="type">u_int32_t</span> s_addr;<span class="comment">//ipv4地址，要用网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h4><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>socket通信分两部分：服务器端与客户端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端(被动接受连接的角色)</span></span><br><span class="line"><span class="number">1.</span>创建一个用于监听的套接字【lfd】</span><br><span class="line">	-监听:监听有客户端的连接</span><br><span class="line">	-套接字:这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span>将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)【【saddr要设置IP、端口、协议】lfd与saddr绑定】</span><br><span class="line">	-客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span>设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字【clientaddr只要定义, cfd【cfd与clientaddr通信】】</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字【clientfd】</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定连接的服务器的IP和端口【serveraddr要设置IP、端口、协议【clientfd与serveraddr连接，用clientfd通信】】</span><br><span class="line"><span class="number">3.</span>连接成功了，客户端可以直接和服务器通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">4.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221112154950130.png" alt="image-20221112154950130" style="zoom:50%;">



<h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><h5 id="要包含的头文件"><a href="#要包含的头文件" class="headerlink" title="要包含的头文件"></a>要包含的头文件</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 若包含了这个，上面两个可以省略</span></span></span><br></pre></td></tr></table></figure>



<h5 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h5><p><code>int socket(int domain, int type, int protocol);</code> 	创建一个套接字</p>
<blockquote>
<p>  domain	协议族</p>
<p>  ​	AF_INET : ipv4<br>  ​	AF_INET6 : ipv6<br>  ​	AF_UNIX，AF_LOCAL :本地套接字通信(进程间通信)</p>
<p>  type	通信过程中使用的协议类型</p>
<p>  ​	SOCK_STREAM : 流式协议<br>  ​	SOCK_DGRAM : 报式协议</p>
<p>  protocol 	具体的一个协议。一般写0</p>
<p>  ​	SOCK_STREAM : 流式协议默认使用TCP<br>  ​	SOCK_DGRAM : 报式协议默认使用UDP</p>
<p>  返回值	成功:返回文件描述符，操作的就是内核缓冲区	失败: -1</p>
</blockquote>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 	绑定，将fd和本地的IP +端口进行绑定</p>
<blockquote>
<p>  sockfd 	通过socket函数得到的文件描述符</p>
<p>  addr 	需要绑定的socket地址， 这个地址封装了ip和端口号的信息</p>
<p>  addrlen 	第二个参数结构体占的内存大小</p>
</blockquote>
<h5 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h5><p><code>int listen(int sockfd, int backlog);</code>		监听这个socket上的连接</p>
<blockquote>
<p>  sockfd 	通过socket ()函数得到的文件描述符</p>
<p>  backlog 	未连接的和已经连接的和的最大值，给5就行  不能超过&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值</p>
</blockquote>
<h5 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h5><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>	阻塞的函数，阻塞等待客户端连接</p>
<blockquote>
<p>  sockfd 	用于监听的文件描述符</p>
<p>  addr 	传出参数，记录了连接成功后客户端的地址信息(ip, port)</p>
<p>  addrlen 	指定第二个参数的对应的内存大小</p>
<p>  返回值	成功返回用于通信的文件描述符，失败返回-1</p>
</blockquote>
<h5 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h5><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>	客户端连接服务器</p>
<blockquote>
<p>  sockfd 	用于通信的文件描述符</p>
<p>  addr 	客户端要连接的服务器的地址信息</p>
<p>  addrlen 	第二个参数的内存大小</p>
</blockquote>
<h5 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h5><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<h5 id="send"><a href="#send" class="headerlink" title="(send)"></a>(send)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">send</span>( cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h5 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h5><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<h5 id="recv"><a href="#recv" class="headerlink" title="(recv)"></a>(recv)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">recv</span>(cfd, recvBuf, <span class="built_in">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\);</span></span><br><span class="line"><span class="string">	break ;</span></span><br><span class="line"><span class="string">&#125;else if(len &gt; 0)&#123;</span></span><br><span class="line"><span class="string">	printf(&quot;</span>read buf = %s\n<span class="string">&quot;, recvBuf);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="fgets"><a href="#fgets" class="headerlink" title="* fgets"></a>* fgets</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">fgets</span>(sendBuf, <span class="built_in">sizeof</span>(sendBuf), stdin); <span class="comment">// 阻塞，接收用户输入，再写入sendBuf</span></span><br><span class="line"><span class="built_in">write</span>(fd, sendBuf, <span class="built_in">strlen</span>( sendBuf) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h4 id="代码实现服务器-x2F-客户端通信"><a href="#代码实现服务器-x2F-客户端通信" class="headerlink" title="代码实现服务器&#x2F;客户端通信"></a>代码实现服务器&#x2F;客户端通信</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCP通信的服务器端</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个用于监听的套接字(lfd)</span></span><br><span class="line"><span class="comment">	-监听:监听有客户端的连接</span></span><br><span class="line"><span class="comment">	-套接字:这个套接字其实就是一个文件描述符</span></span><br><span class="line"><span class="comment">2.将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)</span></span><br><span class="line"><span class="comment">	-客户端连接 服务器的时候使用的就是这个IP和端口</span></span><br><span class="line"><span class="comment">3.设置监听，监听的fd开始工作</span></span><br><span class="line"><span class="comment">4.阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字(cfd)</span></span><br><span class="line"><span class="comment">5.通信</span></span><br><span class="line"><span class="comment">	-接收数据</span></span><br><span class="line"><span class="comment">	-发送数据</span></span><br><span class="line"><span class="comment">6.通信结束，断开连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bind() </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">// 网络协议</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.12.1&quot;, &amp;saddr.sin_addr.s_addr); // IP</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 服务器开发时可写,表示服务器端任何IP都可以被客户端访问</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 8为连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.accept()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd  = <span class="built_in">accept</span>(listenfd, (sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span> *)len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 获取客户端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示客户端断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCP通信的客户端</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个用于通信的套接字(clientfd)</span></span><br><span class="line"><span class="comment">2.连接服务器，需要指定连接的服务器的IP和端口</span></span><br><span class="line"><span class="comment">3.连接成功了，客户端可以直接和服务器通信</span></span><br><span class="line"><span class="comment">	-接收数据</span></span><br><span class="line"><span class="comment">	-发送数据</span></span><br><span class="line"><span class="comment">4.通信结束，断开连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clientfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %d\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示服务器断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手 &amp; 四次挥手"></a>TCP三次握手 &amp; 四次挥手</h4><h5 id="三次握手-发生在客户端connect-中"><a href="#三次握手-发生在客户端connect-中" class="headerlink" title="三次握手(发生在客户端connect()中)"></a>三次握手(发生在客户端connect()中)</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/AB3FC1B1325FA341A39644BA061FA439.jpeg" alt="img" style="zoom:50%;">

<p>1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq&#x3D;x），请求建立连接，等待确认</p>
<p>2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK&#x3D;x+1）确认收到，同时发送一个SYN包（seq&#x3D;y）给客户端</p>
<p>3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK&#x3D;y+1）告诉服务端已经收到</p>
<p>4）三次握手完成，成功建立连接，开始传输数据</p>
<h5 id="四次握手-发生在两端close-中"><a href="#四次握手-发生在两端close-中" class="headerlink" title="四次握手(发生在两端close()中)"></a>四次握手(发生在两端close()中)</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg" alt="img" style="zoom:50%;">

<p>1）客户端发送FIN包（FIN&#x3D;1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据</p>
<p>2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕</p>
<p>3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接</p>
<p>4）客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><ol>
<li><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的</p>
<p>TCP的滑动窗口解决了<strong>端到端的流量控制</strong>、ACK确认、拥塞控制 问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据</p>
</li>
<li><p>TCP协议要求维护以下两个端口：</p>
<ol>
<li>接收窗口rwnd，<strong>接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量</strong>( 由接收方根据其放在TCP报文的首部的窗口字段通知发送方)</li>
<li>拥塞窗口cwnd，<strong>发送方根据自己估算的网络拥塞程度而设置的窗口值</strong>，反映网络的当前容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。</li>
</ol>
<ul>
<li>发送窗口的上限值应取接收窗口rwnd和拥塞窗口cwnd中较小的一个 <strong>发送窗口的上限值&#x3D;min{rwnd，cwnd}</strong></li>
</ul>
</li>
</ol>
<h5 id="发送方如何维护拥塞窗口"><a href="#发送方如何维护拥塞窗口" class="headerlink" title="发送方如何维护拥塞窗口"></a>发送方如何维护拥塞窗口</h5><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-eff93036b85f660537ac9c8036cb896b_1440w.webp" alt="img" style="zoom:67%;">

<h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/v2-b4e28461732b87b1d96da64456868ec4_1440w.webp" alt="img" style="zoom:67%;">

<h5 id="补充-TCP两种重传方式"><a href="#补充-TCP两种重传方式" class="headerlink" title="(补充)TCP两种重传方式"></a>(补充)TCP两种重传方式</h5><p>TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为<strong>超时重传</strong> </p>
<p>另一种方式的重传称为<strong>快速重传</strong>，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传</p>
<h4 id="TCP通信并发"><a href="#TCP通信并发" class="headerlink" title="TCP通信并发"></a>TCP通信并发</h4><h5 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h5><h6 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:</span></span><br><span class="line"><span class="comment">1.一个父进程,多个子进程</span></span><br><span class="line"><span class="comment">2.父进程: 负责等待并接受客户端的连接</span></span><br><span class="line"><span class="comment">3.子进程: 完成通信，接受一个客户端连接，就创建一个子进程用于通信</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，就创建一个子进程和客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// pid == 0 为子进程</span></span><br><span class="line">            <span class="comment">// 输出客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 通信</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//表示客户端断开连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">                <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="comment">// exit(0);  可写可不写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i ++);</span><br><span class="line">        <span class="built_in">write</span>(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示服务器断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="第二版-回收子进程资源"><a href="#第二版-回收子进程资源" class="headerlink" title="第二版(回收子进程资源)"></a>第二版(回收子进程资源)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recycleChild</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); <span class="comment">// -1代表回收所有子进程， WNOHANG代表非阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//被回收了  </span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;被回收了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 注册信号捕捉, 目的是回收资源</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recycleChild; <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，就创建一个子进程和客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// pid == 0 为子进程</span></span><br><span class="line">            <span class="comment">// 输出客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 通信</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//表示客户端断开连接</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 不break的话会继续发送一份数据</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                <span class="built_in">write</span>(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="comment">// exit(0);  可写可不写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i ++);</span><br><span class="line">        <span class="built_in">write</span>(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示服务器断开连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;server closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 只是为了教学方便</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockInfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// cfd</span></span><br><span class="line">    <span class="type">pthread_t</span> tid; <span class="comment">// 自己tid</span></span><br><span class="line">    sockaddr_in addr; <span class="comment">// 客户端信息</span></span><br><span class="line">&#125;;</span><br><span class="line">sockInfo sockInfos[<span class="number">128</span>]; <span class="comment">// 最多有128个子线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">working</span><span class="params">(<span class="type">void</span> * arg)</span></span>&#123;</span><br><span class="line">    sockInfo* pinfo = (sockInfo* )arg;</span><br><span class="line">    <span class="comment">// 5.子线程和客户端通信</span></span><br><span class="line">    <span class="comment">// 输出客户端信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(pinfo-&gt;fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf)) ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示客户端断开连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 不break的话会继续发送一份数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(pinfo-&gt;fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">sizeof</span>(sockInfos) / <span class="built_in">sizeof</span>(sockInfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i ++)&#123;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;sockInfos[i], <span class="built_in">sizeof</span>(sockInfos[i]));</span><br><span class="line">        sockInfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockInfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accept() 并创建子线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockInfo</span> * pinfo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i ++)&#123;</span><br><span class="line">            <span class="comment">//从这个数组I找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockInfos[i].fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                pinfo = &amp;sockInfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo -&gt; fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo -&gt; addr, &amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pinfo -&gt; tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// pthread_join() 不能用，因为它是阻塞的。如果子线程不死亡，主线程则会一直卡在此处，不会执行 while 循环</span></span><br><span class="line">        <span class="built_in">pthread_detach</span>(pinfo -&gt; tid); <span class="comment">// 设置线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.close()</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TCP半关闭、端口复用"><a href="#TCP半关闭、端口复用" class="headerlink" title="TCP半关闭、端口复用"></a>TCP半关闭、端口复用</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p><code>int shutdown(int sockfd, int how);</code></p>
<blockquote>
<p>  当TCP链接中A向B发送FIN请求关闭，另一端B回应ACK之后(A端进入FIN_WAIT2状态)，并没有立即发送FIN给A, A处于半连接状态(半开关)，此时A可以接收B发送的数据，但是A已经不能再向B发送数据。从程序的角度，可以使用API来控制实现半连接状态:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line">sockfd:		需要关闭的socket的描述符</span><br><span class="line">how:	允许为shutdown操作选择以下几种方式:</span><br><span class="line"><span class="built_in">SHUT_RD</span>(<span class="number">0</span>):		关闭sdckfd上的读功能，此选项将不允许sockfd进行读操作</span><br><span class="line">				该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉</span><br><span class="line"><span class="built_in">SHUT_WR</span>(<span class="number">1</span>):		关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作</span><br><span class="line"><span class="built_in">SHUT_RDWR</span>(<span class="number">2</span>):	关闭sockfd的读写功能。相当于调用shut down两次:首先是以SHUT_RD ,然后以SHUT_WR</span><br></pre></td></tr></table></figure>

<p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写</p>
<p>注意:</p>
<ol>
<li><p>如果有多个进程共享一个套接字, close 每被调用一次,计数减1，直到计数为0时，也就是所用进程都调用了close,套接字将被释放</p>
</li>
<li><p><strong>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后,其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响到其它进程</strong></p>
</li>
</ol>
<h5 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h5><blockquote>
<p>  设置端口复用（也可以设置socket的其他属性）：</p>
<ol>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>防止程序突然退出而系统没有释放端口</li>
</ol>
  <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221116151457850.png" alt="image-20221116151457850" style="zoom:50%;">
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- sockfd: 要操作的文件描述符</span><br><span class="line">- level: 级别</span><br><span class="line">    <span class="built_in">SOL_SOCKET</span> (端口复用的级别)</span><br><span class="line">- optname: 选项的名称</span><br><span class="line">    SO_REUSEADDR</span><br><span class="line">    SO_REUSEPORT</span><br><span class="line">-optval: 端口复用的值(端口复用中为整型)</span><br><span class="line">    <span class="number">1</span>:	可以复用</span><br><span class="line">    <span class="number">0</span>:	不可以复用</span><br><span class="line">-optlen: optva1参数的大小</span><br><span class="line">    </span><br><span class="line">端口复用，设置的时机是在服务器绑定端口之前。</span><br><span class="line"><span class="built_in">setsockopt</span>();</span><br><span class="line"><span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure>



<h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><blockquote>
<p>  查看网络相关信息的命令</p>
<p>  参数:<br>  -a	所有的socket<br>  -p	显示正在使用socket的程序的名称<br>  -n	直接使用IP地址,而不通过域名服务器</p>
</blockquote>
<h4 id="IO多路复用-转接"><a href="#IO多路复用-转接" class="headerlink" title="IO多路复用(转接)"></a>IO多路复用(转接)</h4><p>I:	输入 指数据由	程序(文件) -&gt; 内存</p>
<p>O:	输出 指数据由	内存 -&gt; 程序(文件） </p>
<p>I&#x2F;O多路复用使得程序能同时监听多个文件描述符(在此之前，若有多个客户端同时请求，我们只能在while循环中依次监听),能够提高程序的性能, Linux 下实现I&#x2F;O多路复用的系统调用主要有select, poll 和epoll</p>
<h5 id="几种常见的I-x2F-O模型"><a href="#几种常见的I-x2F-O模型" class="headerlink" title="几种常见的I&#x2F;O模型"></a>几种常见的I&#x2F;O模型</h5><h6 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7786.PNG" alt="IMG_7786" style="zoom: 33%;">

<h6 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7787.PNG" alt="IMG_7787" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7788.PNG" alt="IMG_7788" style="zoom: 33%;">

<p>解决NIO的方法:IO多路复用</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7790.PNG" alt="IMG_7790" style="zoom: 33%;">

<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IMG_7791.PNG" alt="IMG_7791" style="zoom: 33%;">



<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ol>
<li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回。<ul>
<li>函数对文件描述符的检测的操作是由内核完成的</li>
<li>在返回时，它会告诉进程有多少(哪工)描述符要进行I&#x2F;O操作</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds , fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">    - nfds	委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">    - readfds	要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">    - writefds	要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        - 委托内核检测写缓冲区是不是还可以写数据(不满的就可以写)</span><br><span class="line">    - exceptfds :检测发生异常的文件描述符的集合</span><br><span class="line">    - timeout	设置的超时时间</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeva1</span> &#123;</span><br><span class="line">        	<span class="type">long</span> tv_ sec; <span class="comment">/* seconds */</span></span><br><span class="line">        	<span class="type">long</span> tv_ _usec; <span class="comment">/* microseconds */</span></span><br><span class="line">        &#125;;</span><br><span class="line">	- <span class="literal">NULL</span>	永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">		- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>，不阻塞</span><br><span class="line">		- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>，阻塞对应的时间</span><br><span class="line">-返回值:</span><br><span class="line">	- <span class="number">-1</span>		失败</span><br><span class="line">    - &gt;<span class="number">0</span> (n)	检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *set); <span class="comment">//将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">//判断fd对应的标志位是0还是1，返回值 : fd对应的标志位的值， 0, 返回0，1, 返回1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>; <span class="comment">// fd_set共有1024 bit,全部初始化为0</span></span><br></pre></td></tr></table></figure>

<h6 id="select工作流程"><a href="#select工作流程" class="headerlink" title="select工作流程"></a>select工作流程</h6><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117131507683.png" alt="image-20221117131507683" style="zoom: 67%;">

<h6 id="select代码实现"><a href="#select代码实现" class="headerlink" title="select代码实现"></a>select代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, temp; <span class="comment">// rdset是用户自己维护的, temp是交给内核去修改的</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset); <span class="comment">//初始化，全置0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset); <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = rdset;</span><br><span class="line">        <span class="comment">// 调用select，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;temp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">// 这里我们设置的timeval为NULL，所以是阻塞型，ret不可能返回0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;temp))&#123;</span><br><span class="line">                <span class="comment">// 判断fd对应的标志位是0还是1 , 为1代表有新的客户端连接进来了</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到set中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i ++)&#123; <span class="comment">// lfd最先被监听，肯定在最前面</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;temp))&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h6><ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了默认是1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;po11.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">po11fd</span>&#123;</span><br><span class="line">	<span class="type">int</span>	fd;	<span class="comment">/*委托内核检测的文件描述符*/</span></span><br><span class="line">	<span class="type">short</span> events;	<span class="comment">/*委托内核检测文件描述符的什么事件*/</span></span><br><span class="line">	<span class="type">short</span> revents;	<span class="comment">/*内核返回文件描述符实际发生的事件*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">po11</span><span class="params">(<span class="keyword">struct</span> po11fd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	-fds	是一个<span class="keyword">struct</span> <span class="title class_">pol1fd</span>结构体数组，这是一个需要检测的文件描述符的集合</span><br><span class="line">	-nfds	这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">	-timeout	阻塞时长</span><br><span class="line">        <span class="number">0</span>	不阻塞</span><br><span class="line">        <span class="number">-1</span> 	阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">        &gt;<span class="number">0</span> 	阻塞的时长</span><br><span class="line">-返回值: </span><br><span class="line">    <span class="number">-1</span>	失败</span><br><span class="line">    &gt;<span class="number">0</span> (n) 	成功，n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117145127724.png" alt="image-20221117145127724"></p>
<h6 id="poll代码实现"><a href="#poll代码实现" class="headerlink" title="poll代码实现"></a>poll代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">//需要检测读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>; <span class="comment">// 这里就是最大索引，而不是最大索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用 poll，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123; <span class="comment">// 有新客户端连接进来了，因为revents 返回的是 POLLIN ｜ POLLOUT</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将cfd加入到监听数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i ++)&#123; <span class="comment">// 0是lfd</span></span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)&#123; <span class="comment">// fds[i]可用</span></span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i ++)&#123; <span class="comment">// lfd最先被监听，为0</span></span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h6><ol>
<li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
</li>
<li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
</li>
<li><p><del>select支持的文件描述符数量太小了默认是1024</del></p>
</li>
<li><p><del>fds集合不能重用，每次都需要重置</del></p>
</li>
</ol>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个新的epo11实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息(红黑树)，还有一个是就绪列表，存放检测到数据发生改变的文件描述符信息(双向链表)。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	size :目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">-返回值:</span><br><span class="line">	<span class="number">-1</span>	失败</span><br><span class="line">	&gt;<span class="number">0</span>	文件描述符，操作epo11实例的</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epo11_data</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epo11_event</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epo11 events */</span></span><br><span class="line">	<span class="type">epo11_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对epoll实例进行管理:添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_ct1</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epo11_event *event)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	epfd	epo11实例对应的文件描述符</span><br><span class="line">	op		要进行什么操作</span><br><span class="line">            EPOLL_CTL_ADD:添加</span><br><span class="line">            EPOLL_CTL_MOD:修改</span><br><span class="line">            EPOLL_CTL_DEL :删除</span><br><span class="line">	fd		要检测的文件描述符</span><br><span class="line">    event	检测文件描述符什么事情</span><br><span class="line">        EPOLLIN</span><br><span class="line">        EPOLLOUT</span><br><span class="line">        EPOLLERR</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epo11_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epo11_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">	epfd	epo11实例对应的文件描述符</span><br><span class="line">	events	传出参数,数组,保存了发生了变化的文件描述符的信息,</span><br><span class="line">	maxevents	第二个参数结构体数组的大小</span><br><span class="line">	timeout	阻塞时间</span><br><span class="line">		<span class="number">0</span>:不阻塞</span><br><span class="line">		<span class="number">-1</span> :阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">		&gt;<span class="number">0</span>:阻塞的时长(毫秒)</span><br><span class="line">返回值:</span><br><span class="line">	成功	返回发送变化的文件描述符的个数</span><br><span class="line">	失败	<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221117172543560.png" alt="image-20221117172543560"></p>
<h6 id="epoll代码实现"><a href="#epoll代码实现" class="headerlink" title="epoll代码实现"></a>epoll代码实现</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将监听的文件描述符相关的检测信息加入到epoll实例中</span></span><br><span class="line">    epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN; <span class="comment">// 要检测他的读事件</span></span><br><span class="line">    epev.data.fd = lfd; <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line">    </span><br><span class="line">    epoll_event epevs[<span class="number">1024</span>]; <span class="comment">// 内核检测后会将已就绪的文件描述符放在这里面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>); <span class="comment">// -1设置阻塞。只有设置了阻塞时，会返回0，代表超时了都没有检测到变化的文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(epevs[i].data.fd == lfd) &#123; <span class="comment">// 监听到了客户端的连接</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); <span class="comment">// 添加到epoll实例中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// epevs[i].data.fd == cfd  有数据到达，通信</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(epevs[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// 将此fd从红黑树中删除</span></span><br><span class="line">                    <span class="built_in">close</span>(epevs[i].data.fd); <span class="comment">// close(cfd)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">write</span>(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="epoll两种工作模式"><a href="#epoll两种工作模式" class="headerlink" title="epoll两种工作模式"></a>epoll两种工作模式</h6><ul>
<li><p>LT模式(水平触发)</p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区-&gt;读缓冲区有数据 -&gt; epoll检测到了会给用户通知</p>
<ol>
<li>用户不读数据，数据一直在缓冲区，epoll 会一直通知</li>
<li>用户只读了一部分数据， epoll会通知</li>
<li>缓冲区的数据读完了，不通知</li>
</ol>
<blockquote>
<p>  LT (level - triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行操作。如果你不作任何操作，内核还是会继续通知你的</p>
</blockquote>
</li>
<li><p>ET模式(边沿触发) </p>
<p>假设委托内核检测读事件-&gt;检测fd的读缓冲区-&gt;读缓冲区有数据-&gt; epoll检测到了会给用户通知</p>
<ol>
<li>用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</li>
<li>用户只读了一部分数据，epoll不通知</li>
<li>缓冲区的数据读完了，不通知</li>
</ol>
<blockquote>
<p>  ET (edge - triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epolI告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是, 如果一直不对这个fd做操作, 内核不会发送更多的通知</p>
</blockquote>
<p>EPOLLONESHOT（相当于一个socket的锁）</p>
<blockquote>
<p>  即使可以使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。 比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读. (EPOLIN再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。一个socket连接在任一时刻都只被一个线程处理， 可以使用epoll的 EPOLLONESHOT 事件实现</p>
<p>  对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件,且只触发一次，除非我们使用epoll_ ctl 函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。<strong>但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket</strong></p>
</blockquote>
</li>
</ul>
<h4 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h4><h5 id="UDP通信流程"><a href="#UDP通信流程" class="headerlink" title="UDP通信流程"></a>UDP通信流程</h5><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118183329846.png" alt="image-20221118183329846" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> f1ags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	sockfd	通信的fd</span><br><span class="line">	buf	要发送的数据</span><br><span class="line">	<span class="number">1</span>en	发送数据的长度</span><br><span class="line">	flags	写<span class="number">0</span>就好</span><br><span class="line">	dest_addr :通信的另外一端的地址信息</span><br><span class="line">	addrlen	地址的内存大小</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">-参数:</span><br><span class="line">	sockfd	通信的fd</span><br><span class="line">	buf	接收数据的数组</span><br><span class="line">	len	数组的大小</span><br><span class="line">	flags	<span class="number">0</span></span><br><span class="line">	src_addr	用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">	addrlen	地址的内存大小</span><br></pre></td></tr></table></figure>



<h5 id="UDP通信代码实现"><a href="#UDP通信代码实现" class="headerlink" title="UDP通信代码实现"></a>UDP通信代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UDP服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        sockaddr_in clientaddr;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>, (sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client IP :&quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, ipbuf, <span class="built_in">sizeof</span>(ipbuf)) &lt;&lt; <span class="string">&quot; Port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(clientaddr.sin_port) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say :&quot;</span> &lt;&lt; recvbuf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;clientaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UDP通信客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// saddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf, <span class="string">&quot;hello, i am client: %d\n&quot;</span>, num ++);</span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, sendbuf, <span class="built_in">strlen</span>(sendbuf) + <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收 </span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, sendbuf, <span class="built_in">sizeof</span>(sendbuf), <span class="number">0</span>, (sockaddr*)&amp;saddr, (<span class="type">socklen_t</span>*)<span class="built_in">sizeof</span>(saddr));</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;server say :&quot;</span> &lt;&lt; sendbuf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>子网号：主机号（主机号全0表示该子网，全1代表在该子网中广播）</p>
<blockquote>
<p>  向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。</p>
<ol>
<li>只能在局域网中使用</li>
<li>客户端(ABCD)需要绑定服务器(下图左)广播使用的端口，才可以接收到广播消息</li>
</ol>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221118231053331.png" alt="image-20221118231053331" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置广播属性的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line">	sockfd : 文件描述符</span><br><span class="line">	level : SOL_SOCKET</span><br><span class="line">	optname : SO_BROADCAST</span><br><span class="line">	optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">	optlen : optval的大小</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- 【fd】</span><br><span class="line">(<span class="number">2</span>) 设置为允许发送广播权限 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">3</span>) 填充广播信息结构体 -- 【clientaddr设置IP（X.X.X<span class="number">.255</span>）、端口 用来通信】</span><br><span class="line">(<span class="number">4</span>) 发送数据 -- <span class="built_in">sendto</span>()</span><br><span class="line"></span><br><span class="line">接受者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 --  【fd】</span><br><span class="line">(<span class="number">2</span>) 填充广播信息结构体 -- 【addr设置<span class="built_in">IP</span>(<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>)、端口 用来通信】</span><br><span class="line">(<span class="number">3</span>) 将套接字与广播信息结构体绑定 -- 【addr和fd】</span><br><span class="line">(<span class="number">4</span>) 接收数据 -- <span class="built_in">recvfrom</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BROADCAST_IP <span class="string">&quot;192.168.99.255&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为允许发送广播权限</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(fd , SOL_SOCKET , SO_BROADCAST , &amp;op , <span class="built_in">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造client地址  IP+端口号 </span></span><br><span class="line">    sockaddr_in clientaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, BROADCAST_IP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址--IP地址本地，端口号9000</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span> , &amp;addr.sin_addr.s_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><blockquote>
<p>  单播地址标识单个IP接口,广播地址标识某个子网的所有IP接口，多播地址标识一组IP接口。</p>
<p>  单播和广播是寻址方案的两个极端(要么单个要么全部)，多播则意在两者之间提供一种折中方案。 多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外,广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119030142283.png" alt="image-20221119030142283" style="zoom:50%;">

<p>组播地址</p>
<blockquote>
<p>  IP多播通信必须依赖于IP多播地址，在IPv4中它的范围从224.0.0.0 到239.255.255.255.并被划分为<br>  局部链接多播地址、预留多播地址、管理权限多播地址</p>
<table>
<thead>
<tr>
<th align="left">IP地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">244.0.0.0~244.0.0.255</td>
<td>局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="left">244.0.1.0~244.0.1.255</td>
<td>预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="left">244.0.2.0~238.255.255.255</td>
<td>预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效</td>
</tr>
<tr>
<td align="left">239.0.0.0~239.255.255.255</td>
<td>本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level,<span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器设置多播的信息，外出接口</span></span><br><span class="line">    - leve1 : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端加入到多播组:</span></span><br><span class="line">	- leve1 : IPPROTO_IP</span><br><span class="line">	- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">	- optva1 : <span class="keyword">struct</span> <span class="title class_">ip_mreq</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ip_mreq</span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_multiaddr; <span class="comment">//组播的IP地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_address; <span class="comment">//本地的IP地址</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">            <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjc1MDYyMw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送者：</span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- <span class="built_in">socket</span>()</span><br><span class="line">(<span class="number">2</span>) 填充组播信息结构体 -- <span class="built_in">sockaddr_in</span></span><br><span class="line">(<span class="number">3</span>) 设置为组播属性 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">4</span>) 发送数据 -- <span class="built_in">sendto</span>()</span><br><span class="line"></span><br><span class="line">接收者： </span><br><span class="line">(<span class="number">1</span>) 创建套接字 -- <span class="built_in">socket</span>()</span><br><span class="line">(<span class="number">2</span>) 填充组播信息结构体 -- <span class="built_in">sockaddr_in</span></span><br><span class="line">(<span class="number">3</span>) 将套接字与组播信息结构体绑定 -- <span class="built_in">bind</span>()</span><br><span class="line">(<span class="number">4</span>) 设置为加入多播组 -- <span class="built_in">setsockopt</span>()</span><br><span class="line">(<span class="number">5</span>) 接收数据 -- <span class="built_in">recvfrom</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIIP <span class="string">&quot;239.0.0.10&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket()</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多播属性，设置外出接口</span></span><br><span class="line">    in_addr imr_multiaddr; </span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;imr_multiaddr.s_addr); <span class="comment">//初始化多播地址</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="built_in">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端地址信息</span></span><br><span class="line">    sockaddr_in clientaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, <span class="built_in">sizeof</span>(clientaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIIP <span class="string">&quot;239.0.0.10&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址  IP地址本地，端口号9000</span></span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ip_mreq  op;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, MULTIIP, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="built_in">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h4><blockquote>
<p>  本地套接字：同一主机的进程间通信，有没有关系的进程间通信都可以实现</p>
<p>  采用TCP通信流程</p>
</blockquote>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221119135550407.png" alt="image-20221119135550407" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>&#123;</span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sun_family; <span class="comment">// 地址族协议， AF_LOCAL</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径，这是一个伪文件，大小永远为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地套接字通信的流程- tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="number">1.</span>创建监听的套接字</span><br><span class="line">	<span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span>监听的套接字绑定本地的套接字文件-&gt; server端 </span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr;</span><br><span class="line">	<span class="comment">//绑定成功之后，指定的sun_ path中的套接字文件会自动生成。</span></span><br><span class="line">	<span class="built_in">bind</span>(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span>监听</span><br><span class="line">	<span class="built_in">listen</span>(lfd,<span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span>等待并接受连接请求</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> cliaddr ;</span><br><span class="line">	<span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">    接收数据: read/recv</span><br><span class="line">    发送数据: write/send</span><br><span class="line"><span class="number">6.</span>关闭连接</span><br><span class="line">	<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建通信的套接字</span><br><span class="line">	<span class="type">int</span> fd = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span>监听的套接字绑定本地的IP端口</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr ;</span><br><span class="line">    <span class="comment">//绑定成功之后，指定的sun_ path中的套接字文件会自动生成。</span></span><br><span class="line">    <span class="built_in">bind</span>(fd, addr, len);</span><br><span class="line"><span class="number">3.</span>连接服务器</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> serveraddr ;</span><br><span class="line">    <span class="built_in">connect</span>(fd，&amp;serveraddr ，<span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span>通信</span><br><span class="line">    接收数据: read/recv</span><br><span class="line">    发送数据: write/send</span><br><span class="line"><span class="number">5.</span>关闭连接</span><br><span class="line">	<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>





<h3 id="项目实战与总结"><a href="#项目实战与总结" class="headerlink" title="项目实战与总结"></a>项目实战与总结</h3><h4 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h4><blockquote>
<p>  IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132531092.png" alt="image-20221120132531092"></p>
<blockquote>
<p>  无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
</blockquote>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120132728012.png" alt="image-20221120132728012"></p>
<h4 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h4><h5 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h5><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h5 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h5 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h5><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当10事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h5 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h5><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h5 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h5><p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h4 id="Web服务器简介及HTTP协议"><a href="#Web服务器简介及HTTP协议" class="headerlink" title="Web服务器简介及HTTP协议"></a>Web服务器简介及HTTP协议</h4><h4 id="服务器编程基本框架和两种高效的事件处理模式"><a href="#服务器编程基本框架和两种高效的事件处理模式" class="headerlink" title="服务器编程基本框架和两种高效的事件处理模式"></a>服务器编程基本框架和两种高效的事件处理模式</h4><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理</p>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120175048248.png" alt="image-20221120175048248" style="zoom:80%;">

<p><strong>模块</strong>						<strong>功能</strong><br>I&#x2F;O处理单元		   处理客户连接，读写网络数据</p>
<p>逻辑单元				业务进程或线程</p>
<p>网络存储单元		数据库、文件或缓存</p>
<p>请求队列				各单元之间的通信方式（请求队列通常被实现为池的一部分）</p>
<h5 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h5><p>服务器程序通常需要处理三类事件: I&#x2F;O 事件、信号及定时事件。</p>
<p>有两种高效的事件处理模式: Reactor 和Proactor,同步I&#x2F;O模型通常用于实现Reactor模式，异步I&#x2F;O模型通常用于实现Proactor模式。</p>
<h6 id="Reactor模式-主线程只监听"><a href="#Reactor模式-主线程只监听" class="headerlink" title="Reactor模式(主线程只监听)"></a>Reactor模式(主线程只监听)</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列。(线程池)</strong></li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式-主线程监听-异步读写socket"><a href="#Proactor模式-主线程监听-异步读写socket" class="headerlink" title="Proactor模式(主线程监听+异步读写socket)"></a>Proactor模式(主线程监听+异步读写socket)</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</p>
<p> <img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120194303146.png" alt="image-20221120194303146"></p>
<h6 id="⭐️使用同步IO的方式模拟Proactor"><a href="#⭐️使用同步IO的方式模拟Proactor" class="headerlink" title="⭐️使用同步IO的方式模拟Proactor"></a>⭐️使用同步IO的方式模拟Proactor</h6><p>使用同步I&#x2F;O方式模拟出Proactor模式。原理是:主线程执行数据读写操作,读写完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<p>使用同步I&#x2F;O模型(以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait 等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket_上的写就绪事件。_</li>
<li>主线程调用epoll_wait 等待socket可写。</li>
<li>当socket可写时，epoll_wait 通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
<img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120203431492.png" alt="image-20221120203431492" style="zoom:50%;">





<h4 id="线程同步机制类封装及线程池实现"><a href="#线程同步机制类封装及线程池实现" class="headerlink" title="线程同步机制类封装及线程池实现"></a>线程同步机制类封装及线程池实现</h4><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和CPU数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之 服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式:</p>
<p>●主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和Round Robin (轮流选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</p>
<p>●主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时,主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权”，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</p>
<p>线程池的一般模型为:</p>
<p><img src="/2022/08/10/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20221120212110980.png" alt="image-20221120212110980"></p>
<p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N:如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4 (或者+1防止其他因素造成的线程阻塞) ;对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO, IO的处理一般较慢, 多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>●空间换时间，浪费服务器的硬件资源，换取运行效率。</p>
<p>●池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</p>
<p>●当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取,无需动态分配。</p>
<p>●当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。</p>
<h4 id="项目整体流程代码实现"><a href="#项目整体流程代码实现" class="headerlink" title="项目整体流程代码实现"></a>项目整体流程代码实现</h4><h5 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>(Package _pack)&#123;</span><br><span class="line">    PackageType _type = _pack.<span class="built_in">GetType</span>();</span><br><span class="line">    <span class="keyword">switch</span>(_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            <span class="built_in">process_package_A</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            <span class="built_in">process_package_B</span>(_pack);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>带状态转换的有限状态机</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>( )&#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span>(cur_State != type_C)&#123;</span><br><span class="line">        Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">        <span class="keyword">switch</span>(cur_State)&#123;</span><br><span class="line">            <span class="keyword">case</span> type_ A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>(_pack);</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>(_pack);</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="定时检测非活跃连接"><a href="#定时检测非活跃连接" class="headerlink" title="定时检测非活跃连接"></a>定时检测非活跃连接</h4><p>见<code>/home/kjg/webserver/noactive</code></p>
<h4 id="服务器压力测试"><a href="#服务器压力测试" class="headerlink" title="服务器压力测试"></a>服务器压力测试</h4><p>Webbench是Linux上一款知名的、优秀的web性能压力测试工具。它是由Lionbridge公司开发。</p>
<ul>
<li>测试处在相同硬件上,不同服务的性能以及不同硬件上同一个服务的运行状况。</li>
<li>展示服务器的两项内容:每秒钟响应请求数和每秒钟传输数据量。</li>
</ul>
<p>基本原理: Webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p>
<p>测试示例.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd webbench<span class="number">-1.5</span>/</span><br><span class="line">./webbench -c <span class="number">1000</span> -t <span class="number">30</span> http:<span class="comment">//192.168.110.129:10000/index.htm1</span></span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">    -c 表示客户端数</span><br><span class="line">    -t 表示时间</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux &amp;&amp; 服务器</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++八股</title>
    <url>/2022/11/06/CPP%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h3 id="0️⃣C-x2F-C-基础"><a href="#0️⃣C-x2F-C-基础" class="headerlink" title="0️⃣C&#x2F;C++基础"></a>0️⃣C&#x2F;C++基础</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><h5 id="简述下C-语言的特点"><a href="#简述下C-语言的特点" class="headerlink" title="简述下C++语言的特点"></a>简述下C++语言的特点</h5><ol>
<li><p>C++在C语言基础上引入了<strong>面对对象(三大特性:封装、继承、多态)<strong>的机制，同时也</strong>兼容C语言</strong></p>
</li>
<li><p>C++运行<strong>效率高</strong>，仅比汇编语言慢10%～20%</p>
</li>
<li><p>C++更加安全, 增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try catch</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&gt;(a) <span class="comment">// 用于类之间的转型，运行期间会做检查，转型失败会返回0并抛出bad_cast.</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(a) <span class="comment">// 这个其实和传统的C语言的强制转换是一样的，它不会做任何检查，如果转型失败就会发生未知错误。</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;type&gt;(a) <span class="comment">// 把a从const型转为非const型，常用于函数重载</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;type&gt;(a) <span class="comment">// 可进行任意转型，把a中的内存按type的方式来解读，需要程序员保证转换的正确性。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）</p>
</li>
<li><p>C++是<strong>不断在发展</strong>的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda函数、右值引用、智能指针</p>
</li>
</ol>
<hr>
<h5 id="说说C语言和C-的区别"><a href="#说说C语言和C-的区别" class="headerlink" title="说说C语言和C++的区别"></a>说说C语言和C++的区别</h5><ol>
<li><p>C++<strong>面对对象</strong>；C是<strong>面对过程</strong></p>
</li>
<li><p>C是C++的子集，但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等</p>
</li>
<li><p>C不安全，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++<strong>更安全</strong>，如const常量、引用、cast转换、智能指针、try catch</p>
</li>
<li><p>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，实现了STL。相对于C语言的函数库<strong>更灵活、更通用</strong>。</p>
</li>
</ol>
<hr>
<h5 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++ 中的四种类型转换"></a>C++ 中的四种类型转换</h5><p><code>static_cast&lt;type&gt;(a)</code> </p>
<blockquote>
<p>  和传统的C语言的强制转换一样，不做任何检查，如转型失败会发生未知错误。<br>  在父类和子类之间互相转换时, 进行上行转换是安全的 ; 进行下行转换时，由于没有动态类型检查，不安全 </p>
<p>  <code>static_cast&lt;type&gt;(a)</code> 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int 这种转换的安全性也要开发人员来保证</p>
</blockquote>
<p><code>dynamic_cast&lt;type&gt;(a)</code></p>
<blockquote>
<p>   主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全</p>
<p>  转型失败会返回0并抛出bad_cast</p>
</blockquote>
<p><code>const_cast&lt;type&gt;(a)</code> ：用来去除<strong>某指针或者引用的</strong>const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 </p>
<p><code>reinterpret_cast&lt;type&gt;(a) </code>：可进行任意转型，把a中的内存按type的方式来解读，需要程序员保证转换的正确性。</p>
<hr>
<h5 id="说说-C-中-struct-和-class-的区别"><a href="#说说-C-中-struct-和-class-的区别" class="headerlink" title="说说 C++中 struct 和 class 的区别"></a>说说 C++中 struct 和 class 的区别</h5><ol>
<li><p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</p>
</li>
<li><p>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 public </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="type">int</span> iNum; &#125; <span class="comment">// 默认访问控制权限是 private </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 默认是公有继承，而 class 是私有继承</p>
</li>
<li><p>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Y&amp; y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="⚠️说说头文件双引号””和尖括号-lt-gt-的区别"><a href="#⚠️说说头文件双引号””和尖括号-lt-gt-的区别" class="headerlink" title="⚠️说说头文件双引号””和尖括号&lt;&gt;的区别"></a>⚠️说说头文件双引号””和尖括号&lt;&gt;的区别</h5><ul>
<li>&lt;&gt;的头文件是<strong>系统文件</strong>，””的头文件是<strong>自定义文件</strong></li>
<li>编译器预处理阶段查找头文件的路径不一样<ul>
<li>使用&lt;&gt;的头文件：编译器设置的头文件路径</li>
<li>使用””的头文件：当前头文件目录 -&gt; 编译器设置的头文件路径</li>
</ul>
</li>
</ul>
<hr>
<h5 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h5><ol>
<li><p>C++ 中的 struct 是对 C 中的 struct 进行了扩充, 它们在声明时的区别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">C</th>
<th align="center">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成员函数</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">静态成员</td>
<td align="center">不能有</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="left">访问控制权限</td>
<td align="center">默认public，不能修改</td>
<td align="center">public&#x2F;private&#x2F;protected</td>
</tr>
<tr>
<td align="left">继承关系</td>
<td align="center">不可以继承</td>
<td align="center">可继承类或者其他结构体</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="center">不能直接初始化数据成员</td>
<td align="center">可以</td>
</tr>
</tbody></table>
</li>
<li><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;  </span><br><span class="line">  <span class="type">int</span>  iAgeNum;  </span><br><span class="line">  string strName; </span><br><span class="line">&#125; <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Student2; <span class="comment">//C中取别名  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1; <span class="comment">// C 中正常使用 </span></span><br><span class="line">Student2 stu2;   <span class="comment">// C 中通过取别名的使用 </span></span><br><span class="line">Student stu3;  <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="导入C函数的关键字？C-编译时和C有何不同？"><a href="#导入C函数的关键字？C-编译时和C有何不同？" class="headerlink" title="导入C函数的关键字？C++编译时和C有何不同？"></a>导入C函数的关键字？C++编译时和C有何不同？</h5><ol>
<li><p><strong>关键字：</strong>在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为<strong>extern “C”</strong>。加上extern “C”后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而非C++的</p>
</li>
<li><p><strong>编译区别：</strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时只包括<strong>函数名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="⚠️简述C-从代码到可执行文件过程"><a href="#⚠️简述C-从代码到可执行文件过程" class="headerlink" title="⚠️简述C++从代码到可执行文件过程"></a>⚠️简述C++从代码到可执行文件过程</h5><p> C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>
<ol>
<li><p>预编译</p>
<p>（1） 展开所有的宏定义#define</p>
<p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p>
<p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p>
<p>（4） 过滤所有的注释, 添加行号, 添加文件名标识</p>
</li>
<li><p>编译</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树</p>
<p>（3） 语义分析：判断表达式是否有意义</p>
<p>（4） 代码优化</p>
<p>（5） 生成汇编代码</p>
</li>
<li><p>汇编    将汇编代码 -&gt; 机器码</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。</p>
<p><strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；Windows下.lib	Linux下.a</p>
<blockquote>
<p>  <code>ar rcs Calc.a x.o y.o</code></p>
<p>  <code>gcc main.c -o Calc -L ./ -l Calc</code>		[第一个Calc是生成的可执行文件名]</p>
</blockquote>
<p><strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，生成的可执行文件中没有函数代码, 只包含函数的重定位信息, 在执行的过程中，再去找要链接的函数. 所以当删除动态库时，可执行程序就不能运行. Windows下.dll，Linux下.so</p>
<blockquote>
<p>   <code>gcc -c -fPIC a.c b.c</code>		gcc 得到.o文件，得到和位置无关的代码<br>  <code>gcc －shared a.o b.o -o libcalc.so</code>		gcc 得到动态库</p>
</blockquote>
</li>
</ol>
<p>	</p>
<hr>
<h5 id="说说-static关键字的作用"><a href="#说说-static关键字的作用" class="headerlink" title="说说 static关键字的作用"></a>说说 static关键字的作用</h5><ol>
<li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li>
<li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。</li>
<li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li>
<li><strong>静态成员函数和静态成员变量</strong>是类的一部分,可以被多个对象所共享,无法访问一个对象中的非静态成员</li>
</ol>
<hr>
<h5 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h5><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化</p>
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造</p>
<hr>
<h5 id="说说静态局部变量-全局变量-局部变量的特点"><a href="#说说静态局部变量-全局变量-局部变量的特点" class="headerlink" title="说说静态局部变量, 全局变量, 局部变量的特点"></a>说说静态局部变量, 全局变量, 局部变量的特点</h5><ol>
<li><p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件</p>
<p>全局变量：全局作用域，可以通过extern作用于其他的源文件</p>
</li>
<li><p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值</p>
</li>
</ol>
<hr>
<h5 id="说说指针和引用的区别"><a href="#说说指针和引用的区别" class="headerlink" title="说说指针和引用的区别"></a>说说指针和引用的区别</h5><ol>
<li>指针用于保存地址类型的数据，而引用可以看成是变量的别名。</li>
<li>引用不可以为空，当被创建的时候必须初始化，而指针变量可以是空值，在任何时候初始化</li>
<li>指针可以有多级，但引用只能是一级</li>
<li>引用使用时无需解引用（*），指针需要解引用  </li>
<li>指针的值在初始化后可以指向其它的存储单元，而引用在进行初始化后就不会再改变了 </li>
<li>sizeof 引用得到的是所指向的变量（对象）的大小，而 sizeof 指针得到的是指针变量本身的大小</li>
<li>指针作为函数参数传递时传递的是指针变量的值，而<strong>引用作为函数参数传递时传的是实参本身</strong>，不是副本</li>
<li>指针和引用进行++运算意义不一样</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209194441920.png" alt="image-20230209194441920"></p>
<hr>
<h5 id="⚠️说说什么是函数指针"><a href="#⚠️说说什么是函数指针" class="headerlink" title="⚠️说说什么是函数指针"></a>⚠️说说什么是函数指针</h5><ol>
<li><strong>概念：</strong>函数指针就是<strong>指向函数</strong>的指针。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li>
<li><strong>定义</strong>形式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in">int</span> (*f)(<span class="type">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *,<span class="type">const</span> <span class="type">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a , <span class="type">const</span> <span class="type">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in">sizeof</span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="nullptr可以调用成员函数吗？为什么？"><a href="#nullptr可以调用成员函数吗？为什么？" class="headerlink" title="nullptr可以调用成员函数吗？为什么？"></a>nullptr可以调用成员函数吗？为什么？</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以，因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this&#x3D;nullptr，运行出错。</p>
<hr>
<h5 id="说说使用指针需要注意什么"><a href="#说说使用指针需要注意什么" class="headerlink" title="说说使用指针需要注意什么"></a>说说使用指针需要注意什么</h5><ol>
<li>定义指针时，先初始化为NULL</li>
<li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否不为NULL。防止使用空指针</li>
<li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li>
<li>不要忘记为数组和动态内存<strong>赋初值</strong></li>
<li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li>
<li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li>
</ol>
<hr>
<h5 id="什么是野指针-怎么产生的-如何避免？"><a href="#什么是野指针-怎么产生的-如何避免？" class="headerlink" title="什么是野指针,怎么产生的,如何避免？"></a>什么是野指针,怎么产生的,如何避免？</h5><ol>
<li><p><strong>概念：</strong>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</li>
<li><p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免办法：</strong></p>
<p>（1）初始化置NULL  <em><strong>空</strong></em></p>
<p>（2）申请内存后判空   <em><strong>不空</strong></em></p>
<p>（3）指针释放后置NULL   <em><strong>空</strong></em></p>
<p>（4）使用智能指针 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="inline函数和函数的区别-内联函数的作用"><a href="#inline函数和函数的区别-内联函数的作用" class="headerlink" title="inline函数和函数的区别,内联函数的作用"></a>inline函数和函数的区别,内联函数的作用</h5><ol>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p>   <strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<hr>
<h5 id="说说内联函数和宏的区别"><a href="#说说内联函数和宏的区别" class="headerlink" title="说说内联函数和宏的区别"></a>说说内联函数和宏的区别</h5><ol>
<li><strong>宏定义不是函数</strong>，相当于直接替换；<strong>而内联函数本质上是一个函数</strong>，内联函数满足函数的性质，比如有返回值、参数列表</li>
<li><strong>宏函数</strong>是在预编译的时候字符串替换；<strong>而内联函数</strong>则是在编译的时候进行代码插入</li>
<li><strong>宏定义</strong>是没有类型检查的；<strong>而内联函数</strong>在编译的时候会进行类型的检查</li>
</ol>
<hr>
<h5 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i++和++i的区别"></a>说说运算符i++和++i的区别</h5><ol>
<li><p><strong>效率不同</strong>：后置++执行速度比前置的慢</p>
</li>
<li><p><strong>i++ 不能作为左值，而++i 可以</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// int* p2 = &amp;(i++);//错误</span></span><br><span class="line">++i = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// i++ = 1;//错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说new和malloc的区别，底层实现原理"><a href="#说说new和malloc的区别，底层实现原理" class="headerlink" title="说说new和malloc的区别，底层实现原理"></a>说说new和malloc的区别，底层实现原理</h5><ol>
<li>new是操作符可以被重载，而malloc是函数</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转</li>
<li>new分配内存更直接和安全</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk () 函数；当开辟的空间大于 128K 时，调用mmap()</p>
<p>malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<p> (1) 创建一个新的对象</p>
<p> (2) 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
<p> (3) 执行构造函数（为这个新对象添加属性）</p>
<hr>
<h5 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h5><ol>
<li>delete 是操作符，而 free 是函数；</li>
<li>free 不会调用对象的析构函数，而 delete 会调用对象的析构函数；</li>
<li>调用 free 之前需要检查要释放的指针是否为 NULL，使用 delete 释放内存则不需要检查指针是否为 NULL；</li>
</ol>
<hr>
<h5 id="说说const和define的区别。"><a href="#说说const和define的区别。" class="headerlink" title="说说const和define的区别。"></a>说说const和define的区别。</h5><p>const用于定义常量；而define用于定义宏 ：</p>
<ol>
<li>const生效于编译的阶段；define生效于预处理阶段</li>
<li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的</li>
<li>const定义的常量是带类型的；define定义的常量不带类型，不利于类型检查</li>
</ol>
<hr>
<h5 id="说说下列的情况"><a href="#说说下列的情况" class="headerlink" title="说说下列的情况"></a>说说下列的情况</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">const</span> <span class="type">int</span> a;     <span class="comment">// 指的是a是一个常量，不允许修改</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *a;    <span class="comment">// a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> *a;    <span class="comment">// 同 const int *a;</span></span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> *<span class="type">const</span> a;    <span class="comment">// a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="number">5.</span> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> a;   <span class="comment">// 都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述C-有几种传值方式-区别是什么？"><a href="#简述C-有几种传值方式-区别是什么？" class="headerlink" title="简述C++有几种传值方式,区别是什么？"></a>简述C++有几种传值方式,区别是什么？</h5><ol>
<li>值传递：不会影响实参的值</li>
<li>引用传递：会影响实参的值</li>
<li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值</li>
</ol>
<blockquote>
<p>  值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递本质是值传递，不如引用传递安全。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> *b, <span class="type">int</span> &amp;c)</span></span>&#123;<span class="comment">//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值</span></span><br><span class="line">     a += <span class="number">1</span>;</span><br><span class="line">     (*b) += <span class="number">1</span>;</span><br><span class="line">     c += <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a= %d, b= %d, c= %d\n&quot;</span>,a,*b,c);<span class="comment">//a= 2, b= 2, c= 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">1</span>, a = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> *j = &amp;a;</span><br><span class="line">     <span class="built_in">testfunc</span>(i, j, k);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d, k= %d\n&quot;</span>,i,*j,k);<span class="comment">//i= 1, j= 2, k= 2</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h5 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span> <span class="keyword">final</span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++中还允许将方法标记为final，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="built_in">Super</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SomeMethod</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️同名全局变量在多个c文件中公用的方法"><a href="#⚠️同名全局变量在多个c文件中公用的方法" class="headerlink" title="⚠️同名全局变量在多个c文件中公用的方法"></a>⚠️同名全局变量在多个c文件中公用的方法</h5><p>项目文件夹下有a.c、b.c和c.h三个文件, 其中a.c和b.c文件中都#include c.h <strong>我们希望声明一个变量key，在a.c和b.c中公用</strong></p>
<p>有人想，既然是想两个文件都用，那就在c.h中声明一个unsigned char key，然后由于包含关系，在a.c和b.c中都是可见的，所以就能共用了,但实际写出来，我们发现编译的时候编译器提示出错，编译器认为我们重复定义了key这个变量。这是因为**#include命令就是原封不动的把头文件中的内容搬到#include的位置**，所以相当于a.c和b.c中都执行了一次unsigned char key，而C语言中全局变量是项目内可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义</p>
<p><strong>正确办法1：</strong>使用extern关键字来声明变量为外部变量。在其中一个c文件中定义一个全局变量key，然后在另一个要使用key的c文件中用extern声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：<strong>定义</strong>和<strong>声明</strong>。例如在a.c文件中定义变量key，在b.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215202524179.png" alt="image-20230215202524179" style="zoom:50%;">

<p><strong>正确办法2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a.c文件中：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> changeflag = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*c.h文件中：*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> changeflag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*b.c文件中：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span> <span class="comment">// 这样就已经可以使用全局变量 changeflag 了。</span></span></span><br></pre></td></tr></table></figure>

<p><strong>正确方法3:</strong> 在不同的C文件中以<strong>static形式来声明同名全局变量</strong></p>
<hr>
<h5 id="c-命名空间"><a href="#c-命名空间" class="headerlink" title="c++命名空间"></a>c++命名空间</h5><p>namespace命名空间语法，定义格式为namespace  A {}，大括号是范围限定，也就是括号内是一个整体空间，可以有任何东西，如变量、函数等，括号内可以直接引用，而括号外的想相互访问必须指定<strong>空间名称+内部名称</strong>，namespace本质上就是改变全局变量或函数的链接属性，即改变作用域。</p>
<p><strong>定义:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test&#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line">test::<span class="built_in">func1</span>();</span><br><span class="line">test::<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">using</span> test::func1; <span class="comment">//单独声明命名空间中的func1函数</span></span><br><span class="line"><span class="built_in">func1</span>();            <span class="comment">//直接使用func1，无须添加其他的前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> test  <span class="comment">//将整个命名空间全部声明</span></span><br><span class="line">func1（）；            <span class="comment">//访问空间内的函数1</span></span><br><span class="line">func2（）；            <span class="comment">//访问空间内的函数2</span></span><br></pre></td></tr></table></figure>

<p><strong>跨文件使用:</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230215210345480.png" alt="image-20230215210345480"></p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h6><p><strong>命名空间只能全局范围内定义（以下错误写法)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> A&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间可嵌套命名空间</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123; <span class="type">int</span> a = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123; <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;	<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h4><h5 id="⚠️进程运行时虚拟地址空间"><a href="#⚠️进程运行时虚拟地址空间" class="headerlink" title="⚠️进程运行时虚拟地址空间"></a>⚠️进程运行时虚拟地址空间</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/798C7A2D023204559B62F88B54E35CBB-20221108121453779.png" alt="img" style="zoom: 67%;">

<ol>
<li><p><strong>data段：</strong>已初始化的全局变量和静态变量</p>
</li>
<li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</p>
</li>
<li><p><strong>bss段</strong>：未初始化的全局变量和静态变量</p>
</li>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>OS创建进程并分配私有进程空间, 然后OS加载器把可执行文件的数据段和代码段映射到进程的虚拟内存空间</li>
<li>加载器读入可执行程序的导入符号表, 根据符号表可以查找出该可执行程序的所有依赖的动态链接库。调用动态链接库的初始化函数</li>
<li>初始化可执行程序的全局变量，对于全局对象自动调用构造函数</li>
<li>进入可执行程序入口处开始执行</li>
</ol>
<hr>
<h5 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h5><ol>
<li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li>
<li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存；堆则是存放在二级缓存中，速度要慢些。</li>
<li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li>
</ol>
<hr>
<h5 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h5><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放</p>
<p><strong>堆</strong>，就是那些由malloc等分配的内存块，不过是用free来结束自己的生命</p>
<p><strong>自由存储区</strong>，就是那些由new分配的内存块，和堆是十分相似的</p>
<p><strong>静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改</p>
</li>
<li><p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）内存分配未成功，却使用了它</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它</p>
<p>（3）操作越过了内存的边界</p>
<p>（4）忘记了释放内存，造成内存泄露</p>
<p>（5）释放了内存却继续使用它</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为NULL</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用</p>
<p>（4）避免数字或指针的下标<strong>越界</strong></p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针</p>
</li>
<li><p><strong>内存泄露</strong>：</p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数</p>
</li>
</ol>
<hr>
<h5 id="⚠️常量存放在内存的哪个位置？"><a href="#⚠️常量存放在内存的哪个位置？" class="headerlink" title="⚠️常量存放在内存的哪个位置？"></a>⚠️常量存放在内存的哪个位置？</h5><p>局部常量，存放在栈区；</p>
<p>全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</p>
<p>字面值常量, 比如字符串，放在常量区。</p>
<hr>
<h5 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h5><p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong>，对齐原则有四个：</p>
<ol>
<li><p>struct或union的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始</p>
</li>
<li><p>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(class a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)</p>
</li>
<li><p>sizeof(struct) &#x3D; 其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)</p>
</li>
<li><p>sizeof(union) &#x3D; 结构里面size最大元素的size，因为在某一时刻，union只有一个成员真正存储于该地址</p>
</li>
</ol>
<hr>
<h5 id="说下RAII-与智能指针之间的联系"><a href="#说下RAII-与智能指针之间的联系" class="headerlink" title="说下RAII, 与智能指针之间的联系"></a>说下RAII, 与智能指针之间的联系</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用RAII</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Agouzao&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Axigou&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// delete a; 堆内存忘记释放,多了可能引起内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用RAII改造后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    A *a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n = <span class="number">1</span>) &#123; a = <span class="keyword">new</span> T[n]; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; </span><br><span class="line">        <span class="keyword">delete</span> []a;</span><br><span class="line">        a = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; <span class="comment">// 调用A构造创建a对象.是普通的栈内存对象.</span></span><br><span class="line">    <span class="comment">// 当其作用范围结束后,就会自动调用其析构函数释放a对象的内存</span></span><br><span class="line">    <span class="type">int</span> *ptr = a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是为了理解RAII简单的实现了一下，实际操作中这么写还会出现很多问题. </p>
<p>RAII对象也可以进行复制，但是拷贝的时候必须要一并复制它所管理的资源。一般设置为不可拷贝是为了防止误拷贝时使用了自动生成的拷贝函数，自动生成的函数一般进行的是浅拷贝</p>
<p>简单的处理就是为A类定义一个父类，在父类中将拷贝构造、赋值操作符与new操作符重载声明为私有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAII升级版</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABase</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ABase</span>(<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认拷贝构造</span></span><br><span class="line">        ABase &amp;<span class="keyword">operator</span> = (<span class="type">const</span> ABase&amp;); <span class="comment">// 防止子类调用默认重载操作符</span></span><br><span class="line">        <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>; <span class="comment">// 防止子类new</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">        ~<span class="built_in">ABase</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>RAII与智能指针</strong></p>
<p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><h5 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h5><p>面向对象的三大特征是封装、继承、多态。</p>
<ol>
<li><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。不想给别人看到的，我们使用protected&#x2F;private把成员封装起来。开放一些共有的成员函数对成员合理的访问。</p>
</li>
<li><p>继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。三种继承方式：</p>
<table>
<thead>
<tr>
<th align="left">继承方式</th>
<th align="left">private继承</th>
<th align="left">protected继承</th>
<th align="left">public继承</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基类的private成员</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
<td align="left">不可见</td>
</tr>
<tr>
<td align="left">基类的protected成员</td>
<td align="left">变为private成员</td>
<td align="left">仍为protected成员</td>
<td align="left">仍为protected成员</td>
</tr>
<tr>
<td align="left">基类的public成员</td>
<td align="left">变为private成员</td>
<td align="left">变为protected成员</td>
<td align="left">仍为public成员</td>
</tr>
</tbody></table>
</li>
<li><p>多态：用父类型别的指针指向其子类的实例，然后<strong>通过父类的指针调用实际子类的成员函数</strong>。</p>
</li>
</ol>
<hr>
<h5 id="成员访问限定符"><a href="#成员访问限定符" class="headerlink" title="成员访问限定符"></a>成员访问限定符</h5><table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">权限</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">可以被任意实体访问</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">只允许子类及本类的成员函数访问</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">只允许本类的成员函数访问</td>
</tr>
</tbody></table>
<hr>
<h5 id="简述一下-C-重载和重写"><a href="#简述一下-C-重载和重写" class="headerlink" title="简述一下 C++重载和重写"></a>简述一下 C++重载和重写</h5><ul>
<li><p>重写:是指派生类中存在重新定义的函数。</p>
<p>其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>基类中被重写的函数必须有virtual修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125; &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a -&gt; <span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载</p>
<p>在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个<strong>具有不同参数（参数的类型，个数，顺序不同）的同名函数</strong>，根据参数列表确定调用哪个函数，重载的返回值类型可以不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;;     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="说说-C-重载和重写是如何实现的"><a href="#说说-C-重载和重写是如何实现的" class="headerlink" title="说说 C++ 重载和重写是如何实现的"></a>说说 C++ 重载和重写是如何实现的</h5><ul>
<li><p>重写</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数</li>
<li>有虚函数的<strong>类</strong>都有个一维的虚函数表叫做虚表，<strong>类的每个对象有一个指向虚表开始的虚指针</strong>。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚指针指向派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚指针指向的是父类的虚函数地址</li>
<li><strong>多态</strong>性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性</li>
<li>重写用虚函数来实现，结合动态绑定</li>
<li>纯虚函数是虚函数再加上 &#x3D; 0；抽象类是指包括至少一个纯虚函数的类</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数</strong></p>
</li>
<li><p>重载</p>
<p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
</li>
</ul>
<hr>
<h5 id="说说C-构造函数有几种"><a href="#说说C-构造函数有几种" class="headerlink" title="说说C++构造函数有几种"></a>说说C++构造函数有几种</h5><p>C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li><p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()&#123; <span class="comment">//默认构造函数  </span></span><br><span class="line">            num=<span class="number">1001</span>;        </span><br><span class="line">            age=<span class="number">18</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">int</span> a):<span class="built_in">num</span>(n),<span class="built_in">age</span>(a)&#123;&#125; <span class="comment">//初始化构造函数  </span></span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="type">int</span> num;  </span><br><span class="line">        <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Student s1; <span class="comment">//用默认构造函数初始化对象S1  </span></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">18</span>)</span></span>; <span class="comment">//用初始化构造函数初始化对象S2  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li><p>复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;     </span><br><span class="line">    <span class="type">int</span> i;     </span><br><span class="line">    <span class="type">int</span> *p; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> value)&#123;         </span><br><span class="line">            i = ai;         </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">int</span>(value);     </span><br><span class="line">        &#125;     </span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;         </span><br><span class="line">            <span class="keyword">delete</span> p;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t)&#123;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;i = t.i;         </span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*t.p);     </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;     </span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;     </span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>：只是对指针的拷贝，拷贝后两个指针指向同一个内存空间。修改其中任意的值,另一个值都会变化</p>
<p><strong>深拷贝</strong>：不但对指针进行拷贝, 且对指针指向的内容拷贝, 经过深拷贝后的指针是指向两个不同地址的指针。修改其中任意的值,另一个值不会变化</p>
</li>
<li><p>移动构造函数</p>
<p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷</p>
<p>拷贝构造函数中，对于指针，我们采用深拷贝，而移动构造函数中，对于指针，我们采用浅拷贝。浅拷贝之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针 (如a-&gt; value) 置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间</p>
<p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)&#123; <span class="comment">// &amp;&amp; 是右值引用 	int num = 10;  int &amp;&amp; a = 10;     </span></span><br><span class="line">		p = a.p;</span><br><span class="line">		a.p = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123; <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ch;</span><br><span class="line">	<span class="function">Test <span class="title">c</span><span class="params">(move(p))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="拷贝构造函数的参数是什么传递方式-为什么"><a href="#拷贝构造函数的参数是什么传递方式-为什么" class="headerlink" title="拷贝构造函数的参数是什么传递方式,为什么"></a>拷贝构造函数的参数是什么传递方式,为什么</h5><ol>
<li><p>拷贝构造函数的参数必须使用引用传递</p>
</li>
<li><p>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)或CClass(const CClass* c_class)，那么就相当于采用了传值的方式(pass-by-value)，<strong>而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数</strong>。因此拷贝构造函数的参数必须是一个引用</p>
</li>
</ol>
<hr>
<h5 id="拷贝构造和移动构造的不同"><a href="#拷贝构造和移动构造的不同" class="headerlink" title="拷贝构造和移动构造的不同"></a>拷贝构造和移动构造的不同</h5><p>拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针</p>
<hr>
<h5 id="只定义析构函数-会自动生成哪些构造函数"><a href="#只定义析构函数-会自动生成哪些构造函数" class="headerlink" title="只定义析构函数,会自动生成哪些构造函数"></a>只定义析构函数,会自动生成哪些构造函数</h5><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<blockquote>
<p>  默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作</p>
</blockquote>
<hr>
<h5 id="一个类默认会生成哪些函数"><a href="#一个类默认会生成哪些函数" class="headerlink" title="一个类默认会生成哪些函数"></a>一个类默认会生成哪些函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认会生成以下几个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.默认构造</span></span><br><span class="line"><span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.拷贝构造</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值运算符</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; copy)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.析构函数（非虚）</span></span><br><span class="line">~<span class="built_in">Empty</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️哪些因素会影一个类的大小"><a href="#⚠️哪些因素会影一个类的大小" class="headerlink" title="⚠️哪些因素会影一个类的大小"></a>⚠️哪些因素会影一个类的大小</h5><p>对象大小 &#x3D; 虚函数指针 + 所有非静态数据成员大小 + 因对齐而多占的字节</p>
<hr>
<h5 id="说说-C-类对象的初始化顺序-有多重继承的情况呢"><a href="#说说-C-类对象的初始化顺序-有多重继承的情况呢" class="headerlink" title="说说 C++ 类对象的初始化顺序,有多重继承的情况呢"></a>说说 C++ 类对象的初始化顺序,有多重继承的情况呢</h5><p>父类构造函数 –&gt; 成员类对象构造函数 –&gt; 自身构造函数</p>
<blockquote>
<p>  其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序</p>
<p>  析构顺序和构造顺序相反</p>
</blockquote>
<hr>
<h5 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h5><ol>
<li><p>向上转型本身就是安全的</p>
</li>
<li><p>向下转型:</p>
<p>(1) 可以使用强制转换, 这种转换不安全, 会导致数据的丢失, <strong>原因是父类的指针或者引用的内存中可能不包含子类的成员的内存</strong></p>
<p>(2) <code>dynamic_cast&lt;type_id&gt;(expression) </code>主要还是用于执行“安全的向下转型（safe downcasting）”，也即是基类对象的指针或引用转换为同一继承层次的其他指针或引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast&lt;type_id&gt;(expression) 把expression转换成type-id类型的对象</span></span><br><span class="line"><span class="comment">// type_id 必须是类的指针、类的引用或者void*</span></span><br><span class="line"><span class="comment">// 使用场景：我们想使用基类对象的指针或引用来调用某个派生类的操作，并且该操作不是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base *Pb = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	Derived* Pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(Pb);</span><br><span class="line">	Pd-&gt;<span class="built_in">func</span>();  <span class="comment">//将输出hello world!	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述下深拷贝和浅拷贝-如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝-如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝, 如何实现深拷贝"></a>简述下深拷贝和浅拷贝, 如何实现深拷贝</h5><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的。深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
</ol>
<p>深拷贝的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STRING</span>(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法1:拷贝构造函数</span></span><br><span class="line">    <span class="comment">//_str = s._str;</span></span><br><span class="line">    _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="type">const</span> STRING&amp; s)&#123; <span class="comment">// 法2: 赋值运算符的重载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/9F844C99D8A154A32CA23995A7C1661B-20221111112802957.png" alt="img" style="zoom:50%;">

<hr>
<h5 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h5><ol>
<li><p>多态成员变量: 编译运行看左边</p>
</li>
<li><p>静态方法和变量：编译运行都看左边，同成员变量一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu *f = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f -&gt; num &lt;&lt; endl; <span class="comment">// 取Fu中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态成员方法: 编译看左边,运行看右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Fu* f1 = <span class="keyword">new</span> <span class="built_in">Zi</span>();</span><br><span class="line">cout &lt;&lt; f1-&gt;<span class="built_in">show</span>() &lt;&lt; endl; <span class="comment">// 用基类类型指针绑定派生类实例,调用的是子类重写后的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说为什么要虚析构-为什么不能虚构造"><a href="#说说为什么要虚析构-为什么不能虚构造" class="headerlink" title="说说为什么要虚析构, 为什么不能虚构造"></a>说说为什么要虚析构, 为什么不能虚构造</h5><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，</p>
<p>可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用子类指针绑定子类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用父类指针绑定子类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构父类，不会析构子类对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。</strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li><p>不能虚构造：</p>
<p>虚函数需要一个虚表存储, 这个表的地址是存储在对象的内存空间开始的。如果将构造函数设置为虚函数，就需要到虚表中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</p>
</li>
</ol>
<hr>
<h5 id="说说模板类"><a href="#说说模板类" class="headerlink" title="说说模板类"></a>说说模板类</h5><ol>
<li>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
<li>模板具体化：<strong>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化</strong>。具体化时可以修改原模板的定义 [修改类内函数(不是重写)]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">sizeof</span>(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TemplateStruct</span>&lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">TemplateStruct</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">int</span>&gt; intStruct; <span class="comment">// 4</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">double</span>&gt; doubleStruct; <span class="comment">// --8--</span></span><br><span class="line">    TemplateStruct&lt;<span class="type">char</span>&gt; llStruct; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="C-类内可以定义引用数据成员吗？"><a href="#C-类内可以定义引用数据成员吗？" class="headerlink" title="C++ 类内可以定义引用数据成员吗？"></a>C++ 类内可以定义引用数据成员吗？</h5><p>c++类内可以定义引用成员变量，但要遵循以下规则：</p>
<ol>
<li>必须用初始化列表(构造)来初始化引用成员变量。否则会造成引用未初始化错误</li>
<li>构造函数的形参也必须是引用类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> &amp;target) :<span class="built_in">a</span>(target)&#123;  <span class="comment">//初始化列表</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>; <span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;</span><br><span class="line">	r.<span class="built_in">printA</span>(); <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> &amp;b = a; <span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">	r1.<span class="built_in">printA</span>(); <span class="comment">// 20</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️简述一下什么是常函数，有什么作用"><a href="#⚠️简述一下什么是常函数，有什么作用" class="headerlink" title="⚠️简述一下什么是常函数，有什么作用"></a>⚠️简述一下什么是常函数，有什么作用</h5><p>类的成员函数后面加 const（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），表明这个函数不会对这个类对象的数据成员（非静态的数据成员）作任何改变。</p>
<p><strong>const对象可以调用 const 成员函数，不能调用非const函数。</strong></p>
<p><strong>非const类型的数据可以给const类型的变量赋值，反之则不成立</strong></p>
<p>在实例化对象时添加const关键字，就是const对象，const对象只能访问类中的const成员变量和const成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">CStu</span>()&#123; a = <span class="number">12</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//a = 13; //常函数不能修改数据成员</span></span><br><span class="line">        cout &lt;&lt;a &lt;&lt; <span class="string">&quot;I am show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CStu st;</span><br><span class="line">    st.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-C-中什么是菱形继承问题，如何解决"><a href="#说说-C-中什么是菱形继承问题，如何解决" class="headerlink" title="说说 C++ 中什么是菱形继承问题，如何解决"></a>说说 C++ 中什么是菱形继承问题，如何解决</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/669F46EC1CA09D9F687FFD9A8EC4CFEE.png" alt="img" style="zoom:25%;">

<p>假设我们有类B和类C，它们都继承了相同的类A。<strong>另外我们还有类D，类D通过多重继承机制继承了类B和类C</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  *Animal类对应于图表的类A* */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;     </span><br><span class="line">    <span class="type">int</span> weight;      </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> weight; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Liger</span> : <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Liger lg;   <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span>   </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>();  <span class="comment">//   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在我们的继承结构中，<strong>我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象”lg”会包含Animal基类的两个子对象。</strong></p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用”lg.getWeight()”将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</p>
</li>
<li><p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;  <span class="comment">// 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了”virtual”关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Liger lg;  <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>  </span><br><span class="line">    <span class="type">int</span> weight = lg.<span class="built_in">getWeight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述一下虚函数和纯虚函数-以及实现原理"><a href="#简述一下虚函数和纯虚函数-以及实现原理" class="headerlink" title="简述一下虚函数和纯虚函数, 以及实现原理"></a><strong>简述一下虚函数和纯虚函数, 以及实现原理</strong></h5><p>C++中的虚函数的作用主要是实现了多态的机制</p>
<p>关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。<strong>虚函数必须是基类的非静态成员函数</strong></p>
<p>在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，<strong>在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型</strong>, 以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;PersonName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">    <span class="comment">//基类调用子类的函数</span></span><br><span class="line">    person-&gt;<span class="built_in">GetName</span>();<span class="comment">//StudentName:xiaosi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但<strong>要求任何派生类都要定义自己的实现方法</strong>。<strong>将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。含有纯虚函数的类称为抽象类，它不能生成对象</strong></p>
<p>所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h5><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，<strong>含有纯虚函数的类被称为抽象类</strong></li>
<li>虚函数可以被直接使用，也可以被子类重写以后，以多态的形式调用，而纯虚函数必须在子类中重写才可以使用，因为纯虚函数在基类有声明而没有定义。</li>
<li>虚函数的定义形式：virtual(){};纯虚函数的定义形式：virtual() &#x3D; 0;<strong>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，</strong>而且被两者修饰的函数生命周期也不一样</li>
</ol>
<hr>
<h5 id="仿函数了解吗？有什么作用"><a href="#仿函数了解吗？有什么作用" class="headerlink" title="仿函数了解吗？有什么作用"></a>仿函数了解吗？有什么作用</h5><ol>
<li>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过<strong>作为仿函数的类，都必须重载operator()运算符</strong>，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Func myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;helloworld!</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>仿函数既能像普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息</strong>。我们可以举个例子：假设有一个vector<string>,你的任务是统计长度小于5的string的个数，如果使用函数的话，你的代码可能长成这样：</string></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LengthIsLessThanFive</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; <span class="number">5</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LenthIsLessThan</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️C-友元函数和友元类（-friend）详解"><a href="#⚠️C-友元函数和友元类（-friend）详解" class="headerlink" title="⚠️C++友元函数和友元类（ friend）详解"></a>⚠️C++友元函数和友元类（ friend）详解</h5><p>友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> 返回值类型 函数名(参数表); <span class="comment">//将全局函数声明为友元</span></span><br><span class="line"><span class="keyword">friend</span> 返回值类型 其他类的类名::成员函数名(参数表); <span class="comment">//将其他类的成员函数声明为友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能把其他类的私有成员函数声明为友元. </span></span><br><span class="line"><span class="comment">// 友元具有单向性, 不具有传递性和继承性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>;  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️C-中哪些函数不能被声明为虚函数"><a href="#⚠️C-中哪些函数不能被声明为虚函数" class="headerlink" title="⚠️C++ 中哪些函数不能被声明为虚函数"></a>⚠️C++ 中哪些函数不能被声明为虚函数</h5><p>常见的不不能声明为虚函数的有：普通函数（不定义在类里），静态成员函数，内联成员函数，构造函数，友元函数</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>略</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态绑定,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
<p>static函数是在编译时期绑定,而虚函数的特性是运行时才动态联编,两者矛盾</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<hr>
<h5 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h5><p>模板的声明或定义只能在全局，命名空间或类范围内进行。</p>
<p>不能在局部范围，函数内进行，比如不能在<strong>main</strong>函数中声明或定义一个模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ClassName 的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替</span></span><br><span class="line">ClassName A = <span class="keyword">new</span> <span class="built_in">ClassName</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h4><h5 id="请说说-STL-的基本组成部分"><a href="#请说说-STL-的基本组成部分" class="headerlink" title="请说说 STL 的基本组成部分"></a>请说说 STL 的基本组成部分</h5><p>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>广义上讲</strong>，STL分为3类：算法、容器、迭代器，容器和算法通过迭代器可以进行无缝地连接。</p>
<p><strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）</p>
<ol>
<li><p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了()的类</p>
</li>
<li><p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3种适配器：Container Adaptor、Iterator Adaptor、Function Adaptor</p>
</li>
<li><p>空间配制器（Allocator）</p>
<p> 为STL提供空间配置的系统。其中主要工作包括两部分</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<hr>
<h5 id="请说说-STL-中常见的容器-并介绍一下实现原理"><a href="#请说说-STL-中常见的容器-并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器, 并介绍一下实现原理"></a>请说说 STL 中常见的容器, 并介绍一下实现原理</h5><ol>
<li><strong>序列式容器</strong></li>
</ol>
<p>所谓序列式容器，其中的元素都是可序的，但是未必都是有序的</p>
<p>（1）vector ：动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
<p>（2）deque ：双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在两端增删元素具有较佳的性能</p>
<p>（3）list ：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取</p>
<ol start="2">
<li><strong>关联式容器</strong></li>
</ol>
<p>关联式容器，每笔数据（每个数据）都有一个键值（key）和一个实值（value）</p>
<blockquote>
<p>  关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()</p>
</blockquote>
<p>关联式容器: set、map、multiset、multimap底层均以RB-tree（红黑树）完成</p>
<p>（1）set&#x2F;multiset ：set 即集合。set中不允许相同元素，multiset中允许存在相同元素</p>
<p>（2）map&#x2F;multimap ：map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素</p>
<ol start="3">
<li><strong>容器适配器</strong></li>
</ol>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个stack。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。stack和queue基于deque实现，priority_queue基于vector实现</p>
<p>（1）stack  </p>
<p>（2）queue ：队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p>
<p>（3）priority_queue：优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p>
<hr>
<h5 id="说说-STL中map-hashtable-deque-list实现原理"><a href="#说说-STL中map-hashtable-deque-list实现原理" class="headerlink" title="说说 STL中map, hashtable, deque, list实现原理"></a>说说 STL中map, hashtable, deque, list实现原理</h5><p>map（红黑树）、hashtable（函数映射）、deque（双向队列）、list（双向链表）</p>
<ol>
<li><p>map实现原理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作</p>
</li>
<li><p>hashtable（也称散列表，直译作哈希表）实现原理</p>
<p>hashtable采用了<strong>函数映射的思想</strong>记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找</p>
</li>
</ol>
<hr>
<h5 id="两种C-类对象实例化方式的异同"><a href="#两种C-类对象实例化方式的异同" class="headerlink" title="两种C++类对象实例化方式的异同"></a>两种C++类对象实例化方式的异同</h5><ol>
<li>在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 <code>Test test;</code>另一种是通过new来实例化一个类对象，如 <code>Test *pTest = new Test();</code>那么，这两种方式有什么异同点呢？</li>
</ol>
<pre><code>我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。



那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间

（2）对于第二种方式来说, new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间
</code></pre>
<hr>
<h5 id="⚠️迭代器用过吗？什么时候会失效？"><a href="#⚠️迭代器用过吗？什么时候会失效？" class="headerlink" title="⚠️迭代器用过吗？什么时候会失效？"></a>⚠️迭代器用过吗？什么时候会失效？</h5><ol>
<li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器</li>
<li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用 erase(iter++) 自增方式删除迭代器</li>
</ol>
<hr>
<h5 id="说一下STL中迭代器的作用-有指针为何还要迭代器？"><a href="#说一下STL中迭代器的作用-有指针为何还要迭代器？" class="headerlink" title="说一下STL中迭代器的作用, 有指针为何还要迭代器？"></a>说一下STL中迭代器的作用, 有指针为何还要迭代器？</h5><ol>
<li><p>迭代器的作用: 指向,读取,修改元素</p>
</li>
<li><p>迭代器和指针的区别</p>
<p><strong>迭代器不是指针，是类模板，表现的像指针。</strong>他只是模拟了指针的一些功能，重载了指针的一些操作符，++、–等。迭代器本质是封装了原生指针，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li><p>迭代器产生的原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//一个存放int元素的数组，一开始里面没有元素  </span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);  </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator i; <span class="comment">//常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//v.begin()表示v第一个元素迭代器指针，++i指向下一个元素   </span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//*i表示迭代器指向的元素  </span></span><br><span class="line">    cout &lt;&lt; endl;   </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator r; <span class="comment">//反向迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (r = v.<span class="built_in">rbegin</span>(); r != v.<span class="built_in">rend</span>(); r++)   </span><br><span class="line">        cout &lt;&lt; *r &lt;&lt; <span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator j; <span class="comment">//非常量迭代器  </span></span><br><span class="line">    <span class="keyword">for</span> (j = v.<span class="built_in">begin</span>();j != v.<span class="built_in">end</span>();j++)   </span><br><span class="line">        *j = <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();i++)   </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      运行结果：   1,2,3,4,   4,3,2,1,   100,100,100,100, */</span> </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说-STL-中-resize-和-reserve-的区别"><a href="#说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="说说 STL 中 resize 和 reserve 的区别"></a>说说 STL 中 resize 和 reserve 的区别</h5><ol>
<li><p>首先必须弄清楚两个概念：</p>
<p>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象</p>
<p>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</p>
</li>
<li><p>resize和reserve区别主要有以下几点：</p>
<p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert()或push_back()等创建对象</p>
<p>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小</p>
</li>
</ol>
<hr>
<h5 id="说说-map和-unordered-map-的区别"><a href="#说说-map和-unordered-map-的区别" class="headerlink" title="说说 map和 unordered_map 的区别"></a>说说 map和 unordered_map 的区别</h5><ol>
<li><p>map实现机理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照BST存储的，使用中序遍历可将键值按照从小到大遍历出来</p>
</li>
<li><p>unordered_map实现机理</p>
<p>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O(1)，其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的</p>
</li>
</ol>
<hr>
<h5 id="说说-vector-和-list-的区别-分别适用于什么场景？"><a href="#说说-vector-和-list-的区别-分别适用于什么场景？" class="headerlink" title="说说 vector 和 list 的区别, 分别适用于什么场景？"></a>说说 vector 和 list 的区别, 分别适用于什么场景？</h5><p><strong>vector：一维数组</strong></p>
<p>  特点：在堆中分配内存，动态数组，元素连续存放，有保留内存，如果减少大小后内存也不会释放</p>
<p>  扩容方式：</p>
<blockquote>
<ol>
<li>申请空间  2. 拷贝数据  3. 释放旧空间    因为 vector 扩容需要申请新的空间，所以扩容以后它的内存地址会发生改变</li>
</ol>
</blockquote>
<blockquote>
<p>  （1）当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加</p>
<p>  （2）新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同</p>
</blockquote>
<p>  优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)</p>
<p>  缺点：由于开辟一段连续的空间, 所以插入删除会需要对数据进行移动比较麻烦, 时间复杂度O(n), 另外当空间不足时还需要进行扩容</p>
<p>  <strong>list：双向链表</strong></p>
<p>  特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问</p>
<p>  优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)</p>
<p>  缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n), 没有提供[]操作符的重载</p>
<hr>
<h5 id="数组与vector的对比"><a href="#数组与vector的对比" class="headerlink" title="数组与vector的对比"></a>数组与vector的对比</h5><p>1、数组名与vector名</p>
<p>数组名和vector名是有区别的，数组名不仅表示数组的名称，还代表了数组的首地址，数组名有时候可看作指针，并使用一些类似于指针的操作，例如初始化了一个数组 int a[10]；可进行如下操作，a+4、*(a+5)等来访问a中的数据。而vector名的话就仅仅只是vector的名称了，它没有类似于数组名的那些操作</p>
<p>2、大小能否变化</p>
<p>数组的大小在初始化后就固定不变，而vector可以通过push_back或pop等操作进行变化。</p>
<p>3、初始化</p>
<p>数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而向量可以。</p>
<p>4、执行效率</p>
<p>数组&gt;vector  主要原因是vector的扩容过程要消耗大量的时间。</p>
<hr>
<h5 id="vector-的-部分STL-源码"><a href="#vector-的-部分STL-源码" class="headerlink" title="vector 的 部分STL 源码"></a>vector 的 部分STL 源码</h5><p>  vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li><p>新增元素</p>
<p> Vector通过一个连续的数组存放元素，如果内存已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index &#x3D; iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="type">const</span> T&amp; t )</span> </span>&#123;    </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_)&#123;   </span><br><span class="line">        <span class="keyword">if</span> (size_==capacity_)&#123;    </span><br><span class="line">            <span class="type">int</span> capa=<span class="built_in">calculateCapacity</span>();    </span><br><span class="line">            <span class="built_in">newCapacity</span>(capa);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="built_in">sizeof</span>(T));    </span><br><span class="line">        buf[index]=t;   </span><br><span class="line">        size_++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<p>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index &#x3D; iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素  </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> index=iter-<span class="built_in">begin</span>();      </span><br><span class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)&#123;         </span><br><span class="line">        <span class="built_in">memmove</span>(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="built_in">sizeof</span>(T));          </span><br><span class="line">        buf[--size_]=<span class="built_in">T</span>();     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="简述-STL-中的-map-的实现原理"><a href="#简述-STL-中的-map-的实现原理" class="headerlink" title="简述 STL 中的 map 的实现原理"></a>简述 STL 中的 map 的实现原理</h5><p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>map的特性如下</p>
<p>（1）map以RBTree作为底层容器；</p>
<p>（2）所有元素都是键+值存在；</p>
<p>（3）不允许键重复；</p>
<p>（4）所有元素是通过键进行自动排序的；</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p>
<hr>
<h5 id="说下-map-和-set-有什么区别-分别是怎么实现的？"><a href="#说下-map-和-set-有什么区别-分别是怎么实现的？" class="headerlink" title="说下 map 和 set 有什么区别, 分别是怎么实现的？"></a>说下 map 和 set 有什么区别, 分别是怎么实现的？</h5><p>同：</p>
<ol>
<li>都是一种关联式容器</li>
<li>以RBTree作为底层容器</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
</ol>
<p>不同：</p>
<ol>
<li><p>set的元素的只有key没有value，value就是key</p>
</li>
<li><p>不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</p>
</li>
<li><p>map中所有元素都是键+值存在</p>
</li>
<li><p>map的键是不能修改的，但是其键对应的值是可以修改的</p>
</li>
</ol>
<hr>
<h5 id="说说-push-back-和-emplace-back-的区别"><a href="#说说-push-back-和-emplace-back-的区别" class="headerlink" title="说说 push_back 和 emplace_back 的区别"></a>说说 push_back 和 emplace_back 的区别</h5><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p>
<hr>
<h4 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h4><h5 id="⚠️说说-C-14、C-17、C-20-新特性"><a href="#⚠️说说-C-14、C-17、C-20-新特性" class="headerlink" title="⚠️说说 C++14、C++17、C++20 新特性"></a>⚠️说说 C++14、C++17、C++20 新特性</h5><ol>
<li>C++14: <ul>
<li>函数返回值类型推导</li>
<li>lambda参数auto</li>
<li>变量模板</li>
<li>别名模板</li>
<li>constexpr的限制</li>
<li>[[<code>deprecated</code>]]标记</li>
<li>二进制字面量与整形字面量分隔符</li>
<li>std::make_unique</li>
<li>std::shared_timed_mutex与std::shared_lock</li>
<li>std::integer_sequence</li>
<li>std::exchange</li>
<li>std::quoted</li>
</ul>
</li>
<li>C++17: <ul>
<li>构造函数模板推导</li>
<li>结构化绑定</li>
<li>if-switch语句初始化</li>
<li>内联变量</li>
<li>折叠表达式</li>
<li>constexpr lamda表达式</li>
<li>namespace嵌套</li>
<li>__has_include预处理表达式</li>
<li>在lambda表达式用*this捕获对象副本</li>
<li>新增Attribute</li>
<li>字符串转换</li>
<li>std::variant</li>
<li>std::optional</li>
</ul>
</li>
<li>C++20:<ul>
<li>新增关键字(keywords)</li>
<li>新增标识符(Identifies)</li>
<li>模块(Modules)</li>
<li>Ranges</li>
<li>协程(Coroutines)</li>
<li>Concepts</li>
<li>Lambda 表达式的更新</li>
<li>常量表达式(<code>constexpr</code>) 的更新</li>
<li>原子(Atomic)智能指针</li>
<li>自动合流(Joining), 可中断(Cancellable) 的线程</li>
<li>C++20 同步(Synchronization)库</li>
</ul>
</li>
</ol>
<hr>
<h5 id="说说-C-11-新特性"><a href="#说说-C-11-新特性" class="headerlink" title="说说 C++11 新特性"></a>说说 C++11 新特性</h5><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）初始化方法可以拓展到任意类</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针 &amp; 空指针 nullptr（原来NULL）</p>
<p>（6）基于范围的for循环</p>
<p>（7）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（1）无序容器（哈希表 hashtable）用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（2）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（3）Lambda表达式</p>
</li>
</ol>
<p><strong>详细：</strong></p>
<ol>
<li><p>统一的初始化方法</p>
<p>  C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125; </span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;     </span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private     </span></span><br><span class="line">    Foo a3 = &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    Foo a4 &#123;<span class="number">123</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a5 = &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="type">int</span> a6 &#123;<span class="number">3</span>&#125;;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<strong>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化</strong></p>
</li>
<li><p>成员变量默认初始化</p>
<p>好处：构建一个类的对象不需要用构造函数初始化成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值  </span></span><br><span class="line">        <span class="type">int</span> n; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    B b;  </span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字  </p>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();   <span class="comment">// auto i = v.begin();  </span></span><br></pre></td></tr></table></figure>

<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>; <span class="comment">//x类型被推断为int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x; <span class="comment">//cx被推断为 const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;rx = x; <span class="comment">//rx被推断为const int &amp;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>auto 原理 : 调用类模板传参</p>
<blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// auto pos = container.begin()的推断等价于如下调用模板的推断</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deducePos</span><span class="params">(T pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deducePos</span>(container.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>decltype  求表达式的类型</p>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>(1)为什么要有decltype</p>
<p><strong>auto 要求变量必须初始化，而 decltype 不要求</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<p>(2)代码示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int </span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double </span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针 </p>
<p>见下⬇️</p>
</li>
<li><p>空指针 nullptr（原来NULL）</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> *a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> *a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>nullptr空指针常数可以转换为任意类型的指针类型</p>
<p>在c++中 <code>(void *)</code> 不能转化为任意类型的指针，即 <code>int *p = (void*)</code>是错误的，但<code>int *p = nullptr</code>是正确的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;1&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;2&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);  <span class="comment">//输出1，c++中NULL为整数0</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);  <span class="comment">//输出2，nullptr 为空指针常量。是指针类型</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于范围的for循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)&#123;  <span class="comment">//使用基于范围的for循环</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要使用引用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : arr)&#123;</span><br><span class="line">    std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用和move语义 </p>
<p>(1) 右值引用</p>
<p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// 正确, 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值</span></span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p><strong>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>; <span class="comment">// 和常量左值引用不同的是，右值引用还可以对右值进行修改   </span></span><br></pre></td></tr></table></figure>

<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成</p>
<p>(2) move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能<strong>很简单，就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值；但对于使用迭代器遍历容器中存储的元素，执行效率较低</li>
</ul>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table>
<thead>
<tr>
<th align="left">无序容器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unordered_map</td>
<td align="left">存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式  </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
</li>
<li><p>Lambda匿名函数</p>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式</p>
<p>(1) 定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p><code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型  &#123; 函数体; &#125;;</code></p>
<blockquote>
<p>  a.  [ ] 捕获外部变量</p>
<p>  b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略</p>
<p>  c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字</p>
<p>  **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</p>
<p>  d. noexcept&#x2F;throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型</p>
<p>  e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”</p>
<p>  f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式捕获（两种）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数</span></span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mp[a] == mp[b] ? a &lt; b : mp[a] &gt; mp[b];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说-C-中的智能指针"><a href="#说说-C-中的智能指针" class="headerlink" title="说说 C++中的智能指针"></a>说说 C++中的智能指针</h5><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong> 其中auto_ptr被C++11弃用。</p>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间,智能指针本质是类模板。</p>
<ol>
<li>shared_ptr</li>
</ol>
<pre><code> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放)

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//构建 2 个智能指针     </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;     </span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;     </span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="comment">//输出 p2 指向的数据    </span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针     </span></span><br><span class="line">    <span class="keyword">if</span> (p1) cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;     <span class="comment">//以上操作，并不会影响 p2     </span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">/*      程序运行结果：          10  p1 为空  10  1  */</span>    </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p>weak_ptr</p>
<p>它只可以从一个 shared_ptr或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的变化</p>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放</p>
<p>weak_ptr和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了</p>
<p>我们把类A里面的shared_ptr pb_; 改为 weak_ptr pb _ ; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p><strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code> pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();   </code></p>
</li>
<li><p>auto_ptr</p>
<p>C++98的方案，C++11已经弃用. 采用所有权模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题</p>
</li>
<li><p>unique_ptr（替换auto_ptr）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 2 allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中1留下悬挂的unique_ptr(pu1)，这可能导致危害</span></span><br><span class="line"><span class="comment">// 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数, 该函数创建的临时对象在其所有权让给 pu3 后就会被销毁</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="智能指针有内存泄露风险吗"><a href="#智能指针有内存泄露风险吗" class="headerlink" title="智能指针有内存泄露风险吗"></a>智能指针有内存泄露风险吗</h5><p>有,<strong>当两个类对象中各自有一个 shared_ptr 指向对方</strong>时，会造成循环引用，使引用计数失效，从而导致内存泄露。 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr</p>
<p>weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针</p>
<p>weak_ptr不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问</p>
<hr>
<h5 id="⚠️说说三种智能指针原理和使用场景和线程安全"><a href="#⚠️说说三种智能指针原理和使用场景和线程安全" class="headerlink" title="⚠️说说三种智能指针原理和使用场景和线程安全"></a>⚠️说说三种智能指针原理和使用场景和线程安全</h5><ol>
<li><p><strong>实现原理:</strong> 所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的析构函数会删除该对象。然后，让赋值操作转让所有权。这就是用于 auto_ptr 和 unique_ptr 的策略.但 unique_ptr 的策略更严格，unique_ptr 能够在编译期识别错误。 </p>
<p>跟踪引用特定对象的智能指针计数，这称为引用计数（reference counting）。例如，赋值时，计数将加 1，而指针过期时，计数将减 1. 仅当最后一个指针过期时，才调用 delete。这是 shared_ptr 采用的策略</p>
</li>
<li><p><strong>使用场景:</strong> 如果程序要使用多个指向同一个对象的指针，应该选择 shared_ptr； </p>
<p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr; 如果使用 new分配内存，应该选择 unique_ptr; 如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p>
</li>
<li><p><strong>线程安全:</strong> <strong>shared_ptr 加减引用计数是原子操作，只要shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了。所以 shared_ptr 在多线程下引用计数也是安全的.</strong></p>
<p><strong>但是指向对象的指针不是线程安全的，使用 shared_ptr 访问资源不是线程安全的，需要手动加锁解锁。智能指针的拷贝也不是线程安全的</strong></p>
</li>
</ol>
<h3 id="1️⃣操作系统"><a href="#1️⃣操作系统" class="headerlink" title="1️⃣操作系统"></a>1️⃣操作系统</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="说一说常用的-Linux-命令"><a href="#说一说常用的-Linux-命令" class="headerlink" title="说一说常用的 Linux 命令"></a>说一说常用的 Linux 命令</h5><p>cd：切换当前目录 </p>
<p>ls：查看当前文件与目录 </p>
<p>touch: 创建新文件</p>
<p>grep：通常与管道命令一起使用，用于对一些命令的输出进行筛选加工 </p>
<p>cp：是在同一个linux系统上，在不同的目录之间复制文件</p>
<blockquote>
<p>  scp：是在不同linux系统之间来回复制文件；</p>
</blockquote>
<p>mv：移动文件或文件夹 </p>
<p>rm：删除文件或文件夹 </p>
<blockquote>
<p>  rm -rf test1    可删除非空文件或文件夹  </p>
<p>  rmdir 只能删除空文件夹</p>
</blockquote>
<p>ps：查看进程情况 </p>
<p>tar：对文件进行解压缩</p>
<p>cat：查看文件内容</p>
<p>top：查看操作系统的信息，如进程、CPU占用率、内存信息等（实时） </p>
<p>free：查看内存使用情况 </p>
<p>pwd：显示当前工作目录</p>
<p>chmod: 修改用户权限	</p>
<p>chown: 更改或文件的所有权转让给指定的用户名</p>
<p>echo: 将一些数据移到文件中。如果要将文本 “Hello, 我的名字叫 John” 添加到名为 name.txt 的文件中，<code> echo Hello,my name is John &gt;&gt; name.txt</code></p>
<p>ldd: <code>ldd [OPTION] FILE</code>  查看libstdc++.so.6依赖的动态库的详细信息</p>
<blockquote>
<p>  ldd -v &#x2F;home&#x2F;libstdc++.so.6</p>
</blockquote>
<blockquote>
<p>  –help 获取指令帮助信息；<br>  –version 打印指令版本号；<br>  -d,–data-relocs 执行重定位和报告任何丢失的对象；<br>  -r, –function-relocs 执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；<br>  -u, –unused 打印未使用的直接依赖；<br>  -v, –verbose 详细信息模式，打印所有相关信息；</p>
</blockquote>
<hr>
<h5 id="Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数"><a href="#Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数" class="headerlink" title="Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数"></a>Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数</h5><ol>
<li><p>查看进程运行状态的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps aux | grep PID </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存使用情况的指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">// 查看内存使用情况 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>查看进程运行状态、查看内存使用情况的指令均可使用top指令</strong></p>
<ol start="3">
<li>tar解压文件的参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>压缩 -cvf</span><br><span class="line">tar -cvf xxx.tar /data : 仅打包</span><br><span class="line">tar -zcvf xxx.tar /data : 打包后，以gzip方式压缩</span><br><span class="line">tar -jcvf xxx.tar /data : 打包后，以bzip2方式压缩</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>解压 -xvf</span><br><span class="line">先进入需要解压缩的文件夹下</span><br><span class="line">cd /tmp/data</span><br><span class="line">tar -xvf xxx.tar : 解包</span><br><span class="line">tar -zxvf xxx.tar : 解压gzip压缩文件</span><br><span class="line">tar -jxvf xxx.tar : 解压bzip2压缩文件</span><br><span class="line">tar -zxvf xxx.tar.gz etc/passwd :只解压部分文件夹</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="文件权限怎么修改"><a href="#文件权限怎么修改" class="headerlink" title="文件权限怎么修改"></a>文件权限怎么修改</h5><h6 id="文字设定法设置权限-ugoa"><a href="#文字设定法设置权限-ugoa" class="headerlink" title="文字设定法设置权限(ugoa)"></a>文字设定法设置权限(ugoa)</h6><p><code>chmod [操作对象] [操作符号] [权限] [文件|目录] </code></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220607286.png" alt="image-20221128220607286"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221128220621457.png" alt="image-20221128220621457"></p>
<p>chmod u+w a	添加所有者对a文件的写入权限</p>
<p>chmod u-r a	取消所有者对a文件的读取权限</p>
<p>chmod g&#x3D;w a	重新分配同组用户对a文件有写入的权限</p>
<p>chmod u+rw,g+r,o+rwx a	添加所有者为读取、写入权限;同组用户为读取权限;其他用户读取、写入和执行的权限</p>
<p>chmod a-rwx a	取消所有用户的读取、写入和执行权限</p>
<h6 id="数字设定法设置权限-ugo"><a href="#数字设定法设置权限-ugo" class="headerlink" title="数字设定法设置权限(ugo)"></a>数字设定法设置权限(ugo)</h6><p><code>chmod [n1n2n3] [文件|目录]</code></p>
<blockquote>
<p>  n1表示用户所有者的权限 ，n2表示组群所有者的权限，n3表示其它用户的权限。</p>
</blockquote>
<ul>
<li><p>文件和目录的权限表中用r、w、x这三个字符来为用户所有者、组群所有者和其它用户设置权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需3个数字。</p>
</li>
<li><p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。</p>
</li>
<li><p>所有数字属性的格式应该是三个0～7的数，其顺序是<strong>u、g、o</strong></p>
</li>
</ul>
<blockquote>
<p>  r：对应数值4	w：对应数值2	x：对应数值1	-：对应数值0</p>
</blockquote>
<blockquote>
<p>  若该文件为目录则第一位用d标志，否则用-标志</p>
</blockquote>
<blockquote>
<p>  -rwx——：用数字表示为700</p>
<p>  -rwxr–r–：用数字表示为744</p>
<p>  -rw-rw-r-x：用数字表示为665</p>
<p>  drwx–x–x：用数字表示为711</p>
<p>  drwx——：用数字表示为700</p>
</blockquote>
<blockquote>
<p>  chmod 777 a	所有用户拥有读取、写入和执行的权限</p>
<p>  chmod (00)7 a	设置a文件权限，其他用户拥有读取、写入和执行的权限</p>
</blockquote>
<h6 id="特殊权限-SUID-SGID-Sticky"><a href="#特殊权限-SUID-SGID-Sticky" class="headerlink" title="特殊权限(SUID SGID Sticky)"></a>特殊权限(SUID SGID Sticky)</h6><p>（1）SUID: 以用户所有者身份来执行一个可执行文件; 对一个目录无影响</p>
<p>（2）SGID: 以组群所有者身份来执行一个可执行文件; 对一个目录，在该目录中创建的任意新文件的所属组与该目录的所属组相同</p>
<p>（3）Sticky: 对一个可执行文件无影响, 对目录设置Sticky后，尽管其它用户有写权限，也必须由所有者执行删除和移动等操作</p>
<p><strong>文字设定法设置特殊权限</strong></p>
<p>chmod u+s a	添加a文件的特殊权限为SUID</p>
<p>chmod g+s a	添加a文件的特殊权限为SGID</p>
<p>chmod o+t a	添加a文件的特殊权限为Sticky</p>
<p><strong>数字设定法设置特殊权限</strong></p>
<p>chmod 4000 a	设置文件a具有SUID权限</p>
<p>chmod 2000 a	设置文件a具有SGID权限</p>
<p>chmod 1000 a	设置文件a具有Sticky权限</p>
<p>chmod 7000 a	设置文件a具有SUID，SGID和Sticky权限</p>
<hr>
<h5 id="如何以root权限运行某个程序"><a href="#如何以root权限运行某个程序" class="headerlink" title="如何以root权限运行某个程序"></a>如何以root权限运行某个程序</h5><p>su:  切换成root, 但不改变当前工作目录和环境变量</p>
<p>su-:  切换成root, 改变当前工作目录和环境变量为root的</p>
<p>sudo:  一种权限管理机制，授权给哪个用户可以以管理员的身份执行什么命令</p>
<blockquote>
<p>  sudo [选项] [-u 新使用者账号] 要执行的命令</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chown root 文件</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chmod u+s 文件</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="什么是大端小端-如何判断"><a href="#什么是大端小端-如何判断" class="headerlink" title="什么是大端小端, 如何判断"></a>什么是大端小端, 如何判断</h5><p>小端模式：低的有效字节存储在低的内存地址。小端一般为主机字节序；X86结构和大多数ARM都为小端模式</p>
<p>大端模式：高的有效字节存储在低的内存地址。大端为网络字节序</p>
<p><strong>如何判断：我们可以根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span>&#123;   </span><br><span class="line">        <span class="type">char</span> c;  <span class="comment">// 一个字节，低地址</span></span><br><span class="line">        <span class="type">int</span> i;  <span class="comment">// 四个字节，高地址</span></span><br><span class="line">    &#125;;  </span><br><span class="line">    test t; t.i = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> (t.c == <span class="number">1</span>);  <span class="comment">//如果是小端,则t.c为1; 反之是大端  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="字节序转换函数-IP转换函数"><a href="#字节序转换函数-IP转换函数" class="headerlink" title="字节序转换函数, IP转换函数"></a>字节序转换函数, IP转换函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从主机字节序到网络字节序的转换函数: </span></span><br><span class="line">htons <span class="comment">// 主机端口 -&gt; 网络端口</span></span><br><span class="line">htonl  <span class="comment">// 转换IP的，IP地址32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络字节序到主机字节序的转换函数</span></span><br><span class="line">ntohs</span><br><span class="line">ntohl</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inet_pton  <span class="comment">// &quot;192.168.12.1&quot; -&gt; 整数</span></span><br><span class="line">inet_ntop  <span class="comment">// 整数 -&gt; IP字符串</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="简述Linux内核态与用户态"><a href="#简述Linux内核态与用户态" class="headerlink" title="简述Linux内核态与用户态"></a>简述Linux内核态与用户态</h5><ol>
<li><strong>内核态与用户态</strong>：<strong>内核态</strong>（系统态）与<strong>用户态</strong>是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。</li>
<li><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</li>
<li><strong>为什么区分内核态与用户态</strong>：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑</li>
</ol>
<hr>
<h5 id="虚拟地址到物理地址怎么映射的"><a href="#虚拟地址到物理地址怎么映射的" class="headerlink" title="虚拟地址到物理地址怎么映射的"></a>虚拟地址到物理地址怎么映射的</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207131212493.png" alt="image-20230207131212493" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221205224538889.png" alt="image-20221205224538889" style="zoom:50%;">

<hr>
<h5 id="说说堆栈溢出是什么-会怎么样"><a href="#说说堆栈溢出是什么-会怎么样" class="headerlink" title="说说堆栈溢出是什么, 会怎么样"></a>说说堆栈溢出是什么, 会怎么样</h5><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。常指调用堆栈溢出，本质上一种数据结构的满溢情况。堆栈溢出可以理解为两个方面：<strong>堆溢出和栈溢出。</strong></p>
<ol>
<li>堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error</li>
<li>栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error</li>
</ol>
<hr>
<h5 id="⚠️说说进程-线程-协程是什么-区别？"><a href="#⚠️说说进程-线程-协程是什么-区别？" class="headerlink" title="⚠️说说进程,线程,协程是什么,区别？"></a>⚠️说说进程,线程,协程是什么,区别？</h5><ol>
<li><p><strong>进程</strong>：进程则是程序的运行实例，包括程序计数器、堆栈和变量值</p>
</li>
<li><p><strong>线程</strong>：一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务</p>
</li>
<li><p><strong>协程</strong>：协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行的</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多. 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用</p>
</li>
<li><p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程</p>
<p>（2）一个进程挂掉，对应的线程挂掉；一个进程挂掉，不会影响其他进程</p>
<p>（3）进程是系统资源分配的最小单位；线程CPU调度的最小单位</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少</p>
<p>（5）进程在执行时拥有独立的内存单元; 多个线程共享进程的内存；但每个线程拥有自己的栈和.text段</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</p>
<p>（7）通信方式不一样</p>
</li>
<li><p><strong>线程与协程的区别：</strong></p>
<p>（1）切换开销更少。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小</p>
<p>（2）协程不需要多线程的锁机制，因为协程从属于线程，不存在同时写变量冲突</p>
<p>（3）协程占用内存少。执行协程只需要极少的栈内存（4～5KB），而线程栈的大小为1MB ;</p>
<p>如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</p>
<ol>
<li><strong>在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。</strong></li>
<li><strong>对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。</strong></li>
</ol>
</li>
</ol>
<hr>
<h5 id="什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程"><a href="#什么是孤儿进程-什么是僵尸进程-如何解决僵尸进程" class="headerlink" title="什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程"></a>什么是孤儿进程?什么是僵尸进程,如何解决僵尸进程</h5><ol>
<li><p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，子进程残留资源(PCB) 存放于内核中，占用系统资源，这种进程称为僵尸进程。</p>
<p><strong>如何解决僵尸进程:</strong></p>
<p>(1) 一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的</p>
<p>(2) <strong>使用kill命令杀死其父进程(使僵尸进程变成孤儿进程)</strong></p>
<p>打开终端并输入下面命令:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> Z </span><br></pre></td></tr></table></figure>

<p>会列出进程表中所有僵尸进程的详细内容。然后输入命令：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">kill</span> -<span class="variable">s</span> <span class="variable">SIGCHLD</span> <span class="function"><span class="title">pid</span>(父进程<span class="variable">pid</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="说说什么是守护进程-如何实现？"><a href="#说说什么是守护进程-如何实现？" class="headerlink" title="说说什么是守护进程, 如何实现？"></a>说说什么是守护进程, 如何实现？</h5><p><strong>守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务</strong></p>
<ol>
<li>创建子进程，父进程退出</li>
<li>setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </li>
<li>改变当前目录为根目录</li>
<li>重设文件权限掩码</li>
<li>关闭文件描述符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pc;</span><br><span class="line">  <span class="type">int</span> i,fd,len;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="string">&quot;this is a Dameon\n&quot;</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">  pc = fork(); <span class="comment">/*第一步: 创建子进程，父进程退出*/</span></span><br><span class="line">  <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error fork\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123; <span class="comment">//子进程号=0,父进程号大于0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程退出，子进程成为孤儿进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setsid</span>(); <span class="comment">/*第二步:setsid() 函数用于创建一个新的会话，并担任该会话组的组长 </span></span><br><span class="line"><span class="comment">          调用setid作用:1、让进程摆脱原会话控制； 2、让进程摆脱原进程组的控制； 3、让进程摆脱原控制终端的控制*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">/*第三步:改变当前目录为根目录*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">/*第四步:重设文件权限掩码*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)&#123;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  &#125; <span class="comment">/*第五步:关闭文件描述符*/</span></span><br><span class="line">	    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(<span class="string">&quot;/tmp/dameon.log&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd,buf,len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="说说进程通信的方式有哪些"><a href="#说说进程通信的方式有哪些" class="headerlink" title="说说进程通信的方式有哪些"></a>说说进程通信的方式有哪些</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221206023051122.png" alt="image-20221206023051122"></p>
<hr>
<h5 id="进程通信中的管道实现原理是什么"><a href="#进程通信中的管道实现原理是什么" class="headerlink" title="进程通信中的管道实现原理是什么"></a>进程通信中的管道实现原理是什么</h5><p>操作系统在内核中开辟一块<strong>缓冲区</strong>（<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制，半双工。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程）。管道本质是一种文件</p>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。读端由描述字fd[0]表示，称其为管道读端；写端由描述字fd[1]来表示。一般文件的 I&#x2F;O 函数都可以用于管道，如close()、read()、write()等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT  0      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT 1          </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="comment">//创建管道         </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];         </span><br><span class="line">    <span class="built_in">pipe</span>(fd);         </span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">//创建子进程, 父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;             </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);             </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);         </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程           </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端            </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);           </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));           </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);       </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="comment">//执行父进程           </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);           </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端             </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);             </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">255</span>];           </span><br><span class="line">        <span class="type">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in">sizeof</span>(buf));           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);       </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="使用管道的四种特殊情况"><a href="#使用管道的四种特殊情况" class="headerlink" title="使用管道的四种特殊情况"></a>使用管道的四种特殊情况</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230207143613149.png" alt="image-20230207143613149"></p>
<hr>
<h5 id="⚠️共享内存"><a href="#⚠️共享内存" class="headerlink" title="⚠️共享内存"></a>⚠️共享内存</h5><p>共享内存允许多个进程共享物理内存的同一块区域。这种IPC 机制无需内核介入。所有要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比(管道是一种存在于内核的文件)，这种IPC技术的速度更快</p>
<p><strong>共享内存使用步骤</strong></p>
<ol>
<li>调用<code>shmget()</code>这个调用将返回后续调用中需要用到的共享内存标识符</li>
<li>使用<code>shmat()</code>和当前进程进行关联, 返回已开辟的内存的首地址</li>
<li>调用<code>shmdt() </code>来分离共享内存段。在此之后，进程就无法再引用这块共享内存了。这是可选的，并且在进程终止时会自动完成这一步</li>
<li>调用<code>shmctl()</code>来删除共享内存段。只有当前所有附加内存段的进程都与之分离后,内存段才会销毁。只有一个进程需要执行这一步</li>
</ol>
<hr>
<h5 id="⚠️简述mmap的原理和使用场景-6参数"><a href="#⚠️简述mmap的原理和使用场景-6参数" class="headerlink" title="⚠️简述mmap的原理和使用场景(6参数)"></a>⚠️简述mmap的原理和使用场景(6参数)</h5><p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件映射到进程的虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>	内存映射</p>
<blockquote>
<p>  addr	是要映射的内存的初始地址,一般由内核指定,我们写 NULL 就行</p>
<p>  length 要映射的数据的长度，这个值不能为0 (一般为分页的整数倍)，一般使用文件的长度 ⬇️</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> size_of_file = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="built_in">stat</span>(_pName, &amp;st);</span><br><span class="line"><span class="keyword">return</span> st.st_size;</span><br></pre></td></tr></table></figure>

<p>  prot	对申请的内存映射区的操作权限 [不能只指定写权限]</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROT_READ      Data can be read.</span><br><span class="line">PROT_WRITE     Data can be written.</span><br><span class="line">PROT_EXEC      Data can be executed.</span><br><span class="line">PROT_NONE      Data cannot be accessed.</span><br></pre></td></tr></table></figure>

<p>  flags	</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MAP_SHARED          Changes are shared. 内存映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项</span><br><span class="line">MAP_PRIVATE         Changes are <span class="keyword">private</span>. 内存映射区的数据改变了，不会修改原来磁盘的文件，会创建一个新文件</span><br><span class="line">MAP_FIXED           Interpret addr exactly.</span><br></pre></td></tr></table></figure>

<p>  fd	需要映射的文件的文件描述符（通过open函数得到（PROT权限要小于open的权限））</p>
<p>  offset	偏移量，一般不用。必须是4K的整数倍，0表示不偏移</p>
<p>  返回值：返回要创建的内存的首地址，失败返回MAP_FAILED宏</p>
</blockquote>
<p><code>int munmap(void * addr, size_t length) ;</code>	解除内存映射</p>
<blockquote>
<p>  addr	要释放的内存的首地址</p>
<p>  length	要释放的内存的大小，要和 mmap 中的 length 一样</p>
</blockquote>
<p><strong>使用场景</strong>：</p>
<ol>
<li>进程对同一块区域频繁读写操作或者大规模数据传输；</li>
<li>进程间相互通信</li>
</ol>
<hr>
<h5 id="说说常见信号"><a href="#说说常见信号" class="headerlink" title="说说常见信号"></a>说说常见信号</h5><table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody></table>
<hr>
<h5 id="⚠️如何保护一个进程不被杀死，具体的代码实现"><a href="#⚠️如何保护一个进程不被杀死，具体的代码实现" class="headerlink" title="⚠️如何保护一个进程不被杀死，具体的代码实现"></a>⚠️如何保护一个进程不被杀死，具体的代码实现</h5><ol>
<li>在 C++ 中, 可以使用信号处理函数拦截 SIGTERM 信号来保护进程不被杀死</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 可以使用 kill 命令向进程发送 SIGTERM 信号来测试该代码的效果。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_signal</span><span class="params">(<span class="type">int</span> signum)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Received signal &quot;</span> &lt;&lt; signum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, handle_signal); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123; <span class="comment">// 模拟进程运行</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改进程的权限：如在 Linux 系统中，可以使用 setrlimit() 函数来限制进程的资源使用，比如限制进程的最大 CPU 使用时间、最大内存使用量等等，从而避免进程因为资源耗尽而被操作系统杀死。</li>
<li>进程守护程序:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">child_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting myapp...&quot;</span> &lt;&lt; endl; <span class="comment">// 这个程序会输出一条消息，然后使用execl()函数调用/path/to/myapp程序</span></span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;/path/to/myapp&quot;</span>, <span class="string">&quot;myapp&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//execl()调用成功后，当前进程的映像就被/path/to/myapp程序替换了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;aaaaa&quot;</span> &lt;&lt; endl; <span class="comment">// 后面的那行输出语句不会被执行。</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parent_process</span><span class="params">(<span class="type">pid_t</span> child_pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> pid = <span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == child_pid)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123; <span class="comment">// 子进程正常退出，那么WIFEXITED宏将返回true 并使用WEXITSTATUS宏来提取子进程的退出状态码。这个退出状态码可能包含了子进程的执行结果，可以用于判断子进程是否成功执行完毕</span></span><br><span class="line">                <span class="type">int</span> exit_status = <span class="built_in">WEXITSTATUS</span>(status);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Myapp exited with code &quot;</span> &lt;&lt; exit_status &lt;&lt; <span class="string">&quot;, restarting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))&#123; <span class="comment">// 如果子进程是被信号终止的，那么WIFSIGNALED宏将返回true，并使用WTERMSIG宏来获取终止信号的编号。这个信号编号可能会提供有关子进程异常终止的一些信息</span></span><br><span class="line">                <span class="type">int</span> sig_num = <span class="built_in">WTERMSIG</span>(status);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Myapp terminated with signal &quot;</span> &lt;&lt; sig_num &lt;&lt; <span class="string">&quot;, restarting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) <span class="built_in">child_process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) <span class="built_in">child_process</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">parent_process</span>(child_pid);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to create child process.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了一个进程守护程序，用于监控一个名为”Myapp”的子进程，并在子进程意外退出时自动重启该进程。具体来说，这个函数会不断地调用waitpid函数来等待子进程的退出，并通过WIFEXITED和WIFSIGNALED宏来判断子进程的退出状态。</p>
<p>如果子进程正常退出（即返回值为0），那么WIFEXITED宏将返回true，并使用WEXITSTATUS宏来提取子进程的退出状态码。这个退出状态码可能包含了子进程的执行结果，可以用于判断子进程是否成功执行完毕。</p>
<p>如果子进程是被信号终止的，那么WIFSIGNALED宏将返回true，并使用WTERMSIG宏来获取终止信号的编号。这个信号编号可能会提供有关子进程异常终止的一些信息。</p>
<p>无论是哪种情况，这个函数都会输出一条信息，并尝试重新启动Myapp子进程。具体来说，它会使用fork函数创建一个新的子进程，并调用child_process函数来执行Myapp程序。然后，它将更新child_pid变量，以便下一次waitpid调用可以等待新的子进程退出。这样，无论Myapp子进程是正常退出还是异常退出，这个函数都可以保证始终有一个Myapp子进程在运行，并能够自动重启该进程以保证服务的可用性</p>
<hr>
<h5 id="进程-线程的中断切换过程是怎样的？"><a href="#进程-线程的中断切换过程是怎样的？" class="headerlink" title="进程, 线程的中断切换过程是怎样的？"></a>进程, 线程的中断切换过程是怎样的？</h5><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换</p>
<ol>
<li><p><strong>进程上下文切换</strong></p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的PCB有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的<strong>地址转换</strong>和<strong>存储保护信息</strong></p>
<p>​    <strong>切换页目录以使用新的地址空间</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）</strong></p>
<p>（6）根据被选中进程恢复处理器现场</p>
</li>
<li><p><strong>线程上下文切换</strong></p>
<p>（1）保护被中断线程的处理器现场信息</p>
<p>（2）修改被中断线程的TCB有关信息，如线程状态等</p>
<p>（3）把被中断线程的线程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的线程</p>
<p>（5）根据被选中线程设置操作系统用到的<strong>存储保护信息</strong></p>
<p>​    <strong>切换内核栈和硬件上下文（切换堆栈，以及各寄存器）</strong></p>
<p>（6）根据被选中线程恢复处理器现场</p>
</li>
</ol>
<hr>
<h5 id="进程五状态模型"><a href="#进程五状态模型" class="headerlink" title="进程五状态模型"></a>进程五状态模型</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/E9B05EC1EBA75193D715B4A05B0B4E4D.png" alt="img"></p>
<hr>
<h5 id="死锁产生条件以及如何解决死锁"><a href="#死锁产生条件以及如何解决死锁" class="headerlink" title="死锁产生条件以及如何解决死锁"></a>死锁产生条件以及如何解决死锁</h5><ol>
<li><p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁</p>
</li>
<li><p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>： </p>
<p>（1）<strong>互斥</strong></p>
<p>（2）<strong>请求保持</strong></p>
<p>（3）<strong>不可剥夺</strong>：进程已获得的资源，只能自己释放，不可剥夺；</p>
<p>（4）<strong>环路等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li><p><strong>如何解决</strong>：</p>
<p>（1）资源一次性分配：从而解决请求保持的问题</p>
<p>（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</p>
</li>
</ol>
<hr>
<h5 id="⚠️在Linux系统中，让程序在系统开启时自启动的方法"><a href="#⚠️在Linux系统中，让程序在系统开启时自启动的方法" class="headerlink" title="⚠️在Linux系统中，让程序在系统开启时自启动的方法"></a>⚠️在Linux系统中，让程序在系统开启时自启动的方法</h5><ol>
<li><strong>使用rc.local文件</strong></li>
</ol>
<p>在Linux系统中，rc.local是一个启动脚本，可以在系统启动时自动运行。可以编辑&#x2F;etc&#x2F;rc.local文件并添加要自启动的程序的命令。例如，如果要在系统启动时启动Apache Web服务器，可以在rc.local文件中添加以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/apachectl start</span><br></pre></td></tr></table></figure>

<p>注意：如果使用了Systemd，则rc.local可能不再适用。</p>
<ol start="2">
<li><strong>使用Systemd服务</strong></li>
</ol>
<p>Systemd是Linux系统中最新的init系统之一。使用systemd服务管理器，可以在系统启动时自动启动指定的程序。可以创建一个新的systemd服务文件，并在其中指定要自启动的程序。例如，如果要在系统启动时启动Nginx Web服务器，可以创建一个名为nginx.service的文件，并将其放置在&#x2F;etc&#x2F;systemd&#x2F;system目录中，然后在文件中添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/kill -s TERM <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️linux-软件驱动"><a href="#⚠️linux-软件驱动" class="headerlink" title="⚠️linux 软件驱动"></a>⚠️linux 软件驱动</h5><p>Linux 为 USB 设备提供了一套标准驱动程序，称为 <strong>USB 核心驱动</strong>。当插入 USB 设备时，USB 核心驱动程序会检测并加载相应的驱动程序，使 USB 设备正常工作。</p>
<p>如果您想手动加载或卸载 USB 设备的驱动程序，可以使用以下命令：</p>
<ul>
<li><code>modprobe</code> 命令：加载一个模块（即驱动程序），例如 <code>modprobe usb-storage</code> 会加载用于 USB 存储设备的驱动程序。</li>
<li><code>rmmod</code> 命令：卸载一个模块，例如 <code>rmmod usb-storage</code> 会卸载用于 USB 存储设备的驱动程序。</li>
</ul>
<p>要查看已加载的 USB 驱动程序列表，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod | grep usb  #这将显示所有已加载的 USB 驱动程序的列表。</span><br></pre></td></tr></table></figure>

<p>要查看已连接的 USB 设备列表，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsusb # 这将显示所有已连接的 USB 设备的列表，包括它们的供应商 ID、产品 ID 等信息。</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="编写一个USB驱动的步骤"><a href="#编写一个USB驱动的步骤" class="headerlink" title="编写一个USB驱动的步骤"></a>编写一个USB驱动的步骤</h6><ol>
<li>确定 USB 设备的供应商 ID 和产品 ID。可以使用 <code>lsusb</code> 命令查看已连接的 USB 设备的信息</li>
<li>创建一个新的内核模块，该模块将作为 USB 驱动程序。</li>
<li>在模块中实现驱动程序的初始化和清理功能。这些功能将在模块加载和卸载时分别被调用。</li>
<li>使用 <code>usb_register_driver()</code> 向 USB 子系统注册驱动程序，并实现驱动程序的控制和数据传输功能。</li>
<li>在驱动程序中实现 <code>probe()</code> 和 <code>disconnect()</code> 函数。 <code>probe()</code> 函数用于检测和识别连接到系统的设备，并为其分配资源和初始化设备。 <code>disconnect()</code> 函数用于在设备被卸载时释放资源。</li>
<li>实现 USB 驱动程序的控制和数据传输功能，例如读取和写入设备数据，控制设备状态等。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面实现了一个 USB 驱动程序，可以通过 USB 控制传输协议向设备发送命令，读取设备状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/usb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VENDOR_ID 0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT_ID 0x5678</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">usb_device_id</span> usbdev_table[] = &#123;</span><br><span class="line">    &#123; <span class="built_in">USB_DEVICE</span>(VENDOR_ID, PRODUCT_ID) &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_DEVICE_TABLE</span>(usb, usbdev_table);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">my_usb_probe</span><span class="params">(<span class="keyword">struct</span> usb_interface *interface, <span class="type">const</span> <span class="keyword">struct</span> usb_device_id *id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;USB device connected\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_usb_disconnect</span><span class="params">(<span class="keyword">struct</span> usb_interface *interface)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;USB device disconnected\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">usb_driver</span> my_usb_driver = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_usb_driver&quot;</span>,</span><br><span class="line">    .id_table = usbdev_table,</span><br><span class="line">    .probe = my_usb_probe,</span><br><span class="line">    .disconnect = my_usb_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">my_usb_init</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = <span class="built_in">usb_register_driver</span>(&amp;my_usb_driver);</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;Failed to register USB driver\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">my_usb_exit</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">usb_deregister</span>(&amp;my_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(my_usb_init);</span><br><span class="line"><span class="built_in">module_exit</span>(my_usb_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_DESCRIPTION</span>(<span class="string">&quot;A simple USB driver&quot;</span>);</span><br></pre></td></tr></table></figure>







<h3 id="2️⃣计算机网络"><a href="#2️⃣计算机网络" class="headerlink" title="2️⃣计算机网络"></a>2️⃣计算机网络</h3><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端(被动接受连接的角色)</span></span><br><span class="line"><span class="number">1.</span>创建一个用于监听客户端连接的套接字(文件描述符)【lfd】</span><br><span class="line"><span class="number">2.</span>将这个监听文件描述符和本地的IP和端口绑定(IP和端口就是服务器的地址信息)【【serveraddr要设置IP、端口、协议】lfd与serversaddr绑定】</span><br><span class="line">	-客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span>设置监听，lfd开始工作</span><br><span class="line"><span class="number">4.</span>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的和客户端通信的套接字【clientaddr只要定义, cfd【cfd与clientaddr通信】】</span><br><span class="line"><span class="number">5.</span>通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bind() </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET; <span class="comment">// 网络协议</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.12.1&quot;, &amp;serveraddr.sin_addr.s_addr); // IP</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 服务器开发时可写,表示服务器端任何IP都可以被客户端访问</span></span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">8</span>); <span class="comment">// 8为连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.accept()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd  = <span class="built_in">accept</span>(listenfd, (sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span> *)len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client ip:&quot;</span> &lt;&lt;  clientIP &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; clientPort &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 获取客户端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf)) ;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示客户端断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字【clientfd】</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定连接的服务器的IP和端口【serveraddr要设置IP、端口、协议【clientfd与serveraddr连接，用clientfd通信】】</span><br><span class="line"><span class="number">3.</span>连接成功了，客户端可以直接和服务器通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line"><span class="number">4.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.socket()</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.16.208.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 两个端口要一致</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. recv() &amp; send()</span></span><br><span class="line">    <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">    <span class="type">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clientfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="comment">// 获取服务器端的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(clientfd, recvBuf, <span class="built_in">sizeof</span> (recvBuf));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %d\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//表示服务器断开连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.close()</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="listen-里的backlog参数"><a href="#listen-里的backlog参数" class="headerlink" title="listen() 里的backlog参数"></a>listen() 里的backlog参数</h5><p>backlog：等待连接队列的最大长度。当有客户端请求连接时，如果已连接的客户端数量达到了backlog值，新的连接请求将被拒绝。</p>
<p><code>backlog</code>参数对于管理服务器性能和连接处理非常重要。如果<code>backlog</code>设置得太低，服务器可能无法处理所有传入的连接请求，导致连接丢失或响应时间缓慢。如果<code>backlog</code>设置得太高，服务器可能会消耗过多的资源来管理大量的挂起连接。</p>
<hr>
<h5 id="accept-在三次握手哪里"><a href="#accept-在三次握手哪里" class="headerlink" title="accept() 在三次握手哪里"></a>accept() 在三次握手哪里</h5><p><strong>accept()需要给此次连接分配资源。</strong>设想一个情景，若有10000个客户端都和该服务端进行连接，发送SYN，服务端收到之后，这些客户端却不再理会服务端的回复，然而此时服务端的资源却都用accept()分配了。这就是所谓的“DDOS攻击”。  <strong>为了解决这个问题，accept() 放在三次握手之后。</strong></p>
<h4 id="网络理论"><a href="#网络理论" class="headerlink" title="网络理论"></a>网络理论</h4><h5 id="应用层-gt-传输层-gt-网络层-gt-链路层"><a href="#应用层-gt-传输层-gt-网络层-gt-链路层" class="headerlink" title="(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)"></a>(应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层)</h5><p>我们就以一个HTTP请求数据包为例子来说明.发送数据的计算机叫做<strong>源主机</strong>，接收数据的计算机叫做<strong>目标主机</strong></p>
<p><strong>应用层</strong><br>首先一个HTTP数据包在应用层中大概包含HTTP协议的版本号、各种字段属性值、最后是包含的要发送的实际数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131442484.png" alt="image-20230227131442484" style="zoom:20%;">

<p><strong>传输层</strong></p>
<p>传输层对应着有UDP和TCP两种协议，HTTP采用的是TCP协议，因为TCP能够提供差错控制。</p>
<p>每一种应用层协议都对应着一个端口号，接着应用层会将HTTP数据包委托给传输层来进一步包装</p>
<blockquote>
<p>  传输层会为将HTTP数据包包装上源端口号和目的端口号等信息。</p>
<p>  <strong>目的端口号</strong>是为了在数据包到达目的计算机的时候让其了解需要将数据包交给什么应用层协议进行处理。</p>
<p>  <strong>源端口号</strong>是为了让目标计算机想要返回数据的时候，知道给源计算机的哪个应用层协议发送数据</p>
</blockquote>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131536296.png" alt="image-20230227131536296" style="zoom:20%;">

<p>如果HTTP报文超过了<strong>数据链路层</strong>规定的最大传输单元MTU,TCP会对HTTP报文进行拆解，将HTTP报文拆分成多个满足传输要求的报文并包装，这些报文之间是有先后顺序的，TCP对这些报文进行顺序编号，保证数据的正确读</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131834043.png" alt="image-20230227131834043" style="zoom:25%;">

<p><strong>网络层</strong></p>
<p>会为其加入源IP和目标IP等信息。	<strong>源IP</strong> 指的是源计算机的IP	<strong>目标IP</strong> 指的是目标计算机的IP</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227131924338.png" alt="image-20230227131924338" style="zoom:25%;">

<p><strong>数据链路层</strong><br>在数据链路层中会在数据包中<strong>加入发送方MAC地址和接收方MAC地址。</strong><br><strong>发送方MAC地址</strong> 就是源计算机的MAC地址。<br><strong>接收方MAC地址</strong> 并不是目标计算机的MAC地址。而是数据包的下一跳的MAC地址，也就是网关的地址，也可以说是第一个转发的路由器的端口mac地址</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132509995.png" alt="image-20230227132509995"></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227132827930.png" alt="image-20230227132827930" style="zoom:25%;">

<blockquote>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
<p>  <strong>交换机</strong><br>  数据包首先会发送到交换机中，交换机工作在MAC层，是一个二层网络设备。</p>
<p>  接收方MAC地址是路由器端口的MAC地址，而不是交换机的端口地址。交换机不会验证接收方MAC地址，也就是帧经过交换机 源MAC地址和目标MAC地址都不会发生变化。交换机只负责转发交换，如果存在对应的MAC地址缓存，就从对应的端口转发出去，如果不存在缓存，就从所有端口转发出去</p>
<p>  交换机中有一个MAC缓存表，会存储MAC地址和对应的转发端口号。</p>
<p>  交换机在接收到数据包后，会取出接收方MAC地址，查看其是否存在缓存，如果存在缓存，就通过其对应的端口号将数据包发送出去。</p>
<p>  如果不存在，就向所有端口号发出数据包。</p>
</blockquote>
<h5 id="链路层-gt-网络层-gt-传输层-gt-应用层"><a href="#链路层-gt-网络层-gt-传输层-gt-应用层" class="headerlink" title="(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)"></a>(链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层)</h5><ol>
<li><strong>路由器——路由转发</strong></li>
</ol>
<blockquote>
<p>  数据包出了交换机就算是出了家门了，开始进入路由器。</p>
<p>  数据包通过端口进入路由器，执行以下步骤：<br>  1、 路由器首先会检查数据包的接收方MAC地址是否等于路由器端口的MAC地址，如果等于就接收，如果不等于就抛弃。<br>  2、 路由器去除头部的MAC包装，暴露出IP地址信息，取出目标IP地址，然后查看路由表。</p>
<p>  <strong>取出路由表中的记录与目标IP地址挨个进行检验，检验过程如下：</strong></p>
<p>  将记录中的子网掩码与目标IP地址进行&amp;运算，如果等于记录中的目标网络，说明存在当前路由器可以到达目标IP地址，就通过记录中对应的端口转发出去, 在转发出去之前需要包装MAC地址</p>
<p>  3、 如果路由表中不存在对应的目标地址，那么就会通过默认路由发出去，默认路由的目标地址和子网掩码都是 <strong>0.0.0.0</strong>，MAC的包装和上述一样。</p>
<p>  4、 如果同时存在多个符合的路由，就按照最长掩码匹配原则，选择掩码中1最多的路由进行转发</p>
</blockquote>
<blockquote>
<p>  从路由转发的过程来看，<strong>源IP地址和目标IP地址一直不变，发送方MAC地址和接收方MAC地址一直在变。</strong></p>
</blockquote>
<ol start="2">
<li><strong>到达目标计算机</strong><br>就这样通过路由器的不断转发，数据包会到达与目标计算机直连的路由器。</li>
</ol>
<blockquote>
<p>  此时，路由器中目标IP地址对应的路由记录中的下一跳IP地址 就是 目标IP地址。</p>
<p>  这个时候，路由表会将目标IP地址的MAC地址当作目的MAC地址，将路由器转发端口对应的MAC地址当作源MAC地址，然后通过端口将MAC帧发送到 路由器端口对应的子网中。</p>
<p>  路由器子网是由多个交换机构成的局域网，交换机只会通过MAC地址缓存将数据包转发给对应的端口，如果没有对应的缓存，就转发给所有的端口。</p>
<p>  这样的话，数据包就会转发到了目标计算机中</p>
</blockquote>
<ol start="3">
<li><strong>目标计算机在收到数据包后会将数据包从下层往上层拆封。</strong></li>
</ol>
<blockquote>
<p>  1、 首先是数据链路层，目标计算机会将MAC包装信息去除，取出接收方MAC地址，查看是否和自己的MAC地址一致，如果不一致，就抛弃。</p>
<p>  2、 接着是网络层，将IP包装信息去除，取出目标IP地址，查看是否与自己的IP地址一致，如果不一致，就抛弃。</p>
<p>  3、 接着是传输层，会取出目标端口号，通过端口号获取对应的进程，将数据包交给对应的进程。比如HTTP数据包的目标端口号是80，就会交给HTTP进程，HTTP会调用其业务逻辑，将返回的数据包装成数据包通过源IP地址发送给源计算机。</p>
</blockquote>
<h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161432357.png" alt="image-20230210161432357"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103852887.png" alt="image-20230227103852887"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227103949486.png" alt="image-20230227103949486"></p>
<p><strong>广播域就是说，如果站点发出一个广播信号后能接收到这个信号的范围，通常来说一个局域网就是一个广播域。（用路由器连接的除外）。冲突域是一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域</strong></p>
<p><strong>三种模型对比</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161511598.png" alt="image-20230210161511598"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230210161524891.png" alt="image-20230210161524891"></p>
<hr>
<h5 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手 &amp; 四次挥手"></a>TCP三次握手 &amp; 四次挥手</h5><p><strong>三次握手(发生在客户端connect()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AB3FC1B1325FA341A39644BA061FA439.jpeg" alt="img" style="zoom:50%;">

<p>1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq&#x3D;x），请求建立连接，等待确认</p>
<p>2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK&#x3D;x+1）确认收到，同时发送一个SYN包（seq&#x3D;y）给客户端</p>
<p>3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK&#x3D;y+1）告诉服务端已经收到</p>
<p>三次握手完成，成功建立连接，开始传输数据</p>
<blockquote>
<p>  TCP是全双工的: 可以从TCP选择重传中看出来，在每一时刻是同时存在收发端发送的帧和ACK信号的。</p>
<p>  但是从三次握手看起来又像是半双工，但是TCP三次握手不能代表平时的数据传输，三次握手的目的是为了确立连接建立，而在实际TCP传输过程中大多情况是收发端同时发送数据的</p>
<p>  总结：传输层TCP是全双工的，但是其上层应用层可能是半双工的。每一个层次都有自己的双工模式，传输层有传输层的双工模式，应用层有应用层的双工模式。下层的双工模式是支持上层双工模式的上限。比如下层支持半双工，上层顶多支持半双工，不可能支持全双工。tcp是全双工的，但它的上层可能支持半双工，比如http1.1，也有可能支持全双工，比如http2.0。</p>
</blockquote>
<p><strong>四次挥手(发生在两端close()中)</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/2F42938B52A4B6494AA9CD8FCE658EBD.jpeg" alt="img" style="zoom:50%;">

<p>1）客户端发送FIN包（FIN&#x3D;1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据</p>
<p>2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕</p>
<p>3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接</p>
<p>4）客户端收到后, 回一个ACK包表明确认收到, 等待一段时间, 确保服务端不再有数据发过来, 然后彻底断开连接</p>
<hr>
<h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230208211405978.png" alt="image-20230208211405978"></p>
<hr>
<h5 id="TCP流量控制：滑动窗口"><a href="#TCP流量控制：滑动窗口" class="headerlink" title="TCP流量控制：滑动窗口"></a><strong>TCP流量控制：滑动窗口</strong></h5><p>在流量控制中那些已经被客户端发送但是还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口，随着TCP协议的运行、数据的运输，这个窗口在序号空间向前滑动，因此这个窗口被称为滑动窗口。 </p>
<p>可以将整个报文段分为四组 </p>
<ol>
<li>已被确认的分组</li>
<li>已发送但未被确认的分组</li>
<li>下一个可以分发的分组</li>
<li>超出窗口长度之后的待使用的分组</li>
</ol>
<hr>
<h5 id="TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复"><a href="#TCP拥塞控制：慢开始-amp-拥塞避免、快重传-amp-快恢复" class="headerlink" title="TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复"></a>TCP拥塞控制：慢开始&amp;拥塞避免、快重传&amp;快恢复</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183029287.png" alt="image-20230301183029287" style="zoom: 40%;">

<hr>
<h5 id="说说-TCP-粘包"><a href="#说说-TCP-粘包" class="headerlink" title="说说 TCP 粘包"></a>说说 TCP 粘包</h5><p>TCP基于字节流，无法判断发送方报文段边界 </p>
<p>多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包</p>
<p>发送端可能堆积了两次数据，每次100字节一共在发送缓存堆积了200字节的数据，而接收方在接收缓存中一次读取120字节的数据，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。 解决粘包的方法： </p>
<ol>
<li>发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界 </li>
<li>数据包末尾加上\r\n标记，模仿FTP协议，但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界 </li>
<li>数据包头部加上数据包的长度</li>
</ol>
<hr>
<h5 id="TCP-和-UDP-可以同时绑定相同的端口吗"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗?"></a>TCP 和 UDP 可以同时绑定相同的端口吗?</h5><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块(TCP &#x2F; UDP)处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181043407.png" alt="image-20230302181043407" style="zoom:67%;">

<p>运行这两个程序后，通过 netstat 命令可以看到，TCP 和 UDP 是可以同时绑定同一个端口号的</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302181113760.png" alt="image-20230302181113760"></p>
<hr>
<h5 id="多个-TCP-服务进程可以绑定同一个端口吗"><a href="#多个-TCP-服务进程可以绑定同一个端口吗" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗?"></a>多个 TCP 服务进程可以绑定同一个端口吗?</h5><p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</p>
<p>默认没有设置端口服用的socket在当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误</p>
<p>解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是<strong>：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong></p>
<p>SO_REUSEADDR 的<strong>另外一个作用是****绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。</strong></p>
<hr>
<h5 id="同一客户端可以-bind-同一个端口吗？"><a href="#同一客户端可以-bind-同一个端口吗？" class="headerlink" title="同一客户端可以 bind 同一个端口吗？"></a>同一客户端可以 bind 同一个端口吗？</h5><p>客户端在执行 connect() 的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</p>
<p>所以，客户端的端口选择的发生在 connect ()，内核在选择端口的时候，会从 <code>net.ipv4.ip_local_port_range</code> 这个内核参数指定的范围来选取一个端口作为客户端端口. 该参数的默认值是 32768 61000，意味着端口总可用的数量是 61000 - 32768 &#x3D; 28232 个。</p>
<p>当客户端与服务端完成 TCP 连接建立后，我们可以通过 netstat 命令查看 TCP 连接<br><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182404371.png" alt="image-20230302182404371"></p>
<blockquote>
<p>  上面客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？</p>
</blockquote>
<p>正确的理解是，TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题</p>
<p>比如下面这张图，有 2 个 TCP 连接，左边是客户端，右边是服务端，客户端使用了相同的端口 50004 与两个服务端建立了 TCP 连接</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230302182616846.png" alt="image-20230302182616846"></p>
<p>上面这两条 TCP 连接的四元组信息中的「目的 IP 地址」是不同的，一个是 180.101.49.12 ，另外一个是 180.101.49.11</p>
<hr>
<h5 id="多个客户端可以-bind-同一个端口吗？"><a href="#多个客户端可以-bind-同一个端口吗？" class="headerlink" title="多个客户端可以 bind 同一个端口吗？"></a>多个客户端可以 bind 同一个端口吗？</h5><p>要看多个客户端绑定的 IP + PORT 是否都相同，如果都是相同的，那么在执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果一个绑定在 192.168.1.100:6666, 一个绑定在 192.168.1.200:6666, 因为 IP 不相同, 所以执行 bind() 的时候, 能正常绑定。</p>
<p>所以， 如果多个客户端同时绑定的 IP 地址和端口都是相同的，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>一般而言，客户端不建议使用 bind 函数，应该交由 connect 函数来选择端口会比较好，因为客户端的端口通常都没什么意义。</p>
<hr>
<h5 id="客户端connect函数选择端口号的过程"><a href="#客户端connect函数选择端口号的过程" class="headerlink" title="客户端connect函数选择端口号的过程"></a>客户端connect函数选择端口号的过程</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/b0b1814b7ed7990ea54c117fbff29599.jpeg" alt="img" style="zoom: 50%;">

<hr>
<h5 id="产生大量CLOSE-WAIT原因和解决-主要是代码原因"><a href="#产生大量CLOSE-WAIT原因和解决-主要是代码原因" class="headerlink" title="产生大量CLOSE_WAIT原因和解决(主要是代码原因)"></a>产生大量CLOSE_WAIT原因和解决(主要是代码原因)</h5><ol>
<li>服务器迟迟无法进行第三次挥手，从而导致CLOSE_WAIT状态的堆积。(正确关闭套接字连接)</li>
<li>网络问题：在网络故障或不稳定的情况下，连接关闭可能会失败，导致CLOSE_WAIT状态的出现。这可能是因为某些网络数据包丢失或者延迟，使得连接无法正确关闭。</li>
<li>使用阻塞式I&#x2F;O：当服务器端使用阻塞式I&#x2F;O时，如果有某个连接上的数据未被及时处理，则可能会导致连接被阻塞，从而导致CLOSE_WAIT状态的堆积</li>
<li>过多的并发连接：如果服务器端同时处理大量的并发连接，可能会导致连接的处理不及时，从而导致CLOSE_WAIT状态的堆积</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方法1: 正确关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>(socket_fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法2: 在发送数据时，如果发生错误，应该及时关闭套接字，而不是等待数据发送完毕</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(socket_fd, buffer, buffer_size, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="产生大量TIME-WAIT原因和解决"><a href="#产生大量TIME-WAIT原因和解决" class="headerlink" title="产生大量TIME_WAIT原因和解决"></a>产生大量TIME_WAIT原因和解决</h5><ol>
<li>大量短连接：如果一个应用程序频繁地打开和关闭TCP连接，就会产生大量的TIME_WAIT状态。这是因为在TIME_WAIT状态下，操作系统会保留连接信息，直到超时时间到期。如果一个应用程序频繁打开和关闭连接，就会导致大量TIME_WAIT状态堆积。</li>
<li>网络延迟：在网络延迟比较大的情况下，连接关闭时可能需要更长的时间来等待所有的数据包到达。在这种情况下，TIME_WAIT状态会持续更长的时间，从而导致大量TIME_WAIT状态的出现。</li>
<li>连接负载：当服务器处理大量并发连接时，TIME_WAIT状态的数量可能会增加。这是因为每个连接在关闭后都会变成TIME_WAIT状态，如果有大量连接，就会产生大量TIME_WAIT状态。</li>
</ol>
<p>解决办法: 优化内核参数，让服务器能够快速回收和重用那些TIME_WAIT的资源</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%编辑内核文件/etc/sysctl.conf，加入以下内容：</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span>    <span class="comment">%表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span>      <span class="comment">%表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span>    <span class="comment">%表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line">net.ipv4.tcp_fin_timeout      <span class="comment">%修改系默认的 TIMEOUT连接超时 时间</span></span><br><span class="line"></span><br><span class="line">执行 /sbin/sysctl -p 让参数生效</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="HTTP请求报文-amp-响应报文"><a href="#HTTP请求报文-amp-响应报文" class="headerlink" title="HTTP请求报文&amp;响应报文"></a>HTTP请求报文&amp;响应报文</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152923685.png" alt="image-20230209152923685" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span>   </span><br><span class="line">-----------------------↑请求行,↓请求头部---------------------------</span><br><span class="line">Host: https:<span class="comment">//www.baidu.com</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">86.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">86.0</span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,*<span class="comment">/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Cookie: BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; __yjs_duid=1_d05d52b14af4a339210722080a668ec2161****694782; BD\_HOME=1; H_PS_PSSID=33514_33257_33273_31660_33570_26350; BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br><span class="line"><span class="comment">-----------------------------↓请求体-----------------------------</span></span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230209152937850.png" alt="image-20230209152937850" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">-----------------------↑状态行,↓响应头部---------------------------</span><br><span class="line">Bdpagetype: <span class="number">1</span></span><br><span class="line">Bdqid: <span class="number">0xf3c9743300024ee4</span></span><br><span class="line">Cache-Control: <span class="keyword">private</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf<span class="number">-8</span></span><br><span class="line">Date: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Expires: Fri, <span class="number">26</span> Feb <span class="number">2021</span> <span class="number">08</span>:<span class="number">44</span>:<span class="number">35</span> GMT</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line">Set-Cookie: BDSVRTM=<span class="number">13</span>; path=/</span><br><span class="line">Set-Cookie: BD_HOME=<span class="number">1</span>; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=<span class="number">33514</span>_33257_33273_31660_33570_26350; path=/; domain=.baidu.com Strict-Transport-Security: max-age=<span class="number">172800</span></span><br><span class="line">Traceid: <span class="number">161</span>****<span class="number">0751284122890175</span>****<span class="number">9583927635684</span></span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">-----------------------------↓响应体-----------------------------</span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="一次HTTP请求响应的流程"><a href="#一次HTTP请求响应的流程" class="headerlink" title="一次HTTP请求响应的流程"></a>一次HTTP请求响应的流程</h5><p>​		浏览器先查看<strong>浏览器缓存</strong>, 如果缓存中有, 会直接在屏幕中显示页面内容</p>
<ul>
<li>域名解析:浏览器查询 DNS，获取域名对应的IP地址:	浏览器先在本地DNS服务器进行查询, 如果本地域名服务器并未缓存该域名对应IP，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得对应的IP后，向服务器请求建立TCP链接，发起三次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
<hr>
<h5 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h5><p>1.无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。（传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低）</p>
<p>2.无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为。（优点解放服务器，但可能每次请求会传输大量重复的内容信息）</p>
<h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置</li>
<li>DELETE：删除文件，与PUT相反，删除对应URI位置文件。</li>
<li>HEAD：获得报文头部，与GET类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法</li>
</ul>
<hr>
<h5 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h5><ol>
<li><p>get重点在从服务器上获取资源；post重点在向服务器发送数据；</p>
</li>
<li><p>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等 </p>
<p>post传输数据将字段与对应值封存在请求体中发送给服务器，这个过程对用户是不可见的</p>
</li>
<li><p>Get传输的数据量小，因为受URL长度限制，但效率较高</p>
<p>Post可以传输大量数据，所以上传文件时只能用Post方式</p>
</li>
<li><p>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码</p>
<p>post支持标准字符集，可以正确传递中文字符</p>
</li>
</ol>
<hr>
<h5 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h5><ul>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<hr>
<h5 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h5><p>Http协议运行在TCP之上，明文传输；Https是身披SSL外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>1）Http端口号80, Https是443</p>
<p>2）Https由于加解密处理消耗更多的CPU和内存资源</p>
<p>3）Https通信需要证书，而证书一般需要向认证机构购买 </p>
<p>4）Https的加密机制是一种结合对称加密和非对称加密的混合加密机制</p>
<hr>
<h5 id="HTTP1-x-和-HTTP2-0-的区别"><a href="#HTTP1-x-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.x 和 HTTP2.0 的区别"></a>HTTP1.x 和 HTTP2.0 的区别</h5><ul>
<li><p>二进制格式：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</p>
</li>
<li><p>多路复用：连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面</p>
</li>
<li><p>头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小</p>
</li>
<li><p>服务端推送：如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回</p>
</li>
</ul>
<hr>
<h5 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h5><ul>
<li>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了</li>
<li>压缩发送的数据：将文本数据进行压缩，减少带宽</li>
<li>SSL加速：SSL协议对HTTP协议进行加密，在通道内加密并加速</li>
<li>TCP复用：TCP复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持</li>
</ul>
<hr>
<h5 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h5><p>是一种基于 TCP 的协议，在客户端和服务器之间建立双向通信的通道，可以在不需要刷新页面或进行轮询的情况下实时传输数据。</p>
<p>WebSocket 协议在客户端和服务器之间建立一条长连接，通过握手协议来协商支持 WebSocket 协议的版本、子协议、扩展等信息。握手成功后，客户端和服务器就可以通过该连接进行实时通信。</p>
<p>此外，WebSocket 协议的数据传输是二进制的，传输效率更高，而且支持跨域通信，可以在不同的域名和端口之间建立连接。</p>
<p>WebSocket 协议的使用场景非常广泛，例如在线聊天室、多人游戏、实时数据传输等。可以使用 WebSocket API 在客户端和服务器之间建立 WebSocket 连接，从而实现实时通信的功能。</p>
<hr>
<h5 id="WebSocket-API-有哪些"><a href="#WebSocket-API-有哪些" class="headerlink" title="WebSocket API 有哪些"></a>WebSocket API 有哪些</h5><ol>
<li><p><code>WebSocket</code> 对象：WebSocket API 的核心对象，用于创建 WebSocket 连接、发送和接收数据。</p>
</li>
<li><p><code>onopen</code> 事件：WebSocket 连接成功建立时触发的事件。</p>
</li>
<li><p><code>onmessage</code> 事件：接收到 WebSocket 数据时触发的事件。</p>
</li>
<li><p><code>onclose</code> 事件：WebSocket 连接关闭时触发的事件。</p>
</li>
<li><p><code>onerror</code> 事件：WebSocket 出错时触发的事件。</p>
</li>
<li><p><code>send()</code> 方法：用于向 WebSocket 服务器发送数据。</p>
</li>
<li><p><code>close()</code> 方法：用于关闭 WebSocket 连接。</p>
</li>
</ol>
<hr>
<h5 id="C-中如何实现websocket协议"><a href="#C-中如何实现websocket协议" class="headerlink" title="C++中如何实现websocket协议"></a>C++中如何实现websocket协议</h5><p>在 C++ 中实现 WebSocket 协议，通常需要使用一个第三方库来处理 WebSocket 的底层协议。以下是一些常用的 C++ WebSocket 库</p>
<ol>
<li>libwebsockets：一个小型、轻量级的 C 语言库，用于实现 WebSockets 协议和 HTTP 协议。</li>
<li>WebSocket++：一个基于 Asio 的 I&#x2F;O  C++ WebSocket 库，支持客户端和服务器端的 WebSocket 连接。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是使用 WebSocket++ 库在 C++ 中实现 WebSocket 服务器的示例代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/config/asio_no_tls.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/server.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> websocketpp::server&lt;websocketpp::config::asio&gt; server;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_message</span><span class="params">(server* s, websocketpp::connection_hdl hdl, server::message_ptr msg)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">get_payload</span>() &lt;&lt; std::endl;</span><br><span class="line">  s-&gt;<span class="built_in">send</span>(hdl, msg-&gt;<span class="built_in">get_payload</span>(), msg-&gt;<span class="built_in">get_opcode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  server echo_server;</span><br><span class="line">  echo_server.<span class="built_in">set_message_handler</span>(&amp;on_message);</span><br><span class="line">  echo_server.<span class="built_in">init_asio</span>();</span><br><span class="line">  echo_server.<span class="built_in">listen</span>(<span class="number">9002</span>);</span><br><span class="line">  echo_server.<span class="built_in">start_accept</span>();</span><br><span class="line">  echo_server.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，使用 WebSocket++ 库创建一个 WebSocket 服务器，监听端口号 9002，并在收到消息时打印消息内容。使用 <code>init_asio()</code> 方法初始化 Asio I&#x2F;O 系统，使用 <code>start_accept()</code> 方法开始接收连接请求，使用 <code>run()</code> 方法等待连接和消息。</p>
<hr>
<h5 id="HTTP-协议和-websocket-协议的区别"><a href="#HTTP-协议和-websocket-协议的区别" class="headerlink" title="HTTP 协议和 websocket 协议的区别"></a>HTTP 协议和 websocket 协议的区别</h5><p>HTTP协议和WebSocket协议都是应用层协议，但是它们有一些重要的区别。</p>
<ol>
<li>连接方式： HTTP协议是一种请求-响应协议，客户端发送请求给服务器端，服务器端响应请求，然后断开连接。这种连接方式被称为”短连接”。而WebSocket协议是一种全双工协议，客户端和服务器端之间可以保持长时间的连接，并且可以在任何时间发送数据。这种连接方式被称为”长连接”。</li>
<li>数据格式： HTTP协议传输的数据格式是纯文本格式，通常使用JSON或XML格式。而WebSocket协议可以传输任何格式的数据，例如二进制数据、文本数据等。</li>
<li>性能： HTTP协议每次请求都需要重新建立连接，这会带来额外的延迟。而WebSocket协议可以在一次连接中传输多个请求和响应，从而可以提高传输效率和性能。</li>
<li>安全性： HTTP协议的安全性较低，通常需要使用SSL协议来加密数据。而WebSocket协议可以在建立连接时使用SSL协议进行加密，从而保证传输的数据安全。</li>
</ol>
<p>总的来说，WebSocket协议比HTTP协议更适合实时通信和数据传输。但是由于WebSocket协议相对于HTTP协议较新，支持程度和兼容性有时可能存在问题</p>
<hr>
<h5 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h5><ul>
<li><p>对称加密是指加密和解密使用同一个密钥的方式</p>
</li>
<li><p>非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送方使用对方的公钥进行加密处理，接收方接收到加密信息后，使用自己的私钥进行解密。</p>
</li>
</ul>
<p>由于非对称加密的方式不需要发送用来解密的私钥, 所以可以保证安全性, 但是慢; 所以我们还是要用对称加密来传送消息, 对称加密所使用的密钥我们可以通过非对称加密的方式发送出去</p>
<hr>
<h5 id="说说ARP协议"><a href="#说说ARP协议" class="headerlink" title="说说ARP协议"></a>说说ARP协议</h5><p>ARP是根据IP地址获取其物理地址的协议</p>
<p>工作原理：</p>
<p>源主机在向目标主机发送IP包前，通过广播ARP请求包， 若源主机不知道目标主机的MAC地址，源主机就会广播一个ARP请求包，请求包中有目标主机的IP，以太网中的所有计算机都会接受到这个请求，而正常情况下只有目标主机会给出ARP应答包，包中就填充上了目标主机的MAC地址，并回复给源主机。源主机得到应答后将目标主机的MAC地址存入本机ARP高速缓存中以便下次使用</p>
<hr>
<h5 id="说说NAT协议"><a href="#说说NAT协议" class="headerlink" title="说说NAT协议"></a>说说NAT协议</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183418866.png" alt="image-20230301183418866" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230301183448058.png" alt="image-20230301183448058" style="zoom:50%;">

<hr>
<h5 id="Session、Cookie"><a href="#Session、Cookie" class="headerlink" title="Session、Cookie"></a>Session、Cookie</h5><p>同：Cookie和Session都是客户端与服务器之间保持状态的解决方案</p>
<p>不同：</p>
<p>1）cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>2）Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
<p>3）Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全</p>
<hr>
<h5 id="国内访问不了谷歌的技术原因"><a href="#国内访问不了谷歌的技术原因" class="headerlink" title="国内访问不了谷歌的技术原因"></a>国内访问不了谷歌的技术原因</h5><ol>
<li><p><strong>IP封锁</strong>：是指通过阻止特定的IP地址，来限制对特定网站或应用程序的访问，这意味着无法通过直接访问其IP地址来访问这些网站。当用户尝试访问这些被屏蔽的网站时，将无法连接到网站服务器，而是会收到一个错误提示或无响应的页面。</p>
</li>
<li><p><strong>DNS劫持</strong>：是指将用户计算机的DNS（域名系统）设置更改为指向另一个地址的技术手段。DNS是将域名转换为IP地址的系统，它将用户输入的域名解析为与之相对应的IP地址，然后将其返回给用户计算机。在中国，政府使用DNS劫持来屏蔽谷歌等国外网站。当用户输入被屏蔽的网站的域名时，政府会将其DNS解析请求重定向到另一个地址，通常是一个被政府控制的服务器，而不是实际的网站服务器。这意味着用户将无法访问被屏蔽的网站，因为他们的计算机将连接到错误的服务器，而不是正确的目标网站。</p>
</li>
</ol>
<hr>
<h5 id="国内可以通过什么技术手段访问谷歌"><a href="#国内可以通过什么技术手段访问谷歌" class="headerlink" title="国内可以通过什么技术手段访问谷歌"></a>国内可以通过什么技术手段访问谷歌</h5><ol>
<li>虚拟私人网络（VPN）：VPN是一种通过加密和隧道技术，将用户的互联网连接路由到远程服务器上，然后再将请求转发到目标网站的技术。用户可以选择连接到位于境外的VPN服务器，以避开中国政府的封锁，从而访问被屏蔽的网站和应用程序</li>
<li>正向代理服务器：代理服务器是一种充当中间人的服务器，它会将用户的互联网请求转发到目标网站，从而帮助用户绕过封锁。用户可以在互联网上找到许多公开的代理服务器，或者使用自己的私人代理服务器，以访问被屏蔽的谷歌网站。</li>
</ol>
<hr>
<h5 id="VPN和代理服务器的区别"><a href="#VPN和代理服务器的区别" class="headerlink" title="VPN和代理服务器的区别"></a>VPN和代理服务器的区别</h5><p>VPN和代理服务器都可以帮助用户绕过封锁，访问被屏蔽的网站和应用程序。</p>
<ol>
<li>加密方式&amp;安全性：VPN使用的是点对点的加密方式，通过建立加密的隧道，保护用户的互联网连接和数据安全。而代理服务器则不提供加密功能，只是将用户的互联网请求转发到目标网站，因此用户的数据可能会在传输过程中被窃取或篡改。</li>
<li>稳定性：VPN比代理服务器更稳定，因为VPN连接通常由专业的VPN服务提供商管理和维护，保证服务器的稳定性和可靠性。而代理服务器可能来自于各种来源，如公开代理服务器和私人代理服务器，其稳定性和可靠性不如VPN。</li>
<li>使用难度：代理服务器相对于VPN使用较为简单，只需要将浏览器或其他应用程序的代理设置更改为代理服务器的IP地址和端口号即可。而VPN需要先下载和安装VPN客户端，然后设置连接参数，相对来说稍微复杂一些。</li>
</ol>
<hr>
<h5 id="运营商给用户限速的类型和原理"><a href="#运营商给用户限速的类型和原理" class="headerlink" title="运营商给用户限速的类型和原理"></a>运营商给用户限速的类型和原理</h5><p>带宽限制(限制用户每秒钟可以传输的数据量)、时间限制、流量限制、服务限制</p>
<h6 id="限速的底层原理"><a href="#限速的底层原理" class="headerlink" title="限速的底层原理"></a>限速的底层原理</h6><ol>
<li>流量控制：运营商会对用户的网络流量进行控制，限制其流量的带宽或流量速率。一般来说，运营商会在核心路由器或边缘路由器上设置策略，根据用户的套餐类型、用量等因素进行流量控制。</li>
<li>调度算法：运营商通过调度算法来控制网络资源的分配，以保证整个网络的公平性和平衡性。常见的调度算法包括最小带宽保证、公平队列调度、公平带宽分配</li>
<li>数据包标记：运营商还可以通过给数据包打上不同的标记，实现不同的服务质量级别。例如，将数据包标记为低优先级的，就会被放入低优先级队列中，从而减少其处理优先级，达到限速的效果。</li>
<li>限速设备：运营商在网络中还可以设置专门的限速设备，例如调度器、速率控制器等，通过对数据包进行筛选和处理，实现对用户网速的限制</li>
</ol>
<hr>
<h5 id="防火墙的原理"><a href="#防火墙的原理" class="headerlink" title="防火墙的原理"></a>防火墙的原理</h5><p>防火墙是一种网络安全设备，它可以监控和控制网络通信，以保护计算机网络免受恶意攻击和未经授权的访问。防火墙通常作为一个网络边界设备，位于内部网络和外部网络之间。</p>
<p>防火墙的原理基于访问控制列表（ACL），它可以允许或拒绝网络流量通过特定端口和协议。当流量进入防火墙时，它会根据预定义的规则来决定是否允许流量通过。如果流量满足规则，则它会被允许通过防火墙，否则它会被阻止或丢弃。</p>
<p>防火墙通常包括以下组件：</p>
<ol>
<li>网络接口：防火墙通过它的网络接口与网络通信。它通常具有多个网络接口，以便与不同网络进行通信。</li>
<li>访问控制列表：防火墙使用ACL来决定允许或拒绝特定流量通过防火墙。</li>
<li>审计日志：防火墙会记录所有进出防火墙的流量，以便管理员可以检查流量并监控网络。</li>
<li>NAT：网络地址转换（NAT）可以隐藏网络中的IP地址，并使外部网络看不到内部网络的实际IP地址。</li>
<li>VPN：防火墙还可以提供虚拟私人网络（VPN）服务，以便用户可以远程连接到内部网络并访问网络资源。</li>
</ol>
<p>总的来说，防火墙通过监控和控制网络流量来保护网络免受恶意攻击和未经授权的访问。其基本原理是使用ACL来决定哪些流量可以通过防火墙，而哪些流量应被阻止或丢弃。</p>
<hr>
<h5 id="常见的流量控制算法"><a href="#常见的流量控制算法" class="headerlink" title="常见的流量控制算法"></a>常见的流量控制算法</h5><ol>
<li><p><strong>漏桶：</strong>水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率，（因为漏桶的漏出速率是固定的参数，所以，即使网络中不存在资源冲突(没有发生拥塞)，漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率</p>
</li>
<li><p><strong>令牌桶算法</strong>：和漏桶效果一样但方向相反的算法，更加容易理解。随着时间流逝，系统会按恒定时间间隔往桶里加入Token(想象和漏洞漏水相反，有个水龙头在不断的加水)，如果桶已经满了就不再加了，新请求来临时，会各自拿走一个Token，如果没有Token可拿了就阻塞或者拒绝服务。令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量。</p>
</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/1011415-20170701192633914-1313517581-20230303141645878.jpg" alt="img"></p>
<h3 id="3️⃣数据库"><a href="#3️⃣数据库" class="headerlink" title="3️⃣数据库"></a>3️⃣数据库</h3><h4 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h4><hr>
<h5 id="⚠️MySQL体系架构"><a href="#⚠️MySQL体系架构" class="headerlink" title="⚠️MySQL体系架构"></a>⚠️MySQL体系架构</h5><p>网络连接层、服务层、存储引擎层和系统文件层</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218115419272.png" alt="image-20230218115419272" style="zoom: 33%;">

<p><strong>一、网络连接层</strong></p>
<p>客户端连接器：提供与MySQL服务器建立连接的支持。如 Java&#x2F;C通过各自API与MySQL建立连接</p>
<p><strong>二、服务层</strong></p>
<p>服务层是MySQL Server的核心，主要包含六个部分</p>
<ul>
<li><p><strong>系统管理和控制工具：</strong>例如备份恢复、安全管理、集群管理【集群就是指一组相互独立的计算机，利用网络组成的一个较大的计算机服务系统，每个集群节点（即每台计算机）都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序，系统资源和数据，并以单一系统的模式加以管理。当用户请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器】</p>
</li>
<li><p><strong>连接池</strong>：负责存储和管理客户端与数据库服务器的连接，一个线程负责管理一个连接</p>
</li>
<li><p><strong>SQL接口：</strong>用于接收客户端发送的各种SQL命令，并且返回用户需要的查询结果</p>
</li>
<li><p><strong>解析器：</strong>负责检查请求的SQL语句的合法性</p>
</li>
<li><p><strong>查询优化器：</strong>当解析树通过语法检查后，将交由优化器将其转化为执行计划，然后与存储引擎交互</p>
</li>
<li><p><strong>缓存：</strong>缓存机制是由表缓存，记录缓存，权限缓存，引擎缓存组成。如果查询语句有命中的结果，则直接在查询缓冲中取数据</p>
</li>
</ul>
<p><strong>三、存储引擎层</strong></p>
<p><strong>负责MySQL中的数据存储和提取，与底层系统文件交互。</strong>服务器中的查询执行引擎通过接口和存储引擎进项通信，接口屏蔽了不同存储引擎的差异</p>
<p><strong>四、系统文件层</strong></p>
<p>负责将数据库的数据和日志存储在文件系统中，并完成与存储引擎的交互，是文件的物理存储层。主要包括日志文件，数据文件，配置文件，socket文件等</p>
<hr>
<h5 id="SQL语句运行机制"><a href="#SQL语句运行机制" class="headerlink" title="SQL语句运行机制"></a>SQL语句运行机制</h5><p><strong>①建立连接</strong>：通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么</p>
<p><strong>②查询缓存：</strong>如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询缓存或者没有查询到SQL 语句则会由解析器进行语法语义解析</p>
<p><strong>③解析：</strong>将客户端发送的SQL进行语法解析。</p>
<p><strong>④查询优化：</strong>根据解析结果生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）</p>
<p><strong>⑤执行引擎执行 SQL 语句：</strong>此时执行引擎会根据 SQL 语句得到查询结果并返回给客户端。若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存中</p>
<hr>
<h5 id="数据库事物特性-ACID"><a href="#数据库事物特性-ACID" class="headerlink" title="数据库事物特性(ACID)"></a>数据库事物特性(ACID)</h5><p>原 一 隔 持 ；原子性和隔离性 -&gt; 推出一致性，持久性应对系统崩溃</p>
<p>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</p>
<p>隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的</p>
<p>持久性：指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</p>
<hr>
<h5 id="⚠️数据库并发一致性问题：丢读不幻"><a href="#⚠️数据库并发一致性问题：丢读不幻" class="headerlink" title="⚠️数据库并发一致性问题：丢读不幻"></a>⚠️数据库并发一致性问题：丢读不幻</h5><p>​	  丢 (丢失修改) 	读(读脏数据)  	不(不可重复读)【一次事务内的两次读数值不同】	幻(幻影读)</p>
<ul>
<li>丢失修改：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li>
<li>读脏数据：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。</li>
<li>幻读与不可重复读类似。它发生在<strong>一个</strong>事务（T1）读取了<strong>几行数据</strong>，接着<strong>另一个</strong>并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<hr>
<h5 id="⚠️当前读和快照读"><a href="#⚠️当前读和快照读" class="headerlink" title="⚠️当前读和快照读"></a>⚠️当前读和快照读</h5><p><strong>快照读：普通的 select 语句</strong></p>
<p>它是基于多版本并发控制即 MVCC机制，快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p>
<p>如下的操作是快照读：不加锁的 select 操作（前提是隔离级别不是串行化，串行化的是当前读）</p>
<p><strong>当前读：能读到所有已经提交的记录的最新值</strong></p>
<p>它读取的记录都是数据库中当前的最新版本，会对当前读取的数据进行加锁，防止其他事务修改数据，是一种悲观锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> … <span class="keyword">for</span> <span class="keyword">update</span> # 当前读</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⚠️两个事务并行提交一定会幻读吗"><a href="#⚠️两个事务并行提交一定会幻读吗" class="headerlink" title="⚠️两个事务并行提交一定会幻读吗"></a>⚠️两个事务并行提交一定会幻读吗</h5><p>在RR(可重复读)隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的</p>
<p><strong>因此，幻读在“当前读”下才会出现。</strong></p>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 引入了新的锁，也就是间隙锁 (Gap Lock)</p>
<p>间隙锁就是，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体</p>
<hr>
<h5 id="数据库锁类型"><a href="#数据库锁类型" class="headerlink" title="数据库锁类型"></a>数据库锁类型</h5><ol>
<li><strong>表级锁</strong></li>
</ol>
<p>（1）锁定粒度大，锁冲突概率高、并发度低</p>
<p>（2）好处是不会出现死锁、开销小、获取锁和释放锁的速度很快</p>
<p>（3）使用表级锁定的主要是MyISAM等一些非事务性存储引擎，适用于以查询为主，少量更新的应用</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230219191007830.png" alt="image-20230219191007830"></p>
<blockquote>
<p>  意向锁：加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。（防止另一个事务逐行判断是否加锁）是InnoDB自动加的，不需用户干预。意向锁不会与行级的读&#x2F;写锁互斥</p>
</blockquote>
<ol start="2">
<li><strong>行级锁</strong></li>
</ol>
<p>（1）好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；</p>
<p>（2）缺点是开销大、加锁慢，行级锁容易发生死锁；</p>
<p>（3）使用行级锁定的主要是InnoDB存储引擎。适用于对事务完整性要求较高的系统</p>
<blockquote>
<p>  InnoDB行级锁类型：读锁、写锁</p>
</blockquote>
<ol start="3">
<li><strong>页面锁</strong></li>
</ol>
<p>（1）介于行级锁和表级锁之间</p>
<p>（2）会发生死锁</p>
<hr>
<h5 id="关于锁的常见问题"><a href="#关于锁的常见问题" class="headerlink" title="关于锁的常见问题"></a>关于锁的常见问题</h5><ol>
<li>InnoDB存储引擎什么时候会锁住整张表，什么时候或只锁住一行呢？</li>
</ol>
<p>只有通过索引条件查询数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p>
<ol start="2">
<li>mysql读锁和写锁</li>
</ol>
<p>用select 命令时触发读锁，当使用update,delete,insert时触发写锁，并且使用rollback或commit后解除本次锁定</p>
<ol start="3">
<li>InnoDB行锁的3种算法：</li>
</ol>
<p>Record Lock： 锁定单个索引记录</p>
<p>Gap Lock ：锁定一个范围，但不包含记录本身</p>
<p>Next-Key Lock：锁定一个范围，并且锁定记录本身</p>
<p><strong>所以 Next-KeyLocks &#x3D; Gap锁+ Recordlock锁</strong></p>
<blockquote>
<p>  Next-Key Locks是 MySQL 的 InnoDB 引擎的一种锁实现。MVCC (多版本的并发控制协议。最大的优点是读不加锁，因此读写不冲突，并发性能好)不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
</blockquote>
<hr>
<h5 id="数据库封锁协议"><a href="#数据库封锁协议" class="headerlink" title="数据库封锁协议"></a>数据库封锁协议</h5><ol>
<li>三级封锁协议(一级:写前加X	 	二级:写前加X读前加S,读完释放 	   三级:与二级一样,S锁事务结束释放)	  </li>
<li>两段锁协议(加锁与解锁串行)</li>
</ol>
<hr>
<h5 id="数据库隔离级别：未-提-可-可"><a href="#数据库隔离级别：未-提-可-可" class="headerlink" title="数据库隔离级别：未 提 可 可"></a>数据库隔离级别：未 提 可 可</h5><p>1、读未提交：顾名思义，就是一个事务可以读取另一个未提交事务的数据</p>
<p>2、读已提交：一个事务要等另一个事务提交后才能读取数据</p>
<p>3、可重复读： 在开始读取数据（事务开启）时，不再允许修改操作</p>
<p>4、串行化：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，一般不使用</p>
<p><strong>并行性依次降低，安全性依次提高</strong></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192103478.png" alt="image-20230129192103478"></p>
<hr>
<h5 id="1NF-2NF-3NF-BCNF"><a href="#1NF-2NF-3NF-BCNF" class="headerlink" title="1NF	 		2NF		 3NF 		BCNF"></a>1NF	 		2NF		 3NF 		BCNF</h5><p>对于 A-&gt;B(A推出B)，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p>
<p>A-&gt;B: B依赖于A</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192017776.png" alt="image-20230129192017776"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129192039819.png" alt="image-20230129192039819"></p>
<p><strong>BCNF：</strong>设关系模式R是1NF。如果对于R的每个函数依赖X-&gt;Y，X必为候选键，则R是BCNF范式。</p>
<hr>
<h5 id="超键-候选键-主键"><a href="#超键-候选键-主键" class="headerlink" title="超键, 候选键, 主键"></a>超键, 候选键, 主键</h5><p>**超键(super key):**在关系中能唯一标识元组的属性集称为关系模式的超键<br>**候选键(candidate key):**不含有多余属性的超键称为候选键<br>**主键(primary key):**用户选作元组标识的一个候选键 </p>
<hr>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><h6 id="什么是索引？优缺点？"><a href="#什么是索引？优缺点？" class="headerlink" title="什么是索引？优缺点？"></a>什么是索引？优缺点？</h6><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。</p>
<p>它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的 数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。</p>
<p>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小</p>
<hr>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><strong>普通索引：</strong></p>
<p>普通索引是mysql里最基本的索引，没有什么特殊性，在任何一列上都能进行创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>);</span><br><span class="line"><span class="comment">-- 例子 length默认我们可以忽略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> <span class="keyword">user</span>(name);</span><br></pre></td></tr></table></figure>

<p><strong>主键索引</strong></p>
<p><strong>复合索引(组合索引)：</strong></p>
<p>指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。</p>
<p>复合索引的使用复合最左原则。举个例子 我们使用 phone和name创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> <span class="keyword">table</span>(column1,column2);</span><br><span class="line"><span class="comment">-- 例子 </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_phone_name <span class="keyword">ON</span> <span class="keyword">user</span>(phone,name);</span><br></pre></td></tr></table></figure>

<p>我们看下面的查询语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_innodb <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;程冯冯&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">&#x27;15100046637&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段才能够进行匹配。而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。</p>
<p><strong>全文索引：</strong></p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。</p>
<p>它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。正常情况下我们也不会使用到全文索引，因为这不是mysql的专长。</p>
<p><strong>空间索引：</strong></p>
<p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>创建空间索引的列必须声明为NOT NULL，只能在存储引擎为MYISAM的表中创建。</p>
<hr>
<h6 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h6><ol>
<li>B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。	辅助索引的叶子节点的 data 域记录着主键的值，需要先查找到主键值，然后再到主索引中进行查找。	</li>
<li>哈希索引，能以 O(1) 时间进行查找，但是失去了有序性。</li>
</ol>
<p>	</p>
<hr>
<h6 id="如何创建及保存MySQL的索引？"><a href="#如何创建及保存MySQL的索引？" class="headerlink" title="如何创建及保存MySQL的索引？"></a>如何创建及保存MySQL的索引？</h6><p>在创建表的时候创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX UniqIdx(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在已存在的表上创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在已经存在的表中创建索引，可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句或者<span class="keyword">CREATE</span> INDEX语句。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx (bookId);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX UniqidIdx <span class="keyword">ON</span> book (bookId);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="如何判断索引有没有生效？"><a href="#如何判断索引有没有生效？" class="headerlink" title="如何判断索引有没有生效？"></a>如何判断索引有没有生效？</h6><p>使用EXPLAIN语句, 假设已创建了book表, 并已经在其year_publication字段上建立了普通索引, 执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication = 1990; </span><br></pre></td></tr></table></figure>

<p>EXPLAIN语句将为我们输出详细的SQL执行信息, 其中：</p>
<ul>
<li>possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key行是MySQL实际选用的索引。</li>
</ul>
<p>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</p>
<hr>
<h6 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h6><p>MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN [EXTENDED] SELECT select_options</span><br></pre></td></tr></table></figure>

<p>使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：</p>
<ul>
<li>id：SELECT识别符。这是SELECT的查询序列号。</li>
<li>select_type：表示SELECT语句的类型。</li>
<li>table：表示查询的表。</li>
<li>type：表示表的连接类型。</li>
<li>possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li>key：是MySQL实际选用的索引。</li>
<li>key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。</li>
<li>ref：给出了关联关系中另一个数据表里的数据列名。</li>
<li>rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>Extra：提供了与关联操作有关的信息。</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC。。DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="⚠️索引优化"><a href="#⚠️索引优化" class="headerlink" title="⚠️索引优化"></a>⚠️索引优化</h6><ol>
<li><p>独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引</p>
</li>
<li><p>多列索引	</p>
</li>
<li><p>索引列的顺序：让选择性最强的索引列放在前面</p>
</li>
<li><p>前缀索引：例如下面 SQL 语句不能使用索引。select * from doc where title like ‘%XX’</p>
<p>而非前导模糊查询则可以使用索引，如下面的 SQL 语句。select * from doc where title like ‘XX%’</p>
</li>
<li><p>覆盖索引：如果有一个查询包含了所有索引的列，并且条件中也是根据这些索引字段检索，我们称之为覆盖索引</p>
</li>
</ol>
<hr>
<h6 id="应该建立索引的条件"><a href="#应该建立索引的条件" class="headerlink" title="应该建立索引的条件"></a>应该建立索引的条件</h6><ol>
<li>在经常使用在 WHERE 子句中的列上面创建索引</li>
<li>在作为主键的列上</li>
<li>在经常用在连接的列上, 这些列主要是一些外键</li>
<li>在经常需要根据范围进行搜索的列上创建索引</li>
<li>在经常需要排序的列上创建索引</li>
</ol>
<hr>
<h6 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h6><p>索引的优点</p>
<ol>
<li>通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度</li>
<li>可以加速表和表之间的连接</li>
<li>加快分组和排序</li>
</ol>
<p>索引的缺点</p>
<ol>
<li>索引有可能降低查询性能，带来磁盘的开销和处理开销等</li>
<li>太多的索引，让设计不稳定</li>
<li>不便维护</li>
<li>数据修改需求&gt;检索需求时，索引会降低性能</li>
</ol>
<hr>
<h6 id="索引的最左前缀问题"><a href="#索引的最左前缀问题" class="headerlink" title="索引的最左前缀问题"></a>索引的最左前缀问题</h6><p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<hr>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。   </li>
<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎放弃使用索引而进行全表扫描。</li>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’   </li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)   </li>
<li>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引2</li>
<li>多使用LIMIT 避免使用SELECT *</li>
</ol>
<hr>
<h5 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h5><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<hr>
<h5 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h5><p>innodb的体系架构就是由多个内存块组成的缓冲池及多个后台线程构成</p>
<p>缓冲池缓存磁盘数据（解决cpu速度和磁盘速度的严重不匹配问题）</p>
<p>后台进程保证缓存池和磁盘数据的一致性（读取、刷新），并保证数据异常宕机时能恢复到正常状态</p>
<p>缓冲池主要分为三个部分：redo <em>log buffer、innodb_buffer_pool、innodb_additional_mem_pool。</em></p>
<ul>
<li>innodb_buffer_pool由包含数据、索引、insert buffer ,adaptive hash index,lock 信息及数据字典。</li>
<li>redo log buffer用来缓存重做日志</li>
<li>additional memory pool:用来缓存LRU链表、等待、锁等数据结构</li>
</ul>
<p>后台进程分为：master thread，IO thread，purge thread，page cleaner thread</p>
<ul>
<li>master thread负责刷新缓存数据到磁盘并协调调度其它后台进程</li>
<li>IO thread 分为 insert buffer、log、read、write进程。分别用来处理insert buffer、重做日志、读写请求的IO回调</li>
<li>purge thread用来回收undo 页</li>
<li>page cleaner thread用来刷新脏页</li>
</ul>
<p>master thread根据服务器的压力分为了每一秒及每十秒的操作。每一秒的操作包括：刷新重做日志、根据过去一秒的磁盘吞吐量来判断是否需要merge insert buffer、根据脏页在缓冲池中占比是否超过最大脏页占比及是否开启自适应刷新来刷新脏页。每十秒的操作包括：根据过去10秒的磁盘吞吐量来刷新脏页，刷新重做日志，回收undo 页，再根据脏页占比是否超过70%刷新定量脏页</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230218122345750.png" alt="image-20230218122345750" style="zoom:50%;">

<hr>
<h5 id="说说-InnoDB-的-MVCC"><a href="#说说-InnoDB-的-MVCC" class="headerlink" title="说说 InnoDB 的 MVCC"></a>说说 InnoDB 的 MVCC</h5><p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。</p>
<p>MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构： </p>
<ol>
<li><p>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log（可以实现事务的回滚操作）的指针</p>
</li>
<li><p>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，形成一条版本链</p>
</li>
<li><p>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务A在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见</p>
</li>
</ol>
<hr>
<h5 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h5><p>整数类型：TINY&#x2F;SMALL&#x2F;MEDIUM INT、INT、BIGINT</p>
<p>实数类型：FLOAT、DOUBLE、DECIMAL</p>
<p>字符串类型：CHAR、VARCHAR、TEXT、BLOB</p>
<p>枚举类型：ENUM</p>
<p>日期与时间：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<hr>
<h5 id="⚠️主从复制"><a href="#⚠️主从复制" class="headerlink" title="⚠️主从复制"></a>⚠️主从复制</h5><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p>主从复制的优点：</p>
<blockquote>
<p>  <strong>读写分离</strong>: 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>  读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
</blockquote>
<hr>
<h5 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h5><p><strong>关系型</strong></p>
<p>主要是指创建在关系模型上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>由关系数据结构、操作集合、完整性约束三部分组成</p>
<p><strong>—优点—</strong></p>
<p>1.事务处理—保持数据的一致性	2.标准化SQL，数据更新的开销小	3.可以进行Join等复杂查询	4.基于严格的数学</p>
<p><strong>—缺点—</strong></p>
<p>1.性能 2.纵向扩展 3.贵</p>
<p><strong>非关系型</strong></p>
<p>—优点—</p>
<ol>
<li><p>简单的扩展（集群）</p>
</li>
<li><p>高性能（它们可以处理超大量的数据）：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作;</p>
</li>
<li><p>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本;</p>
</li>
<li><p>灵活的数据模型。不需要事先对存储数据建立字段。</p>
</li>
</ol>
<p>—缺点—</p>
<ol>
<li><p>不支持SQL的工业标准，将会对用户产生一定的学习和应用迁移成本;</p>
</li>
<li><p>不支持事务，很难保证数据一致性</p>
</li>
<li><p>现有产品的不够成熟：大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语;</p>
</li>
<li><p>不能支持比较复杂的查询</p>
</li>
<li><p>NoSQL 并不完全安全稳定，由于它基于内存，一旦停电或者机器故障数据就很容易丢失数据，其持久化能力也是有限的，而基于磁盘的数据库则不会出现这样的问题</p>
</li>
</ol>
<hr>
<h5 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h5><p>实体完整性：指表中行记录的非空、唯一且不重复</p>
<p>域完整性：指表中的列必须满足某种数据类型或约束。CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL都属于域完整性的范畴</p>
<p>参照完整性：修改表，与之相关联的表也随之改变 不一致的处理方法：拒绝执行 、级联操作 、设置为空</p>
<hr>
<h5 id="对表的外键构建索引的好处"><a href="#对表的外键构建索引的好处" class="headerlink" title="对表的外键构建索引的好处"></a>对表的外键构建索引的好处</h5><p>为确保安全，在对主表操作时，需要对参照表进行加锁操作。如果外键没有索引，查找子记录就会很慢，引起全表扫描。且参照表被锁的时间很长，进而可能发生死锁。</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129191931072.png" alt="image-20230129191931072"></p>
<p><strong>注：联合主键：就是用多个字段一起作为一张表的主键。</strong></p>
<hr>
<h5 id="一个好的模式分解具有哪些性质"><a href="#一个好的模式分解具有哪些性质" class="headerlink" title="一个好的模式分解具有哪些性质"></a>一个好的模式分解具有哪些性质</h5><p>无损连接分解和保持依赖</p>
<p>无损分解指的是对关系分解时，原关系模型中任意合法的列在分解之后应能通过自然联接运算恢复起来。</p>
<p>保持函数依赖指的是对关系分解时，原关系的闭包与分解后关系闭包的并集相等。</p>
<hr>
<h5 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h5><p>视图是从几个表或视图导出的表。是一个虚表。</p>
<p>数据库中只存放视图的定义，而不存放视图对应的数据。</p>
<p>视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化</p>
<hr>
<h5 id="⚠️MySQL分区分表"><a href="#⚠️MySQL分区分表" class="headerlink" title="⚠️MySQL分区分表"></a>⚠️MySQL分区分表</h5><p>MySQL分区是将一个大表分解成更小、更易于管理的部分的过程。分区可以提高查询性能、减少锁定冲突和减轻磁盘I&#x2F;O负载。分区可以按照不同的方式进行，其中包括水平分区和垂直分区。水平分区将表中的行分成不同的分区，而垂直分区将表中的列分成不同的分区。</p>
<p>MySQL分表是将一个大表拆分成多个小表的过程。这种做法可以解决单表数据量过大、索引效率低下的问题。分表一般按照某个条件（例如日期、区域、用户ID等）将数据分散到不同的表中。</p>
<p>下面是MySQL进行分区分表的步骤：</p>
<ol>
<li>创建分区表：使用CREATE TABLE语句创建分区表。</li>
<li>选择分区键：选择一个或多个用于分区的列。</li>
<li>定义分区：使用PARTITION BY子句指定如何将表分区，例如按照日期或地理位置进行分区。</li>
<li>分配数据：将数据插入分区表中。MySQL会根据分区键的值将数据插入正确的分区。</li>
<li>管理分区：可以使用ALTER TABLE语句管理分区，例如添加或删除分区。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    region <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    country <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="type">date</span> <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id, <span class="type">date</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(<span class="type">date</span>)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2015</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2016</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码创建了一个名为sales的分区表，包含六个列，其中id和<span class="type">date</span>列被指定为主键。分区键使用了<span class="type">date</span>列，按照年份进行分区。一共定义了<span class="number">8</span>个分区，每个分区包含小于指定年份的数据。</span><br><span class="line"></span><br><span class="line"># 将数据插入分区表中，MySQL会根据分区键的值将数据插入正确的分区，例如：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales (region, country, product, <span class="type">date</span>, amount)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2018-01-01&#x27;</span>, <span class="number">1000</span>),</span><br><span class="line">       (<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;Japan&#x27;</span>, <span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="number">2000</span>),</span><br><span class="line">       (<span class="string">&#x27;Europe&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;2020-03-01&#x27;</span>, <span class="number">3000</span>),</span><br><span class="line">       (<span class="string">&#x27;North America&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Tablet&#x27;</span>, <span class="string">&#x27;2021-04-01&#x27;</span>, <span class="number">4000</span>),</span><br><span class="line">       (<span class="string">&#x27;South America&#x27;</span>, <span class="string">&#x27;Brazil&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>, <span class="string">&#x27;2022-05-01&#x27;</span>, <span class="number">5000</span>);</span><br><span class="line"># 上述代码将五条数据插入到sales表中，MySQL会将它们分别插入到不同的分区中。</span><br><span class="line"></span><br><span class="line"># 可以使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>语句管理分区，例如添加或删除分区。以下是添加新分区的示例代码：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br><span class="line"># 上述代码向sales表添加了一个新分区p8，包含小于<span class="number">2023</span>年的数据。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="delete、drop、-truncate区别"><a href="#delete、drop、-truncate区别" class="headerlink" title="delete、drop、 truncate区别"></a>delete、drop、 truncate区别</h5><ul>
<li>truncate和delete只删除数据，不删除表结构;drop删除表结构</li>
<li>删除数据的速度: drop &gt; truncate &gt; delete</li>
<li>delete属于DML语言，需要事务管理，commit之后才能生效; drop 和truncate属于DDL语言，操作立刻生效，不可回滚</li>
<li>使用场合:不再需要表时使用drop语句;保留表删除所有记录用truncate语句;删除部分记录用delete语句</li>
</ul>
<hr>
<h5 id="exists和in的区别"><a href="#exists和in的区别" class="headerlink" title="exists和in的区别"></a>exists和in的区别</h5><p>下面将主查询的表称为外表;子查询的表称为内表。exists与in的主要区别如下:</p>
<ul>
<li><p>使用exists, 会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据;      in,会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据</p>
</li>
<li><p>内表大，用exists 效率较高;内表小，用in效率较高。</p>
</li>
<li><p>not exists的效率一般要高于not in</p>
</li>
</ul>
<hr>
<h5 id="说说触发器"><a href="#说说触发器" class="headerlink" title="说说触发器"></a>说说触发器</h5><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码</p>
<p>MySQL数据库中有六种触发器:</p>
<ul>
<li><p>Before Insert</p>
</li>
<li><p>After Insert</p>
</li>
<li><p>Before Update</p>
</li>
<li><p>After Update</p>
</li>
<li><p>Before Delete</p>
</li>
<li><p>After Delete</p>
</li>
</ul>
<hr>
<h5 id="堆表（HOT）和索引组织表（IOT）"><a href="#堆表（HOT）和索引组织表（IOT）" class="headerlink" title="堆表（HOT）和索引组织表（IOT）"></a>堆表（HOT）和索引组织表（IOT）</h5><p> ① 堆组织表，其索引中记录了记录所在位置的rowid(比如，文件号：页号：槽号)，查找的时候先找索引，然后再根据索引rowid找到块中的行数据。索引和表数据是分离的</p>
<p> ② 索引组织表，其行数据以索引形式存放，因此找到索引，就等于找到了行数据。索引和数据是在一起的</p>
<hr>
<h5 id="关系数据库都有哪些操作-特点是什么"><a href="#关系数据库都有哪些操作-特点是什么" class="headerlink" title="关系数据库都有哪些操作,特点是什么?"></a>关系数据库都有哪些操作,特点是什么?</h5><p>◇查询:	选择、投影、连接、除、并、交、差</p>
<p>◇数据更新:	插入、删除、修改</p>
<p>关系操作的特点：	集合操作方式，即操作的对象和结果都是集合。</p>
<hr>
<h5 id="数据库（DDL，DML，DQL、DCL）"><a href="#数据库（DDL，DML，DQL、DCL）" class="headerlink" title="数据库（DDL，DML，DQL、DCL）"></a>数据库（DDL，DML，DQL、DCL）</h5><ol>
<li><p>数据查询语言DQL：SELECT…FROM…WHERE</p>
</li>
<li><p>数据管理语言DML [需事务管理]：INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据定义语言DDL [不需事务管理]</p>
<p>创建数据库中的各种对象—–表、视图、索引等 如：CREATE TABLE（表）&#x2F;VIEW（视图）&#x2F;INDEX（索引）</p>
</li>
<li><p>数据控制语言DCL：GRANT &#x2F; ROLLBACK &#x2F; COMMIT</p>
</li>
</ol>
<hr>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p><strong>使用关联多列索引时，跳过左边的右边的全部失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and c &#x3D; 3，索引a是最左边的，c是最右边的，而这里只写了a和c的条件，跳过了b,那b右边的c虽然写了条件c&#x3D;3但是查询的时候也用不上</p>
<p><strong>范围条件右边失效</strong></p>
<p>例如：建立一个组合索引(a,b,c)，写了查询条件where a &#x3D; 1 and b &gt; 2 and c &#x3D; 3，b是个范围条件，那么索引智能用到a和b，c是范围条件右边的内容，索引用不到</p>
<p>注意：a &#x3D; 1 and b &gt; 2 and c &#x3D; 3和a &#x3D; 1 and c &#x3D; 3 and b &gt; 2是一样的，a、b、c的顺序不是写sql条件时的顺序，而是建立索引时的顺序</p>
<p><strong>模糊查询like ‘%’在左边时失效</strong></p>
<p>例如:条件where name like ‘%a’,这里name这个索引时用不上的</p>
<p><strong>原理：</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230220214904180.png" alt="image-20230220214904180" style="zoom:50%;">

<hr>
<h5 id="B树-x2F-B-树"><a href="#B树-x2F-B-树" class="headerlink" title="B树&#x2F;B+树"></a>B树&#x2F;B+树</h5><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182905354.png" alt="image-20230217182905354" style="zoom:50%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230217182934695.png" alt="image-20230217182934695" style="zoom:50%;">

<p>不同点：</p>
<ol>
<li><p>b树的叶子节点没有指针，b+树有，有指针可以更加方便范围查询，同一种范围查询，b树可能得多次从头节点开始遍历；</p>
</li>
<li><p>b树没有冗余索引，但是b+树有；</p>
</li>
<li><p>b树非叶子节点也存放数据，但是b+树只有叶子节点存放数据；</p>
</li>
<li><p>存放同样的数据，b树的高度可能比b+树要高。</p>
</li>
</ol>
<ul>
<li>B+树在B树中做了一个优化，因为每个磁盘块的大小都是有限的，如果在每个非叶子节点处都存放数据，那么每次获取到的磁盘块上的索引指针信息以及关键字信息将会很少，这样会增加我们的IO次数以及树结构的深度</li>
<li>B+树只在每个非叶子节点处只存放指针以及关键字信息，这样最大化的增加每个磁盘块存放的索引信息，可以更加有效的获取出相对应的地址信息，从而也降低了树结构的深度，而且叶子顶部节点允许互链减少了重新IO的次数</li>
<li>MYSQL引擎InnoDB就是按这种方式存放数据，存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</li>
</ul>
<hr>
<h5 id="说说B-树怎么实现索引-为什么选-B-树"><a href="#说说B-树怎么实现索引-为什么选-B-树" class="headerlink" title="说说B+ 树怎么实现索引, 为什么选 B+ 树"></a>说说B+ 树怎么实现索引, 为什么选 B+ 树</h5><p>索引本质上就是通过预排序+树型结构来加快检索的效率，而MySQL中使用InnoDB和MyISAM引擎时都使用了B+树实现索引</p>
<p>在数据库中，B+树索引还可以分为聚集索引和辅助索引，但不管是聚集索引还是辅助索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<hr>
<h5 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h5><p>首先，红黑树是一种近似平衡二叉树（不完全平衡），结点非黑即红的树，它的树高最高不会超过 2*log(n)，因此查找的时间复杂度为 O(log(n))，无论是增删改查，它的性能都十分稳定； </p>
<p>但是，红黑树本质还是二叉树，在数据量非常大时，需要访问+判断的节点数还是会比较多，同时数据是存在磁盘上的，访问需要进行磁盘IO，导致效率较低； 而B+树是多叉的，可以有效减少磁盘IO次数；同时B+树增加了叶子结点间的连接，能保证范围查询时找到起点和终点后快速取出需要的数据</p>
<hr>
<h5 id="各种连接"><a href="#各种连接" class="headerlink" title="各种连接"></a>各种连接</h5><p><strong>内连接：</strong>只连接匹配的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 &#x3D; B.c3;</p>
<p><strong>自然连接</strong>：是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p>
<p><strong>左外连接：</strong>包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）以及右边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A left join B on A.c3 &#x3D; B.c3;</p>
<p><strong>右外连接：</strong>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）以及左边表中全部匹配的行</p>
<p>select A.c1,B.c2 from A right join B on A.c3 &#x3D; B.c3;</p>
<p><strong>全外连接：</strong>包含左、右两个表的全部行，不管在另一边的表中是否存在与它们匹配的行</p>
<p>select A.c1,B.c2 from A full join B on A.c3 &#x3D; B.c3;</p>
<p><strong>（theta）连接：</strong>使用等值以外的条件来匹配左、右两个表中的行</p>
<p>select A.c1,B.c2 from A join B on A.c3 !&#x3D; B.c3;</p>
<p><strong>交叉连接：</strong>生成笛卡尔积——它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行一一匹配</p>
<p>select A.c1,B.c2 from A,B;</p>
<hr>
<h5 id="数据库连接池优点"><a href="#数据库连接池优点" class="headerlink" title="数据库连接池优点"></a>数据库连接池优点</h5><p><strong>①资源重用</strong></p>
<p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。</p>
<p><strong>②更快的系统响应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p>
<p><strong>③强制收回被占用的连接，避免数据库连接泄露</strong></p>
<hr>
<h5 id="MySQL的慢查询优化有了解吗？"><a href="#MySQL的慢查询优化有了解吗？" class="headerlink" title="MySQL的慢查询优化有了解吗？"></a>MySQL的慢查询优化有了解吗？</h5><p>优化MySQL的慢查询，可以按照如下步骤进行：</p>
<p><strong>开启慢查询日志：</strong>在MySQL服务启动的时候使用<code>--log-slow-queries[=file_name]</code>启动慢查询日志。</p>
<p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p>
<p><strong>分析慢查询日志：</strong></p>
<p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p>
<p><strong>常见慢查询优化：</strong></p>
<ol>
<li><p>索引没起作用的情况</p>
<ul>
<li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</li>
<li>复合索引要注意最左匹配原则</li>
<li>若查询语句的查询条件中只有OR关键字，则当OR前后的两个条件中的列都是索引时，查询中才使用索引</li>
</ul>
</li>
<li><p>优化数据库结构</p>
<ul>
<li>对于列比较多的表，如果有些列的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</li>
</ul>
</li>
<li><p>优化LIMIT分页</p>
<p>当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p>
<p>用 between 优化 SELECT * FROM t_topic WHERE id BETWEEN 10000 AND 10020;</p>
</li>
</ol>
<hr>
<h3 id="4️⃣设计模式"><a href="#4️⃣设计模式" class="headerlink" title="4️⃣设计模式"></a>4️⃣设计模式</h3><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="六种关系"><a href="#六种关系" class="headerlink" title="六种关系"></a>六种关系</h5><p>依赖</p>
<p>依赖关系是在运行过程中起作用的，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_11,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom: 67%;">

<p>关联</p>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定；体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。一般是长期性的，而且双方的关系一般是平等的</p>
<ul>
<li>类B以类属性的形式出现在关联类A中</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7bd6eacd9dba439ab46068a73c65628d-5001938.png" alt="在这里插入图片描述"></p>
<p>聚合</p>
<p>但是公司和员工就属于聚合关系了，因为公司没了员工还在</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_10,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>组合</p>
<p>组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMTM3OeiZn-ebkeWQrOeMvw==,size_9,color_FFFFFF,t_70,g_se,x_16-5001938.png" alt="img" style="zoom:67%;">



<p>继承（extend）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/984ab6245a3e4a77b46637b481411795-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">



<p>实现（implement）</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/dd8b8c2575f240c187d58b2170422cf4-5001938.png" alt="在这里插入图片描述" style="zoom:67%;">

<hr>
<h5 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h5><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230129223341112.png" alt="image-20230129223341112"></p>
<hr>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>懒汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> mutex;<span class="comment">//mutex mlock; 加锁互斥</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//mlock.lock();</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) instance = <span class="keyword">new</span> <span class="built_in">singleInstance</span>();</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//mlock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;; <span class="comment">// 它拥有一个私有构造函数，这确保用户无法通过new直接实例它</span></span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    <span class="type">static</span> singleInstance* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleInstance* singleInstance::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回静态成员变量 </span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleInstance</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleInstance* <span class="title">GetsingleInstance</span><span class="params">()</span></span>&#123; <span class="comment">// 饿汉式，直接创建一个对象，不需要加锁</span></span><br><span class="line">        <span class="type">static</span> singleInstance instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 涉及创建对象的函数都设置为private</span></span><br><span class="line">    <span class="built_in">singleInstance</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">singleInstance</span>(<span class="type">const</span> singleInstance&amp; other)&#123;&#125;;</span><br><span class="line">    singleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleInstance&amp; other)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为没有办法创建对象，就得采用静态成员函数的方法返回</span></span><br><span class="line">    singleInstance *s = singleInstance::<span class="built_in">GetsingleInstance</span>();</span><br><span class="line">    <span class="comment">//singleInstance *s1 = new singleInstance(); // 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="单例模式多线程"><a href="#单例模式多线程" class="headerlink" title="单例模式多线程"></a>单例模式多线程</h6><ul>
<li>解决方法加mutex</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221143214363.png" alt="image-20230221143214363"></p>
<hr>
<h5 id="请说说工厂设计模式"><a href="#请说说工厂设计模式" class="headerlink" title="请说说工厂设计模式"></a>请说说工厂设计模式</h5><p> 工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong></p>
<h6 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h6><p>  它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/51DCD35848973E9096D228117990019A-5001938.png" alt="img" style="zoom:33%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象,降低了耦合性</p>
<p><strong>缺点：</strong>就是要增加新的核类型时，就需要修改工厂类。这就违反了开闭原则</p>
<h6 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h6><p>  所谓工厂方法模式, 是指定义一个用于创建对象的接口, 让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/AD13A5950A4A1A2198C2AF4FE9F49B2A-5001938.png" alt="img" style="zoom: 33%;">

<p>  <strong>举例：</strong>这家生产处理器核的产家决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。  </p>
<p><strong>缺点：</strong>每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义</p>
<h6 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h6><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221116164855060-5001938.png" alt="image-20221116164855060" style="zoom:50%;">

<p><strong>举例：</strong>这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory&#123;    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h6 id="⭐️三种工厂模式的区别"><a href="#⭐️三种工厂模式的区别" class="headerlink" title="⭐️三种工厂模式的区别"></a>⭐️三种工厂模式的区别</h6><p>简单工厂 ：用来生产同一产品族中的任意产品(对于增加新的产品，无能为力)</p>
<p>工厂方法 ：用来生产同一产品族中的固定产品(支持增加任意产品)</p>
<p>抽象工厂 ：按产品族抽象，这方便增加某个产品族内的具体产品；按具体产品抽象，这方便增加产品族；</p>
<hr>
<hr>
<hr>
<h3 id="5️⃣项目相关"><a href="#5️⃣项目相关" class="headerlink" title="5️⃣项目相关"></a>5️⃣项目相关</h3><h4 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h4><h5 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h5><p>此项目是基于Linux的轻量级多线程Web服务器，应用层实现了一个简单的HTTP服务器，利用多路IO复用，可以同时监听多个请求，使用线程池处理请求，使用模拟proactor模式，主线程负责监听，监听有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在请求队列上的工作线程被唤醒进行处理，使用状态机解析HTTP请求报文，将响应报文和资源文件写回通信的socket，并对系统进行了压力测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数   process() = process_read() + process_write()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，需要继续读取客户数据</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="主从状态机"><a href="#主从状态机" class="headerlink" title="主从状态机"></a>主从状态机</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230227144327617.png" alt="image-20230227144327617"></p>
<p>主状态机：三种状态，标识解析位置</p>
<p>CHECK_STATE_REQUESTLINE，解析请求行</p>
<p>CHECK_STATE_HEADER，解析请求头</p>
<p>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</p>
<p>从状态机：三种状态，标识解析一行的读取状态</p>
<p>LINE_OK，完整读取一行</p>
<p>LINE_BAD，报文语法有误</p>
<p>LINE_OPEN，读取的行不完整</p>
<p>服务器处理HTTP请求的可能结果，报文解析的结果</p>
<p>NO_REQUEST          :   请求不完整，需要继续读取客户数据</p>
<p>GET_REQUEST         :   表示获得了一个完整的客户请求</p>
<p>BAD_REQUEST         :   表示客户请求语法错误</p>
<p>NO_RESOURCE         :   表示服务器没有资源</p>
<p>FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</p>
<p>FILE_REQUEST        :   文件请求,获取文件成功</p>
<p>INTERNAL_ERROR      :   表示服务器内部错误</p>
<p>CLOSED_CONNECTION   :   表示客户端已经关闭连接了</p>
<hr>
<h6 id="子线程如何提醒主线程"><a href="#子线程如何提醒主线程" class="headerlink" title="子线程如何提醒主线程"></a>子线程如何提醒主线程</h6><p>子线程调用<code>http_conn::process()</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向epoll中添加需要监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot )</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot) event.events |= EPOLLONESHOT; <span class="comment">// 防止同一个通信被不同的线程处理</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd); <span class="comment">// 设置文件描述符非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从epoll中移除监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">( <span class="type">int</span> epollfd, <span class="type">int</span> fd )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN); <span class="comment">// 请求不完整，注册读事件，让主线程继续读取客户数据</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);  <span class="comment">// 响应完，注册写事件，让主线程写入通信socket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="服务器是怎么把静态资源传回客户端的"><a href="#服务器是怎么把静态资源传回客户端的" class="headerlink" title="服务器是怎么把静态资源传回客户端的"></a>服务器是怎么把静态资源传回客户端的</h6><p>首先客户端请求里有一个url，服务器端在解析请求首行的时候已经把他存在一个字符串m_url里了。然后我们要把存在服务器相应的资源目录地址拼接上m_url，判断有没有该文件以及该文件的访问权限。如果目标文件存在、对所有用户可读，且不是目录。则使用mmap将其映射到内存地址m_file_address处，并告诉调用者获取文件成功</p>
<p>最后由主线程执行write方法，将其传输给本次连接的socket</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write方法里 分散写，共有两块内存要写出去 m_write_buf 、 m_file_address</span></span><br><span class="line">temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, temp; <span class="comment">// rdset是用户自己维护的, temp是交给内核去修改的</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset); <span class="comment">//初始化，全置0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset); <span class="comment">//将参数文件描述符fd对应的标志位，设置为1</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = rdset;</span><br><span class="line">        <span class="comment">// 调用select，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;temp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">// 这里我们设置的timeval为NULL，所以是阻塞型，ret不可能返回0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;temp))&#123;</span><br><span class="line">                <span class="comment">// 判断fd对应的标志位是0还是1 , 为1代表有新的客户端连接进来了</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到set中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i ++)&#123; <span class="comment">// lfd最先被监听，肯定在最前面</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;temp))&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h6><ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了默认是1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<hr>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">//需要检测读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>; <span class="comment">// 这里就是最大索引，而不是最大索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用 poll，让内核检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123; <span class="comment">// 有新客户端连接进来了，因为revents 返回的是 POLLIN ｜ POLLOUT</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将cfd加入到监听数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i ++)&#123; <span class="comment">// 0是lfd</span></span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)&#123; <span class="comment">// fds[i]可用</span></span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i ++)&#123; <span class="comment">// lfd最先被监听，为0</span></span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123; <span class="comment">// 说明该文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">close</span>(i); <span class="comment">// close(cfd)</span></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h6><ol>
<li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
</li>
<li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
</li>
<li><p><del>select支持的文件描述符数量太小了默认是1024</del></p>
</li>
<li><p><del>fds集合不能重用，每次都需要重置</del></p>
</li>
</ol>
<hr>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><h6 id="说说-epoll-的原理"><a href="#说说-epoll-的原理" class="headerlink" title="说说 epoll 的原理"></a>说说 epoll 的原理</h6><p>wait检测，有EPOLLIN就读，有EPOLLOUT就回</p>
<p>执行epoll_create会在内核中维护一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点</p>
<p>在执行epoll_ctl的add操作时,不仅将文件描述符放到红黑树上,而且也注册了回调函数, 内核在检测到某文件描述符可读&#x2F;可写时会调用回调函数,该回调函数将文件描述符放在就绪链表中</p>
<p>epoll_wait只用观察就绪链表中有无数据即可,最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中,所以只用遍历依次处理即可</p>
<blockquote>
<p>  epoll采用回调机制。造成的结果就是,随着fd的增加,select和poll的效率会线性降低,而epoll不会受到太大影响,除非活跃的socket很多</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. socket()</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,  SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bind()</span></span><br><span class="line">    sockaddr_in saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//（2）将监听的文件描述符相关的检测信息加入到epoll实例中</span></span><br><span class="line">    epoll_event epev;</span><br><span class="line">    epev.events = EPOLLIN; </span><br><span class="line">    epev.data.fd = lfd; </span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line">    </span><br><span class="line">    epoll_event epevs[<span class="number">1024</span>]; <span class="comment">// 内核检测后会将已就绪的文件描述符放在这里面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>); <span class="comment">//（3）-1设置阻塞。只有设置了阻塞时，会返回0，代表超时了都没有检测到变化的文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(epevs[i].data.fd == lfd) &#123; <span class="comment">// 监听到了客户端的连接</span></span><br><span class="line">                sockaddr_in clientaddr;</span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); <span class="comment">// 添加到epoll实例中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// epevs[i].data.fd == cfd  有数据到达，通信</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(epevs[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client closed...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// （4）将此fd从红黑树中删除</span></span><br><span class="line">                    <span class="built_in">close</span>(epevs[i].data.fd); <span class="comment">// close(cfd)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;read buf =&quot;</span>  &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">write</span>(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);<span class="comment">// （5）关闭epoll实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="epoll水平触发与边缘触发的区别"><a href="#epoll水平触发与边缘触发的区别" class="headerlink" title="epoll水平触发与边缘触发的区别"></a>epoll水平触发与边缘触发的区别</h6><p>LT模式（水平触发）: 同时支持 Block (读写操作完才返回)和 Nonblock Socket (读写不等待完毕就返回); 只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。LT模式通常需要使用阻塞I&#x2F;O，以确保程序能够正确处理事件。</p>
<p>而在ET（边缘触发）: 支持 Nonblock socket, 它只会提示一次,  直到下次再有数据流入之前都不会再提示了, 无论fd中是否还有数据可读。如果程序没有及时处理事件，事件会被丢失。ET模式通常需要使用非阻塞I&#x2F;O，以确保程序能够及时响应事件。</p>
<p><strong>场景上来说</strong>：</p>
<p>ET模式适用于需要高并发、高吞吐量的场景，例如网络编程中的服务器端。服务器需要及时响应大量的客户端请求，并发地处理多个请求。ET模式可以确保服务器能够及时响应客户端请求，并发地处理多个请求。</p>
<p>LT模式适用于需要保证数据的完整性和可靠性的场景，例如数据库、事务处理等。LT模式可以确保程序能够正确处理所有的事件，并保证数据的完整性和可靠性。</p>
<hr>
<h6 id="EPOLLONESHOT事件-保证线程安全"><a href="#EPOLLONESHOT事件-保证线程安全" class="headerlink" title="EPOLLONESHOT事件(保证线程安全)"></a>EPOLLONESHOT事件(保证线程安全)</h6><p>即使<strong>可以使用 ET 模式</strong>，一个socket 上的某个事件还是可能被触发多次。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，对此我们可以使用 epoll 的 EPOLLONESHOT 事件实现</p>
<p>对于注册了 EPOLLONESHOT 事件的文件描述符，<strong>操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次</strong>，<strong>除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件</strong>。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， <strong>该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发</strong>，进而让其他工作线程有机会继续处理这个 socket</p>
<hr>
<h5 id="阻塞和非阻塞、同步和异步"><a href="#阻塞和非阻塞、同步和异步" class="headerlink" title="阻塞和非阻塞、同步和异步"></a>阻塞和非阻塞、同步和异步</h5><p>IO同步与进程同步不一样,IO同步是指自己操作数据,异步是指告诉内核要怎么做然后处理自己的事</p>
<p>无论阻塞还是非阻塞，都是同步，只有调用了相关的API才是异步</p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120132728012.png" alt="image-20221120132728012"></p>
<hr>
<h5 id="说说Reactor、Proactor模式"><a href="#说说Reactor、Proactor模式" class="headerlink" title="说说Reactor、Proactor模式"></a>说说Reactor、Proactor模式</h5><h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p>要求主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成<br>使用同步I&#x2F;O(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。<strong>主线程则将socket可读事件放入请求队列(线程池)</strong></li>
<li>线程池中的某个线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入线程池</li>
<li>线程池上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>
</ol>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120192657906.png" alt="image-20221120192657906"></p>
<h6 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h6><p>Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型(以aio_read和aio_write 为例)实现的Proactor 模式的工作流程是:</p>
<p>1.主线程调用aio_read 函数向内核注册socket上的读完成事件,并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</p>
<p>2.主线程继续处理其他逻辑。</p>
<p>3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号， 以通知应用程序数据已经可用。</p>
<p>4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_ write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</p>
<p>5.主线程继续处理其他逻辑。</p>
<p>6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。</p>
<p>7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120194303146.png" alt="image-20221120194303146"></p>
<h6 id="同步IO的模拟Proactor"><a href="#同步IO的模拟Proactor" class="headerlink" title="同步IO的模拟Proactor"></a>同步IO的模拟Proactor</h6><p>使用同步I&#x2F;O方式模拟出Proactor模式。原理是:主线程执行数据读写操作,读写**(就是将socket上的数据(客户端传的http报文)读取至http类对象维护的读写缓冲区)**完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理</p>
<p>使用同步I&#x2F;O模型(以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait 等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理完客户请求，然后往epoll内核事件表中注册socket上的写完成事件</li>
<li>因为主线程调用epoll_wait 等待socket可写, 所以当socket可写时, epoll_wait 通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120203431492.png" alt="image-20221120203431492" style="zoom:50%;">



<hr>
<h5 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h5><h6 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h6><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/694be39c2749f98700567080f2b56154.png" alt="img" style="zoom:50%;">



<h6 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h6><p>非阻塞等待，每隔一段时间就去检测IO事件是否就緒。没有就緒就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept, recv和send，事件末发生时，errno通常被设置成EAGAIN &#x2F; EWOULDBLOCK</p>
<p>这种工作方式下需要不断轮询查看状态</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/7848d265b695b27b3175be6ffe1ff381.png" alt="img" style="zoom:50%;">



<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h6><p>Linux用select&#x2F;poll&#x2F;epoll实现IO多路复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120135606806.png" alt="image-20221120135606806" style="zoom: 40%;">

<h6 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h6><p>Linux用工接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221120140459752.png" alt="image-20221120140459752" style="zoom: 40%;">

<h6 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h6><p>当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/787ff6e538868898f53a27e55bc30c62.png" alt="img" style="zoom:50%;">



<h6 id="⭐️5种IO模型的区别"><a href="#⭐️5种IO模型的区别" class="headerlink" title="⭐️5种IO模型的区别"></a>⭐️5种IO模型的区别</h6><p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<hr>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>该项目使用线程池（同步模拟Proactor）并发处理用户请求，<strong>主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> #<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number; <span class="comment">// 线程的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> * m_threads; <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_max_requests; <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    </span><br><span class="line">    std::list&lt; T* &gt; m_workqueue; <span class="comment">// 请求队列 按理说应当叫 m_requestqueue</span></span><br><span class="line"></span><br><span class="line">    locker m_queuelocker; <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line"></span><br><span class="line">    sem m_queuestat; <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">bool</span> m_stop; <span class="comment">// 是否结束线程                     </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : </span><br><span class="line">        <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), </span><br><span class="line">        <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_detach</span>( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt; T &gt;::<span class="built_in">append</span>( T* request )&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt; T &gt;::<span class="built_in">worker</span>( <span class="type">void</span>* arg )&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt; T &gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) <span class="keyword">continue</span>;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h6 id="如何确定线程数量"><a href="#如何确定线程数量" class="headerlink" title="如何确定线程数量"></a>如何确定线程数量</h6><p>线程数量的确定需要考虑多种因素，如处理器核心数、内存大小、任务类型、线程间的依赖关系等。</p>
<ol>
<li>处理器核心数：线程数不宜超过处理器核心数，因为超过这个数量后，线程之间可能会竞争处理器资源，导致性能下降。</li>
<li>内存大小：每个线程需要占用一定的内存，因此线程数不能过多，否则会导致内存不足。</li>
<li>任务类型：如果任务是I&#x2F;O密集型的，例如网络通信或者文件读写等，线程数可以比较多，因为线程会在I&#x2F;O操作中阻塞，不会占用过多的处理器资源。而如果是CPU密集型的任务，例如图像处理或者计算密集型算法等，则线程数需要适当减少，避免CPU资源竞争。</li>
<li>线程间的依赖关系：如果任务中的线程之间存在依赖关系，需要根据依赖关系来确定线程数，避免出现死锁等问题。</li>
</ol>
<h6 id="线程池中的工作线程是一直等待吗？"><a href="#线程池中的工作线程是一直等待吗？" class="headerlink" title="线程池中的工作线程是一直等待吗？"></a>线程池中的工作线程是一直等待吗？</h6><p>在run函数中，我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的 </p>
<h6 id="线程池工作线程处理完一个任务后的状态是什么？"><a href="#线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="线程池工作线程处理完一个任务后的状态是什么？"></a>线程池工作线程处理完一个任务后的状态是什么？</h6><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p>
<p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格</p>
<h6 id="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h6><p>本项目是通过对子线程循环调用来解决高并发的问题的</p>
<hr>
<h5 id="读多写少的优化"><a href="#读多写少的优化" class="headerlink" title="读多写少的优化"></a>读多写少的优化</h5><ul>
<li><p>加读写锁</p>
<p>但是，只要加了锁，就会带来竞争，即使加的是读写锁，虽然读之间不互斥，但写一样会影响读，而且读写同时争夺锁的时候，锁优先分配给写。</p>
<p>例如，写的时候，要求所有的读请求阻塞住，等到写线程或协程释放锁之后才能读。如果写的临界区耗时比较大，则所有的读请求都会受影响，所有的读请求都在队列中等待处理，如果在下个更新周期来之前，服务能处理完这些读请求，可能情况没那么糟糕。但极端情况下，如果下个更新周期来了，读请求还没处理完，就会形成一个恶性循环，不断的有读请求在队列中等待，最终导致队列被挤满，服务出现假死，情况再恶劣一点的话，上游服务发现某个节点假死后，由于负载均衡策略，一般会重试请求其他节点，这时候其他节点的压力跟着增加了，最终导致整个系统出现雪崩。<br>因此，加锁在高并发场景下要尽量避免，如果避免不了，需要让锁的粒度尽量小，接近无锁（lock-free）更好，简单的对一大片临界区加锁，在高并发场景下不是一种合适的解决方案</p>
</li>
<li><p>双缓冲</p>
</li>
</ul>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221161535855.png" alt="image-20230221161535855"></p>
<hr>
<h5 id="GDB-常见的调试命令"><a href="#GDB-常见的调试命令" class="headerlink" title="GDB 常见的调试命令"></a>GDB 常见的调试命令</h5><h6 id="GDB命令-启动-x2F-退出-x2F-查看代码"><a href="#GDB命令-启动-x2F-退出-x2F-查看代码" class="headerlink" title="GDB命令-启动&#x2F;退出&#x2F;查看代码"></a>GDB命令-启动&#x2F;退出&#x2F;查看代码</h6><ul>
<li>进入gdb环境和退出</li>
</ul>
<blockquote>
<p>  <code>gdb 可执行文件</code></p>
<p>  <code>quit</code></p>
</blockquote>
<ul>
<li>给程序设置参数&#x2F;获取设置参数[需要先进入gdb环境]</li>
</ul>
<blockquote>
<p>  <code>set args 10 20</code></p>
<p>  <code>show args</code></p>
</blockquote>
<ul>
<li><p>GDB使用帮助	直接<code>help</code>	或者<code>set(还可以是其他的关键字) help</code></p>
</li>
<li><p>查看当前文件代码[<code>vim 文件名</code>]</p>
</li>
</ul>
<blockquote>
<p>  <code>list/l</code> 	(从默认位置 显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	行号</code>	(从指定的行显示    前面必须有<code>-g</code>)</p>
<p>  <code>list/l	函数名</code>	(从指定的函数显示    前面必须有<code>-g</code>)</p>
</blockquote>
<ul>
<li>查看非当前文件代码</li>
</ul>
<blockquote>
<p>  <code>list/l	文件名:行号</code></p>
<p>  <code>list/l	文件名:函数名</code></p>
</blockquote>
<ul>
<li>设置&#x2F;显示行数</li>
</ul>
<blockquote>
<p>  <code>show   list/listsize</code>		显示行数<br>  <code>set   list/listsize   行数</code>		设置行数</p>
</blockquote>
<h6 id="GDB命令-断点操作"><a href="#GDB命令-断点操作" class="headerlink" title="GDB命令-断点操作"></a>GDB命令-断点操作</h6><ul>
<li>设置断点</li>
</ul>
<blockquote>
<p>  <code>b/break	行号</code></p>
<p>  <code>b/break	函数名</code></p>
<p>  <code>b/break	文件名:行号</code></p>
<p>  <code>b/break	文件名:函数</code></p>
</blockquote>
<ul>
<li>查看断点</li>
</ul>
<blockquote>
<p>  <code>i/info	b/break</code>	</p>
  <img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20221029160442047.png" alt="image-20221029160442047" style="zoom:50%;">
</blockquote>
<ul>
<li>删除断点</li>
</ul>
<blockquote>
<p>  <code>d/del/delete	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点无效</li>
</ul>
<blockquote>
<p>  <code>dis/disable	断点编号</code></p>
</blockquote>
<ul>
<li>设置断点生效</li>
</ul>
<blockquote>
<p>  <code>ena/enable	断点编号</code></p>
</blockquote>
<ul>
<li>设置条件断点(一般用在循环的位置)</li>
</ul>
<blockquote>
<p>  <code>b/break	10	if	i=5</code>		在第十行设置断点</p>
</blockquote>
<h6 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h6><ul>
<li>运行GDB程序</li>
</ul>
<blockquote>
<p>  <code>start</code> 	(程序停在第一行)</p>
<p>  <code>run</code> 	(遇到断点才停)</p>
</blockquote>
<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<blockquote>
<p>  <code>c/ continue</code></p>
</blockquote>
<ul>
<li>向下执行一行代码(不会进入函数体)</li>
</ul>
<blockquote>
<p>  <code>n/ next</code></p>
</blockquote>
<ul>
<li>向下执行一行代码((遇到函数进入函数体)</li>
</ul>
<blockquote>
<p>  <code>s/ step</code></p>
<p>  <code>finish</code>	(跳出函数体)</p>
</blockquote>
<ul>
<li>变量操作</li>
</ul>
<blockquote>
<p>  <code>p/print	变量名</code>	(打印变量值)</p>
<p>  <code>ptype	变量名</code>	(打印变量类型)</p>
</blockquote>
<ul>
<li>自动变量操作</li>
</ul>
<blockquote>
<p>  <code>display	a;	display	b;</code>	每次调试时如果a, b值发生变化的话, 自动打印</p>
<p>  <code>i/info	display</code>	查看设置了哪些自动变量</p>
<p>  <code>undisplay	编号</code></p>
</blockquote>
<ul>
<li>其它操作</li>
</ul>
<blockquote>
<p>  <code>set	var	变量名 = 变量值</code></p>
<p>  <code>until</code>	(跳出循环)</p>
</blockquote>
<hr>
<h5 id="提高WebServer的性能"><a href="#提高WebServer的性能" class="headerlink" title="提高WebServer的性能"></a>提高WebServer的性能</h5><ol>
<li>加机器</li>
<li>提升机器性能(内存, CPU)</li>
<li>拓展线程池的大小</li>
</ol>
<hr>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>假如我们刚刚上线一个网站，最多只有 10 个人同时访问，那么只需要把网站放到一台服务器上就够了，又叫 <strong>单机部署</strong> </p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131733787.png" alt="image-20230221131733787" style="zoom:33%;">

<p>随着我们网站的不断宣传，可能出现上万用户同时访问的情况。由于一台服务器的 CPU、内存、带宽等资源都是有限的，无法同时支撑那么多用户。因此可能需要多台服务器一起来扛，分摊用户的请求，又叫 <strong>集群部署</strong></p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131811712.png" alt="image-20230221131811712" style="zoom: 33%;">

<p>但这样有个问题，每个服务器都有一个不同的 IP 地址，想把用户的请求分摊到不同的服务器上，不能让用户自己去输入不同的 IP 访问。</p>
<p>因此，我们还需要一台 <strong>代理服务器</strong> ，对外提供 <strong>唯一</strong> 的入口，<strong>统一</strong> 接受用户的请求。再根据请求（或流量）的 <strong>特征</strong> ，依据一定的 <strong>算法</strong> ，将请求转发到内部的服务器集群中</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221131913227.png" alt="image-20230221131913227" style="zoom:33%;">

<p>这样对于用户来说，始终通过一个域名访问网站即可，他完全感知不到你的网站到底部署到多少台服务器上、也不关心它是如何部署的。这便是 <strong>负载均衡</strong>（Load Balancing 简称 LB），是企业中最重要的高并发解决方案</p>
<p><strong>优点：</strong></p>
<p>提高整个系统的可用性，假如集群中有一台服务器挂了，代理服务器只要不再把请求转发给它就行了，集群中的其他服务器仍然能够正常地接受和处理请求</p>
<p>此外，负载均衡还能够减少用户等待响应的时间、通过并行提高整个系统的处理能力等</p>
<hr>
<h6 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h6><p>虽然通过代理服务器转发请求能够提升整个系统的并发访问数，但不要忘了，代理服务器本身的资源也是有限的啊！像比较常用的 Nginx 代理，能有个几万并发就撑死了。如果同时访问的用户量再大一点，不就忍不下了么？</p>
<p>而且代理服务器也存在挂掉的可能性，一旦它挂了，后果不堪设想。因此，我们可以将负载均衡进行分类，针对不同的场景来选择相对合适的实现方式。比较常见的分类方法是：根据 <strong>计算机网络七层模型</strong> ，按照负载均衡所属的网络层次去区分</p>
<ol>
<li><p><strong>二层负载均衡</strong>：二层指数据链路层，数据以数据帧的形式通过交换机进行传输。</p>
<p>这一层是没有 IP 地址概念的，只能用 MAC 地址对机器进行区分。因此负载均衡服务器会通过一个虚拟 MAC 地址接受请求，并通过改写报文目标 MAC 地址的方式将请求转发到具有不同 MAC 地址的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221132718380.png" alt="image-20230221132718380" style="zoom:33%;">
</li>
<li><p><strong>三层负载均衡</strong>：三层即网络层，这一层开始有了 IP 地址的概念，可以根据 IP 地址路由网络。</p>
<p>这一层的负载均衡设备会对外提供一个虚拟的 IP 地址（VIP）以接收请求，然后根据算法将请求转发到 IP 地址不同的目标机器</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133036044.png" alt="image-20230221133036044" style="zoom:33%;">
</li>
<li><p><strong>四层即传输层</strong>：除了包含三层的 IP 地址信息之外，还多了源目端口号的概念，可以区分同一机器上不同的应用。</p>
<p>由于得到了更多的信息，这一层的负载均衡会更加灵活，对外提供一个虚拟的 IP 地址 + 端口号来接收请求，然后根据算法将请求转发到不同目标机器的不同端口上</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133148277.png" alt="image-20230221133148277" style="zoom:33%;">
</li>
<li><p><strong>七层指应用层</strong>：是计算机网络模型的最上层，因此能得到请求最为详细的信息，比如 HTTP 请求头等。</p>
<p>可以根据域名或主机 IP + 端口接收请求，并通过应用层信息（请求头、Cookie 等）灵活地转发请求，比如将手机端用户转发到服务器 A、桌面端用户转发到服务器 B 等</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221133313580.png" alt="image-20230221133313580" style="zoom:33%;"></li>
</ol>
<hr>
<h6 id="负载均衡算法：一致性哈希"><a href="#负载均衡算法：一致性哈希" class="headerlink" title="负载均衡算法：一致性哈希"></a>负载均衡算法：一致性哈希</h6><ul>
<li><p><strong>哈希算法</strong></p>
<p>以分布式缓存为例，假设现在有3台缓存服务器(S0，S1，S2)，要将一些图片尽可能平均地分配到不同的服务器上，hash算法的做法是：</p>
<p>(1) 以图片的名称作为key，然后对其做hash运算。</p>
<p>(2) 将hash值对服务器数量进行求余，得到服务器编号，最后存入即可。</p>
<p>如：a.jpg 需要存入， 我们就得到hash(a.jpg) &#x3D; 5 ——-&gt; 5%3 &#x3D; 2 得到数据存入S2   思考:</p>
<p>上述HASH算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法</p>
</li>
<li><p><strong>一致性哈希算法</strong></p>
<p>也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：</p>
<ol>
<li>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</li>
<li>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</li>
<li>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</li>
</ol>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135029847.png" alt="image-20230221135029847" style="zoom:40%;">

<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135135171.png" alt="image-20230221135135171" style="zoom:40%;"></li>
</ul>
<p>优点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135313611.png" alt="image-20230221135313611" style="zoom:50%;">

<p>哈希环的倾斜与虚拟节点：</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230221135454172.png" alt="image-20230221135454172" style="zoom:50%;">

<hr>
<h5 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a>Webbench</h5><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出</p>
<p><code>webbench -c 1000 -t 60 http://www.baidu.com</code></p>
<hr>
<h5 id="访问服务端延迟高的原因"><a href="#访问服务端延迟高的原因" class="headerlink" title="访问服务端延迟高的原因"></a>访问服务端延迟高的原因</h5><ol>
<li>服务端应用压力太大，确实处理不过来了</li>
<li>请求的资源太大</li>
<li>线程池配置的不合理，线程数配置的太少导致的请求积压</li>
<li>客户端网络原因，丢包、带宽限制、重传等</li>
<li>节点距离：需要跳转的网络节点越多，呈现在现实就是网络访问速度会越慢</li>
</ol>
<hr>
<h5 id="如何定位服务器性能瓶颈"><a href="#如何定位服务器性能瓶颈" class="headerlink" title="如何定位服务器性能瓶颈"></a>如何定位服务器性能瓶颈</h5><p>如果出现比较多的响应时间过长，首先要排查所有服务器是否存在资源使用瓶颈，</p>
<p>查看系统参数：内存、cpu、文件描述符、磁盘io、看内核态和用户态占用的cpu比率、火焰图</p>
<p><strong>查看内存(top) + jstack</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">top <span class="comment">// 使用top指令找到CPU使用最高的进程</span></span><br><span class="line">top -Hp <span class="number">6962</span> <span class="comment">// 使用 top -Hp 进程Id ，找到使用率最高的线程</span></span><br><span class="line">printf <span class="string">&quot;%x\n&quot;</span> <span class="number">2846</span> <span class="comment">// 将这些线程id转换为16进制的，printf “%x\n” 线程Id</span></span><br><span class="line">jstack <span class="number">6962</span> | grep a33 -A <span class="number">100</span> <span class="comment">// 打印进程堆栈信息 （6962是进程id，a33是线程id的对应的16进制）</span></span><br><span class="line"><span class="comment">// 这样就能找到导致CPU使用率飙高的具体的代码了。</span></span><br></pre></td></tr></table></figure>



<p><strong>查看端口状态(netstat)</strong></p>
<p><strong>抓包(tcpdump)</strong></p>
<blockquote>
<p>  host 192.168.130.1表示一台主机.    没有指明数据类型，那么默认就是host</p>
<p>  net 192.168.130.0表示一个网络网段</p>
<p>  port 80 指明端口号为80</p>
</blockquote>
<p><code>tcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host ! www.baidu.com  </code></p>
<p><code>tcpdump udp port 53</code> 监听本机udp的53端口的数据包</p>
<p><code>tcpdump tcp port 22 and host 192.168.56.210</code> 捕获主机192.168.56.210接收和发出的tcp协议的数据包</p>
<hr>
<h5 id="防止恶意请求，服务器端可以采取措施"><a href="#防止恶意请求，服务器端可以采取措施" class="headerlink" title="防止恶意请求，服务器端可以采取措施"></a><strong>防止恶意请求，服务器端可以采取措施</strong></h5><ol>
<li>在服务器端对所有输入进行验证, 确保只有有效的请求才会被处理. 可以使用正则表达式或其他验证库来验证输入</li>
<li>可以限制单个IP地址或用户在特定时间内访问服务器的次数。这可以防止暴力攻击和DDoS攻击等。</li>
<li>可以在敏感操作前要求用户输入验证码，这可以防止自动化脚本或机器人攻击。</li>
<li>可以使用HTTPS协议进行通信，这可以防止网络窃听和中间人攻击等。</li>
<li>可以在服务器上安装防火墙，来过滤不受欢迎的网络流量，包括恶意请求。</li>
<li>可以实时监控服务器端的请求日志，这可以帮助发现潜在的恶意请求和攻击。</li>
</ol>
<hr>
<h5 id="如何限制单个IP地址或用户在特定时间内访问服务器的次数"><a href="#如何限制单个IP地址或用户在特定时间内访问服务器的次数" class="headerlink" title="如何限制单个IP地址或用户在特定时间内访问服务器的次数"></a>如何限制单个IP地址或用户在特定时间内访问服务器的次数</h5><ol>
<li>配置防火墙规则：大多数防火墙都允许您设置规则以限制特定IP地址或用户在特定时间内的访问次数。您可以配置规则，使它们在指定时间内仅允许有限数量的请求通过。这是一个基于网络层面的解决方案，可以防止任何类型的请求访问服务器。</li>
<li>使用限流器：限流器是一个应用层面的解决方案，可以限制单个IP地址或用户在特定时间内访问服务器的次数。您可以配置限流器以允许每个IP地址或用户在指定的时间段内仅能发送有限数量的请求。这可以确保您的服务器不会被恶意请求攻击。</li>
<li>使用反向代理服务器：如果您使用反向代理服务器，您可以在代理服务器上设置规则以限制特定IP地址或用户在特定时间内访问服务器的次数。反向代理服务器可以充当服务器和客户端之间的中介，允许您在代理服务器上执行任意数量的控制和限制。</li>
</ol>
<hr>
<h5 id="服务器端限流"><a href="#服务器端限流" class="headerlink" title="服务器端限流"></a>服务器端限流</h5><p>一种防止服务器过载的措施。通过限制每个客户端在一定时间内可以发送到服务器的请求数量，可以避免某些恶意用户或脚本通过高速请求导致服务器宕机或运行缓慢</p>
<p>以下是实施服务器端限流的一些方法：</p>
<ol>
<li>客户端IP地址限制：限制来自单个IP地址的请求数量，这可以防止单个客户端对服务器进行过度请求。</li>
<li>并发连接数限制：限制服务器能够同时处理的连接数量，这可以防止服务器过载。</li>
<li>请求速率限制：限制客户端在一定时间内可以发送的请求数量，这可以防止DDoS攻击和暴力破解等。</li>
<li>Token Bucket算法：Token Bucket算法是一种常见的限流算法。服务器为每个客户端分配一个令牌桶，每个令牌代表一个请求。客户端在发送请求之前必须从令牌桶中获取令牌。如果令牌桶为空，则请求被拒绝。</li>
<li>漏桶算法：漏桶算法是另一种常见的限流算法。服务器维护一个固定大小的漏桶，每个请求被视为一个水滴。当一个请求到达时，服务器将水滴放入漏桶中。如果漏桶已经满了，则请求被拒绝。</li>
</ol>
<hr>
<h5 id="检测内存泄漏-用htop发现虚拟内存在涨"><a href="#检测内存泄漏-用htop发现虚拟内存在涨" class="headerlink" title="检测内存泄漏(用htop发现虚拟内存在涨)"></a>检测内存泄漏(用htop发现虚拟内存在涨)</h5><p>线上系统要做好热更新，方便随时打开内存调试。 <code>#if  mem = 1  #endif</code></p>
<h6 id="法一-malloc-stats-和-malloc-info-0-stdout"><a href="#法一-malloc-stats-和-malloc-info-0-stdout" class="headerlink" title="法一:  malloc_stats() 和 malloc_info(0, stdout)"></a><strong>法一:</strong>  malloc_stats() 和 malloc_info(0, stdout)</h6><p>检测具体函数的内存泄漏: gdb中打断点配合调用malloc_stats()函数 <code>call malloc_stats()</code></p>
<p>函数执行前后调用<code>call malloc_info(0, stdout)</code>输出内存,比较</p>
<h6 id="法二：宏定义"><a href="#法二：宏定义" class="headerlink" title="法二：宏定义"></a>法二：宏定义</h6><p>创建一个文件夹。每次malloc的时候在其中创建一个文件，文件名是本次malloc申请的内存地址。free的时候去该文件夹中查找与没有 那个名为那个地址的文件，有的话就删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _malloc(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%s:%d]_malloc:%ld,ptr:%p\n&quot;</span>, filename, line, size, p);</span><br><span class="line">    <span class="built_in">fflush</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _free(<span class="type">void</span> *p, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> line)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./memleak/%p.mem&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>)&#123; <span class="comment">// 删除失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;[-%s:%d]_free:%p\n&quot;, filename, line, p);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) _malloc(size, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) _free(ptr, __FILE__, __LINE__)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230222155844859.png" alt="image-20230222155844859"></p>
<h6 id="法三：-hook截获malloc和free-dlsym改成自定义的"><a href="#法三：-hook截获malloc和free-dlsym改成自定义的" class="headerlink" title="法三： hook截获malloc和free, dlsym改成自定义的"></a>法三： hook截获malloc和free, dlsym改成自定义的</h6> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">malloc_t</span> malloc_f; <span class="comment">// malloc_f 是 malloc_t 类型的函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="type">free_t</span> free_f;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> enable_malloc_hook = <span class="number">1</span>, enable_free_hook = <span class="number">1</span>; <span class="comment">// 防止malloc中循环调用malloc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_malloc_hook)&#123;</span><br><span class="line">        enable_malloc_hook = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *p = <span class="built_in">malloc_f</span>(size);</span><br><span class="line">        <span class="type">void</span> *caller = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        FILE *fp = <span class="built_in">fopen</span>(buff, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;[+%p]malloc --&gt; addr:%p size:%lu\n&quot;</span>, caller, p, size);</span><br><span class="line">        <span class="built_in">fflush</span>(fp);</span><br><span class="line"></span><br><span class="line">        enable_malloc_hook = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">malloc_f</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enable_free_hook)&#123;</span><br><span class="line">        enable_free_hook = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buff, <span class="string">&quot;./mem/%p.mem&quot;</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlink</span>(buff) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;double free: %p\n&quot;</span>, p);</span><br><span class="line">        <span class="built_in">free_f</span>(p);</span><br><span class="line">        </span><br><span class="line">        enable_free_hook = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">free_f</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有malloc和free包括第三方库中的，走我们自定义的那一段</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init_hook</span><span class="params">()</span></span>&#123;</span><br><span class="line">    malloc_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">// 获取 malloc 地址为 malloc_f, 因此调用malloc_f等价于调用malloc</span></span><br><span class="line">    free_f = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -o memleak_0 memleak_0.c -ldl -g </span></span><br><span class="line"><span class="comment">// addr2line -f -e  memleak_0 -a 0x4006d8   （-f表示file -e表示execute -a表示代码段地址）可以查看 内存泄漏的行数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init_hook</span>();</span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="法四：-mtrace"><a href="#法四：-mtrace" class="headerlink" title="法四： mtrace"></a>法四： mtrace</h6><p>mtrace() 函数中会为那些和动态内存分配有关的函数（譬如 malloc()、realloc()、memalign() 以及 free()）安装 “钩子（hook）” 函数，这些 hook 函数会为我们记录所有有关内存分配和释放的跟踪信息，而 muntrace() 则会卸载相应的 hook 函数。基于这些 hook 函数生成的调试跟踪信息，我们就可以分析是否存在 “内存泄露” 这类问题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">mtrace</span>();  <span class="comment">// 开始跟踪</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">muntrace</span>();   <span class="comment">// 结束跟踪，并生成日志信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test  <span class="comment">// 一定加上 -g 能够帮我们定位代码中的具体位置，否则看到的只是执行文件中的地址信息</span></span><br></pre></td></tr></table></figure>

<p>mtrace 机制需要我们实际运行一下程序，然后才能生成跟踪的日志，但在实际运行程序之前还有一件要做的事情是需要告诉 mtrace生成日志文件的路径。具体的方法是通过定义并导出一个环境变量 “MALLOC_TRACE”，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> MALLOC_TRACE=./test.log  <span class="comment">// 当前目录下</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200347354.png" alt="image-20230226200347354"></p>
<p><img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230226200602769.png" alt="image-20230226200602769"></p>
<hr>
<h5 id="查看链接了哪些动态库和第三方库有无内存泄漏"><a href="#查看链接了哪些动态库和第三方库有无内存泄漏" class="headerlink" title="查看链接了哪些动态库和第三方库有无内存泄漏"></a>查看链接了哪些动态库和第三方库有无内存泄漏</h5><ul>
<li>查看链接了哪些动态库</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ldd a.so	<span class="comment">//查看SO文件的动态链接库</span></span><br><span class="line">nm -D a.so	<span class="comment">//查看so文件的函数列表</span></span><br><span class="line">objdump -tT a.so	<span class="comment">//查看so文件的导出函数及源文件等信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Linux&#x2F;unix 提供了使用 dlopen 和 dlsym 方法动态加载库和调用函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开指定的动态库，返回的是该动态库的handle，在dlsym，dlclose中将继续使用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// RTLD_LAZY 暂缓决定，等有需要时再解出符号 </span></span><br><span class="line"><span class="comment">// RTLD_NOW 立即决定，返回前解除所有未决定的符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看错误信息</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">dlerror</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获得对应的函数或变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="comment">//关闭打开的动态库</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="git-如何查看远程服务器分支"><a href="#git-如何查看远程服务器分支" class="headerlink" title="git 如何查看远程服务器分支"></a>git 如何查看远程服务器分支</h5><p>要查看远程服务器上的分支，可以使用 <code>git branch -r</code> 该命令会显示所有已知的远程分支列表。</p>
<p>如果你想查看特定远程分支的详细信息，可以使用 <code>git show &lt;remote-name&gt;/&lt;branch-name&gt;</code> 命令，其中 <code>remote-name</code> 是远程服务器的名称，<code>branch-name</code> 是要查看的分支名称。例如，要查看名为 <code>master</code> 的远程分支的详细信息，可以运行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git show origin/master</span><br></pre></td></tr></table></figure>

<p>请注意，在使用此命令之前，你需要先确保已经将远程分支拉取到本地仓库中，否则该命令将无法正常工作。可以使用 <code>git fetch</code> 命令将远程分支更新到本地仓库</p>
<h3 id="6️⃣其他"><a href="#6️⃣其他" class="headerlink" title="6️⃣其他"></a>6️⃣其他</h3><h4 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h4><h5 id="沙漏计时问题"><a href="#沙漏计时问题" class="headerlink" title="沙漏计时问题"></a>沙漏计时问题</h5><p>有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>两个沙漏同时倒置开始计时，等小沙漏漏完，大沙漏还剩<span class="number">2</span>分钟，这时倒置小沙漏继续计时；</span><br><span class="line"><span class="number">2.</span>大沙漏漏完小沙漏还剩<span class="number">4</span>分钟，再把大沙漏倒置继续计时；</span><br><span class="line"><span class="number">3.</span>小沙漏漏完大沙漏还剩<span class="number">4</span>分钟，这时准备工作已经完毕；</span><br><span class="line"><span class="number">4.</span>等待大沙漏漏完（<span class="number">4</span>分钟）+小沙漏（<span class="number">6</span>分钟）=<span class="number">10</span>分钟。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="吃药片问题"><a href="#吃药片问题" class="headerlink" title="吃药片问题"></a>吃药片问题</h5><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 把手上的三片药各自切成两半，分成两堆摆放；</span><br><span class="line"><span class="number">2.</span> 再取出一粒药片 A，也把它切成两半，然后在每一堆里加上半片的 A；</span><br><span class="line"><span class="number">3.</span> 现在，每一堆药片恰好包含两个半片的 A 和两个半片的 B；</span><br><span class="line"><span class="number">4.</span> 一天服用其中一堆即可。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="老鼠毒药问题"><a href="#老鼠毒药问题" class="headerlink" title="老鼠毒药问题"></a>老鼠毒药问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤一： 给所有瓶子转化为二进制</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0000000001</span></span><br><span class="line"><span class="number">2</span>：<span class="number">0000000010</span></span><br><span class="line"><span class="number">3</span>：<span class="number">0000000011</span></span><br><span class="line"><span class="number">4</span>：<span class="number">0000000100</span></span><br><span class="line">.....<span class="number">.1000</span>：<span class="number">1111101000</span> </span><br><span class="line"><span class="comment">// 步骤二： 让第i只老鼠喝二进制表示第i位为一的所有瓶子</span></span><br><span class="line"><span class="comment">// 一星期后看第几只老鼠死了, 比如第1,3,5只死了, 则毒药编号就是 1010100000</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="箱子开锁问题"><a href="#箱子开锁问题" class="headerlink" title="箱子开锁问题"></a>箱子开锁问题</h5><p>A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> A 把药放进箱子，用自己的锁把箱子锁上；</span><br><span class="line"><span class="number">2.</span> B 拿到箱子后，再在箱子上加一把自己的锁；</span><br><span class="line"><span class="number">3.</span> 箱子运回 A 后，A 取下自己的锁；</span><br><span class="line"><span class="number">4.</span> 箱子再运到 B 手中时，B 取下自己的锁，获得药物。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="人鬼过桥问题"><a href="#人鬼过桥问题" class="headerlink" title="人鬼过桥问题"></a>人鬼过桥问题</h5><p>有三个人跟三个鬼要过河，河上没桥只有条小船，然后船一次只能渡一个人和一个鬼，或者两个鬼和两个人，无论在哪边岸上，只有是人比鬼少的情况下（如两鬼一人，三鬼两人，三鬼一人），人会被鬼吃掉，然而船有一定需要人或鬼操作才能航行（要有人或鬼划船），问，如何安全的把三人三鬼渡过河对岸？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 先两鬼过去，再一鬼回来。此时，对面有一鬼，这边有三人两鬼；</span><br><span class="line"><span class="number">2.</span> 再两鬼过去，再一鬼回来。此时对面有两鬼，这边有三人一鬼；</span><br><span class="line"><span class="number">3.</span> 再两人过去，一人一鬼回来。此时，对面一人一鬼。这边两人两鬼；</span><br><span class="line"><span class="number">4.</span> 最后两人过去，一鬼回来。此时，对面三人，这边三鬼；</span><br><span class="line"><span class="number">5.</span> 剩下的就三个鬼，两个过去，一个回来再接另外一个鬼就结束了。</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="赛马找最快的马匹"><a href="#赛马找最快的马匹" class="headerlink" title="赛马找最快的马匹"></a>赛马找最快的马匹</h5><p>25匹马5条跑道找最快的3匹马，需要跑几次？参考回答：7</p>
<p>64匹马8条跑道找最快的4匹马，需要跑几次？参考回答：11</p>
<p>25匹马5条跑道找最快的5匹马，需要跑几次？参考回答：最少8次最多9次</p>
<h6 id="25匹马5条跑道找最快的3匹马"><a href="#25匹马5条跑道找最快的3匹马" class="headerlink" title="25匹马5条跑道找最快的3匹马"></a>25匹马5条跑道找最快的3匹马</h6><p>将25匹马分成ABCDE5组，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5，这里比赛5次</p>
<p>第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1</p>
<p>D1，E1肯定进不了前3，直接排除掉。 第7次，B1 C1 A2 B2 A3比赛，可以找出第二，第三名</p>
<h6 id="64匹马8条跑道找最快的4匹马"><a href="#64匹马8条跑道找最快的4匹马" class="headerlink" title="64匹马8条跑道找最快的4匹马"></a><strong>64匹马8条跑道找最快的4匹马</strong></h6><p>第一步：全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名</p>
<p>第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马。这个时候总冠军已经诞生，它就是这场比赛第一名</p>
<p>第三步：可能是前四名的只能是下面淡黄色的9只，随机选出8匹马进行一次比赛</p>
<img src="/2022/11/06/CPP%E5%85%AB%E8%82%A1/image-20230309193955191.png" alt="image-20230309193955191" style="zoom:50%;">

<p>第四步：上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，就和前三名比一比，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了</p>
<h4 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h4><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
